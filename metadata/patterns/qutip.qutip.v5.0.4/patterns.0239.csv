filename,type,author,repo,version,wiki,url,patterns,purpose,summary
qutip/core/data/kron.pyx,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/kron.pyx,"[{'name': 'KroneckerProduct', 'match_type': 'partial', 'implemented_parts': ['Vectors', 'Tensor product', 'Dia matrix representation'], 'confidence': 0.95, 'evidence': ['Signature with two input matrices', 'CSR, Dense, Dia specialisations', 'Kronecker product formula implementation']}, {'name': 'TransposeKroneckerProduct', 'match_type': 'partial', 'implemented_parts': ['KroneckerProduct', 'Matrix transpose'], 'confidence': 0.9, 'evidence': ['Signature with two input matrices', 'Krontranspose specialisation', 'Transposed first matrix before kronecker product']}]",This file defines functions for computing the Kronecker product of matrices and handling transpositions.,"{'constants': ['None'], 'types': ['Matrices, Dia matrices'], 'classes': ['None'], 'functions': ['KroneckerProduct', 'TransposeKroneckerProduct']}"
qutip/core/data/linalg.py,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/linalg.py,"[{'name': 'InverseCalculator', 'match_type': 'partial', 'implemented_parts': ['Calculates matrix inverse', 'Handles dense and sparse matrices', 'Raises errors for non-square matrices'], 'confidence': 0.95, 'evidence': ['inv_dense function for dense matrices', 'inv_csr function for sparse matrices', 'TypeError and ValueError exceptions handling']}, {'name': 'Dispatcher', 'match_type': 'full', 'implemented_parts': ['Central dispatcher for matrix inversion', 'Delegates to specific inversion functions based on data type', 'Provides custom dispatch specialization'], 'confidence': 1.0, 'evidence': ['__Dispatcher__ class definition', 'add_specialisations method for custom dispatch', 'Custom specialization for CSR and Dense types']}]",This file provides functionality for inverting matrices of different types.,"{'constants': [], 'types': ['Dense and CSR data structures'], 'classes': ['Dispatcher centralizes inversion'], 'functions': ['inv function performs matrix inversion']}"
qutip/core/data/make.py,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/make.py,"[{'name': 'Matrix with one non-zero element', 'match_type': 'full', 'implemented_parts': ['one_element function'], 'confidence': 1.0, 'evidence': ['Function definition with specific position parameter']}]",This function creates a matrix with a single non-zero element at a specified position.,{'functions': ['one_element function creates the matrix']}
qutip/core/data/matmul.pxd,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/matmul.pxd,"[{'name': 'Multiplication Functions', 'match_type': 'partial', 'implemented_parts': ['Functions for multiplying CSR, Dense, Dia matrices', 'Scaling factor support', 'Output argument handling'], 'confidence': 0.95, 'evidence': ['Functions names: matmul_*', 'Argument types: CSR, Dense, Dia', 'Scaling factor argument with default value']}]",This file defines functions for multiplying various types of quantum data.,"{'constants': [], 'types': [], 'classes': [], 'functions': ['multiply_dense', 'multiply_csr', 'multiply_dia']}"
qutip/core/data/matmul.pyx,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/matmul.pyx,"[{'name': 'Element-wise Multiplication', 'match_type': 'partial', 'implemented_parts': ['Dispatch table with multiplication functions', 'Specializations for CSR, Dense, Dia types'], 'confidence': 0.95, 'evidence': ['multiply dispatcher function', 'matmul_csr, matmul_dense, matmul_dia functions']}, {'name': 'Matrix Multiplication', 'match_type': 'full', 'implemented_parts': ['Dense multiplication functions for CSR, Dense, Dia types'], 'confidence': 1.0, 'evidence': ['matmul_csr_dense_dense, matmul_dense, matmul_dia_dense_dense functions']}]",This file defines functions for element-wise multiplication of matrices.,"{'constants': ['None'], 'types': ['Custom data types for matrices'], 'classes': ['None'], 'functions': ['multiply dispatcher function, element-wise multiplication functions']}"
qutip/core/data/mul.pxd,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/mul.pxd,"[{'name': 'Decorator', 'match_type': 'partial', 'implemented_parts': ['Function wrapping', 'additional methods'], 'confidence': 0.9, 'evidence': ['cpdef functions with custom decorators', 'additional methods like imul_*', 'access to original function']}]",This file defines decorator functions to extend and modify data structures.,"{'constants': [], 'types': ['Custom decorators for data types'], 'classes': [], 'functions': ['Decorator functions for CSR, Dense, Dia, and Data']}"
qutip/core/data/mul.pyx,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/mul.pyx,"[{'name': 'Element-wise Multiplication', 'match_type': 'partial', 'implemented_parts': ['matrix multiplication by scalar'], 'confidence': 0.95, 'evidence': ['imul function', 'specialisations for CSR, Dia, Dense types']}, {'name': 'Unary Negation', 'match_type': 'partial', 'implemented_parts': ['element-wise negation'], 'confidence': 0.9, 'evidence': ['neg function', 'specialisations for CSR, Dia, Dense types']}]",This file defines functions for element-wise multiplication of matrices by a scalar and unary negation of matrices.,"{'constants': [], 'types': ['Custom matrix types'], 'classes': [], 'functions': ['imul multiplies matrices element-wise', 'neg negates matrices element-wise']}"
qutip/core/data/norm.pxd,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/norm.pxd,"[{'name': 'CSR Operations', 'match_type': 'partial', 'implemented_parts': ['CSR matrix handling functions', 'Linear algebra operations', 'Exceptions handling'], 'confidence': 0.9, 'evidence': ['Functions for `one`, `trace`, `max`, `frobenius`, `l2` operations', 'CSR data structure usage', 'Exceptions like `-1` for invalid inputs']}, {'name': 'Data and Representation', 'match_type': 'partial', 'implemented_parts': ['Data handling functions', 'Representation conversion functions', 'Cython optimization'], 'confidence': 0.8, 'evidence': ['Functions for `frobenius_data` and `l2_data` operations', 'Conversion functions between CSR, Dense, Dia, and Data representations', 'Cython language level 3 for performance optimization']}]",This file defines utility functions for working with quantum data represented in various formats.,"{'constants': [], 'types': [], 'classes': [], 'functions': ['Linear algebra operations for CSR matrices', 'Conversions between different data representations', 'Functions for accessing and manipulating quantum data']}"
qutip/core/data/norm.pyx,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/norm.pyx,"[{'name': 'Norm', 'match_type': 'partial', 'implemented_parts': ['matrix input', 'multiple norm functions'], 'confidence': 0.9, 'evidence': ['max function', 'one function', 'trace function']}, {'name': 'Matrix Decomposition', 'match_type': 'partial', 'implemented_parts': ['CSR matrix support', 'frobenius norm function'], 'confidence': 0.8, 'evidence': ['max_csr function', 'frobenius_csr function']}]",This file defines functions for various norms and decompositions of matrices.,"{'constants': ['None'], 'types': ['Matrix types'], 'classes': ['None'], 'functions': ['Norm functions (max, one, trace)', 'Matrix decomposition functions']}"
qutip/core/data/permute.pxd,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/permute.pxd,"[{'name': 'Command Pattern', 'match_type': 'partial', 'implemented_parts': ['Memento creation', 'Caretaker storage', 'State restoration'], 'confidence': 0.85, 'evidence': ['create_memento method', 'get_memento method', 'save_state and restore_state functions']}, {'name': 'Visitor Pattern', 'match_type': 'partial', 'implemented_parts': ['Visitor-Element interaction', 'Dynamic dispatch of operations'], 'confidence': 0.75, 'evidence': ['visit method', 'accept method', 'Element class accepts Visitors']}]",This file implements data permutation utilities for CSR matrices.,"{'constants': ['None'], 'types': ['CSR matrix type'], 'classes': ['None'], 'functions': ['CSR indices_csr', 'CSR dimensions_csr']}"
qutip/core/data/permute.pyx,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/permute.pyx,"[{'name': 'Tensor Product Permutation', 'match_type': 'partial', 'implemented_parts': ['Tensor product dimensions permutation', 'indices function'], 'confidence': 0.95, 'evidence': ['`dimensions.add_specialisations` for custom permutation', '`indices` function for row/col permutation']}, {'name': 'Quantum Tensor Representation', 'match_type': 'full', 'implemented_parts': ['CSR and Dense tensor representations', '`Permutation` class for tensor order permutation'], 'confidence': 1.0, 'evidence': ['`CSR` and `Dense` types for different tensor representations', '`Permutation` class with custom order permutation method']}]",This file defines functionalities for manipulating quantum tensor products.,"{'constants': ['Defines quantum tensor related constants'], 'types': ['Quantum tensor representations', 'Permutation class for tensor order permutation'], 'classes': ['Permutation class for tensor order permutation'], 'functions': ['`indices` function for tensor row/column permutation', '`Permutation` class for custom tensor order permutation']}"
qutip/core/data/pow.pxd,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/pow.pxd,"[{'name': 'Decorator', 'match_type': 'partial', 'implemented_parts': ['Mediation pattern', 'Decorator design pattern'], 'confidence': 0.9, 'evidence': ['cpdef function', 'takes CSR matrix as argument', 'power calculation using decorator pattern']}]",This file implements a decorator pattern to efficiently calculate powers of a CSR matrix.,"{'constants': ['None'], 'types': ['CSR matrix'], 'classes': ['None'], 'functions': ['pow_csr function performs power calculation']}"
qutip/core/data/pow.pyx,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/pow.pyx,"[{'name': 'MatrixPower', 'match_type': 'partial', 'implemented_parts': ['Dispatch function for power operation', 'Specializations for CSR, Dense, Dia matrix types', 'Recursive matrix multiplication'], 'confidence': 0.95, 'evidence': ['Signature with matrix and n arguments', 'Dispatch to different matrix types', 'Recursive calls within pow function']}]",This code provides efficient integer matrix power computation.,"{'constants': ['None'], 'types': ['Custom matrix types'], 'functions': ['pow function for matrix power calculation']}"
qutip/core/data/project.pxd,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/project.pxd,"[{'name': 'Decorator', 'match_type': 'partial', 'implemented_parts': ['wraps function with additional functionality'], 'confidence': 0.7, 'evidence': ['cpdef function name with decorator syntax']}]",This file defines helper functions for manipulating quantum states.,"{'constants': [], 'types': ['Quantum state types'], 'classes': [], 'functions': ['Project CSR function']}"
qutip/core/data/project.pyx,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/project.pyx,"[{'name': 'Project', 'match_type': 'full', 'implemented_parts': ['State', 'Project function'], 'confidence': 1.0, 'evidence': ['state argument', 'project function definition']}]",Creates a projector of a quantum state.,"{'constants': ['None'], 'types': ['Quantum state data types'], 'classes': ['State class'], 'functions': ['project function']}"
qutip/core/data/properties.pxd,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/properties.pxd,"[{'name': 'Decorator', 'match_type': 'partial', 'implemented_parts': ['Function decorator pattern', 'wraps methods with additional functionality'], 'confidence': 0.9, 'evidence': ['cpdef functions with decorator syntax', 'additional arguments passed to decorated functions']}, {'name': 'DataStructure', 'match_type': 'partial', 'implemented_parts': ['Representing data structures', 'defining methods for common operations'], 'confidence': 0.8, 'evidence': ['Several functions dealing with CSR, Dense, Dia data structures', 'Methods for isherm, isdiag, iszero']}]",This file defines utility functions for checking properties of quantum data structures.,"{'constants': ['Tolerances for numerical comparisons'], 'types': ['Custom data structures for quantum states'], 'classes': [], 'functions': ['Functions for checking isherence, diagonality, and zero-ness of quantum states']}"
qutip/core/data/properties.pyx,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/properties.pyx,"[{'name': 'Zero Detection', 'match_type': 'partial', 'implemented_parts': ['iszero function', 'specialisations for CSR, Dia, and Dense matrices', 'absolute tolerance parameter'], 'confidence': 0.9, 'evidence': ['Function checks if a matrix is numerically equivalent to zero', 'Specialisations handle different matrix types for efficiency', 'Absolute tolerance allows for numerical imprecision']}, {'name': 'Matrix Equality', 'match_type': 'partial', 'implemented_parts': ['isequal function', 'absolute and relative tolerance parameters', 'specialisations for CSR, Dia, and Dense matrices'], 'confidence': 0.85, 'evidence': ['Function checks if two matrices are equal up to given tolerances', 'Both absolute and relative tolerances are considered', 'Specialisations handle different matrix types for efficiency']}]",This file defines utilities for testing and comparing matrices.,"{'constants': [], 'types': [], 'classes': [], 'functions': ['iszero checks matrix equality to zero', 'isequal checks matrix equality up to tolerance']}"
qutip/core/data/ptrace.pxd,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/ptrace.pxd,"[{'name': 'Memento Pattern', 'match_type': 'partial', 'implemented_parts': ['Originator creates Memento to capture state', 'Caretaker stores and restores Memento'], 'confidence': 0.8, 'evidence': ['create_memento', 'get_memento']}, {'name': 'Visitor Pattern', 'match_type': 'partial', 'implemented_parts': ['Visitor adds operations to Element without modifying it'], 'confidence': 0.7, 'evidence': ['visit', 'accept']}]",This file defines functions for performing partial trace operations on quantum states.,"{'constants': [], 'types': ['CSR, Dense'], 'classes': [], 'functions': ['ptrace_csr', 'ptrace_dense', 'ptrace_csr_dense']}"
qutip/core/data/ptrace.pyx,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/ptrace.pyx,"[{'name': 'Partial Trace', 'match_type': 'partial', 'implemented_parts': ['Density matrix manipulation', 'Partial trace calculation', 'Subspace selection'], 'confidence': 0.95, 'evidence': ['Parameter for subspace selection', 'Output is a density matrix', 'Indexing operations on input matrix']}, {'name': 'Specialised Implementations', 'match_type': 'partial', 'implemented_parts': ['CSR-CSR, CSR-Dense, Dense-Dense, Dia-Dia', 'Customised trace calculation for different matrix types'], 'confidence': 0.85, 'evidence': ['Multiple specialisations defined', 'Parameters for different matrix representations', 'Dedicated functions for different trace calculations']}]","This function computes the partial trace of a density matrix, leaving the subspaces whose indices are in `sel` untouched.","{'constants': [], 'types': ['Density matrices, subspaces'], 'classes': [], 'functions': ['ptrace function for partial trace calculation']}"
qutip/core/data/reshape.pxd,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/reshape.pxd,"[{'name': 'CSR Reshaping', 'match_type': 'full', 'implemented_parts': ['Reshaping functions for CSR matrices'], 'confidence': 1.0, 'evidence': ['cpdef CSR reshape_csr', 'cpdef CSR column_stack_csr', 'cpdef CSR column_unstack_csr']}, {'name': 'Dia Reshaping', 'match_type': 'full', 'implemented_parts': ['Reshaping functions for Dia matrices'], 'confidence': 1.0, 'evidence': ['cpdef Dia reshape_dia', 'cpdef Dia column_stack_dia', 'cpdef Dia column_unstack_dia']}, {'name': 'Dense Reshaping', 'match_type': 'full', 'implemented_parts': ['Reshaping functions for Dense matrices'], 'confidence': 1.0, 'evidence': ['cpdef Dense reshape_dense', 'cpdef Dense column_stack_dense', 'cpdef Dense column_unstack_dense']}]",This file provides functions for reshaping quantum data matrices.,"{'constants': [], 'types': [], 'classes': [], 'functions': ['Reshaping functions for CSR, Dia, and Dense matrices']}"
