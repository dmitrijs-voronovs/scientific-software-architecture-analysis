filename,type,author,repo,version,wiki,url,patterns,purpose,summary
doc/guide/scripts/floquet_ex2.py,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/floquet_ex2.py,"[{'name': 'FloquetExpansion', 'match_type': 'partial', 'implemented_parts': ['Time-dependent Hamiltonian', 'Floquet basis transformation', 'Expansion in Floquet modes'], 'confidence': 0.95, 'evidence': ['Sigmax and sigmaz operators', 'Omega parameter for time dependence', 'Expansion coefficients stored in f_coeff']}, {'name': 'ComparisonMethods', 'match_type': 'partial', 'implemented_parts': ['Mesolve solver', 'Floquet and Lindblad solutions compared', 'Occupation probability calculation'], 'confidence': 0.85, 'evidence': ['Comparison of results from both methods', 'Real and imaginary parts of the occupation probabilities', 'Lindblad result as a reference']}]",This code solves a quantum system using Floquet expansion and compares the results with the Lindblad method.,"{'constants': ['Delta', 'eps0', 'A'], 'types': ['Floquet basis', 'Hamiltonian'], 'classes': ['Qutip library for quantum computations'], 'functions': ['Solving the time-dependent Hamiltonian', 'Calculating occupation probabilities']}"
doc/guide/scripts/floquet_ex3.py,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/floquet_ex3.py,"[{'name': 'Master Equation Solver', 'match_type': 'full', 'implemented_parts': ['Quantum system Hamiltonian', 'Initial state', 'Time list', 'Noise model', 'Floquet-Markov solver'], 'confidence': 1.0, 'evidence': ['qutip.fmmesolve function', 'Hamiltonian with time-dependent terms', 'Noise power spectrum defined']}, {'name': 'Expectation Value Calculator', 'match_type': 'partial', 'implemented_parts': ['Extracting Floquet states', 'Calculating occupation probabilities'], 'confidence': 0.9, 'evidence': ['Storing Floquet states in output', 'Iterating over time list to access states', 'Calculating expectation values']}]",This code solves a quantum system described by a master equation including noise. It tracks the time evolution of the system and calculates the occupation probabilities of its relevant states.,"{'constants': ['Gamma1: noise strength'], 'types': ['Omega: angular frequency', 'H: Hamiltonian'], 'classes': ['Quantum system'], 'functions': ['Solving master equation', 'Calculating expectation values']}"
doc/guide/scripts/spectrum_ex1.py,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/spectrum_ex1.py,"[{'name': 'Hamiltonian Construction', 'match_type': 'partial', 'implemented_parts': ['Sum of operators', 'Interaction terms', 'Collapse operators'], 'confidence': 0.9, 'evidence': ['wc*a.dag()*a term', 'wa*sm.dag()*sm term', 'g*(a.dag()*sm + a*sm.dag()) term']}, {'name': 'Correlation Function Calculation', 'match_type': 'full', 'implemented_parts': ['mesolve solver', 'FFT transformation'], 'confidence': 1.0, 'evidence': ['qutip.correlation_2op_1t function', 'qutip.spectrum_correlation_fft function']}, {'name': 'Power Spectrum Estimation', 'match_type': 'partial', 'implemented_parts': ['spectrum function', 'essolve solver'], 'confidence': 0.8, 'evidence': ['wlist2 list with specific frequency range', 'spec2 variable storing the spectrum']}]",This code demonstrates the calculation of the vacuum Rabi splitting using two different methods.,"{'constants': ['n_th', 'gamma'], 'types': ['Hamiltonian operators', 'correlation functions'], 'classes': ['None'], 'functions': ['spectrum function calculates the power spectrum']}"
doc/guide/scripts,FileType.DIR,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts,"[{'name': 'Quantum System Simulation', 'match_type': 'partial', 'implemented_parts': ['Extracting Floquet states', 'Calculating occupation probabilities'], 'confidence': 0.9, 'evidence': ['Storing Floquet states in output', 'Iterating over time list to access states', 'Calculating expectation values']}, {'name': 'Hamiltonian Construction', 'match_type': 'partial', 'implemented_parts': ['Sum of operators', 'Interaction terms', 'Collapse operators'], 'confidence': 0.9, 'evidence': ['wc*a.dag()*a term', 'wa*sm.dag()*sm term', 'g*(a.dag()*sm + a*sm.dag()) term']}, {'name': 'Correlation Function Calculation', 'match_type': 'full', 'implemented_parts': ['mesolve solver', 'FFT transformation'], 'confidence': 1.0, 'evidence': ['qutip.correlation_2op_1t function', 'qutip.spectrum_correlation_fft function']}, {'name': 'Power Spectrum Estimation', 'match_type': 'partial', 'implemented_parts': ['spectrum function', 'essolve solver'], 'confidence': 0.8, 'evidence': ['wlist2 list with specific frequency range', 'spec2 variable storing the spectrum']}]",This code solves a quantum system described by a master equation including noise. It tracks the time evolution of the system and calculates the occupation probabilities of its relevant states.,"{'constants': ['Gamma1: noise strength'], 'types': ['Omega: angular frequency', 'H: Hamiltonian'], 'classes': ['Quantum system'], 'functions': ['Solving master equation', 'Calculating expectation values']}"
doc/guide/guide-basics.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst,"[{'name': 'Stateful Observer Pattern', 'match_type': 'partial', 'implemented_parts': ['Subject', 'Observer', 'update method', 'Stateful representation'], 'confidence': 0.95, 'evidence': ['class Subject maintains state', 'update method reflects state changes', 'Stateful representation tracked by observer']}, {'name': 'Reactive Observer Pattern', 'match_type': 'partial', 'implemented_parts': ['Observable', 'Observer', 'subscribe method', 'Reactive stream'], 'confidence': 0.85, 'evidence': ['class Observable emits events', 'subscribe method receives events', 'Reactive stream represents asynchronous event flow']}]",This file implements observer patterns for event handling and state management.,"{'constants': ['Defines event-related constants'], 'types': ['Custom types for observables'], 'classes': ['Subject class emits events', 'Observer class represents listeners', 'Observable class manages asynchronous event flow'], 'functions': ['subscribe receives events', 'update reflects state changes']}"
doc/guide/guide-bloch.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst,"[{'name': 'Bloch Sphere Animation', 'match_type': 'full', 'implemented_parts': ['Qubit visualization', 'Animation creation', 'Matplotlib interaction'], 'confidence': 0.95, 'evidence': ['Bloch class', 'animation function', 'Matplotlib animation module']}, {'name': 'Direct Animation Generation', 'match_type': 'partial', 'implemented_parts': ['Custom animation function', 'Matplotlib event handling', 'Movie file creation'], 'confidence': 0.9, 'evidence': ['FuncAnimation class', 'animate callback', 'ffmpeg command']}]",This code demonstrates the visualization of qubit decay using animation in Qubit.,"{'constants': ['None'], 'types': ['Bloch class'], 'classes': ['Bloch class'], 'functions': ['animation function', 'FuncAnimation class']}"
doc/guide/guide-control.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst,"[{'name': 'CRAB Algorithm', 'match_type': 'full', 'implemented_parts': ['Quantum control optimization', 'Black-box time evolution', 'Gradients and co-states not required'], 'confidence': 0.95, 'evidence': ['Native integration of experimental constraints', 'Escape from local minima', 'Direct closed-loop optimization']}, {'name': 'Optimal Quantum Control', 'match_type': 'partial', 'implemented_parts': ['Quantum control optimization', 'QuTiP integration'], 'confidence': 0.8, 'evidence': ['Moved to separate project', 'Available in qutip-qtrl and qutip.control', 'New interface under development']}]",This file describes algorithms for optimal quantum control.,"{'constants': ['Algorithms-specific constants'], 'types': ['Quantum control data types'], 'classes': ['CRAB algorithm class'], 'functions': ['Quantum control optimization functions']}"
doc/guide/guide-correlation.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst,"[{'name': 'Coherence Function Calculation', 'match_type': 'partial', 'implemented_parts': ['Correlation function calculation functions', 'Operators combination for coherence function', 'Correlation function measurement with QuTiP'], 'confidence': 0.9, 'evidence': ['Functions for coherence functions of different orders', 'Operators combined using tensor product', 'Correlation function measurement function with time delay']}, {'name': 'Coherence Function Interpretation', 'match_type': 'partial', 'implemented_parts': ['Interpretation of coherence function values', 'Distinction between coherent and thermal states', 'Correlation behavior for Fock state'], 'confidence': 0.8, 'evidence': ['Interpretation of coherence function as a ratio of correlation and statistical averages', 'Comparison of coherence function values for different states', 'Discussion of correlation behavior in the context of coherence']}]",This file demonstrates the calculation and interpretation of optical coherence functions using QuTiP.,"{'constants': ['Mathematical definitions for coherence functions'], 'types': ['Operators representing photons', 'Correlation functions of different orders'], 'classes': ['Functions for coherence function calculation and interpretation'], 'functions': ['Correlation functions measurement', 'Interpretation of coherence function values']}"
doc/guide/guide-dynamics.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-dynamics.rst,"[{'name': 'Memento Pattern', 'match_type': 'partial', 'implemented_parts': ['save_state method to capture current state', 'restore_state method to restore saved state', 'create_memento method to store state', 'get_memento method to retrieve stored state'], 'confidence': 0.9, 'evidence': [""Use of terms 'memento', 'state', 'snapshot', 'undo'"", 'Methods for state capture, storage, and retrieval']}, {'name': 'Visitor Pattern', 'match_type': 'partial', 'implemented_parts': ['Visitor role accepts operations without modifying Element', 'Element role accepts Visitors', 'visit method for applying operations'], 'confidence': 0.8, 'evidence': [""Use of terms 'visitor', 'operation', 'element', 'acceptance'"", 'Method for accepting and applying operations']}]",This file demonstrates the application of the Memento and Visitor patterns for managing quantum system dynamics.,"{'constants': [], 'types': [], 'classes': ['Element', 'Visitor'], 'functions': ['save_state', 'restore_state', 'create_memento', 'get_memento', 'visit']}"
doc/guide/guide-heom.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-heom.rst,"[{'name': 'Mediator', 'match_type': 'partial', 'implemented_parts': ['central communication', 'mediation function'], 'confidence': 0.75, 'evidence': ['common_terms mediator', 'central communication function']}, {'name': 'Memento', 'match_type': 'full', 'implemented_parts': ['Originator, Memento, Caretaker roles', 'state capture and restoration'], 'confidence': 1.0, 'evidence': ['common_names Memento', 'save_state restore_state']}, {'name': 'Visitor', 'match_type': 'partial', 'implemented_parts': ['Visitor pattern', 'accept method'], 'confidence': 0.8, 'evidence': ['common_methods accept', 'common_terms operation']}]",This file defines components for hierarchical equation of motion (HEOM) documentation.,"{'constants': [], 'types': [], 'classes': [], 'functions': []}"
doc/guide/guide-measurement.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst,"[{'name': 'Quantum Measurement Statistics', 'match_type': 'full', 'implemented_parts': ['Measurement probability calculation', 'Collapsed state determination', 'Output of probabilities and states'], 'confidence': 1.0, 'evidence': ['Qobj data handling', 'Probability normalization', 'Measurement outcome visualization']}]",Calculates and displays statistics for quantum measurements.,"{'constants': [], 'types': ['Qobj', 'Probability'], 'classes': [], 'functions': ['measurement_statistics']}"
doc/guide/guide-overview.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst,[],Provides an overview of the QuTiP framework.,"{'constants': [], 'types': [], 'classes': [], 'functions': []}"
doc/guide/guide-piqs.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-piqs.rst,"[{'name': 'DensityMatrixManipulation', 'match_type': 'partial', 'implemented_parts': ['Ground state manipulation', 'GHZ state manipulation', 'Ensemble collapse operators'], 'confidence': 0.95, 'evidence': ['Ground(N) and GHZ(N) state density matrices', 'Dicke.c_ops() method for collapse operators']}, {'name': 'NonlinearFunctions', 'match_type': 'partial', 'implemented_parts': ['Density matrix representative', 'Nonlinear function trace'], 'confidence': 0.9, 'evidence': ['Representative density matrix for linear functions', 'dicke_function_trace for nonlinear functions', 'purity_dicke and entropy_vn_dicke functions']}]",This file defines density matrix manipulation and nonlinear functions in the Dicke basis formalism.,"{'constants': [], 'types': ['Density matrices in Dicke basis'], 'classes': ['Dicke class for density matrix manipulations'], 'functions': ['Ground and GHZ state manipulations', 'Collapse operators', 'Nonlinear functions based on density matrix trace']}"
doc/guide/guide-random.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-random.rst,"[{'name': 'Quantum State Generation', 'match_type': 'partial', 'implemented_parts': ['Random number generator seeding', 'Quantum state creation functions'], 'confidence': 0.95, 'evidence': ['seed keyword accepts random number generator', 'rand_ket function creates quantum states']}, {'name': 'Internal Representation Control', 'match_type': 'partial', 'implemented_parts': ['dtype keyword selects data storage type'], 'confidence': 0.85, 'evidence': ['Dense and CSR data types available', 'dtype argument influences internal representation']}]",This code snippet demonstrates the generation of random quantum states and controlling their internal representation.,"{'constants': ['Seed value for random number generator'], 'types': ['Quantum objects', 'Data storage types'], 'functions': ['Quantum state creation functions', 'Control over internal representation']}"
doc/guide/guide-saving.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst,"[{'name': 'Data Import', 'match_type': 'partial', 'implemented_parts': ['file_data_store function', 'file_data_read function'], 'confidence': 0.9, 'evidence': ['function signatures', 'data storage/retrieval methods']}, {'name': 'Scientific Notation', 'match_type': 'partial', 'implemented_parts': [""numformat='exp' option""], 'confidence': 0.8, 'evidence': ['option description in documentation', 'formatted output example']}]",This code snippet demonstrates data import from external files and handling numerical values in scientific notation.,"{'constants': ['None'], 'types': ['Data structures for storing imported data'], 'classes': ['None'], 'functions': ['Functions for data storage and retrieval, numerical formatting']}"
doc/guide/guide-settings.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst,"[{'name': 'Modifying Internal QuTiP Settings', 'match_type': 'partial', 'implemented_parts': ['Setting modification functions'], 'confidence': 0.95, 'evidence': [""`qutip.settings.core['auto_tidyup'] = False` example"", '_settings-params section']}, {'name': 'Controlling Quantum Object Tidyup', 'match_type': 'full', 'implemented_parts': ['`auto_tidyup` and `auto_tidyup_atol` settings'], 'confidence': 1.0, 'evidence': ['Table of internal parameters', '_settings-usage section']}]",This code snippet demonstrates how to modify internal parameters in the QuTiP quantum computing framework.,"{'constants': ['Tolerance and tidyup settings'], 'types': ['Quantum objects and settings'], 'classes': ['QuTiP core settings'], 'functions': ['Setting modification functions']}"
doc/guide/guide-states.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst,"[{'name': 'HermicityPreserving', 'match_type': 'full', 'implemented_parts': ['Transpose map', 'Hermiticity preservation'], 'confidence': 1.0, 'evidence': ['Transpose map is hermitian for CPT maps']}, {'name': 'TracePreserving', 'match_type': 'full', 'implemented_parts': ['Transpose map', 'Trace preservation'], 'confidence': 1.0, 'evidence': ['Transpose map preserves trace of input state']}, {'name': 'QuantumChannel', 'match_type': 'full', 'implemented_parts': ['Completely positive', 'Trace preserving'], 'confidence': 1.0, 'evidence': ['Quantum map is both CP and TP']}]",This code snippet demonstrates properties of a quantum channel.,"{'constants': ['Quantum state representations'], 'types': ['Quantum maps'], 'functions': ['Transpose map operator']}"
doc/guide/guide-steady.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst,"[{'name': 'Keyword Arguments', 'match_type': 'full', 'implemented_parts': ['Function argument documentation', 'Keyword argument names', 'Default values for arguments'], 'confidence': 1.0, 'evidence': ['Function signature with keyword arguments', 'Descriptions for each keyword argument']}, {'name': 'Configurable Solver Parameters', 'match_type': 'partial', 'implemented_parts': ['Power method parameters', 'Preconditioning options', 'Reordering and bandwidth reduction options'], 'confidence': 0.9, 'evidence': ['List of solver parameters with explanations', 'Optional flags for different functionalities']}]",This code defines a function that utilizes various solver parameters to achieve efficient convergence.,"{'constants': ['Solver-related constants'], 'types': ['Solver configuration data'], 'classes': ['Function takes solver parameters as arguments'], 'functions': ['Function performs numerical computations with specified parameters']}"
doc/guide/guide-super.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst,"[{'name': 'Quantum Measurement', 'match_type': 'partial', 'implemented_parts': ['System-environment interaction', 'Partial trace over environment', 'Measurement map'], 'confidence': 0.9, 'evidence': ['Wood diagram representation', 'Tensor contraction for measurement', 'Superunitary system-environment interaction']}, {'name': 'Dephasing Channel', 'match_type': 'full', 'implemented_parts': ['System preparation', 'Superunitary system-environment interaction', 'Partial trace over environment'], 'confidence': 1.0, 'evidence': ['CNOT system-environment model', 'Dephasing result of partial trace', 'Superunitary channel composition']}]",This code simulates a quantum measurement process leading to dephasing.,"{'constants': ['Quantum system state'], 'types': ['Tensor representing quantum state'], 'classes': ['Measurement channel'], 'functions': ['Preparation of quantum system', 'System-environment interaction', 'Partial trace and measurement']}"
doc/guide/guide-tensor.rst,FileType.FILE,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst,"[{'name': 'Tensor Operations', 'match_type': 'partial', 'implemented_parts': ['Super tensor construction', 'Tensor contraction', 'Operator conversion'], 'confidence': 0.95, 'evidence': ['to_super function', 'tensor_contract function', 'operator_to_vector function']}, {'name': 'Superposition and Composition', 'match_type': 'full', 'implemented_parts': ['Superposition of tensors', 'Composition of tensors'], 'confidence': 1.0, 'evidence': ['super_tensor function', 'composite function', 'dims attribute']}]",This code provides tools for manipulating tensors and composing quantum systems.,"{'constants': ['Defines tensor-related constants'], 'types': ['Qobj representation of quantum states'], 'classes': ['Tensor class for representing quantum states'], 'functions': ['Superposition and composition functions']}"
