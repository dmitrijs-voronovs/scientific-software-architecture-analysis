id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:5545,Security,Access,Access,5545," ROOT::Math::SVector<double,2U*(2U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,2,2>fRep; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:5568,Security,access,access,5568," ROOT::Math::SVector<double,2U*(2U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,2,2>fRep; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:5673,Security,access,accessing,5673," ROOT::Math::SVector<double,2U*(2U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,2,2>fRep; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:5938,Security,access,access,5938,"2,ROOT::Math::MatRepStd<double,2,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:6962,Security,access,access,6962,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:7076,Security,access,access,7076,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:7192,Security,access,access,7192,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:7370,Security,access,access,7370,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:7294,Testability,assert,assert,7294,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:7471,Testability,assert,assert,7471,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow.html:2141,Modifiability,Inherit,Inheritance,2141,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepStd<double,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow.html:2154,Modifiability,Inherit,Inherited,2154,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow&&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepStd<double,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow_const.html:2261,Modifiability,Inherit,Inheritance,2261,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepStd<double,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow_const.html:2274,Modifiability,Inherit,Inherited,2274,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepStd<double,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepStd<double,2,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:9563,Availability,error,error,9563,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:9632,Availability,failure,failure,9632,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:9978,Availability,error,error,9978,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:10047,Availability,failure,failure,10047,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:11160,Availability,error,error,11160,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5831,Integrability,interface,interface,5831,"e,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:6284,Integrability,interface,interface,6284,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:6326,Integrability,interface,interface,6326,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:6388,Integrability,interface,interface,6388,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:6448,Integrability,interface,interface,6448,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:8112,Integrability,rout,routine,8112," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5025,Modifiability,Inherit,Inheritance,5025,"T::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepSym<double,2> >& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const double& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const ROOT::Math::SVector<double,2U*(2U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,2>fRep; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5038,Modifiability,Inherit,Inherited,5038,"T::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepSym<double,2> >& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const double& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const ROOT::Math::SVector<double,2U*(2U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,2>fRep; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:9815,Performance,perform,performing,9815,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:11511,Safety,avoid,avoid,11511,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5467,Security,Access,Access,5467," >(const ROOT::Math::SVector<double,2U*(2U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,2>fRep; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5490,Security,access,access,5490," >(const ROOT::Math::SVector<double,2U*(2U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,2>fRep; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5595,Security,access,accessing,5595," >(const ROOT::Math::SVector<double,2U*(2U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,2>fRep; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5860,Security,access,access,5860,"e,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:6884,Security,access,access,6884,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:6998,Security,access,access,6998,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:7114,Security,access,access,7114,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:7292,Security,access,access,7292,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:7216,Testability,assert,assert,7216,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:7393,Testability,assert,assert,7393,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow.html:2113,Modifiability,Inherit,Inheritance,2113,", where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepSym<double,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow.html:2126,Modifiability,Inherit,Inherited,2126,", where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow&&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepSym<double,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow_const.html:2233,Modifiability,Inherit,Inheritance,2233,"on, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepSym<double,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow_const.html:2246,Modifiability,Inherit,Inherited,2246,"on, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepSym<double,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,2U,2U,ROOT::Math::MatRepSym<double,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:9641,Availability,error,error,9641,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:9710,Availability,failure,failure,9710,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:10056,Availability,error,error,10056,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:10125,Availability,failure,failure,10125,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:11238,Availability,error,error,11238,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:5909,Integrability,interface,interface,5909,"3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:6362,Integrability,interface,interface,6362,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:6404,Integrability,interface,interface,6404,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:6466,Integrability,interface,interface,6466,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:6526,Integrability,interface,interface,6526,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:8190,Integrability,rout,routine,8190," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:5103,Modifiability,Inherit,Inheritance,5103,"ty); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepStd<double,3,3> >& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const ROOT::Math::SVector<double,3U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,3,3>fRep; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:5116,Modifiability,Inherit,Inherited,5116,"ty); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepStd<double,3,3> >& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const ROOT::Math::SVector<double,3U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,3,3>fRep; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:9893,Performance,perform,performing,9893,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:11589,Safety,avoid,avoid,11589,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:5545,Security,Access,Access,5545," ROOT::Math::SVector<double,3U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,3,3>fRep; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:5568,Security,access,access,5568," ROOT::Math::SVector<double,3U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,3,3>fRep; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:5673,Security,access,accessing,5673," ROOT::Math::SVector<double,3U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,3,3>fRep; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:5938,Security,access,access,5938,"3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:6962,Security,access,access,6962,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:7076,Security,access,access,7076,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:7192,Security,access,access,7192,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:7370,Security,access,access,7370,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:7294,Testability,assert,assert,7294,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:7471,Testability,assert,assert,7471,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow.html:2141,Modifiability,Inherit,Inheritance,2141,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepStd<double,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow.html:2154,Modifiability,Inherit,Inherited,2154,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow&&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepStd<double,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow_const.html:2261,Modifiability,Inherit,Inheritance,2261,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepStd<double,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow_const.html:2274,Modifiability,Inherit,Inherited,2274,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepStd<double,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepStd<double,3,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:9563,Availability,error,error,9563,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:9632,Availability,failure,failure,9632,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:9978,Availability,error,error,9978,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:10047,Availability,failure,failure,10047,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:11160,Availability,error,error,11160,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5831,Integrability,interface,interface,5831,"e,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:6284,Integrability,interface,interface,6284,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:6326,Integrability,interface,interface,6326,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:6388,Integrability,interface,interface,6388,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:6448,Integrability,interface,interface,6448,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:8112,Integrability,rout,routine,8112," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5025,Modifiability,Inherit,Inheritance,5025,"T::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepSym<double,3> >& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const ROOT::Math::SVector<double,3U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,3>fRep; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5038,Modifiability,Inherit,Inherited,5038,"T::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepSym<double,3> >& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const ROOT::Math::SVector<double,3U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,3>fRep; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:9815,Performance,perform,performing,9815,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:11511,Safety,avoid,avoid,11511,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5467,Security,Access,Access,5467," >(const ROOT::Math::SVector<double,3U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,3>fRep; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5490,Security,access,access,5490," >(const ROOT::Math::SVector<double,3U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,3>fRep; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5595,Security,access,accessing,5595," >(const ROOT::Math::SVector<double,3U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,3>fRep; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5860,Security,access,access,5860,"e,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:6884,Security,access,access,6884,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:6998,Security,access,access,6998,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:7114,Security,access,access,7114,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:7292,Security,access,access,7292,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:7216,Testability,assert,assert,7216,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:7393,Testability,assert,assert,7393,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow.html:2113,Modifiability,Inherit,Inheritance,2113,", where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepSym<double,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow.html:2126,Modifiability,Inherit,Inherited,2126,", where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow&&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepSym<double,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow_const.html:2233,Modifiability,Inherit,Inheritance,2233,"on, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepSym<double,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow_const.html:2246,Modifiability,Inherit,Inherited,2246,"on, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepSym<double,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,3U,3U,ROOT::Math::MatRepSym<double,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:9641,Availability,error,error,9641,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:9710,Availability,failure,failure,9710,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:10056,Availability,error,error,10056,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:10125,Availability,failure,failure,10125,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:11238,Availability,error,error,11238,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:5909,Integrability,interface,interface,5909,"4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:6362,Integrability,interface,interface,6362,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:6404,Integrability,interface,interface,6404,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:6466,Integrability,interface,interface,6466,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:6526,Integrability,interface,interface,6526,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:8190,Integrability,rout,routine,8190," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:5103,Modifiability,Inherit,Inheritance,5103,"ty); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const ROOT::Math::SMatrix<double,3U,4U,ROOT::Math::MatRepStd<double,3,4> >& rhs); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const double& rhs); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const ROOT::Math::SVector<double,3U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,3,4>fRep; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:5116,Modifiability,Inherit,Inherited,5116,"ty); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const ROOT::Math::SMatrix<double,3U,4U,ROOT::Math::MatRepStd<double,3,4> >& rhs); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const double& rhs); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const ROOT::Math::SVector<double,3U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,3,4>fRep; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:9893,Performance,perform,performing,9893,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:11589,Safety,avoid,avoid,11589,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:5545,Security,Access,Access,5545," ROOT::Math::SVector<double,3U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,3,4>fRep; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:5568,Security,access,access,5568," ROOT::Math::SVector<double,3U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,3,4>fRep; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:5673,Security,access,accessing,5673," ROOT::Math::SVector<double,3U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,3,4>fRep; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:5938,Security,access,access,5938,"4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:6962,Security,access,access,6962,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:7076,Security,access,access,7076,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:7192,Security,access,access,7192,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:7370,Security,access,access,7370,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:7294,Testability,assert,assert,7294,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:7471,Testability,assert,assert,7471,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow.html:2141,Modifiability,Inherit,Inheritance,2141,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3U,4U,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,3U,4U,ROOT::Math::MatRepStd<double,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,3U,4U,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow.html:2154,Modifiability,Inherit,Inherited,2154,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow&&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,3U,4U,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,3U,4U,ROOT::Math::MatRepStd<double,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,3U,4U,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow_const.html:2261,Modifiability,Inherit,Inheritance,2261,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3U,4U,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,3U,4U,ROOT::Math::MatRepStd<double,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,3U,4U,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow_const.html:2274,Modifiability,Inherit,Inherited,2274,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,3U,4U,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,3U,4U,ROOT::Math::MatRepStd<double,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,3U,4U,ROOT::Math::MatRepStd<double,3,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:9641,Availability,error,error,9641,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:9710,Availability,failure,failure,9710,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:10056,Availability,error,error,10056,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:10125,Availability,failure,failure,10125,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:11238,Availability,error,error,11238,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:5909,Integrability,interface,interface,5909,"3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:6362,Integrability,interface,interface,6362,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:6404,Integrability,interface,interface,6404,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:6466,Integrability,interface,interface,6466,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:6526,Integrability,interface,interface,6526,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:8190,Integrability,rout,routine,8190," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:5103,Modifiability,Inherit,Inheritance,5103,"ty); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const ROOT::Math::SMatrix<double,4U,3U,ROOT::Math::MatRepStd<double,4,3> >& rhs); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const double& rhs); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const ROOT::Math::SVector<double,4U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,4,3>fRep; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:5116,Modifiability,Inherit,Inherited,5116,"ty); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const ROOT::Math::SMatrix<double,4U,3U,ROOT::Math::MatRepStd<double,4,3> >& rhs); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const double& rhs); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const ROOT::Math::SVector<double,4U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,4,3>fRep; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:9893,Performance,perform,performing,9893,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:11589,Safety,avoid,avoid,11589,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:5545,Security,Access,Access,5545," ROOT::Math::SVector<double,4U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,4,3>fRep; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:5568,Security,access,access,5568," ROOT::Math::SVector<double,4U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,4,3>fRep; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:5673,Security,access,accessing,5673," ROOT::Math::SVector<double,4U*(3U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,4,3>fRep; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:5938,Security,access,access,5938,"3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:6962,Security,access,access,6962,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:7076,Security,access,access,7076,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:7192,Security,access,access,7192,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:7370,Security,access,access,7370,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:7294,Testability,assert,assert,7294,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:7471,Testability,assert,assert,7471,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow.html:2141,Modifiability,Inherit,Inheritance,2141,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4U,3U,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,4U,3U,ROOT::Math::MatRepStd<double,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,4U,3U,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow.html:2154,Modifiability,Inherit,Inherited,2154,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow&&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4U,3U,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,4U,3U,ROOT::Math::MatRepStd<double,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,4U,3U,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow_const.html:2261,Modifiability,Inherit,Inheritance,2261,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4U,3U,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,4U,3U,ROOT::Math::MatRepStd<double,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,4U,3U,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow_const.html:2274,Modifiability,Inherit,Inherited,2274,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4U,3U,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,4U,3U,ROOT::Math::MatRepStd<double,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,4U,3U,ROOT::Math::MatRepStd<double,4,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:9641,Availability,error,error,9641,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:9710,Availability,failure,failure,9710,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:10056,Availability,error,error,10056,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:10125,Availability,failure,failure,10125,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:11238,Availability,error,error,11238,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:5909,Integrability,interface,interface,5909,"4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:6362,Integrability,interface,interface,6362,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:6404,Integrability,interface,interface,6404,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:6466,Integrability,interface,interface,6466,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:6526,Integrability,interface,interface,6526,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:8190,Integrability,rout,routine,8190," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:5103,Modifiability,Inherit,Inheritance,5103,"ty); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepStd<double,4,4> >& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const ROOT::Math::SVector<double,4U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,4,4>fRep; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:5116,Modifiability,Inherit,Inherited,5116,"ty); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepStd<double,4,4> >& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const ROOT::Math::SVector<double,4U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,4,4>fRep; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:9893,Performance,perform,performing,9893,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:11589,Safety,avoid,avoid,11589,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:5545,Security,Access,Access,5545," ROOT::Math::SVector<double,4U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,4,4>fRep; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:5568,Security,access,access,5568," ROOT::Math::SVector<double,4U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,4,4>fRep; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:5673,Security,access,accessing,5673," ROOT::Math::SVector<double,4U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,4,4>fRep; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:5938,Security,access,access,5938,"4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:6962,Security,access,access,6962,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:7076,Security,access,access,7076,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:7192,Security,access,access,7192,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:7370,Security,access,access,7370,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:7294,Testability,assert,assert,7294,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:7471,Testability,assert,assert,7471,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow.html:2141,Modifiability,Inherit,Inheritance,2141,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepStd<double,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow.html:2154,Modifiability,Inherit,Inherited,2154,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow&&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepStd<double,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow_const.html:2261,Modifiability,Inherit,Inheritance,2261,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepStd<double,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow_const.html:2274,Modifiability,Inherit,Inherited,2274,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepStd<double,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepStd<double,4,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:9563,Availability,error,error,9563,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:9632,Availability,failure,failure,9632,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:9978,Availability,error,error,9978,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:10047,Availability,failure,failure,10047,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:11160,Availability,error,error,11160,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5831,Integrability,interface,interface,5831,"e,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:6284,Integrability,interface,interface,6284,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:6326,Integrability,interface,interface,6326,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:6388,Integrability,interface,interface,6388,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:6448,Integrability,interface,interface,6448,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:8112,Integrability,rout,routine,8112," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5025,Modifiability,Inherit,Inheritance,5025,"T::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepSym<double,4> >& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const ROOT::Math::SVector<double,4U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,4>fRep; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5038,Modifiability,Inherit,Inherited,5038,"T::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepSym<double,4> >& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const ROOT::Math::SVector<double,4U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,4>fRep; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:9815,Performance,perform,performing,9815,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:11511,Safety,avoid,avoid,11511,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5467,Security,Access,Access,5467," >(const ROOT::Math::SVector<double,4U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,4>fRep; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5490,Security,access,access,5490," >(const ROOT::Math::SVector<double,4U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,4>fRep; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5595,Security,access,accessing,5595," >(const ROOT::Math::SVector<double,4U*(4U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,4>fRep; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5860,Security,access,access,5860,"e,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:6884,Security,access,access,6884,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:6998,Security,access,access,6998,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:7114,Security,access,access,7114,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:7292,Security,access,access,7292,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:7216,Testability,assert,assert,7216,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:7393,Testability,assert,assert,7393,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow.html:2113,Modifiability,Inherit,Inheritance,2113,", where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepSym<double,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow.html:2126,Modifiability,Inherit,Inherited,2126,", where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow&&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepSym<double,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow_const.html:2233,Modifiability,Inherit,Inheritance,2233,"on, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepSym<double,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow_const.html:2246,Modifiability,Inherit,Inherited,2246,"on, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepSym<double,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,4U,4U,ROOT::Math::MatRepSym<double,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:9641,Availability,error,error,9641,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:9710,Availability,failure,failure,9710,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:10056,Availability,error,error,10056,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:10125,Availability,failure,failure,10125,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:11238,Availability,error,error,11238,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:5909,Integrability,interface,interface,5909,"5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:6362,Integrability,interface,interface,6362,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:6404,Integrability,interface,interface,6404,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:6466,Integrability,interface,interface,6466,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:6526,Integrability,interface,interface,6526,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:8190,Integrability,rout,routine,8190," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:5103,Modifiability,Inherit,Inheritance,5103,"ty); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepStd<double,5,5> >& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const ROOT::Math::SVector<double,5U*(5U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,5,5>fRep; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:5116,Modifiability,Inherit,Inherited,5116,"ty); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepStd<double,5,5> >& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const ROOT::Math::SVector<double,5U*(5U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,5,5>fRep; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:9893,Performance,perform,performing,9893,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:11589,Safety,avoid,avoid,11589,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:5545,Security,Access,Access,5545," ROOT::Math::SVector<double,5U*(5U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,5,5>fRep; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:5568,Security,access,access,5568," ROOT::Math::SVector<double,5U*(5U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,5,5>fRep; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:5673,Security,access,accessing,5673," ROOT::Math::SVector<double,5U*(5U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,5,5>fRep; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:5938,Security,access,access,5938,"5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:6962,Security,access,access,6962,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:7076,Security,access,access,7076,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:7192,Security,access,access,7192,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:7370,Security,access,access,7370,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:7294,Testability,assert,assert,7294,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:7471,Testability,assert,assert,7471,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow.html:2141,Modifiability,Inherit,Inheritance,2141,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepStd<double,5,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow.html:2154,Modifiability,Inherit,Inherited,2154,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow&&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepStd<double,5,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow_const.html:2261,Modifiability,Inherit,Inheritance,2261,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepStd<double,5,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow_const.html:2274,Modifiability,Inherit,Inherited,2274,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepStd<double,5,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepStd<double,5,5> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:9563,Availability,error,error,9563,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:9632,Availability,failure,failure,9632,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:9978,Availability,error,error,9978,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:10047,Availability,failure,failure,10047,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:11160,Availability,error,error,11160,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5831,Integrability,interface,interface,5831,"e,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:6284,Integrability,interface,interface,6284,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:6326,Integrability,interface,interface,6326,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:6388,Integrability,interface,interface,6388,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:6448,Integrability,interface,interface,6448,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:8112,Integrability,rout,routine,8112," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5025,Modifiability,Inherit,Inheritance,5025,"T::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepSym<double,5> >& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const ROOT::Math::SVector<double,5U*(5U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,5>fRep; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5038,Modifiability,Inherit,Inherited,5038,"T::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepSym<double,5> >& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const ROOT::Math::SVector<double,5U*(5U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,5>fRep; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:9815,Performance,perform,performing,9815,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:11511,Safety,avoid,avoid,11511,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5467,Security,Access,Access,5467," >(const ROOT::Math::SVector<double,5U*(5U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,5>fRep; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5490,Security,access,access,5490," >(const ROOT::Math::SVector<double,5U*(5U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,5>fRep; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5595,Security,access,accessing,5595," >(const ROOT::Math::SVector<double,5U*(5U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,5>fRep; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5860,Security,access,access,5860,"e,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:6884,Security,access,access,6884,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:6998,Security,access,access,6998,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:7114,Security,access,access,7114,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:7292,Security,access,access,7292,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:7216,Testability,assert,assert,7216,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:7393,Testability,assert,assert,7393,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow.html:2113,Modifiability,Inherit,Inheritance,2113,", where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepSym<double,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow.html:2126,Modifiability,Inherit,Inherited,2126,", where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow&&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepSym<double,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow_const.html:2233,Modifiability,Inherit,Inheritance,2233,"on, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepSym<double,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow_const.html:2246,Modifiability,Inherit,Inherited,2246,"on, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepSym<double,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,5U,5U,ROOT::Math::MatRepSym<double,5> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:9641,Availability,error,error,9641,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:9710,Availability,failure,failure,9710,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:10056,Availability,error,error,10056,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:10125,Availability,failure,failure,10125,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:11238,Availability,error,error,11238,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:5909,Integrability,interface,interface,5909,"6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:6362,Integrability,interface,interface,6362,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:6404,Integrability,interface,interface,6404,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:6466,Integrability,interface,interface,6466,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:6526,Integrability,interface,interface,6526,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:8190,Integrability,rout,routine,8190," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:5103,Modifiability,Inherit,Inheritance,5103,"ty); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepStd<double,6,6> >& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const ROOT::Math::SVector<double,6U*(6U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,6,6>fRep; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:5116,Modifiability,Inherit,Inherited,5116,"ty); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepStd<double,6,6> >& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const ROOT::Math::SVector<double,6U*(6U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,6,6>fRep; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:9893,Performance,perform,performing,9893,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:11589,Safety,avoid,avoid,11589,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:5545,Security,Access,Access,5545," ROOT::Math::SVector<double,6U*(6U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,6,6>fRep; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:5568,Security,access,access,5568," ROOT::Math::SVector<double,6U*(6U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,6,6>fRep; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:5673,Security,access,accessing,5673," ROOT::Math::SVector<double,6U*(6U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,6,6>fRep; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:5938,Security,access,access,5938,"6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:6962,Security,access,access,6962,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:7076,Security,access,access,7076,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:7192,Security,access,access,7192,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:7370,Security,access,access,7370,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:7294,Testability,assert,assert,7294,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:7471,Testability,assert,assert,7471,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow.html:2141,Modifiability,Inherit,Inheritance,2141,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepStd<double,6,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow.html:2154,Modifiability,Inherit,Inherited,2154,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow&&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepStd<double,6,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow_const.html:2261,Modifiability,Inherit,Inheritance,2261,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepStd<double,6,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow_const.html:2274,Modifiability,Inherit,Inherited,2274,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepStd<double,6,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepStd<double,6,6> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:9563,Availability,error,error,9563,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:9632,Availability,failure,failure,9632,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:9978,Availability,error,error,9978,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:10047,Availability,failure,failure,10047,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:11160,Availability,error,error,11160,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5831,Integrability,interface,interface,5831,"e,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:6284,Integrability,interface,interface,6284,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:6326,Integrability,interface,interface,6326,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:6388,Integrability,interface,interface,6388,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:6448,Integrability,interface,interface,6448,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:8112,Integrability,rout,routine,8112," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5025,Modifiability,Inherit,Inheritance,5025,"T::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepSym<double,6> >& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const ROOT::Math::SVector<double,6U*(6U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,6>fRep; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5038,Modifiability,Inherit,Inherited,5038,"T::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepSym<double,6> >& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const ROOT::Math::SVector<double,6U*(6U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,6>fRep; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:9815,Performance,perform,performing,9815,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:11511,Safety,avoid,avoid,11511,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5467,Security,Access,Access,5467," >(const ROOT::Math::SVector<double,6U*(6U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,6>fRep; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5490,Security,access,access,5490," >(const ROOT::Math::SVector<double,6U*(6U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,6>fRep; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5595,Security,access,accessing,5595," >(const ROOT::Math::SVector<double,6U*(6U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,6>fRep; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5860,Security,access,access,5860,"e,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:6884,Security,access,access,6884,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:6998,Security,access,access,6998,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:7114,Security,access,access,7114,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:7292,Security,access,access,7292,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:7216,Testability,assert,assert,7216,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:7393,Testability,assert,assert,7393,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow.html:2113,Modifiability,Inherit,Inheritance,2113,", where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepSym<double,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow.html:2126,Modifiability,Inherit,Inherited,2126,", where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow&&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepSym<double,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow_const.html:2233,Modifiability,Inherit,Inheritance,2233,"on, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepSym<double,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow_const.html:2246,Modifiability,Inherit,Inherited,2246,"on, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepSym<double,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,6U,6U,ROOT::Math::MatRepSym<double,6> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:9641,Availability,error,error,9641,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:9710,Availability,failure,failure,9710,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:10056,Availability,error,error,10056,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:10125,Availability,failure,failure,10125,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:11238,Availability,error,error,11238,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:5909,Integrability,interface,interface,5909,"7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:6362,Integrability,interface,interface,6362,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:6404,Integrability,interface,interface,6404,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:6466,Integrability,interface,interface,6466,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:6526,Integrability,interface,interface,6526,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:8190,Integrability,rout,routine,8190," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:5103,Modifiability,Inherit,Inheritance,5103,"ty); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepStd<double,7,7> >& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const ROOT::Math::SVector<double,7U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,7,7>fRep; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:5116,Modifiability,Inherit,Inherited,5116,"ty); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepStd<double,7,7> >& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const ROOT::Math::SVector<double,7U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,7,7>fRep; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:9893,Performance,perform,performing,9893,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:11589,Safety,avoid,avoid,11589,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:5545,Security,Access,Access,5545," ROOT::Math::SVector<double,7U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,7,7>fRep; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:5568,Security,access,access,5568," ROOT::Math::SVector<double,7U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,7,7>fRep; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:5673,Security,access,accessing,5673," ROOT::Math::SVector<double,7U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,7,7>fRep; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:5938,Security,access,access,5938,"7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:6962,Security,access,access,6962,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:7076,Security,access,access,7076,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:7192,Security,access,access,7192,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:7370,Security,access,access,7370,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:7294,Testability,assert,assert,7294,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:7471,Testability,assert,assert,7471,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow.html:2141,Modifiability,Inherit,Inheritance,2141,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepStd<double,7,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow.html:2154,Modifiability,Inherit,Inherited,2154,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow&&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepStd<double,7,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow_const.html:2261,Modifiability,Inherit,Inheritance,2261,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepStd<double,7,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow_const.html:2274,Modifiability,Inherit,Inherited,2274,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepStd<double,7,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepStd<double,7,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:9563,Availability,error,error,9563,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:9632,Availability,failure,failure,9632,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:9978,Availability,error,error,9978,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:10047,Availability,failure,failure,10047,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:11160,Availability,error,error,11160,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5831,Integrability,interface,interface,5831,"e,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:6284,Integrability,interface,interface,6284,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:6326,Integrability,interface,interface,6326,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:6388,Integrability,interface,interface,6388,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:6448,Integrability,interface,interface,6448,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:8112,Integrability,rout,routine,8112," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5025,Modifiability,Inherit,Inheritance,5025,"T::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepSym<double,7> >& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const ROOT::Math::SVector<double,7U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,7>fRep; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5038,Modifiability,Inherit,Inherited,5038,"T::Math::SMatrixIdentity); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepSym<double,7> >& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const ROOT::Math::SVector<double,7U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,7>fRep; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:9815,Performance,perform,performing,9815,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:11511,Safety,avoid,avoid,11511,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5467,Security,Access,Access,5467," >(const ROOT::Math::SVector<double,7U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,7>fRep; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5490,Security,access,access,5490," >(const ROOT::Math::SVector<double,7U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,7>fRep; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5595,Security,access,accessing,5595," >(const ROOT::Math::SVector<double,7U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<double,7>fRep; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5860,Security,access,access,5860,"e,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:6884,Security,access,access,6884,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:6998,Security,access,access,6998,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:7114,Security,access,access,7114,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:7292,Security,access,access,7292,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:7216,Testability,assert,assert,7216,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:7393,Testability,assert,assert,7393,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow.html:2113,Modifiability,Inherit,Inheritance,2113,", where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepSym<double,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow.html:2126,Modifiability,Inherit,Inherited,2126,", where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow&&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepSym<double,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow_const.html:2233,Modifiability,Inherit,Inheritance,2233,"on, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepSym<double,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow_const.html:2246,Modifiability,Inherit,Inherited,2246,"on, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepSym<double,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,7U,7U,ROOT::Math::MatRepSym<double,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:9641,Availability,error,error,9641,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:9710,Availability,failure,failure,9710,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:10056,Availability,error,error,10056,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:10125,Availability,failure,failure,10125,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. re",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:11238,Availability,error,error,11238,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:5909,Integrability,interface,interface,5909,"7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:6362,Integrability,interface,interface,6362,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). r",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:6404,Integrability,interface,interface,6404,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:6466,Integrability,interface,interface,6466,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:6526,Integrability,interface,interface,6526,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operat",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:8190,Integrability,rout,routine,8190," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:5103,Modifiability,Inherit,Inheritance,5103,"ty); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const ROOT::Math::SMatrix<double,9U,7U,ROOT::Math::MatRepStd<double,9,7> >& rhs); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const double& rhs); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const ROOT::Math::SVector<double,9U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,9U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,9,7>fRep; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:5116,Modifiability,Inherit,Inherited,5116,"ty); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const ROOT::Math::SMatrix<double,9U,7U,ROOT::Math::MatRepStd<double,9,7> >& rhs); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const double& rhs); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const ROOT::Math::SVector<double,9U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,9U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,9,7>fRep; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:9893,Performance,perform,performing,9893,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:11589,Safety,avoid,avoid,11589,"re if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:5545,Security,Access,Access,5545," ROOT::Math::SVector<double,9U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,9U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,9,7>fRep; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:5568,Security,access,access,5568," ROOT::Math::SVector<double,9U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,9U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,9,7>fRep; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:5673,Security,access,accessing,5673," ROOT::Math::SVector<double,9U*(7U+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,9U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<double,9,7>fRep; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:5938,Security,access,access,5938,"7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:6962,Security,access,access,6962,"y are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Fun",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:7076,Security,access,access,7076,"r spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is succe",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:7192,Security,access,access,7192,",...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLI",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:7370,Security,access,access,7370,"STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors)",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:7294,Testability,assert,assert,7294,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:7471,Testability,assert,assert,7471,"rator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matri",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow.html:2141,Modifiability,Inherit,Inheritance,2141,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,9U,7U,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,9U,7U,ROOT::Math::MatRepStd<double,9,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,9U,7U,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow.html:2154,Modifiability,Inherit,Inherited,2154,"nly; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&operator=(ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&&); double&operator[](int j); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow&&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<double,9U,7U,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<double,9U,7U,ROOT::Math::MatRepStd<double,9,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<double,9U,7U,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow_const.html:2261,Modifiability,Inherit,Inheritance,2261,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,9U,7U,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,9U,7U,ROOT::Math::MatRepStd<double,9,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,9U,7U,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow_const.html:2274,Modifiability,Inherit,Inherited,2274,"any). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const&&); const double&operator[](int j) const; ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_const&&); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<double,9U,7U,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<double,9U,7U,ROOT::Math::MatRepStd<double,9,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<double,9U,7U,ROOT::Math::MatRepStd<double,9,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:9530,Availability,error,error,9530,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:9599,Availability,failure,failure,9599,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:9945,Availability,error,error,9945,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:10014,Availability,failure,failure,10014,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:11125,Availability,error,error,11125,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:5805,Integrability,interface,interface,5805,",2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6258,Integrability,interface,interface,6258,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6300,Integrability,interface,interface,6300,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6362,Integrability,interface,interface,6362,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6422,Integrability,interface,interface,6422,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:8079,Integrability,rout,routine,8079," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:4999,Modifiability,Inherit,Inheritance,4999,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepStd<float,2,2> >& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const ROOT::Math::SVector<float,2U*(2U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,2,2>fRep; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:5012,Modifiability,Inherit,Inherited,5012,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepStd<float,2,2> >& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const ROOT::Math::SVector<float,2U*(2U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,2,2>fRep; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:9782,Performance,perform,performing,9782,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:11475,Safety,avoid,avoid,11475,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:5441,Security,Access,Access,5441,"2> >(const ROOT::Math::SVector<float,2U*(2U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,2,2>fRep; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:5464,Security,access,access,5464,"2> >(const ROOT::Math::SVector<float,2U*(2U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,2,2>fRep; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:5569,Security,access,accessing,5569,"2> >(const ROOT::Math::SVector<float,2U*(2U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,2,2>fRep; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:5834,Security,access,access,5834,",2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6855,Security,access,access,6855,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6969,Security,access,access,6969,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:7085,Security,access,access,7085,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:7263,Security,access,access,7263,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:7187,Testability,assert,assert,7187,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:7364,Testability,assert,assert,7364,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow.html:2112,Modifiability,Inherit,Inheritance,2112,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepStd<float,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow.html:2125,Modifiability,Inherit,Inherited,2125,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow&&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepStd<float,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow_const.html:2232,Modifiability,Inherit,Inheritance,2232,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepStd<float,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow_const.html:2245,Modifiability,Inherit,Inherited,2245,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepStd<float,2,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepStd<float,2,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:9452,Availability,error,error,9452,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:9521,Availability,failure,failure,9521,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:9867,Availability,error,error,9867,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:9936,Availability,failure,failure,9936,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:11047,Availability,error,error,11047,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:5727,Integrability,interface,interface,5727,"loat,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:6180,Integrability,interface,interface,6180,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:6222,Integrability,interface,interface,6222,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:6284,Integrability,interface,interface,6284,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:6344,Integrability,interface,interface,6344,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:8001,Integrability,rout,routine,8001," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:4921,Modifiability,Inherit,Inheritance,4921,":MatRepSym<float,2> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepSym<float,2> >& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const ROOT::Math::SVector<float,2U*(2U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,2>fRep; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:4934,Modifiability,Inherit,Inherited,4934,":MatRepSym<float,2> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepSym<float,2> >& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const ROOT::Math::SVector<float,2U*(2U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,2>fRep; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:9704,Performance,perform,performing,9704,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:11397,Safety,avoid,avoid,11397,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:5363,Security,Access,Access,5363,"m<float,2> >(const ROOT::Math::SVector<float,2U*(2U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,2>fRep; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:5386,Security,access,access,5386,"m<float,2> >(const ROOT::Math::SVector<float,2U*(2U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,2>fRep; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:5491,Security,access,accessing,5491,"m<float,2> >(const ROOT::Math::SVector<float,2U*(2U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2U*(2U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,2>fRep; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:5756,Security,access,access,5756,"loat,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:6777,Security,access,access,6777,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:6891,Security,access,access,6891,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:7007,Security,access,access,7007,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:7185,Security,access,access,7185,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:7109,Testability,assert,assert,7109,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html:7286,Testability,assert,assert,7286,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow.html:2084,Modifiability,Inherit,Inheritance,2084,"or symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepSym<float,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow.html:2097,Modifiability,Inherit,Inherited,2097,"or symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow&&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepSym<float,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow_const.html:2204,Modifiability,Inherit,Inheritance,2204,"Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepSym<float,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow_const.html:2217,Modifiability,Inherit,Inherited,2217,"Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepSym<float,2> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,2U,2U,ROOT::Math::MatRepSym<float,2> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:9530,Availability,error,error,9530,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:9599,Availability,failure,failure,9599,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:9945,Availability,error,error,9945,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:10014,Availability,failure,failure,10014,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:11125,Availability,error,error,11125,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:5805,Integrability,interface,interface,5805,",3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:6258,Integrability,interface,interface,6258,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:6300,Integrability,interface,interface,6300,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:6362,Integrability,interface,interface,6362,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:6422,Integrability,interface,interface,6422,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:8079,Integrability,rout,routine,8079," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:4999,Modifiability,Inherit,Inheritance,4999,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepStd<float,3,3> >& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const ROOT::Math::SVector<float,3U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,3,3>fRep; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:5012,Modifiability,Inherit,Inherited,5012,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepStd<float,3,3> >& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const ROOT::Math::SVector<float,3U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,3,3>fRep; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:9782,Performance,perform,performing,9782,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:11475,Safety,avoid,avoid,11475,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:5441,Security,Access,Access,5441,"3> >(const ROOT::Math::SVector<float,3U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,3,3>fRep; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:5464,Security,access,access,5464,"3> >(const ROOT::Math::SVector<float,3U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,3,3>fRep; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:5569,Security,access,accessing,5569,"3> >(const ROOT::Math::SVector<float,3U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,3,3>fRep; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:5834,Security,access,access,5834,",3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:6855,Security,access,access,6855,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:6969,Security,access,access,6969,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:7085,Security,access,access,7085,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:7263,Security,access,access,7263,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:7187,Testability,assert,assert,7187,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html:7364,Testability,assert,assert,7364,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow.html:2112,Modifiability,Inherit,Inheritance,2112,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepStd<float,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow.html:2125,Modifiability,Inherit,Inherited,2125,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow&&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepStd<float,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow_const.html:2232,Modifiability,Inherit,Inheritance,2232,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepStd<float,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow_const.html:2245,Modifiability,Inherit,Inherited,2245,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepStd<float,3,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepStd<float,3,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:9452,Availability,error,error,9452,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:9521,Availability,failure,failure,9521,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:9867,Availability,error,error,9867,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:9936,Availability,failure,failure,9936,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:11047,Availability,error,error,11047,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:5727,Integrability,interface,interface,5727,"loat,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:6180,Integrability,interface,interface,6180,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:6222,Integrability,interface,interface,6222,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:6284,Integrability,interface,interface,6284,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:6344,Integrability,interface,interface,6344,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:8001,Integrability,rout,routine,8001," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:4921,Modifiability,Inherit,Inheritance,4921,":MatRepSym<float,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepSym<float,3> >& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const ROOT::Math::SVector<float,3U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,3>fRep; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:4934,Modifiability,Inherit,Inherited,4934,":MatRepSym<float,3> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepSym<float,3> >& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const ROOT::Math::SVector<float,3U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,3>fRep; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:9704,Performance,perform,performing,9704,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:11397,Safety,avoid,avoid,11397,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:5363,Security,Access,Access,5363,"m<float,3> >(const ROOT::Math::SVector<float,3U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,3>fRep; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:5386,Security,access,access,5386,"m<float,3> >(const ROOT::Math::SVector<float,3U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,3>fRep; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:5491,Security,access,accessing,5491,"m<float,3> >(const ROOT::Math::SVector<float,3U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,3>fRep; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:5756,Security,access,access,5756,"loat,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:6777,Security,access,access,6777,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:6891,Security,access,access,6891,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:7007,Security,access,access,7007,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:7185,Security,access,access,7185,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:7109,Testability,assert,assert,7109,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html:7286,Testability,assert,assert,7286,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow.html:2084,Modifiability,Inherit,Inheritance,2084,"or symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepSym<float,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow.html:2097,Modifiability,Inherit,Inherited,2097,"or symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow&&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepSym<float,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow_const.html:2204,Modifiability,Inherit,Inheritance,2204,"Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepSym<float,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow_const.html:2217,Modifiability,Inherit,Inherited,2217,"Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepSym<float,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,3U,3U,ROOT::Math::MatRepSym<float,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:9530,Availability,error,error,9530,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:9599,Availability,failure,failure,9599,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:9945,Availability,error,error,9945,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:10014,Availability,failure,failure,10014,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:11125,Availability,error,error,11125,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:5805,Integrability,interface,interface,5805,",3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:6258,Integrability,interface,interface,6258,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:6300,Integrability,interface,interface,6300,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:6362,Integrability,interface,interface,6362,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:6422,Integrability,interface,interface,6422,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:8079,Integrability,rout,routine,8079," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:4999,Modifiability,Inherit,Inheritance,4999,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const ROOT::Math::SMatrix<float,3U,4U,ROOT::Math::MatRepStd<float,3,4> >& rhs); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const float& rhs); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const ROOT::Math::SVector<float,3U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,3,4>fRep; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:5012,Modifiability,Inherit,Inherited,5012,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const ROOT::Math::SMatrix<float,3U,4U,ROOT::Math::MatRepStd<float,3,4> >& rhs); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const float& rhs); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const ROOT::Math::SVector<float,3U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,3,4>fRep; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:9782,Performance,perform,performing,9782,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:11475,Safety,avoid,avoid,11475,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:5441,Security,Access,Access,5441,"4> >(const ROOT::Math::SVector<float,3U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,3,4>fRep; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:5464,Security,access,access,5464,"4> >(const ROOT::Math::SVector<float,3U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,3,4>fRep; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:5569,Security,access,accessing,5569,"4> >(const ROOT::Math::SVector<float,3U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,3,4>fRep; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:5834,Security,access,access,5834,",3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:6855,Security,access,access,6855,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:6969,Security,access,access,6969,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:7085,Security,access,access,7085,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:7263,Security,access,access,7263,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:7187,Testability,assert,assert,7187,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html:7364,Testability,assert,assert,7364,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow.html:2112,Modifiability,Inherit,Inheritance,2112,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3U,4U,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,3U,4U,ROOT::Math::MatRepStd<float,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,3U,4U,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow.html:2125,Modifiability,Inherit,Inherited,2125,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow&&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,3U,4U,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,3U,4U,ROOT::Math::MatRepStd<float,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,3U,4U,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow_const.html:2232,Modifiability,Inherit,Inheritance,2232,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3U,4U,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,3U,4U,ROOT::Math::MatRepStd<float,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,3U,4U,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow_const.html:2245,Modifiability,Inherit,Inherited,2245,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,3U,4U,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,3U,4U,ROOT::Math::MatRepStd<float,3,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,3U,4U,ROOT::Math::MatRepStd<float,3,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:9530,Availability,error,error,9530,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:9599,Availability,failure,failure,9599,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:9945,Availability,error,error,9945,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:10014,Availability,failure,failure,10014,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:11125,Availability,error,error,11125,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:5805,Integrability,interface,interface,5805,",4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:6258,Integrability,interface,interface,6258,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:6300,Integrability,interface,interface,6300,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:6362,Integrability,interface,interface,6362,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:6422,Integrability,interface,interface,6422,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:8079,Integrability,rout,routine,8079," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:4999,Modifiability,Inherit,Inheritance,4999,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const ROOT::Math::SMatrix<float,4U,3U,ROOT::Math::MatRepStd<float,4,3> >& rhs); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const float& rhs); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const ROOT::Math::SVector<float,4U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,4,3>fRep; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:5012,Modifiability,Inherit,Inherited,5012,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const ROOT::Math::SMatrix<float,4U,3U,ROOT::Math::MatRepStd<float,4,3> >& rhs); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const float& rhs); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const ROOT::Math::SVector<float,4U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,4,3>fRep; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:9782,Performance,perform,performing,9782,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:11475,Safety,avoid,avoid,11475,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:5441,Security,Access,Access,5441,"3> >(const ROOT::Math::SVector<float,4U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,4,3>fRep; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:5464,Security,access,access,5464,"3> >(const ROOT::Math::SVector<float,4U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,4,3>fRep; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:5569,Security,access,accessing,5569,"3> >(const ROOT::Math::SVector<float,4U*(3U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(3U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,4,3>fRep; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:5834,Security,access,access,5834,",4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:6855,Security,access,access,6855,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:6969,Security,access,access,6969,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:7085,Security,access,access,7085,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:7263,Security,access,access,7263,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:7187,Testability,assert,assert,7187,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html:7364,Testability,assert,assert,7364,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow.html:2112,Modifiability,Inherit,Inheritance,2112,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4U,3U,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,4U,3U,ROOT::Math::MatRepStd<float,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,4U,3U,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow.html:2125,Modifiability,Inherit,Inherited,2125,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow&&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4U,3U,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,4U,3U,ROOT::Math::MatRepStd<float,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,4U,3U,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow_const.html:2232,Modifiability,Inherit,Inheritance,2232,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4U,3U,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,4U,3U,ROOT::Math::MatRepStd<float,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,4U,3U,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow_const.html:2245,Modifiability,Inherit,Inherited,2245,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4U,3U,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,4U,3U,ROOT::Math::MatRepStd<float,4,3> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,4U,3U,ROOT::Math::MatRepStd<float,4,3> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:9530,Availability,error,error,9530,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:9599,Availability,failure,failure,9599,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:9945,Availability,error,error,9945,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:10014,Availability,failure,failure,10014,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:11125,Availability,error,error,11125,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:5805,Integrability,interface,interface,5805,",4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:6258,Integrability,interface,interface,6258,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:6300,Integrability,interface,interface,6300,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:6362,Integrability,interface,interface,6362,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:6422,Integrability,interface,interface,6422,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:8079,Integrability,rout,routine,8079," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:4999,Modifiability,Inherit,Inheritance,4999,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepStd<float,4,4> >& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const ROOT::Math::SVector<float,4U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,4,4>fRep; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:5012,Modifiability,Inherit,Inherited,5012,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepStd<float,4,4> >& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const ROOT::Math::SVector<float,4U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,4,4>fRep; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:9782,Performance,perform,performing,9782,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:11475,Safety,avoid,avoid,11475,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:5441,Security,Access,Access,5441,"4> >(const ROOT::Math::SVector<float,4U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,4,4>fRep; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:5464,Security,access,access,5464,"4> >(const ROOT::Math::SVector<float,4U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,4,4>fRep; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:5569,Security,access,accessing,5569,"4> >(const ROOT::Math::SVector<float,4U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,4,4>fRep; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:5834,Security,access,access,5834,",4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:6855,Security,access,access,6855,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:6969,Security,access,access,6969,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:7085,Security,access,access,7085,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:7263,Security,access,access,7263,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:7187,Testability,assert,assert,7187,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html:7364,Testability,assert,assert,7364,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow.html:2112,Modifiability,Inherit,Inheritance,2112,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepStd<float,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow.html:2125,Modifiability,Inherit,Inherited,2125,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow&&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepStd<float,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow_const.html:2232,Modifiability,Inherit,Inheritance,2232,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepStd<float,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow_const.html:2245,Modifiability,Inherit,Inherited,2245,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepStd<float,4,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepStd<float,4,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:9452,Availability,error,error,9452,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:9521,Availability,failure,failure,9521,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:9867,Availability,error,error,9867,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:9936,Availability,failure,failure,9936,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:11047,Availability,error,error,11047,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:5727,Integrability,interface,interface,5727,"loat,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:6180,Integrability,interface,interface,6180,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:6222,Integrability,interface,interface,6222,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:6284,Integrability,interface,interface,6284,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:6344,Integrability,interface,interface,6344,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:8001,Integrability,rout,routine,8001," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:4921,Modifiability,Inherit,Inheritance,4921,":MatRepSym<float,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepSym<float,4> >& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const ROOT::Math::SVector<float,4U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,4>fRep; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:4934,Modifiability,Inherit,Inherited,4934,":MatRepSym<float,4> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepSym<float,4> >& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const ROOT::Math::SVector<float,4U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,4>fRep; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:9704,Performance,perform,performing,9704,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:11397,Safety,avoid,avoid,11397,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:5363,Security,Access,Access,5363,"m<float,4> >(const ROOT::Math::SVector<float,4U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,4>fRep; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:5386,Security,access,access,5386,"m<float,4> >(const ROOT::Math::SVector<float,4U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,4>fRep; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:5491,Security,access,accessing,5491,"m<float,4> >(const ROOT::Math::SVector<float,4U*(4U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4U*(4U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,4>fRep; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:5756,Security,access,access,5756,"loat,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:6777,Security,access,access,6777,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:6891,Security,access,access,6891,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:7007,Security,access,access,7007,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:7185,Security,access,access,7185,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:7109,Testability,assert,assert,7109,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html:7286,Testability,assert,assert,7286,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow.html:2084,Modifiability,Inherit,Inheritance,2084,"or symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepSym<float,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow.html:2097,Modifiability,Inherit,Inherited,2097,"or symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow&&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepSym<float,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow_const.html:2204,Modifiability,Inherit,Inheritance,2204,"Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepSym<float,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow_const.html:2217,Modifiability,Inherit,Inherited,2217,"Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepSym<float,4> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,4U,4U,ROOT::Math::MatRepSym<float,4> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:9530,Availability,error,error,9530,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:9599,Availability,failure,failure,9599,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:9945,Availability,error,error,9945,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:10014,Availability,failure,failure,10014,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:11125,Availability,error,error,11125,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:5805,Integrability,interface,interface,5805,",5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:6258,Integrability,interface,interface,6258,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:6300,Integrability,interface,interface,6300,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:6362,Integrability,interface,interface,6362,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:6422,Integrability,interface,interface,6422,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:8079,Integrability,rout,routine,8079," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:4999,Modifiability,Inherit,Inheritance,4999,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepStd<float,5,5> >& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(const float& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(const ROOT::Math::SVector<float,5U*(5U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,5,5>fRep; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:5012,Modifiability,Inherit,Inherited,5012,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepStd<float,5,5> >& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(const float& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(const ROOT::Math::SVector<float,5U*(5U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,5,5>fRep; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:9782,Performance,perform,performing,9782,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:11475,Safety,avoid,avoid,11475,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:5441,Security,Access,Access,5441,"5> >(const ROOT::Math::SVector<float,5U*(5U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,5,5>fRep; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:5464,Security,access,access,5464,"5> >(const ROOT::Math::SVector<float,5U*(5U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,5,5>fRep; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:5569,Security,access,accessing,5569,"5> >(const ROOT::Math::SVector<float,5U*(5U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,5,5>fRep; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:5834,Security,access,access,5834,",5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:6855,Security,access,access,6855,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:6969,Security,access,access,6969,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:7085,Security,access,access,7085,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:7263,Security,access,access,7263,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:7187,Testability,assert,assert,7187,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html:7364,Testability,assert,assert,7364,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5_____SMatrixRow.html:2112,Modifiability,Inherit,Inheritance,2112,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow&&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepStd<float,5,5> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepStd<float,5,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepStd<float,5,5> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5_____SMatrixRow.html:2125,Modifiability,Inherit,Inherited,2125,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow&&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepStd<float,5,5> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepStd<float,5,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepStd<float,5,5> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5_____SMatrixRow_const.html:2232,Modifiability,Inherit,Inheritance,2232,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepStd<float,5,5> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepStd<float,5,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepStd<float,5,5> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5_____SMatrixRow_const.html:2245,Modifiability,Inherit,Inherited,2245,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepStd<float,5,5> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepStd<float,5,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepStd<float,5,5> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:9452,Availability,error,error,9452,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:9521,Availability,failure,failure,9521,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:9867,Availability,error,error,9867,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:9936,Availability,failure,failure,9936,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:11047,Availability,error,error,11047,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:5727,Integrability,interface,interface,5727,"loat,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:6180,Integrability,interface,interface,6180,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:6222,Integrability,interface,interface,6222,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:6284,Integrability,interface,interface,6284,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:6344,Integrability,interface,interface,6344,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:8001,Integrability,rout,routine,8001," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:4921,Modifiability,Inherit,Inheritance,4921,":MatRepSym<float,5> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >(const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepSym<float,5> >& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >(const float& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >(const ROOT::Math::SVector<float,5U*(5U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,5>fRep; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:4934,Modifiability,Inherit,Inherited,4934,":MatRepSym<float,5> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >(const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepSym<float,5> >& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >(const float& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >(const ROOT::Math::SVector<float,5U*(5U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,5>fRep; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:9704,Performance,perform,performing,9704,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:11397,Safety,avoid,avoid,11397,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:5363,Security,Access,Access,5363,"m<float,5> >(const ROOT::Math::SVector<float,5U*(5U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,5>fRep; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:5386,Security,access,access,5386,"m<float,5> >(const ROOT::Math::SVector<float,5U*(5U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,5>fRep; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:5491,Security,access,accessing,5491,"m<float,5> >(const ROOT::Math::SVector<float,5U*(5U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5U*(5U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,5>fRep; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:5756,Security,access,access,5756,"loat,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:6777,Security,access,access,6777,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:6891,Security,access,access,6891,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:7007,Security,access,access,7007,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:7185,Security,access,access,7185,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:7109,Testability,assert,assert,7109,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html:7286,Testability,assert,assert,7286,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5_____SMatrixRow.html:2084,Modifiability,Inherit,Inheritance,2084,"or symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow&&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepSym<float,5> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepSym<float,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepSym<float,5> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5_____SMatrixRow.html:2097,Modifiability,Inherit,Inherited,2097,"or symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow&&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepSym<float,5> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepSym<float,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepSym<float,5> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5_____SMatrixRow_const.html:2204,Modifiability,Inherit,Inheritance,2204,"Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepSym<float,5> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepSym<float,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepSym<float,5> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5_____SMatrixRow_const.html:2217,Modifiability,Inherit,Inherited,2217,"Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepSym<float,5> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepSym<float,5> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,5U,5U,ROOT::Math::MatRepSym<float,5> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:9530,Availability,error,error,9530,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:9599,Availability,failure,failure,9599,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:9945,Availability,error,error,9945,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:10014,Availability,failure,failure,10014,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:11125,Availability,error,error,11125,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:5805,Integrability,interface,interface,5805,",6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:6258,Integrability,interface,interface,6258,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:6300,Integrability,interface,interface,6300,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:6362,Integrability,interface,interface,6362,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:6422,Integrability,interface,interface,6422,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:8079,Integrability,rout,routine,8079," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:4999,Modifiability,Inherit,Inheritance,4999,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >(const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepStd<float,6,6> >& rhs); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >(const float& rhs); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >(const ROOT::Math::SVector<float,6U*(6U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,6,6>fRep; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:5012,Modifiability,Inherit,Inherited,5012,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >(const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepStd<float,6,6> >& rhs); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >(const float& rhs); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >(const ROOT::Math::SVector<float,6U*(6U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,6,6>fRep; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:9782,Performance,perform,performing,9782,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:11475,Safety,avoid,avoid,11475,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:5441,Security,Access,Access,5441,"6> >(const ROOT::Math::SVector<float,6U*(6U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,6,6>fRep; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:5464,Security,access,access,5464,"6> >(const ROOT::Math::SVector<float,6U*(6U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,6,6>fRep; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:5569,Security,access,accessing,5569,"6> >(const ROOT::Math::SVector<float,6U*(6U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,6,6>fRep; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:5834,Security,access,access,5834,",6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:6855,Security,access,access,6855,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:6969,Security,access,access,6969,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:7085,Security,access,access,7085,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:7263,Security,access,access,7263,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:7187,Testability,assert,assert,7187,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html:7364,Testability,assert,assert,7364,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6_____SMatrixRow.html:2112,Modifiability,Inherit,Inheritance,2112,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow&&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepStd<float,6,6> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepStd<float,6,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepStd<float,6,6> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6_____SMatrixRow.html:2125,Modifiability,Inherit,Inherited,2125,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow&&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepStd<float,6,6> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepStd<float,6,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepStd<float,6,6> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6_____SMatrixRow_const.html:2232,Modifiability,Inherit,Inheritance,2232,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepStd<float,6,6> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepStd<float,6,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepStd<float,6,6> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6_____SMatrixRow_const.html:2245,Modifiability,Inherit,Inherited,2245,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepStd<float,6,6> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepStd<float,6,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepStd<float,6,6> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:9452,Availability,error,error,9452,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:9521,Availability,failure,failure,9521,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:9867,Availability,error,error,9867,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:9936,Availability,failure,failure,9936,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:11047,Availability,error,error,11047,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:5727,Integrability,interface,interface,5727,"loat,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:6180,Integrability,interface,interface,6180,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:6222,Integrability,interface,interface,6222,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:6284,Integrability,interface,interface,6284,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:6344,Integrability,interface,interface,6344,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:8001,Integrability,rout,routine,8001," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:4921,Modifiability,Inherit,Inheritance,4921,":MatRepSym<float,6> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >(const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepSym<float,6> >& rhs); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >(const float& rhs); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >(const ROOT::Math::SVector<float,6U*(6U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,6>fRep; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:4934,Modifiability,Inherit,Inherited,4934,":MatRepSym<float,6> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >(const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepSym<float,6> >& rhs); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >(const float& rhs); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >(const ROOT::Math::SVector<float,6U*(6U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,6>fRep; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:9704,Performance,perform,performing,9704,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:11397,Safety,avoid,avoid,11397,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:5363,Security,Access,Access,5363,"m<float,6> >(const ROOT::Math::SVector<float,6U*(6U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,6>fRep; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:5386,Security,access,access,5386,"m<float,6> >(const ROOT::Math::SVector<float,6U*(6U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,6>fRep; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:5491,Security,access,accessing,5491,"m<float,6> >(const ROOT::Math::SVector<float,6U*(6U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6U*(6U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,6>fRep; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:5756,Security,access,access,5756,"loat,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:6777,Security,access,access,6777,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:6891,Security,access,access,6891,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:7007,Security,access,access,7007,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:7185,Security,access,access,7185,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:7109,Testability,assert,assert,7109,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html:7286,Testability,assert,assert,7286,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6_____SMatrixRow.html:2084,Modifiability,Inherit,Inheritance,2084,"or symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow&&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepSym<float,6> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepSym<float,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepSym<float,6> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6_____SMatrixRow.html:2097,Modifiability,Inherit,Inherited,2097,"or symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow&&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepSym<float,6> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepSym<float,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepSym<float,6> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6_____SMatrixRow_const.html:2204,Modifiability,Inherit,Inheritance,2204,"Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepSym<float,6> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepSym<float,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepSym<float,6> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6_____SMatrixRow_const.html:2217,Modifiability,Inherit,Inherited,2217,"Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepSym<float,6> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepSym<float,6> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,6U,6U,ROOT::Math::MatRepSym<float,6> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:9530,Availability,error,error,9530,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:9599,Availability,failure,failure,9599,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:9945,Availability,error,error,9945,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:10014,Availability,failure,failure,10014,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:11125,Availability,error,error,11125,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:5805,Integrability,interface,interface,5805,",7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:6258,Integrability,interface,interface,6258,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:6300,Integrability,interface,interface,6300,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:6362,Integrability,interface,interface,6362,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:6422,Integrability,interface,interface,6422,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:8079,Integrability,rout,routine,8079," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:4999,Modifiability,Inherit,Inheritance,4999,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >(const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepStd<float,7,7> >& rhs); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >(const float& rhs); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >(const ROOT::Math::SVector<float,7U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,7,7>fRep; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:5012,Modifiability,Inherit,Inherited,5012,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >(const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepStd<float,7,7> >& rhs); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >(const float& rhs); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >(const ROOT::Math::SVector<float,7U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,7,7>fRep; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:9782,Performance,perform,performing,9782,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:11475,Safety,avoid,avoid,11475,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:5441,Security,Access,Access,5441,"7> >(const ROOT::Math::SVector<float,7U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,7,7>fRep; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:5464,Security,access,access,5464,"7> >(const ROOT::Math::SVector<float,7U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,7,7>fRep; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:5569,Security,access,accessing,5569,"7> >(const ROOT::Math::SVector<float,7U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,7,7>fRep; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:5834,Security,access,access,5834,",7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:6855,Security,access,access,6855,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:6969,Security,access,access,6969,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:7085,Security,access,access,7085,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:7263,Security,access,access,7263,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:7187,Testability,assert,assert,7187,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html:7364,Testability,assert,assert,7364,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7_____SMatrixRow.html:2112,Modifiability,Inherit,Inheritance,2112,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow&&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepStd<float,7,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepStd<float,7,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepStd<float,7,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7_____SMatrixRow.html:2125,Modifiability,Inherit,Inherited,2125,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow&&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepStd<float,7,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepStd<float,7,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepStd<float,7,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7_____SMatrixRow_const.html:2232,Modifiability,Inherit,Inheritance,2232,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepStd<float,7,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepStd<float,7,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepStd<float,7,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7_____SMatrixRow_const.html:2245,Modifiability,Inherit,Inherited,2245,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepStd<float,7,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepStd<float,7,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepStd<float,7,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:9452,Availability,error,error,9452,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:9521,Availability,failure,failure,9521,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:9867,Availability,error,error,9867,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:9936,Availability,failure,failure,9936,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:11047,Availability,error,error,11047,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:5727,Integrability,interface,interface,5727,"loat,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:6180,Integrability,interface,interface,6180,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:6222,Integrability,interface,interface,6222,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:6284,Integrability,interface,interface,6284,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:6344,Integrability,interface,interface,6344,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:8001,Integrability,rout,routine,8001," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:4921,Modifiability,Inherit,Inheritance,4921,":MatRepSym<float,7> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >(const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepSym<float,7> >& rhs); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >(const float& rhs); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >(const ROOT::Math::SVector<float,7U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,7>fRep; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:4934,Modifiability,Inherit,Inherited,4934,":MatRepSym<float,7> >(ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >(const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepSym<float,7> >& rhs); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >(const float& rhs); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >(const ROOT::Math::SVector<float,7U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,7>fRep; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:9704,Performance,perform,performing,9704,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:11397,Safety,avoid,avoid,11397,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:5363,Security,Access,Access,5363,"m<float,7> >(const ROOT::Math::SVector<float,7U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,7>fRep; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:5386,Security,access,access,5386,"m<float,7> >(const ROOT::Math::SVector<float,7U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,7>fRep; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:5491,Security,access,accessing,5491,"m<float,7> >(const ROOT::Math::SVector<float,7U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepSym<float,7>fRep; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:5756,Security,access,access,5756,"loat,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:6777,Security,access,access,6777,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:6891,Security,access,access,6891,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:7007,Security,access,access,7007,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:7185,Security,access,access,7185,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:7109,Testability,assert,assert,7109,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html:7286,Testability,assert,assert,7286,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7_____SMatrixRow.html:2084,Modifiability,Inherit,Inheritance,2084,"or symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow&&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepSym<float,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepSym<float,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepSym<float,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7_____SMatrixRow.html:2097,Modifiability,Inherit,Inherited,2097,"or symmetric matrices DxD, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow&&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepSym<float,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepSym<float,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepSym<float,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7_____SMatrixRow_const.html:2204,Modifiability,Inherit,Inheritance,2204,"Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepSym<float,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepSym<float,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepSym<float,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7_____SMatrixRow_const.html:2217,Modifiability,Inherit,Inherited,2217,"Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepSym<float,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepSym<float,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,7U,7U,ROOT::Math::MatRepSym<float,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:9530,Availability,error,error,9530,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:9599,Availability,failure,failure,9599,"on algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:9945,Availability,error,error,9945,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:10014,Availability,failure,failure,10014,"D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. retu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:11125,Availability,error,error,11125,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:5805,Integrability,interface,interface,5805,",9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:6258,Integrability,interface,interface,6258,"D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:6300,Integrability,interface,interface,6300,"rix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element wi",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:6362,Integrability,interface,interface,6362,":Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check ind",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:6422,Integrability,interface,interface,6422,"pply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:8079,Integrability,rout,routine,8079," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:4999,Modifiability,Inherit,Inheritance,4999,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >(const ROOT::Math::SMatrix<float,9U,7U,ROOT::Math::MatRepStd<float,9,7> >& rhs); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >(const float& rhs); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >(const ROOT::Math::SVector<float,9U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,9U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,9,7>fRep; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:5012,Modifiability,Inherit,Inherited,5012,"ROOT::Math::SMatrixIdentity); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >(const ROOT::Math::SMatrix<float,9U,7U,ROOT::Math::MatRepStd<float,9,7> >& rhs); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >(const float& rhs); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >(const ROOT::Math::SVector<float,9U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,9U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,9,7>fRep; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal;",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:9782,Performance,perform,performing,9782,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:11475,Safety,avoid,avoid,11475,"ilure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:5441,Security,Access,Access,5441,"7> >(const ROOT::Math::SVector<float,9U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,9U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,9,7>fRep; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:5464,Security,access,access,5464,"7> >(const ROOT::Math::SVector<float,9U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,9U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,9,7>fRep; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:5569,Security,access,accessing,5569,"7> >(const ROOT::Math::SVector<float,9U*(7U+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,9U*(7U+1)/2>UpperBlock() const. Data Members; public:. ROOT::Math::MatRepStd<float,9,7>fRep; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kCols; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:5834,Security,access,access,5834,",9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:6855,Security,access,access,6855,"they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functio",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:6969,Security,access,access,6969,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:7085,Security,access,access,7085,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:7263,Security,access,access,7263,"); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SM",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:7187,Testability,assert,assert,7187,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html:7364,Testability,assert,assert,7364,"iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix an",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7_____SMatrixRow.html:2112,Modifiability,Inherit,Inheritance,2112,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow&); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow&); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow&&); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,9U,7U,ROOT::Math::MatRepStd<float,9,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,9U,7U,ROOT::Math::MatRepStd<float,9,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,9U,7U,ROOT::Math::MatRepStd<float,9,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7_____SMatrixRow.html:2125,Modifiability,Inherit,Inherited,2125,"D, where the storage is only; D*(D+1)/2. See \ref SMatrixDoc. Original author is Thorsten Glebe; HERA-B Collaboration, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow(); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow&operator=(const ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow&); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow&operator=(ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow&&); float&operator[](int j); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRowSMatrixRow(const ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow&); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow&&); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRowSMatrixRow(ROOT::Math::SMatrix<float,9U,7U,ROOT::Math::MatRepStd<float,9,7> >& rhs, unsigned int i). Data Members; private:. ROOT::Math::SMatrix<float,9U,7U,ROOT::Math::MatRepStd<float,9,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrixRow(ROOT::Math::SMatrix<float,9U,7U,ROOT::Math::MatRepStd<float,9,7> >& rhs, unsigned int i); {}. T & operator[](int j); { return (*fMat)(fRow,j); }. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7_____SMatrixRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7_____SMatrixRow.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7_____SMatrixRow_const.html:2232,Modifiability,Inherit,Inheritance,2232,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,9U,7U,ROOT::Math::MatRepStd<float,9,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,9U,7U,ROOT::Math::MatRepStd<float,9,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,9U,7U,ROOT::Math::MatRepStd<float,9,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7_____SMatrixRow_const.html:2245,Modifiability,Inherit,Inherited,2245,"ion, MPI Heidelberg (Germany). @ingroup SMatrixSVector. @authors T. Glebe, L. Moneta and J. Palacios. SMatrix: column-wise storage. Function Members (Methods); public:. ~SMatrixRow_const(); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_const&operator=(const ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_const&operator=(ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_const&&); const float&operator[](int j) const; ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_const&); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_constSMatrixRow_const(ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_const&&); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >::SMatrixRow_constSMatrixRow_const(const ROOT::Math::SMatrix<float,9U,7U,ROOT::Math::MatRepStd<float,9,7> >& rhs, unsigned int i). Data Members; private:. const ROOT::Math::SMatrix<float,9U,7U,ROOT::Math::MatRepStd<float,9,7> >*fMat; unsigned intfRow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T & operator[](int j); { return (*fMat)(fRow,j); }. SMatrixRow_const(const ROOT::Math::SMatrix<float,9U,7U,ROOT::Math::MatRepStd<float,9,7> >& rhs, unsigned int i); {}. » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7_____SMatrixRow_const.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7_____SMatrixRow_const.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:4834,Integrability,interface,interface,4834,"a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:4863,Integrability,interface,interface,4863,"a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:4905,Integrability,interface,interface,4905,"OT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:4967,Integrability,interface,interface,4967,"ouble& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:5027,Integrability,interface,interface,5027,"a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:4285,Modifiability,Inherit,Inheritance,4285,"& a6); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:4298,Modifiability,Inherit,Inherited,4298,"& a6); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:6895,Safety,avoid,avoid,6895,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:4626,Security,access,access,4626,"e& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:5607,Security,access,access,5607,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtr",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:5708,Security,access,access,5708,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:5801,Security,access,access,5801,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing sam",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:5911,Security,access,access,5911,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid th",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:6001,Security,access,access,6001,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in o",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html:6083,Security,access,access,6083,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate resul",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html:4834,Integrability,interface,interface,4834,"a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html:4863,Integrability,interface,interface,4863,"a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html:4905,Integrability,interface,interface,4905,"OT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html:4967,Integrability,interface,interface,4967,"ouble& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html:5027,Integrability,interface,interface,5027,"a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html:4285,Modifiability,Inherit,Inheritance,4285,"& a6); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html:4298,Modifiability,Inherit,Inherited,4298,"& a6); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html:6895,Safety,avoid,avoid,6895,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html:4626,Security,access,access,4626,"e& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html:5607,Security,access,access,5607,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtr",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html:5708,Security,access,access,5708,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html:5801,Security,access,access,5801,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing sam",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html:5911,Security,access,access,5911,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid th",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html:6001,Security,access,access,6001,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in o",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html:6083,Security,access,access,6083,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate resul",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html:4834,Integrability,interface,interface,4834,"a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html:4863,Integrability,interface,interface,4863,"a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html:4905,Integrability,interface,interface,4905,"OT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html:4967,Integrability,interface,interface,4967,"ouble& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html:5027,Integrability,interface,interface,5027,"a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html:4285,Modifiability,Inherit,Inheritance,4285,"& a6); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html:4298,Modifiability,Inherit,Inherited,4298,"& a6); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html:6895,Safety,avoid,avoid,6895,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html:4626,Security,access,access,4626,"e& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html:5607,Security,access,access,5607,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtr",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html:5708,Security,access,access,5708,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html:5801,Security,access,access,5801,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing sam",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html:5911,Security,access,access,5911,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid th",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html:6001,Security,access,access,6001,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in o",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html:6083,Security,access,access,6083,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate resul",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html:4834,Integrability,interface,interface,4834,"a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html:4863,Integrability,interface,interface,4863,"a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html:4905,Integrability,interface,interface,4905,"OT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html:4967,Integrability,interface,interface,4967,"ouble& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html:5027,Integrability,interface,interface,5027,"a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html:4285,Modifiability,Inherit,Inheritance,4285,"& a6); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html:4298,Modifiability,Inherit,Inherited,4298,"& a6); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html:6895,Safety,avoid,avoid,6895,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html:4626,Security,access,access,4626,"e& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html:5607,Security,access,access,5607,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtr",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html:5708,Security,access,access,5708,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html:5801,Security,access,access,5801,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing sam",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html:5911,Security,access,access,5911,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid th",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html:6001,Security,access,access,6001,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in o",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html:6083,Security,access,access,6083,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate resul",MatchSource.WIKI,root/html604/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_Double32_t_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html:4818,Integrability,interface,interface,4818,"le& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,2>::(anonymous)kSize. private:. doublefArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html:4847,Integrability,interface,interface,4847,"le& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,2>::(anonymous)kSize. private:. doublefArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html:4889,Integrability,interface,interface,4889,"; ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,2>::(anonymous)kSize. private:. doublefArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html:4951,Integrability,interface,interface,4951,"st double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,2>::(anonymous)kSize. private:. doublefArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html:5011,Integrability,interface,interface,5011,"le& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,2>::(anonymous)kSize. private:. doublefArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html:4269,Modifiability,Inherit,Inheritance,4269,"uble& a6); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,2>::(anonymous)kSize. private:. doublefArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html:4282,Modifiability,Inherit,Inherited,4282,"uble& a6); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,2>::(anonymous)kSize. private:. doublefArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html:6879,Safety,avoid,avoid,6879,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html:4610,Security,access,access,4610,"ouble& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,2>::(anonymous)kSize. private:. doublefArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html:5591,Security,access,access,5591,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtr",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html:5692,Security,access,access,5692,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html:5785,Security,access,access,5785,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing sam",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html:5895,Security,access,access,5895,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid th",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html:5985,Security,access,access,5985,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in o",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html:6067,Security,access,access,6067,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate resul",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html:4818,Integrability,interface,interface,4818,"le& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. doublefArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html:4847,Integrability,interface,interface,4847,"le& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. doublefArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html:4889,Integrability,interface,interface,4889,"; ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. doublefArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html:4951,Integrability,interface,interface,4951,"st double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. doublefArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html:5011,Integrability,interface,interface,5011,"le& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. doublefArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html:4269,Modifiability,Inherit,Inheritance,4269,"uble& a6); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. doublefArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html:4282,Modifiability,Inherit,Inherited,4282,"uble& a6); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. doublefArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html:6879,Safety,avoid,avoid,6879,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html:4610,Security,access,access,4610,"ouble& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. doublefArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html:5591,Security,access,access,5591,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtr",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html:5692,Security,access,access,5692,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html:5785,Security,access,access,5785,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing sam",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html:5895,Security,access,access,5895,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid th",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html:5985,Security,access,access,5985,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in o",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html:6067,Security,access,access,6067,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate resul",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html:4818,Integrability,interface,interface,4818,"le& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. doublefArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html:4847,Integrability,interface,interface,4847,"le& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. doublefArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html:4889,Integrability,interface,interface,4889,"; ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. doublefArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html:4951,Integrability,interface,interface,4951,"st double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. doublefArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html:5011,Integrability,interface,interface,5011,"le& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. doublefArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html:4269,Modifiability,Inherit,Inheritance,4269,"uble& a6); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. doublefArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html:4282,Modifiability,Inherit,Inherited,4282,"uble& a6); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. doublefArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html:6879,Safety,avoid,avoid,6879,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html:4610,Security,access,access,4610,"ouble& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. doublefArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html:5591,Security,access,access,5591,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtr",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html:5692,Security,access,access,5692,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html:5785,Security,access,access,5785,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing sam",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html:5895,Security,access,access,5895,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid th",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html:5985,Security,access,access,5985,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in o",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html:6067,Security,access,access,6067,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate resul",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html:4818,Integrability,interface,interface,4818,"le& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. doublefArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html:4847,Integrability,interface,interface,4847,"le& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. doublefArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html:4889,Integrability,interface,interface,4889,"; ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. doublefArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html:4951,Integrability,interface,interface,4951,"st double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. doublefArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html:5011,Integrability,interface,interface,5011,"le& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. doublefArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html:4269,Modifiability,Inherit,Inheritance,4269,"uble& a6); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. doublefArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html:4282,Modifiability,Inherit,Inherited,4282,"uble& a6); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. doublefArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html:6879,Safety,avoid,avoid,6879,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html:4610,Security,access,access,4610,"ouble& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. doublefArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html:5591,Security,access,access,5591,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtr",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html:5692,Security,access,access,5692,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html:5785,Security,access,access,5785,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing sam",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html:5895,Security,access,access,5895,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid th",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html:5985,Security,access,access,5985,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in o",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html:6067,Security,access,access,6067,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate resul",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html:4818,Integrability,interface,interface,4818,"le& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. doublefArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html:4847,Integrability,interface,interface,4847,"le& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. doublefArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html:4889,Integrability,interface,interface,4889,"; ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. doublefArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html:4951,Integrability,interface,interface,4951,"st double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. doublefArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html:5011,Integrability,interface,interface,5011,"le& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. doublefArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html:4269,Modifiability,Inherit,Inheritance,4269,"uble& a6); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. doublefArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html:4282,Modifiability,Inherit,Inherited,4282,"uble& a6); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. doublefArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html:6879,Safety,avoid,avoid,6879,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html:4610,Security,access,access,4610,"ouble& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. doublefArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html:5591,Security,access,access,5591,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtr",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html:5692,Security,access,access,5692,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html:5785,Security,access,access,5785,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing sam",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html:5895,Security,access,access,5895,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid th",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html:5985,Security,access,access,5985,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in o",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html:6067,Security,access,access,6067,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate resul",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html:4818,Integrability,interface,interface,4818,"le& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,7>::(anonymous)kSize. private:. doublefArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html:4847,Integrability,interface,interface,4847,"le& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,7>::(anonymous)kSize. private:. doublefArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html:4889,Integrability,interface,interface,4889,"; ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,7>::(anonymous)kSize. private:. doublefArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html:4951,Integrability,interface,interface,4951,"st double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,7>::(anonymous)kSize. private:. doublefArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html:5011,Integrability,interface,interface,5011,"le& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,7>::(anonymous)kSize. private:. doublefArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html:4269,Modifiability,Inherit,Inheritance,4269,"uble& a6); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,7>::(anonymous)kSize. private:. doublefArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html:4282,Modifiability,Inherit,Inherited,4282,"uble& a6); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,7>::(anonymous)kSize. private:. doublefArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html:6879,Safety,avoid,avoid,6879,"(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html:4610,Security,access,access,4610,"ouble& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,7>::(anonymous)kSize. private:. doublefArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html:5591,Security,access,access,5591,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtr",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html:5692,Security,access,access,5692,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html:5785,Security,access,access,5785,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing sam",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html:5895,Security,access,access,5895,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid th",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html:5985,Security,access,access,5985,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in o",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html:6067,Security,access,access,6067,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate resul",MatchSource.WIKI,root/html604/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_double_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:4686,Integrability,interface,interface,4686,"oat& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,2>::(anonymous)kSize. private:. floatfArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:4715,Integrability,interface,interface,4715,"oat& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,2>::(anonymous)kSize. private:. floatfArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:4757,Integrability,interface,interface,4757,"onst float& a9); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,2>::(anonymous)kSize. private:. floatfArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:4819,Integrability,interface,interface,4819,"<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,2>::(anonymous)kSize. private:. floatfArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:4879,Integrability,interface,interface,4879,"const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,2>::(anonymous)kSize. private:. floatfArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:4137,Modifiability,Inherit,Inheritance,4137,"a3, const float& a4, const float& a5, const float& a6); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,2>::(anonymous)kSize. private:. floatfArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:4150,Modifiability,Inherit,Inherited,4150,"a3, const float& a4, const float& a5, const float& a6); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,2>::(anonymous)kSize. private:. floatfArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:6744,Safety,avoid,avoid,6744,"or>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:4478,Security,access,access,4478,"& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,2U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,2>::(anonymous)kSize. private:. floatfArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:5459,Security,access,access,5459,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtrac",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:5560,Security,access,access,5560,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:5653,Security,access,access,5653,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same m",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:5763,Security,access,access,5763,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the a",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:5853,Security,access,access,5853,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in oper",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html:5935,Security,access,access,5935,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_2_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html:4686,Integrability,interface,interface,4686,"oat& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,3>::(anonymous)kSize. private:. floatfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html:4715,Integrability,interface,interface,4715,"oat& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,3>::(anonymous)kSize. private:. floatfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html:4757,Integrability,interface,interface,4757,"onst float& a9); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,3>::(anonymous)kSize. private:. floatfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html:4819,Integrability,interface,interface,4819,"<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,3>::(anonymous)kSize. private:. floatfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html:4879,Integrability,interface,interface,4879,"const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,3>::(anonymous)kSize. private:. floatfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html:4137,Modifiability,Inherit,Inheritance,4137,"a3, const float& a4, const float& a5, const float& a6); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,3>::(anonymous)kSize. private:. floatfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html:4150,Modifiability,Inherit,Inherited,4150,"a3, const float& a4, const float& a5, const float& a6); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,3>::(anonymous)kSize. private:. floatfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html:6744,Safety,avoid,avoid,6744,"or>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html:4478,Security,access,access,4478,"& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,3>::(anonymous)kSize. private:. floatfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html:5459,Security,access,access,5459,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtrac",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html:5560,Security,access,access,5560,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html:5653,Security,access,access,5653,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same m",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html:5763,Security,access,access,5763,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the a",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html:5853,Security,access,access,5853,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in oper",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html:5935,Security,access,access,5935,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_3_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html:4686,Integrability,interface,interface,4686,"oat& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,4>::(anonymous)kSize. private:. floatfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html:4715,Integrability,interface,interface,4715,"oat& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,4>::(anonymous)kSize. private:. floatfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html:4757,Integrability,interface,interface,4757,"onst float& a9); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,4>::(anonymous)kSize. private:. floatfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html:4819,Integrability,interface,interface,4819,"<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,4>::(anonymous)kSize. private:. floatfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html:4879,Integrability,interface,interface,4879,"const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,4>::(anonymous)kSize. private:. floatfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html:4137,Modifiability,Inherit,Inheritance,4137,"a3, const float& a4, const float& a5, const float& a6); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,4>::(anonymous)kSize. private:. floatfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html:4150,Modifiability,Inherit,Inherited,4150,"a3, const float& a4, const float& a5, const float& a6); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,4>::(anonymous)kSize. private:. floatfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html:6744,Safety,avoid,avoid,6744,"or>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html:4478,Security,access,access,4478,"& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,4>::(anonymous)kSize. private:. floatfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html:5459,Security,access,access,5459,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtrac",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html:5560,Security,access,access,5560,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html:5653,Security,access,access,5653,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same m",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html:5763,Security,access,access,5763,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the a",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html:5853,Security,access,access,5853,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in oper",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html:5935,Security,access,access,5935,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_4_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html:4686,Integrability,interface,interface,4686,"oat& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,5>::(anonymous)kSize. private:. floatfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html:4715,Integrability,interface,interface,4715,"oat& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,5>::(anonymous)kSize. private:. floatfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html:4757,Integrability,interface,interface,4757,"onst float& a9); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,5>::(anonymous)kSize. private:. floatfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html:4819,Integrability,interface,interface,4819,"<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,5>::(anonymous)kSize. private:. floatfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html:4879,Integrability,interface,interface,4879,"const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,5>::(anonymous)kSize. private:. floatfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html:4137,Modifiability,Inherit,Inheritance,4137,"a3, const float& a4, const float& a5, const float& a6); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,5>::(anonymous)kSize. private:. floatfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html:4150,Modifiability,Inherit,Inherited,4150,"a3, const float& a4, const float& a5, const float& a6); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,5>::(anonymous)kSize. private:. floatfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html:6744,Safety,avoid,avoid,6744,"or>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html:4478,Security,access,access,4478,"& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,5>::(anonymous)kSize. private:. floatfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html:5459,Security,access,access,5459,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtrac",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html:5560,Security,access,access,5560,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html:5653,Security,access,access,5653,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same m",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html:5763,Security,access,access,5763,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the a",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html:5853,Security,access,access,5853,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in oper",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html:5935,Security,access,access,5935,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_5_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html:4686,Integrability,interface,interface,4686,"oat& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,6>::(anonymous)kSize. private:. floatfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html:4715,Integrability,interface,interface,4715,"oat& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,6>::(anonymous)kSize. private:. floatfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html:4757,Integrability,interface,interface,4757,"onst float& a9); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,6>::(anonymous)kSize. private:. floatfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html:4819,Integrability,interface,interface,4819,"<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,6>::(anonymous)kSize. private:. floatfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html:4879,Integrability,interface,interface,4879,"const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,6>::(anonymous)kSize. private:. floatfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html:4137,Modifiability,Inherit,Inheritance,4137,"a3, const float& a4, const float& a5, const float& a6); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,6>::(anonymous)kSize. private:. floatfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html:4150,Modifiability,Inherit,Inherited,4150,"a3, const float& a4, const float& a5, const float& a6); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,6>::(anonymous)kSize. private:. floatfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html:6744,Safety,avoid,avoid,6744,"or>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html:4478,Security,access,access,4478,"& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,6>::(anonymous)kSize. private:. floatfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html:5459,Security,access,access,5459,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtrac",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html:5560,Security,access,access,5560,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html:5653,Security,access,access,5653,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same m",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html:5763,Security,access,access,5763,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the a",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html:5853,Security,access,access,5853,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in oper",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html:5935,Security,access,access,5935,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_6_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html:4686,Integrability,interface,interface,4686,"oat& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,7>::(anonymous)kSize. private:. floatfArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html:4715,Integrability,interface,interface,4715,"oat& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,7>::(anonymous)kSize. private:. floatfArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html:4757,Integrability,interface,interface,4757,"onst float& a9); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,7>::(anonymous)kSize. private:. floatfArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html:4819,Integrability,interface,interface,4819,"<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,7>::(anonymous)kSize. private:. floatfArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index sta",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html:4879,Integrability,interface,interface,4879,"const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,7>::(anonymous)kSize. private:. floatfArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html:4137,Modifiability,Inherit,Inheritance,4137,"a3, const float& a4, const float& a5, const float& a6); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,7>::(anonymous)kSize. private:. floatfArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html:4150,Modifiability,Inherit,Inherited,4150,"a3, const float& a4, const float& a5, const float& a6); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,7>::(anonymous)kSize. private:. floatfArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison.",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html:6744,Safety,avoid,avoid,6744,"or>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html:4478,Security,access,access,4478,"& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,7U>&Unit(). Data Members; public:. static ROOT::Math::SVector<float,7>::(anonymous)kSize. private:. floatfArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html:5459,Security,access,access,5459,". T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtrac",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html:5560,Security,access,access,5560,"t; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector int",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html:5653,Security,access,access,5653,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same m",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html:5763,Security,access,access,5763,"or interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the a",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html:5853,Security,access,access,5853,"or end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in oper",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html
https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html:5935,Security,access,access,5935,"rs --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result i",MatchSource.WIKI,root/html604/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__SVector_float_7_.html
https://root.cern/root/html604/ROOT__Math__TDataPointN_double_.html:1125,Modifiability,Inherit,Inheritance,1125,". ROOT::Math::TDataPointN<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::TDataPointN<double>. class ROOT::Math::TDataPointN<double>. Function Members (Methods); public:. virtual~TDataPointN<double>(); static UInt_tDimension(); doubleGetCoordinate(unsigned int iAxis) const; doubleGetWeight() const; boolLess(ROOT::Math::TDataPointN<double>& rPoint, unsigned int iAxis) const; ROOT::Math::TDataPointN<double>&operator=(const ROOT::Math::TDataPointN<double>&); voidSetCoordinate(unsigned int iAxis, ROOT::Math::TDataPointN<double>::value_type fValue); static voidSetDimension(UInt_t dim); voidSetWeight(float fWeight); ROOT::Math::TDataPointN<double>TDataPointN<double>(); ROOT::Math::TDataPointN<double>TDataPointN<double>(const ROOT::Math::TDataPointN<double>&). Data Members; private:. static UInt_tkDimension; ROOT::Math::TDataPointN<double>::value_typem_fWeight; ROOT::Math::TDataPointN<double>::value_type*m_vCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UInt_t Dimension(); {return kDimension;}. void SetDimension(UInt_t dim); {assert(dim>0);kDimension=dim;}. _val_type GetCoordinate(unsigned int iAxis) const. _val_type GetWeight() const; {return m_fWeight;}. bool Less(ROOT::Math::TDataPointN<double>& rPoint, unsigned int iAxis) const. void SetCoordinate(unsigned int iAxis, ROOT::Math::TDataPointN<double>::value_type fValue). void SetWeight(float fWeight); {m_fWeight = fWeight;}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__TDataPointN_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__TDataPointN_double_.html
https://root.cern/root/html604/ROOT__Math__TDataPointN_double_.html:1138,Modifiability,Inherit,Inherited,1138,". ROOT::Math::TDataPointN<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::TDataPointN<double>. class ROOT::Math::TDataPointN<double>. Function Members (Methods); public:. virtual~TDataPointN<double>(); static UInt_tDimension(); doubleGetCoordinate(unsigned int iAxis) const; doubleGetWeight() const; boolLess(ROOT::Math::TDataPointN<double>& rPoint, unsigned int iAxis) const; ROOT::Math::TDataPointN<double>&operator=(const ROOT::Math::TDataPointN<double>&); voidSetCoordinate(unsigned int iAxis, ROOT::Math::TDataPointN<double>::value_type fValue); static voidSetDimension(UInt_t dim); voidSetWeight(float fWeight); ROOT::Math::TDataPointN<double>TDataPointN<double>(); ROOT::Math::TDataPointN<double>TDataPointN<double>(const ROOT::Math::TDataPointN<double>&). Data Members; private:. static UInt_tkDimension; ROOT::Math::TDataPointN<double>::value_typem_fWeight; ROOT::Math::TDataPointN<double>::value_type*m_vCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UInt_t Dimension(); {return kDimension;}. void SetDimension(UInt_t dim); {assert(dim>0);kDimension=dim;}. _val_type GetCoordinate(unsigned int iAxis) const. _val_type GetWeight() const; {return m_fWeight;}. bool Less(ROOT::Math::TDataPointN<double>& rPoint, unsigned int iAxis) const. void SetCoordinate(unsigned int iAxis, ROOT::Math::TDataPointN<double>::value_type fValue). void SetWeight(float fWeight); {m_fWeight = fWeight;}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__TDataPointN_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__TDataPointN_double_.html
https://root.cern/root/html604/ROOT__Math__TDataPointN_double_.html:1276,Testability,assert,assert,1276,". ROOT::Math::TDataPointN<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::TDataPointN<double>. class ROOT::Math::TDataPointN<double>. Function Members (Methods); public:. virtual~TDataPointN<double>(); static UInt_tDimension(); doubleGetCoordinate(unsigned int iAxis) const; doubleGetWeight() const; boolLess(ROOT::Math::TDataPointN<double>& rPoint, unsigned int iAxis) const; ROOT::Math::TDataPointN<double>&operator=(const ROOT::Math::TDataPointN<double>&); voidSetCoordinate(unsigned int iAxis, ROOT::Math::TDataPointN<double>::value_type fValue); static voidSetDimension(UInt_t dim); voidSetWeight(float fWeight); ROOT::Math::TDataPointN<double>TDataPointN<double>(); ROOT::Math::TDataPointN<double>TDataPointN<double>(const ROOT::Math::TDataPointN<double>&). Data Members; private:. static UInt_tkDimension; ROOT::Math::TDataPointN<double>::value_typem_fWeight; ROOT::Math::TDataPointN<double>::value_type*m_vCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UInt_t Dimension(); {return kDimension;}. void SetDimension(UInt_t dim); {assert(dim>0);kDimension=dim;}. _val_type GetCoordinate(unsigned int iAxis) const. _val_type GetWeight() const; {return m_fWeight;}. bool Less(ROOT::Math::TDataPointN<double>& rPoint, unsigned int iAxis) const. void SetCoordinate(unsigned int iAxis, ROOT::Math::TDataPointN<double>::value_type fValue). void SetWeight(float fWeight); {m_fWeight = fWeight;}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__TDataPointN_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__TDataPointN_double_.html
https://root.cern/root/html604/ROOT__Math__TDataPointN_float_.html:1108,Modifiability,Inherit,Inheritance,1108,". ROOT::Math::TDataPointN<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::TDataPointN<float>. class ROOT::Math::TDataPointN<float>. Function Members (Methods); public:. virtual~TDataPointN<float>(); static UInt_tDimension(); floatGetCoordinate(unsigned int iAxis) const; floatGetWeight() const; boolLess(ROOT::Math::TDataPointN<float>& rPoint, unsigned int iAxis) const; ROOT::Math::TDataPointN<float>&operator=(const ROOT::Math::TDataPointN<float>&); voidSetCoordinate(unsigned int iAxis, ROOT::Math::TDataPointN<float>::value_type fValue); static voidSetDimension(UInt_t dim); voidSetWeight(float fWeight); ROOT::Math::TDataPointN<float>TDataPointN<float>(); ROOT::Math::TDataPointN<float>TDataPointN<float>(const ROOT::Math::TDataPointN<float>&). Data Members; private:. static UInt_tkDimension; ROOT::Math::TDataPointN<float>::value_typem_fWeight; ROOT::Math::TDataPointN<float>::value_type*m_vCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UInt_t Dimension(); {return kDimension;}. void SetDimension(UInt_t dim); {assert(dim>0);kDimension=dim;}. _val_type GetCoordinate(unsigned int iAxis) const. _val_type GetWeight() const; {return m_fWeight;}. bool Less(ROOT::Math::TDataPointN<float>& rPoint, unsigned int iAxis) const. void SetCoordinate(unsigned int iAxis, ROOT::Math::TDataPointN<float>::value_type fValue). void SetWeight(float fWeight); {m_fWeight = fWeight;}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__TDataPointN_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__TDataPointN_float_.html
https://root.cern/root/html604/ROOT__Math__TDataPointN_float_.html:1121,Modifiability,Inherit,Inherited,1121,". ROOT::Math::TDataPointN<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::TDataPointN<float>. class ROOT::Math::TDataPointN<float>. Function Members (Methods); public:. virtual~TDataPointN<float>(); static UInt_tDimension(); floatGetCoordinate(unsigned int iAxis) const; floatGetWeight() const; boolLess(ROOT::Math::TDataPointN<float>& rPoint, unsigned int iAxis) const; ROOT::Math::TDataPointN<float>&operator=(const ROOT::Math::TDataPointN<float>&); voidSetCoordinate(unsigned int iAxis, ROOT::Math::TDataPointN<float>::value_type fValue); static voidSetDimension(UInt_t dim); voidSetWeight(float fWeight); ROOT::Math::TDataPointN<float>TDataPointN<float>(); ROOT::Math::TDataPointN<float>TDataPointN<float>(const ROOT::Math::TDataPointN<float>&). Data Members; private:. static UInt_tkDimension; ROOT::Math::TDataPointN<float>::value_typem_fWeight; ROOT::Math::TDataPointN<float>::value_type*m_vCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UInt_t Dimension(); {return kDimension;}. void SetDimension(UInt_t dim); {assert(dim>0);kDimension=dim;}. _val_type GetCoordinate(unsigned int iAxis) const. _val_type GetWeight() const; {return m_fWeight;}. bool Less(ROOT::Math::TDataPointN<float>& rPoint, unsigned int iAxis) const. void SetCoordinate(unsigned int iAxis, ROOT::Math::TDataPointN<float>::value_type fValue). void SetWeight(float fWeight); {m_fWeight = fWeight;}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__TDataPointN_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__TDataPointN_float_.html
https://root.cern/root/html604/ROOT__Math__TDataPointN_float_.html:1259,Testability,assert,assert,1259,". ROOT::Math::TDataPointN<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::TDataPointN<float>. class ROOT::Math::TDataPointN<float>. Function Members (Methods); public:. virtual~TDataPointN<float>(); static UInt_tDimension(); floatGetCoordinate(unsigned int iAxis) const; floatGetWeight() const; boolLess(ROOT::Math::TDataPointN<float>& rPoint, unsigned int iAxis) const; ROOT::Math::TDataPointN<float>&operator=(const ROOT::Math::TDataPointN<float>&); voidSetCoordinate(unsigned int iAxis, ROOT::Math::TDataPointN<float>::value_type fValue); static voidSetDimension(UInt_t dim); voidSetWeight(float fWeight); ROOT::Math::TDataPointN<float>TDataPointN<float>(); ROOT::Math::TDataPointN<float>TDataPointN<float>(const ROOT::Math::TDataPointN<float>&). Data Members; private:. static UInt_tkDimension; ROOT::Math::TDataPointN<float>::value_typem_fWeight; ROOT::Math::TDataPointN<float>::value_type*m_vCoordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UInt_t Dimension(); {return kDimension;}. void SetDimension(UInt_t dim); {assert(dim>0);kDimension=dim;}. _val_type GetCoordinate(unsigned int iAxis) const. _val_type GetWeight() const; {return m_fWeight;}. bool Less(ROOT::Math::TDataPointN<float>& rPoint, unsigned int iAxis) const. void SetCoordinate(unsigned int iAxis, ROOT::Math::TDataPointN<float>::value_type fValue). void SetWeight(float fWeight); {m_fWeight = fWeight;}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__TDataPointN_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__TDataPointN_float_.html
https://root.cern/root/html604/ROOT__Math__TDataPoint_1_double_.html:1387,Modifiability,Inherit,Inheritance,1387,",double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::TDataPoint<1,double>. class ROOT::Math::TDataPoint<1,double>. Function Members (Methods); public:. ~TDataPoint<1,double>(); static UInt_tDimension(); ROOT::Math::TDataPoint<1,double>::value_typeGetCoordinate(unsigned int iAxis) const; ROOT::Math::TDataPoint<1,double>::value_typeGetWeight() const; Bool_tLess(ROOT::Math::TDataPoint<1,double>& rPoint, unsigned int iAxis) const; ROOT::Math::TDataPoint<1,double>&operator=(const ROOT::Math::TDataPoint<1,double>&); ROOT::Math::TDataPoint<1,double>&operator=(ROOT::Math::TDataPoint<1,double>&&); voidSetCoordinate(unsigned int iAxis, double fValue); voidSetWeight(float fWeight); ROOT::Math::TDataPoint<1,double>TDataPoint<1,double>(); ROOT::Math::TDataPoint<1,double>TDataPoint<1,double>(const ROOT::Math::TDataPoint<1,double>&); ROOT::Math::TDataPoint<1,double>TDataPoint<1,double>(ROOT::Math::TDataPoint<1,double>&&). Data Members; public:. static ROOT::Math::TDataPoint<1,double>::(anonymous)kDimension. private:. ROOT::Math::TDataPoint<1,double>::value_typem_fWeightweight at this point; ROOT::Math::TDataPoint<1,double>::value_typem_vCoordinates[1]coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UInt_t Dimension(); {return kDimension;}. value_type GetCoordinate(unsigned int iAxis) const. value_type GetWeight() const; {return m_fWeight;}. Bool_t Less(ROOT::Math::TDataPoint<1,double>& rPoint, unsigned int iAxis) const. void SetCoordinate(unsigned int iAxis, double fValue). void SetWeight(float fWeight); {m_fWeight = fWeight;}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__TDataPoint_1_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__TDataPoint_1_double_.html
https://root.cern/root/html604/ROOT__Math__TDataPoint_1_double_.html:1400,Modifiability,Inherit,Inherited,1400,",double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::TDataPoint<1,double>. class ROOT::Math::TDataPoint<1,double>. Function Members (Methods); public:. ~TDataPoint<1,double>(); static UInt_tDimension(); ROOT::Math::TDataPoint<1,double>::value_typeGetCoordinate(unsigned int iAxis) const; ROOT::Math::TDataPoint<1,double>::value_typeGetWeight() const; Bool_tLess(ROOT::Math::TDataPoint<1,double>& rPoint, unsigned int iAxis) const; ROOT::Math::TDataPoint<1,double>&operator=(const ROOT::Math::TDataPoint<1,double>&); ROOT::Math::TDataPoint<1,double>&operator=(ROOT::Math::TDataPoint<1,double>&&); voidSetCoordinate(unsigned int iAxis, double fValue); voidSetWeight(float fWeight); ROOT::Math::TDataPoint<1,double>TDataPoint<1,double>(); ROOT::Math::TDataPoint<1,double>TDataPoint<1,double>(const ROOT::Math::TDataPoint<1,double>&); ROOT::Math::TDataPoint<1,double>TDataPoint<1,double>(ROOT::Math::TDataPoint<1,double>&&). Data Members; public:. static ROOT::Math::TDataPoint<1,double>::(anonymous)kDimension. private:. ROOT::Math::TDataPoint<1,double>::value_typem_fWeightweight at this point; ROOT::Math::TDataPoint<1,double>::value_typem_vCoordinates[1]coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UInt_t Dimension(); {return kDimension;}. value_type GetCoordinate(unsigned int iAxis) const. value_type GetWeight() const; {return m_fWeight;}. Bool_t Less(ROOT::Math::TDataPoint<1,double>& rPoint, unsigned int iAxis) const. void SetCoordinate(unsigned int iAxis, double fValue). void SetWeight(float fWeight); {m_fWeight = fWeight;}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__TDataPoint_1_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__TDataPoint_1_double_.html
https://root.cern/root/html604/ROOT__Math__TDataPoint_1_float_.html:1364,Modifiability,Inherit,Inheritance,1364," ROOT::Math::TDataPoint<1,float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::TDataPoint<1,float>. class ROOT::Math::TDataPoint<1,float>. Function Members (Methods); public:. ~TDataPoint<1,float>(); static UInt_tDimension(); ROOT::Math::TDataPoint<1,float>::value_typeGetCoordinate(unsigned int iAxis) const; ROOT::Math::TDataPoint<1,float>::value_typeGetWeight() const; Bool_tLess(ROOT::Math::TDataPoint<1,float>& rPoint, unsigned int iAxis) const; ROOT::Math::TDataPoint<1,float>&operator=(const ROOT::Math::TDataPoint<1,float>&); ROOT::Math::TDataPoint<1,float>&operator=(ROOT::Math::TDataPoint<1,float>&&); voidSetCoordinate(unsigned int iAxis, float fValue); voidSetWeight(float fWeight); ROOT::Math::TDataPoint<1,float>TDataPoint<1,float>(); ROOT::Math::TDataPoint<1,float>TDataPoint<1,float>(const ROOT::Math::TDataPoint<1,float>&); ROOT::Math::TDataPoint<1,float>TDataPoint<1,float>(ROOT::Math::TDataPoint<1,float>&&). Data Members; public:. static ROOT::Math::TDataPoint<1,float>::(anonymous)kDimension. private:. ROOT::Math::TDataPoint<1,float>::value_typem_fWeightweight at this point; ROOT::Math::TDataPoint<1,float>::value_typem_vCoordinates[1]coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UInt_t Dimension(); {return kDimension;}. value_type GetCoordinate(unsigned int iAxis) const. value_type GetWeight() const; {return m_fWeight;}. Bool_t Less(ROOT::Math::TDataPoint<1,float>& rPoint, unsigned int iAxis) const. void SetCoordinate(unsigned int iAxis, float fValue). void SetWeight(float fWeight); {m_fWeight = fWeight;}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__TDataPoint_1_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__TDataPoint_1_float_.html
https://root.cern/root/html604/ROOT__Math__TDataPoint_1_float_.html:1377,Modifiability,Inherit,Inherited,1377," ROOT::Math::TDataPoint<1,float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::TDataPoint<1,float>. class ROOT::Math::TDataPoint<1,float>. Function Members (Methods); public:. ~TDataPoint<1,float>(); static UInt_tDimension(); ROOT::Math::TDataPoint<1,float>::value_typeGetCoordinate(unsigned int iAxis) const; ROOT::Math::TDataPoint<1,float>::value_typeGetWeight() const; Bool_tLess(ROOT::Math::TDataPoint<1,float>& rPoint, unsigned int iAxis) const; ROOT::Math::TDataPoint<1,float>&operator=(const ROOT::Math::TDataPoint<1,float>&); ROOT::Math::TDataPoint<1,float>&operator=(ROOT::Math::TDataPoint<1,float>&&); voidSetCoordinate(unsigned int iAxis, float fValue); voidSetWeight(float fWeight); ROOT::Math::TDataPoint<1,float>TDataPoint<1,float>(); ROOT::Math::TDataPoint<1,float>TDataPoint<1,float>(const ROOT::Math::TDataPoint<1,float>&); ROOT::Math::TDataPoint<1,float>TDataPoint<1,float>(ROOT::Math::TDataPoint<1,float>&&). Data Members; public:. static ROOT::Math::TDataPoint<1,float>::(anonymous)kDimension. private:. ROOT::Math::TDataPoint<1,float>::value_typem_fWeightweight at this point; ROOT::Math::TDataPoint<1,float>::value_typem_vCoordinates[1]coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UInt_t Dimension(); {return kDimension;}. value_type GetCoordinate(unsigned int iAxis) const. value_type GetWeight() const; {return m_fWeight;}. Bool_t Less(ROOT::Math::TDataPoint<1,float>& rPoint, unsigned int iAxis) const. void SetCoordinate(unsigned int iAxis, float fValue). void SetWeight(float fWeight); {m_fWeight = fWeight;}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__TDataPoint_1_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__TDataPoint_1_float_.html
https://root.cern/root/html604/ROOT__Math__Transform3D.html:6547,Modifiability,Inherit,Inheritance,6547,"From(const ROOT::Math::Transform3D::Vector& v); voidAssignFrom(const ROOT::Math::Rotation3D& r, const ROOT::Math::Transform3D::Vector& v); voidSetIdentity(). Data Members; public:. static ROOT::Math::Transform3D::ETransform3DMatrixIndexkDX; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkDY; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkDZ; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkXX; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkXY; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkXZ; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkYX; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkYY; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkYZ; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkZX; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkZY; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkZZ. private:. doublefM[12]transformation elements (3x4 matrix). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Transform3D(). Default constructor (identy rotation) + zero translation. SetIdentity(). Transform3D(IT begin, IT end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of 12 Scalars. SetComponents(begin,end). Transform3D( const Rotation3D & r, const Vector & v). Construct from a rotation and then a translation described by a Vector. AssignFrom(const ROOT::Math::Rotation3D& r, const ROOT::Math::Transform3D::Vector& v). Transform3D( const Rotation3D & r, const Translation3D & t). Construct from a rotation and then a translation described by a Translation3D class. AssignFrom(const ROOT::Math::Rotation3D& r, const ROOT::Math::Transform3D::Vector& v). Transform3D( const ARotation & r, const DisplacementVector3D<CoordSystem,Tag> & v). Construct from a rotation (any rotation object) and then a translation; (represented by any DisplacementVector); The requirements on the rotation and vector objects ar",MatchSource.WIKI,root/html604/ROOT__Math__Transform3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__Transform3D.html
https://root.cern/root/html604/ROOT__Math__Transform3D.html:6560,Modifiability,Inherit,Inherited,6560,"From(const ROOT::Math::Transform3D::Vector& v); voidAssignFrom(const ROOT::Math::Rotation3D& r, const ROOT::Math::Transform3D::Vector& v); voidSetIdentity(). Data Members; public:. static ROOT::Math::Transform3D::ETransform3DMatrixIndexkDX; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkDY; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkDZ; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkXX; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkXY; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkXZ; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkYX; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkYY; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkYZ; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkZX; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkZY; static ROOT::Math::Transform3D::ETransform3DMatrixIndexkZZ. private:. doublefM[12]transformation elements (3x4 matrix). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Transform3D(). Default constructor (identy rotation) + zero translation. SetIdentity(). Transform3D(IT begin, IT end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of 12 Scalars. SetComponents(begin,end). Transform3D( const Rotation3D & r, const Vector & v). Construct from a rotation and then a translation described by a Vector. AssignFrom(const ROOT::Math::Rotation3D& r, const ROOT::Math::Transform3D::Vector& v). Transform3D( const Rotation3D & r, const Translation3D & t). Construct from a rotation and then a translation described by a Translation3D class. AssignFrom(const ROOT::Math::Rotation3D& r, const ROOT::Math::Transform3D::Vector& v). Transform3D( const ARotation & r, const DisplacementVector3D<CoordSystem,Tag> & v). Construct from a rotation (any rotation object) and then a translation; (represented by any DisplacementVector); The requirements on the rotation and vector objects ar",MatchSource.WIKI,root/html604/ROOT__Math__Transform3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__Transform3D.html
https://root.cern/root/html604/ROOT__Math__Transform3D.html:530,Usability,simpl,simple,530,". ROOT::Math::Transform3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::Transform3D. class ROOT::Math::Transform3D. Basic 3D Transformation class describing a rotation and then a translation; The internal data are a 3D rotation data (represented as a 3x3 matrix) and a 3D vector data.; They are represented and held in this class like a 3x4 matrix (a simple array of 12 numbers). The class can be constructed from any 3D rotation object; (ROOT::Math::Rotation3D, ROOT::Math::AxisAngle, ROOT::Math::Quaternion, etc...) and/or; a 3D Vector (ROOT::Math::DislacementVector3D or via ROOT::Math::Translation ) representing a Translation.; The Transformation is defined by applying first the rotation and then the translation.; A transformation defined by applying first a translation and then a rotation is equivalent to the; transformation obtained applying first the rotation and then a translation equivalent to the rotated vector.; The operator * can be used to obtain directly such transformations, in addition to combine various; transformations.; Keep in mind that the operator * (like in the case of rotations ) is not commutative.; The operator * is used (in addition to operator() ) to apply a transformations on the vector; (DisplacementVector3D and LorentzVector classes) and point (PositionVector3D) classes.; In the case of Vector objects the transformation only rotates them and does not translate them.; Only Point objects are able to be both rotated and translated. @ingroup GenVector. Function Members (Methods); public:. ~Transform3D(); voidGetComponents(double& xx, double& xy, double& xz, double& dx, double& yx, double& yy, double& yz, double& dy, double& zx, double& zy, double& zz, double& dz) const; voidGetDecomposition(ROOT::Math::Rotation3D& r, ROOT::Math::Transform3D::Vector& v) const; voidGetRotat",MatchSource.WIKI,root/html604/ROOT__Math__Transform3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__Transform3D.html
https://root.cern/root/html604/ROOT__Math__Translation3D.html:2136,Modifiability,Inherit,Inheritance,2136,"n3D& t) const; ROOT::Math::Translation3D&operator*=(const ROOT::Math::Translation3D& t); ROOT::Math::Translation3D&operator=(const ROOT::Math::Translation3D&); ROOT::Math::Translation3D&operator=(ROOT::Math::Translation3D&&); booloperator==(const ROOT::Math::Translation3D& rhs) const; voidSetComponents(double dx, double dy, double dz); voidSetXYZ(double dx, double dy, double dz); ROOT::Math::Translation3DTranslation3D(); ROOT::Math::Translation3DTranslation3D(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v); ROOT::Math::Translation3DTranslation3D(const ROOT::Math::Translation3D&); ROOT::Math::Translation3DTranslation3D(ROOT::Math::Translation3D&&); ROOT::Math::Translation3DTranslation3D(double dx, double dy, double dz); const ROOT::Math::Translation3D::Vector&Vect() const. Data Members; private:. ROOT::Math::Translation3D::VectorfVectinternal 3D vector representing the translation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Translation3D(). Default constructor ( zero translation ). {}. Translation3D(IT begin, IT end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of 3 Scalars representing the z,y,z of the translation vector. Translation3D(double dx, double dy, double dz). Construct from x,y,z values representing the translation. { }. explicit Translation3D( const DisplacementVector3D<CoordSystem,Tag> & v). Construct from any Displacement vector in ant tag and coordinate system. { }. Translation3D(const PositionVector3D<CoordSystem,Tag> & p1, const PositionVector3D<CoordSystem,Tag> & p2 ). Construct transformation from one coordinate system defined one point (the origin); to a new coordinate system defined by other point (origin ); @param p1 point defining origin of original reference system; @param p2 point defining origin of transformed reference system. { }. void SetComponents(IT begin, IT end). Set the 3 co",MatchSource.WIKI,root/html604/ROOT__Math__Translation3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__Translation3D.html
https://root.cern/root/html604/ROOT__Math__Translation3D.html:2149,Modifiability,Inherit,Inherited,2149,"n3D& t) const; ROOT::Math::Translation3D&operator*=(const ROOT::Math::Translation3D& t); ROOT::Math::Translation3D&operator=(const ROOT::Math::Translation3D&); ROOT::Math::Translation3D&operator=(ROOT::Math::Translation3D&&); booloperator==(const ROOT::Math::Translation3D& rhs) const; voidSetComponents(double dx, double dy, double dz); voidSetXYZ(double dx, double dy, double dz); ROOT::Math::Translation3DTranslation3D(); ROOT::Math::Translation3DTranslation3D(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v); ROOT::Math::Translation3DTranslation3D(const ROOT::Math::Translation3D&); ROOT::Math::Translation3DTranslation3D(ROOT::Math::Translation3D&&); ROOT::Math::Translation3DTranslation3D(double dx, double dy, double dz); const ROOT::Math::Translation3D::Vector&Vect() const. Data Members; private:. ROOT::Math::Translation3D::VectorfVectinternal 3D vector representing the translation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Translation3D(). Default constructor ( zero translation ). {}. Translation3D(IT begin, IT end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of 3 Scalars representing the z,y,z of the translation vector. Translation3D(double dx, double dy, double dz). Construct from x,y,z values representing the translation. { }. explicit Translation3D( const DisplacementVector3D<CoordSystem,Tag> & v). Construct from any Displacement vector in ant tag and coordinate system. { }. Translation3D(const PositionVector3D<CoordSystem,Tag> & p1, const PositionVector3D<CoordSystem,Tag> & p2 ). Construct transformation from one coordinate system defined one point (the origin); to a new coordinate system defined by other point (origin ); @param p1 point defining origin of original reference system; @param p2 point defining origin of transformed reference system. { }. void SetComponents(IT begin, IT end). Set the 3 co",MatchSource.WIKI,root/html604/ROOT__Math__Translation3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__Translation3D.html
https://root.cern/root/html604/ROOT__Math__Translation3D.html:640,Performance,perform,performes,640,". ROOT::Math::Translation3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::Translation3D. class ROOT::Math::Translation3D. Class describing a 3 dimensional translation. It can be combined (using the operator *); with the ROOT::Math::Rotation3D classes and ROOT::Math::Transform3D to obtained combined; transformations and to operate on points and vectors.; Note that a the translation applied to a Vector object (DisplacementVector3D and LorentzVector classes); performes a noop, i.e. it returns the same vector. A translation can be applied only to the Point objects; (PositionVector3D classes). @ingroup GenVector. Function Members (Methods); public:. ~Translation3D(); voidGetComponents(double& dx, double& dy, double& dz) const; ROOT::Math::Translation3DInverse() const; voidInvert(); booloperator!=(const ROOT::Math::Translation3D& rhs) const; ROOT::Math::Plane3Doperator()(const ROOT::Math::Plane3D& plane) const; ROOT::Math::Translation3Doperator*(const ROOT::Math::Translation3D& t) const; ROOT::Math::Translation3D&operator*=(const ROOT::Math::Translation3D& t); ROOT::Math::Translation3D&operator=(const ROOT::Math::Translation3D&); ROOT::Math::Translation3D&operator=(ROOT::Math::Translation3D&&); booloperator==(const ROOT::Math::Translation3D& rhs) const; voidSetComponents(double dx, double dy, double dz); voidSetXYZ(double dx, double dy, double dz); ROOT::Math::Translation3DTranslation3D(); ROOT::Math::Translation3DTranslation3D(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v); ROOT::Math::Translation3DTranslation3D(const ROOT::Math::Translation3D&); ROOT::Math::Translation3DTranslation3D(ROOT::Math::Translation3D&&); ROOT::Math::Translation3DTranslation3D(double dx, double dy, double dz); const ROOT::Math::Translation3D::Vector&Vect",MatchSource.WIKI,root/html604/ROOT__Math__Translation3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__Translation3D.html
https://root.cern/root/html604/ROOT__Math__Vavilov.html:1639,Availability,Avail,Available,1639," \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class Vavilov,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::Mean(kappa, beta2); and sqrt(Vavilov::Variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. Two subclasses are provided:; - VavilovFast uses the algorithm by; A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution,; <A HREF=""http://dx.doi.org/10.1016/0168-583X(90)90749-K"">Nucl. Instr. and Meth. B47 (1990) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g115/top.html"">; CERNLIB (G115)</A>. - VavilovAccurate uses the algorithm by; B. Schorr, Programs for the Landau and the Vavilov distributions and the corresponding random numbers,; <A HREF=""http://dx.do",MatchSource.WIKI,root/html604/ROOT__Math__Vavilov.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__Vavilov.html
https://root.cern/root/html604/ROOT__Math__Vavilov.html:3631,Availability,avail,available,3631,"om numbers,; <A HREF=""http://dx.doi.org/10.1016/0010-4655(74)90091-5"">Computer Phys. Comm. 7 (1974) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g116/top.html"">; CERNLIB (G116)</A>. Both subclasses store coefficients needed to calculate \f$p(\lambda; \kappa, \beta^2)\f$; for fixed values of \f$\kappa\f$ and \f$\beta^2\f$.; Changing these values is computationally expensive. VavilovFast is about 5 times faster for the calculation of the Pdf than VavilovAccurate;; initialization takes about 100 times longer than calculation of the Pdf value.; For the quantile calculation, VavilovFast; is 30 times faster for the initialization, and 6 times faster for; subsequent calculations. Initialization for Quantile takes; 27 (11) times longer than subsequent calls for VavilovFast (VavilovAccurate). @ingroup StatFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Vavilov(); virtual doubleCdf(double x) const; virtual doubleCdf(double x, double kappa, double beta2); virtual doubleCdf_c(double x) const; virtual doubleCdf_c(double x, double kappa, double beta2); virtual doubleGetBeta2() const; virtual doubleGetKappa() const; virtual doubleGetLambdaMax() const; virtual doubleGetLambdaMin() const; virtual doubleKurtosis() const; static doubleKurtosis(double kappa, double beta2); virtual doubleMean() const; static doubleMean(double kappa, double beta2); virtual doubleMode() const; virtual doubleMode(double kappa, double beta2); ROOT::Math::Vavilov&operator=(const ROOT::Math::Vavilov&); virtual doublePdf(double x) const; virtual doublePdf(double x, double kappa, double beta2); virtual doubleQuantile(double z) const; virtual doubleQuantile(double z, double kappa, double beta2); virtual doubleQuantile_c(double z) const; virtual doubleQuantile_c(double z, double kappa, double beta2); virtual voidSetKappaBet",MatchSource.WIKI,root/html604/ROOT__Math__Vavilov.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__Vavilov.html
https://root.cern/root/html604/ROOT__Math__Vavilov.html:408,Energy Efficiency,energy,energy,408,". ROOT::Math::Vavilov. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Vavilov. class ROOT::Math::Vavilov. Base class describing a Vavilov distribution. The Vavilov distribution is defined in; P.V. Vavilov: Ionization losses of high-energy heavy particles,; Sov. Phys. JETP 5 (1957) 749 [Zh. Eksp. Teor. Fiz. 32 (1957) 920]. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class Vavilov,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::Mean(kappa, beta2); and",MatchSource.WIKI,root/html604/ROOT__Math__Vavilov.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__Vavilov.html
https://root.cern/root/html604/ROOT__Math__Vavilov.html:1303,Energy Efficiency,Energy,Energy,1303,"in; P.V. Vavilov: Ionization losses of high-energy heavy particles,; Sov. Phys. JETP 5 (1957) 749 [Zh. Eksp. Teor. Fiz. 32 (1957) 920]. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class Vavilov,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::Mean(kappa, beta2); and sqrt(Vavilov::Variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. Two subclasses are provided:; - VavilovFast uses the algorithm by; A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution,; <A HREF=""http://dx.doi.org/10.1016/0168-583X(90)90749-K"">Nucl. Instr. and Meth. B47 (1990) 215-224</A>,; w",MatchSource.WIKI,root/html604/ROOT__Math__Vavilov.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__Vavilov.html
https://root.cern/root/html604/ROOT__Math__Vavilov.html:1496,Energy Efficiency,charge,charged,1496," 32 (1957) 920]. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class Vavilov,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::Mean(kappa, beta2); and sqrt(Vavilov::Variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. Two subclasses are provided:; - VavilovFast uses the algorithm by; A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution,; <A HREF=""http://dx.doi.org/10.1016/0168-583X(90)90749-K"">Nucl. Instr. and Meth. B47 (1990) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g115/top.html"">; CERNLIB (G11",MatchSource.WIKI,root/html604/ROOT__Math__Vavilov.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__Vavilov.html
https://root.cern/root/html604/ROOT__Math__Vavilov.html:1241,Integrability,rout,routines,1241,"nction members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Vavilov. class ROOT::Math::Vavilov. Base class describing a Vavilov distribution. The Vavilov distribution is defined in; P.V. Vavilov: Ionization losses of high-energy heavy particles,; Sov. Phys. JETP 5 (1957) 749 [Zh. Eksp. Teor. Fiz. 32 (1957) 920]. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class Vavilov,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::Mean(kappa, beta2); and sqrt(Vavilov::Variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. Two subclasses are provided:; - VavilovFast",MatchSource.WIKI,root/html604/ROOT__Math__Vavilov.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__Vavilov.html
https://root.cern/root/html604/ROOT__Math__Vavilov.html:4922,Modifiability,Inherit,Inheritance,4922,"bleGetLambdaMax() const; virtual doubleGetLambdaMin() const; virtual doubleKurtosis() const; static doubleKurtosis(double kappa, double beta2); virtual doubleMean() const; static doubleMean(double kappa, double beta2); virtual doubleMode() const; virtual doubleMode(double kappa, double beta2); ROOT::Math::Vavilov&operator=(const ROOT::Math::Vavilov&); virtual doublePdf(double x) const; virtual doublePdf(double x, double kappa, double beta2); virtual doubleQuantile(double z) const; virtual doubleQuantile(double z, double kappa, double beta2); virtual doubleQuantile_c(double z) const; virtual doubleQuantile_c(double z, double kappa, double beta2); virtual voidSetKappaBeta2(double kappa, double beta2); virtual doubleSkewness() const; static doubleSkewness(double kappa, double beta2); virtual doubleVariance() const; static doubleVariance(double kappa, double beta2); ROOT::Math::VavilovVavilov(); ROOT::Math::VavilovVavilov(const ROOT::Math::Vavilov&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Vavilov(). Default constructor. virtual ~Vavilov(). Destructor. double Pdf(double x) const. Evaluate the Vavilov probability density function. @param x The Landau parameter \f$x = \lambda_L\f$. double Pdf(double x, double kappa, double beta2). Evaluate the Vavilov probability density function,; and set kappa and beta2, if necessary. @param x The Landau parameter \f$x = \lambda_L\f$; @param kappa The parameter \f$\kappa\f$, which should be in the range \f$0.01 \le \kappa \le 10 \f$; @param beta2 The parameter \f$\beta^2\f$, which must be in the range \f$0 \le \beta^2 \le 1 \f$. double Cdf(double x) const. Evaluate the Vavilov cummulative probability density function. @param x The Landau parameter \f$x = \lambda_L\f$. double Cdf(double x, double kappa, double beta2). Evaluate the Vavilov cummulative probability density function,; and set kappa and beta2, if necessary. @param x The Landau parameter \f$x = \lambda_L\f$; @param kappa The pa",MatchSource.WIKI,root/html604/ROOT__Math__Vavilov.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__Vavilov.html
https://root.cern/root/html604/ROOT__Math__Vavilov.html:4935,Modifiability,Inherit,Inherited,4935,"bleGetLambdaMax() const; virtual doubleGetLambdaMin() const; virtual doubleKurtosis() const; static doubleKurtosis(double kappa, double beta2); virtual doubleMean() const; static doubleMean(double kappa, double beta2); virtual doubleMode() const; virtual doubleMode(double kappa, double beta2); ROOT::Math::Vavilov&operator=(const ROOT::Math::Vavilov&); virtual doublePdf(double x) const; virtual doublePdf(double x, double kappa, double beta2); virtual doubleQuantile(double z) const; virtual doubleQuantile(double z, double kappa, double beta2); virtual doubleQuantile_c(double z) const; virtual doubleQuantile_c(double z, double kappa, double beta2); virtual voidSetKappaBeta2(double kappa, double beta2); virtual doubleSkewness() const; static doubleSkewness(double kappa, double beta2); virtual doubleVariance() const; static doubleVariance(double kappa, double beta2); ROOT::Math::VavilovVavilov(); ROOT::Math::VavilovVavilov(const ROOT::Math::Vavilov&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Vavilov(). Default constructor. virtual ~Vavilov(). Destructor. double Pdf(double x) const. Evaluate the Vavilov probability density function. @param x The Landau parameter \f$x = \lambda_L\f$. double Pdf(double x, double kappa, double beta2). Evaluate the Vavilov probability density function,; and set kappa and beta2, if necessary. @param x The Landau parameter \f$x = \lambda_L\f$; @param kappa The parameter \f$\kappa\f$, which should be in the range \f$0.01 \le \kappa \le 10 \f$; @param beta2 The parameter \f$\beta^2\f$, which must be in the range \f$0 \le \beta^2 \le 1 \f$. double Cdf(double x) const. Evaluate the Vavilov cummulative probability density function. @param x The Landau parameter \f$x = \lambda_L\f$. double Cdf(double x, double kappa, double beta2). Evaluate the Vavilov cummulative probability density function,; and set kappa and beta2, if necessary. @param x The Landau parameter \f$x = \lambda_L\f$; @param kappa The pa",MatchSource.WIKI,root/html604/ROOT__Math__Vavilov.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__Vavilov.html
https://root.cern/root/html604/ROOT__Math__Vavilov.html:2101,Testability,log,log,2101,"stribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::Mean(kappa, beta2); and sqrt(Vavilov::Variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. Two subclasses are provided:; - VavilovFast uses the algorithm by; A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution,; <A HREF=""http://dx.doi.org/10.1016/0168-583X(90)90749-K"">Nucl. Instr. and Meth. B47 (1990) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g115/top.html"">; CERNLIB (G115)</A>. - VavilovAccurate uses the algorithm by; B. Schorr, Programs for the Landau and the Vavilov distributions and the corresponding random numbers,; <A HREF=""http://dx.doi.org/10.1016/0010-4655(74)90091-5"">Computer Phys. Comm. 7 (1974) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g116/top.html"">; CERNLIB (G116)</A>. Both subclasses store coefficients needed to calculate \f$p(\lambda; \kappa, \beta^2)\f$; for fixed values of \f$\kappa\f$ and \f$\beta^2\f$.; Changing these values is computationally expensive. VavilovFast is about 5 times faster for t",MatchSource.WIKI,root/html604/ROOT__Math__Vavilov.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__Vavilov.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html:1522,Availability,Avail,Available,1522,"int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class VavilovAccurate,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. For detailed description see; B. Schorr, Programs for the Landau and the Vavilov distributions and the corresponding random numbers,; <A HREF=""http://dx.doi.org/10.1016/0010-4655(74)90091-5"">Computer Phys. Comm. 7 (1974) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g116/top.html"">; CERNLIB (G116)</A>. The class stores coefficients needed to calculate \f$p(\lambda; \kappa, \beta^2)\f$; for fixed values of \f$\kappa\f$ and \f$\beta^2\f$.; Changing these values is computation",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html:1186,Energy Efficiency,Energy,Energy,1186,":Math::VavilovAccurate. class ROOT::Math::VavilovAccurate: public ROOT::Math::Vavilov. Class describing a Vavilov distribution. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class VavilovAccurate,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. For detailed description see; B. Schorr, Programs for the Landau and the Vavilov distributions and the corresponding random numbers,; <A HREF=""http://dx.doi.org/10.1016/0010-4655(74)90091-5"">Computer Phys. Comm. 7 (1974) 215-224</A>,; which has",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html:1379,Energy Efficiency,charge,charged,1379,"ibution. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class VavilovAccurate,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. For detailed description see; B. Schorr, Programs for the Landau and the Vavilov distributions and the corresponding random numbers,; <A HREF=""http://dx.doi.org/10.1016/0010-4655(74)90091-5"">Computer Phys. Comm. 7 (1974) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g116/top.html"">; CERNLIB (G116)</A>. ",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html:1124,Integrability,rout,routines,1124,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::VavilovAccurate. class ROOT::Math::VavilovAccurate: public ROOT::Math::Vavilov. Class describing a Vavilov distribution. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class VavilovAccurate,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. For detailed description see; B. Schorr",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html:4087,Integrability,depend,depending,4087,") of Schorr's paper.; epsilonPM gives an estimate on the integral of the cummulative distribution function; outside the range \f$\lambda_{min} \le \lambda \le \lambda_{max}\f$; where the approximation is valid.; Thus, it determines the support of the approximation used here (called $T_0 - T_1$ in the paper).; Schorr recommends \f$\epsilon^+ = \epsilon^- = 5\cdot 10^{-4}\f$.; The code from CERNLIB has been extended such that also smaller values are possible. - epsilon corresponds to \f$\epsilon\f$ in Eq. (4.10) of Schorr's paper.; It determines the accuracy of the series expansion.; Schorr recommends \f$\epsilon = 10^{-5}\f$. For the quantile calculation, the algorithm given by Schorr is not used,; because it turns out to be very slow and still inaccurate.; Instead, an initial estimate is calculated based on a precalculated table,; which is subsequently improved by Newton iterations. While the CERNLIB implementation calculates at most 156 terms in the series expansion; for the pdf and cdf calculation, this class calculates up to 500 terms, depending; on the values of epsilonPM and epsilon. Average times on a Pentium Core2 Duo P8400 2.26GHz:; - 38us per call to SetKappaBeta2 or constructor; - 0.49us per call to Pdf, Cdf; - 8.2us per first call to Quantile after SetKappaBeta2 or constructor; - 0.83us per subsequent call to Quantile. Benno List, June 2010. @ingroup StatFunc. Function Members (Methods); public:. virtual~VavilovAccurate(); virtual doubleCdf(double x) const; virtual doubleCdf(double x, double kappa, double beta2); virtual doubleCdf_c(double x) const; virtual doubleCdf_c(double x, double kappa, double beta2); virtual doubleGetBeta2() const; doubleGetEpsilon() const; doubleGetEpsilonPM() const; static ROOT::Math::VavilovAccurate*GetInstance(); static ROOT::Math::VavilovAccurate*GetInstance(double kappa, double beta2); virtual doubleGetKappa() const; virtual doubleGetLambdaMax() const; virtual doubleGetLambdaMin() const; doubleGetNTerms() const; virtual doubl",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html:3441,Modifiability,extend,extended,3441," for fixed values of \f$\kappa\f$ and \f$\beta^2\f$.; Changing these values is computationally expensive. The parameter \f$\kappa\f$ should be in the range \f$0.01 \le \kappa \le 10\f$.; In contrast to the CERNLIB implementation, all values of \f$\kappa \ge 0.001\f$ may be used,; but may result in slower running and/or inaccurate results. The parameter \f$\beta^2\f$ must be in the range \f$0 \le \beta^2 \le 1\f$. Two parameters which are fixed in the CERNLIB implementation may be set by the user:; - epsilonPM corresponds to \f$\epsilon^+ = \epsilon^-\f$ in Eqs. (2.1) and (2.2) of Schorr's paper.; epsilonPM gives an estimate on the integral of the cummulative distribution function; outside the range \f$\lambda_{min} \le \lambda \le \lambda_{max}\f$; where the approximation is valid.; Thus, it determines the support of the approximation used here (called $T_0 - T_1$ in the paper).; Schorr recommends \f$\epsilon^+ = \epsilon^- = 5\cdot 10^{-4}\f$.; The code from CERNLIB has been extended such that also smaller values are possible. - epsilon corresponds to \f$\epsilon\f$ in Eq. (4.10) of Schorr's paper.; It determines the accuracy of the series expansion.; Schorr recommends \f$\epsilon = 10^{-5}\f$. For the quantile calculation, the algorithm given by Schorr is not used,; because it turns out to be very slow and still inaccurate.; Instead, an initial estimate is calculated based on a precalculated table,; which is subsequently improved by Newton iterations. While the CERNLIB implementation calculates at most 156 terms in the series expansion; for the pdf and cdf calculation, this class calculates up to 500 terms, depending; on the values of epsilonPM and epsilon. Average times on a Pentium Core2 Duo P8400 2.26GHz:; - 38us per call to SetKappaBeta2 or constructor; - 0.49us per call to Pdf, Cdf; - 8.2us per first call to Quantile after SetKappaBeta2 or constructor; - 0.83us per subsequent call to Quantile. Benno List, June 2010. @ingroup StatFunc. Function Members (Methods",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html:7235,Modifiability,Inherit,Inheritance,7235,"&); ROOT::Math::VavilovAccurateVavilovAccurate(const ROOT::Math::VavilovAccurate&); ROOT::Math::VavilovAccurateVavilovAccurate(double kappa = 1, double beta2 = 1, double epsilonPM = 5.0000000000000001E-4, double epsilon = 1.0000000000000001E-5). private:. static doubleE1plLog(double x); doubleG116f1(double x) const; doubleG116f2(double x) const; voidInitQuantile() const; intRzero(double a, double b, double& x0, double eps, int mxf, double(ROOT::Math::VavilovAccurate::*)(double)const f) const. Data Members; private:. static ROOT::Math::VavilovAccurate::(anonymous)MAXTERMS; doublefA_cdf[501]; doublefA_pdf[501]; doublefB_cdf[501]; doublefB_pdf[501]; doublefBeta2; doublefEpsilon; doublefEpsilonPM; doublefH[8]; doublefKappa; doublefLambda[32]; intfNQuant; doublefOmega; doublefQuant[32]; boolfQuantileInit; doublefT; doublefT0; doublefT1; doublefX0; static ROOT::Math::VavilovAccurate*fgInstance; static ROOT::Math::VavilovAccurate::(anonymous)kNquantMax. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurate(double kappa = 1, double beta2 = 1, double epsilonPM = 5.0000000000000001E-4, double epsilon = 1.0000000000000001E-5). Initialize an object to calculate the Vavilov distribution. @param kappa The parameter \f$\kappa\f$, which must be in the range \f$\kappa \ge 0.001 \f$; @param beta2 The parameter \f$\beta^2\f$, which must be in the range \f$0 \le \beta^2 \le 1 \f$; @param epsilonPM: \f$\epsilon^+ = \epsilon^-\f$ in Eqs. (2.1) and (2.2) of Schorr's paper; gives an estimate on the integral of the cummulative distribution function; outside the range \f$\lambda_{min} \le \lambda \le \lambda_{max}\f$; where the approximation is valid.; @param epsilon: \f$\epsilon\f$ in Eq. (4.10) of Schorr's paper; determines the accuracy of the series expansion. virtual ~VavilovAccurate(). Destructor. double Pdf(double x) const. Evaluate the Vavilov probability density function. @param x The Landau parameter \f$x = \lambda_L\f$. double Pdf",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html:7248,Modifiability,Inherit,Inherited,7248,"&); ROOT::Math::VavilovAccurateVavilovAccurate(const ROOT::Math::VavilovAccurate&); ROOT::Math::VavilovAccurateVavilovAccurate(double kappa = 1, double beta2 = 1, double epsilonPM = 5.0000000000000001E-4, double epsilon = 1.0000000000000001E-5). private:. static doubleE1plLog(double x); doubleG116f1(double x) const; doubleG116f2(double x) const; voidInitQuantile() const; intRzero(double a, double b, double& x0, double eps, int mxf, double(ROOT::Math::VavilovAccurate::*)(double)const f) const. Data Members; private:. static ROOT::Math::VavilovAccurate::(anonymous)MAXTERMS; doublefA_cdf[501]; doublefA_pdf[501]; doublefB_cdf[501]; doublefB_pdf[501]; doublefBeta2; doublefEpsilon; doublefEpsilonPM; doublefH[8]; doublefKappa; doublefLambda[32]; intfNQuant; doublefOmega; doublefQuant[32]; boolfQuantileInit; doublefT; doublefT0; doublefT1; doublefX0; static ROOT::Math::VavilovAccurate*fgInstance; static ROOT::Math::VavilovAccurate::(anonymous)kNquantMax. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurate(double kappa = 1, double beta2 = 1, double epsilonPM = 5.0000000000000001E-4, double epsilon = 1.0000000000000001E-5). Initialize an object to calculate the Vavilov distribution. @param kappa The parameter \f$\kappa\f$, which must be in the range \f$\kappa \ge 0.001 \f$; @param beta2 The parameter \f$\beta^2\f$, which must be in the range \f$0 \le \beta^2 \le 1 \f$; @param epsilonPM: \f$\epsilon^+ = \epsilon^-\f$ in Eqs. (2.1) and (2.2) of Schorr's paper; gives an estimate on the integral of the cummulative distribution function; outside the range \f$\lambda_{min} \le \lambda \le \lambda_{max}\f$; where the approximation is valid.; @param epsilon: \f$\epsilon\f$ in Eq. (4.10) of Schorr's paper; determines the accuracy of the series expansion. virtual ~VavilovAccurate(). Destructor. double Pdf(double x) const. Evaluate the Vavilov probability density function. @param x The Landau parameter \f$x = \lambda_L\f$. double Pdf",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html:1984,Testability,log,log,1984,"stribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. For detailed description see; B. Schorr, Programs for the Landau and the Vavilov distributions and the corresponding random numbers,; <A HREF=""http://dx.doi.org/10.1016/0010-4655(74)90091-5"">Computer Phys. Comm. 7 (1974) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g116/top.html"">; CERNLIB (G116)</A>. The class stores coefficients needed to calculate \f$p(\lambda; \kappa, \beta^2)\f$; for fixed values of \f$\kappa\f$ and \f$\beta^2\f$.; Changing these values is computationally expensive. The parameter \f$\kappa\f$ should be in the range \f$0.01 \le \kappa \le 10\f$.; In contrast to the CERNLIB implementation, all values of \f$\kappa \ge 0.001\f$ may be used,; but may result in slower running and/or inaccurate results. The parameter \f$\beta^2\f$ must be in the range \f$0 \le \beta^2 \le 1\f$. Two parameters which are fixed in the CERNLIB implementation may be set by the user:; - epsilonPM corresponds to \f$\",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurate.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurateCdf.html:2869,Modifiability,Inherit,Inheritance,2869,"rametricFunctionOneDimROOT::Math::IParametricFunctionOneDim::IParametricFunctionOneDim(ROOT::Math::IParametricFunctionOneDim&&); ROOT::Math::IParametricFunctionOneDimROOT::Math::IParametricFunctionOneDim::IParametricFunctionOneDim(const ROOT::Math::IParametricFunctionOneDim&); virtual unsigned intNPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; ",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurateCdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurateCdf.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurateCdf.html:2882,Modifiability,Inherit,Inherited,2882,"rametricFunctionOneDimROOT::Math::IParametricFunctionOneDim::IParametricFunctionOneDim(ROOT::Math::IParametricFunctionOneDim&&); ROOT::Math::IParametricFunctionOneDimROOT::Math::IParametricFunctionOneDim::IParametricFunctionOneDim(const ROOT::Math::IParametricFunctionOneDim&); virtual unsigned intNPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; ",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurateCdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurateCdf.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurateCdf.html:3599,Safety,avoid,avoid,3599," double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurateCdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurateCdf.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurateCdf.html:3228,Security,Access,Access,3228,"onOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general p",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurateCdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurateCdf.html
https://root.cern/root/html604/ROOT__Math__VavilovAccuratePdf.html:2869,Modifiability,Inherit,Inheritance,2869,"rametricFunctionOneDimROOT::Math::IParametricFunctionOneDim::IParametricFunctionOneDim(ROOT::Math::IParametricFunctionOneDim&&); ROOT::Math::IParametricFunctionOneDimROOT::Math::IParametricFunctionOneDim::IParametricFunctionOneDim(const ROOT::Math::IParametricFunctionOneDim&); virtual unsigned intNPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccuratePdf&operator=(const ROOT::Math::VavilovAccuratePdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccuratePdfVavilovAccuratePdf(); ROOT::Math::VavilovAccuratePdfVavilovAccuratePdf(const double* p); ROOT::Math::VavilovAccuratePdfVavilovAccuratePdf(const ROOT::Math::VavilovAccuratePdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccuratePdf(). Default constructor. VavilovAccuratePdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccuratePdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values. @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccuratePdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccuratePdf.html
https://root.cern/root/html604/ROOT__Math__VavilovAccuratePdf.html:2882,Modifiability,Inherit,Inherited,2882,"rametricFunctionOneDimROOT::Math::IParametricFunctionOneDim::IParametricFunctionOneDim(ROOT::Math::IParametricFunctionOneDim&&); ROOT::Math::IParametricFunctionOneDimROOT::Math::IParametricFunctionOneDim::IParametricFunctionOneDim(const ROOT::Math::IParametricFunctionOneDim&); virtual unsigned intNPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccuratePdf&operator=(const ROOT::Math::VavilovAccuratePdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccuratePdfVavilovAccuratePdf(); ROOT::Math::VavilovAccuratePdfVavilovAccuratePdf(const double* p); ROOT::Math::VavilovAccuratePdfVavilovAccuratePdf(const ROOT::Math::VavilovAccuratePdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccuratePdf(). Default constructor. VavilovAccuratePdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccuratePdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values. @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccuratePdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccuratePdf.html
https://root.cern/root/html604/ROOT__Math__VavilovAccuratePdf.html:3228,Security,Access,Access,3228,"leROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccuratePdf&operator=(const ROOT::Math::VavilovAccuratePdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccuratePdfVavilovAccuratePdf(); ROOT::Math::VavilovAccuratePdfVavilovAccuratePdf(const double* p); ROOT::Math::VavilovAccuratePdfVavilovAccuratePdf(const ROOT::Math::VavilovAccuratePdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccuratePdf(). Default constructor. VavilovAccuratePdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccuratePdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values. @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccuratePdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccuratePdf.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurateQuantile.html:2948,Modifiability,Inherit,Inheritance,2948,"FunctionOneDim::IParametricFunctionOneDim(ROOT::Math::IParametricFunctionOneDim&&); ROOT::Math::IParametricFunctionOneDimROOT::Math::IParametricFunctionOneDim::IParametricFunctionOneDim(const ROOT::Math::IParametricFunctionOneDim&); virtual unsigned intNPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateQuantile&operator=(const ROOT::Math::VavilovAccurateQuantile&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateQuantileVavilovAccurateQuantile(); ROOT::Math::VavilovAccurateQuantileVavilovAccurateQuantile(const double* p); ROOT::Math::VavilovAccurateQuantileVavilovAccurateQuantile(const ROOT::Math::VavilovAccurateQuantile&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateQuantile(). Default constructor. VavilovAccurateQuantile(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateQuantile(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero). double DoEval(double x) const. Evaluate the function. @param x The Quantile \f$z\f$ , \f$0 \le z \le 1\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Quantile \f$z\f$, \f$0 \le z \le 1\f$; @param p vector of doubles containing the paramet",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurateQuantile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurateQuantile.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurateQuantile.html:2961,Modifiability,Inherit,Inherited,2961,"FunctionOneDim::IParametricFunctionOneDim(ROOT::Math::IParametricFunctionOneDim&&); ROOT::Math::IParametricFunctionOneDimROOT::Math::IParametricFunctionOneDim::IParametricFunctionOneDim(const ROOT::Math::IParametricFunctionOneDim&); virtual unsigned intNPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateQuantile&operator=(const ROOT::Math::VavilovAccurateQuantile&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateQuantileVavilovAccurateQuantile(); ROOT::Math::VavilovAccurateQuantileVavilovAccurateQuantile(const double* p); ROOT::Math::VavilovAccurateQuantileVavilovAccurateQuantile(const ROOT::Math::VavilovAccurateQuantile&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateQuantile(). Default constructor. VavilovAccurateQuantile(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateQuantile(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero). double DoEval(double x) const. Evaluate the function. @param x The Quantile \f$z\f$ , \f$0 \le z \le 1\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Quantile \f$z\f$, \f$0 \le z \le 1\f$; @param p vector of doubles containing the paramet",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurateQuantile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurateQuantile.html
https://root.cern/root/html604/ROOT__Math__VavilovAccurateQuantile.html:3322,Security,Access,Access,3322,"onst double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateQuantile&operator=(const ROOT::Math::VavilovAccurateQuantile&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateQuantileVavilovAccurateQuantile(); ROOT::Math::VavilovAccurateQuantileVavilovAccurateQuantile(const double* p); ROOT::Math::VavilovAccurateQuantileVavilovAccurateQuantile(const ROOT::Math::VavilovAccurateQuantile&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateQuantile(). Default constructor. VavilovAccurateQuantile(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateQuantile(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero). double DoEval(double x) const. Evaluate the function. @param x The Quantile \f$z\f$ , \f$0 \le z \le 1\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Quantile \f$z\f$, \f$0 \le z \le 1\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VavilovAccurateQuantile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovAccurateQuantile.html
https://root.cern/root/html604/ROOT__Math__VavilovFast.html:1506,Availability,Avail,Available,1506," i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class VavilovFast,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. For detailed description see; A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution,; <A HREF=""http://dx.doi.org/10.1016/0168-583X(90)90749-K"">Nucl. Instr. and Meth. B47 (1990) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g115/top.html"">; CERNLIB (G115)</A>. The class stores coef",MatchSource.WIKI,root/html604/ROOT__Math__VavilovFast.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovFast.html
https://root.cern/root/html604/ROOT__Math__VavilovFast.html:1170,Energy Efficiency,Energy,Energy,1170,"ORE; » ROOT::Math::VavilovFast. class ROOT::Math::VavilovFast: public ROOT::Math::Vavilov. Class describing a Vavilov distribution. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class VavilovFast,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. For detailed description see; A. Rotondi and P. Montagna, Fast",MatchSource.WIKI,root/html604/ROOT__Math__VavilovFast.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovFast.html
https://root.cern/root/html604/ROOT__Math__VavilovFast.html:1363,Energy Efficiency,charge,charged,1363,"istribution. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class VavilovFast,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. For detailed description see; A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution,; <A HREF=""http://dx.doi.org/10.1016/0168-583X(90)90749-K"">Nucl. Instr. and Meth. ",MatchSource.WIKI,root/html604/ROOT__Math__VavilovFast.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovFast.html
https://root.cern/root/html604/ROOT__Math__VavilovFast.html:1108,Integrability,rout,routines,1108,"Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::VavilovFast. class ROOT::Math::VavilovFast: public ROOT::Math::Vavilov. Class describing a Vavilov distribution. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class VavilovFast,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::m",MatchSource.WIKI,root/html604/ROOT__Math__VavilovFast.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovFast.html
https://root.cern/root/html604/ROOT__Math__VavilovFast.html:5115,Modifiability,Inherit,Inheritance,5115,"pa, double beta2); virtual doubleQuantile(double z) const; virtual doubleQuantile(double z, double kappa, double beta2); virtual doubleQuantile_c(double z) const; virtual doubleQuantile_c(double z, double kappa, double beta2); virtual voidSetKappaBeta2(double kappa, double beta2); virtual doubleROOT::Math::Vavilov::Skewness() const; static doubleROOT::Math::Vavilov::Skewness(double kappa, double beta2); virtual doubleROOT::Math::Vavilov::Variance() const; static doubleROOT::Math::Vavilov::Variance(double kappa, double beta2); ROOT::Math::VavilovROOT::Math::Vavilov::Vavilov(); ROOT::Math::VavilovROOT::Math::Vavilov::Vavilov(const ROOT::Math::Vavilov&); ROOT::Math::VavilovFastVavilovFast(const ROOT::Math::VavilovFast&); ROOT::Math::VavilovFastVavilovFast(double kappa = 1, double beta2 = 1). Data Members; private:. doublefAC[14]; doublefBeta2; doublefHC[9]; intfItype; doublefKappa; intfNpt; doublefWCM[201]; static ROOT::Math::VavilovFast*fgInstance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovFast(double kappa = 1, double beta2 = 1). Initialize an object to calculate the Vavilov distribution. @param kappa The parameter \f$\kappa\f$, which must be in the range \f$0.01 \le \kappa \le 12 \f$; @param beta2 The parameter \f$\beta^2\f$, which must be in the range \f$0 \le \beta^2 \le 1 \f$. virtual ~VavilovFast(). Destructor. double Pdf(double x) const. Evaluate the Vavilov probability density function. @param x The Landau parameter \f$x = \lambda_L\f$. double Pdf(double x, double kappa, double beta2). Evaluate the Vavilov probability density function,; and set kappa and beta2, if necessary. @param x The Landau parameter \f$x = \lambda_L\f$; @param kappa The parameter \f$\kappa\f$, which must be in the range \f$0.01 \le \kappa \le 12 \f$; @param beta2 The parameter \f$\beta^2\f$, which must be in the range \f$0 \le \beta^2 \le 1 \f$. double Cdf(double x) const. Evaluate the Vavilov cummulative probability density function.",MatchSource.WIKI,root/html604/ROOT__Math__VavilovFast.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovFast.html
https://root.cern/root/html604/ROOT__Math__VavilovFast.html:5128,Modifiability,Inherit,Inherited,5128,"pa, double beta2); virtual doubleQuantile(double z) const; virtual doubleQuantile(double z, double kappa, double beta2); virtual doubleQuantile_c(double z) const; virtual doubleQuantile_c(double z, double kappa, double beta2); virtual voidSetKappaBeta2(double kappa, double beta2); virtual doubleROOT::Math::Vavilov::Skewness() const; static doubleROOT::Math::Vavilov::Skewness(double kappa, double beta2); virtual doubleROOT::Math::Vavilov::Variance() const; static doubleROOT::Math::Vavilov::Variance(double kappa, double beta2); ROOT::Math::VavilovROOT::Math::Vavilov::Vavilov(); ROOT::Math::VavilovROOT::Math::Vavilov::Vavilov(const ROOT::Math::Vavilov&); ROOT::Math::VavilovFastVavilovFast(const ROOT::Math::VavilovFast&); ROOT::Math::VavilovFastVavilovFast(double kappa = 1, double beta2 = 1). Data Members; private:. doublefAC[14]; doublefBeta2; doublefHC[9]; intfItype; doublefKappa; intfNpt; doublefWCM[201]; static ROOT::Math::VavilovFast*fgInstance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovFast(double kappa = 1, double beta2 = 1). Initialize an object to calculate the Vavilov distribution. @param kappa The parameter \f$\kappa\f$, which must be in the range \f$0.01 \le \kappa \le 12 \f$; @param beta2 The parameter \f$\beta^2\f$, which must be in the range \f$0 \le \beta^2 \le 1 \f$. virtual ~VavilovFast(). Destructor. double Pdf(double x) const. Evaluate the Vavilov probability density function. @param x The Landau parameter \f$x = \lambda_L\f$. double Pdf(double x, double kappa, double beta2). Evaluate the Vavilov probability density function,; and set kappa and beta2, if necessary. @param x The Landau parameter \f$x = \lambda_L\f$; @param kappa The parameter \f$\kappa\f$, which must be in the range \f$0.01 \le \kappa \le 12 \f$; @param beta2 The parameter \f$\beta^2\f$, which must be in the range \f$0 \le \beta^2 \le 1 \f$. double Cdf(double x) const. Evaluate the Vavilov cummulative probability density function.",MatchSource.WIKI,root/html604/ROOT__Math__VavilovFast.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovFast.html
https://root.cern/root/html604/ROOT__Math__VavilovFast.html:2150,Testability,log,log,2150,"er and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. For detailed description see; A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution,; <A HREF=""http://dx.doi.org/10.1016/0168-583X(90)90749-K"">Nucl. Instr. and Meth. B47 (1990) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g115/top.html"">; CERNLIB (G115)</A>. The class stores coefficients needed to calculate \f$p(\lambda; \kappa, \beta^2)\f$; for fixed values of \f$\kappa\f$ and \f$\beta^2\f$.; Changing these values is computationally expensive. The parameter \f$\kappa\f$ must be in the range \f$0.01 \le \kappa \le 12\f$. The parameter \f$\beta^2\f$ must be in the range \f$0 \le \beta^2 \le 1\f$. Average times on a Pentium Core2 Duo P8400 2.26GHz:; - 9.9us per call to SetKappaBeta2 or constructor; - 0.095us per call to Pdf, Cdf; - 3.7us per first call to Quantile after SetKappaBeta2 or constructor; - 0.137us per subsequent call to Quantile. Benno List, June 2010. @ingroup StatFunc. Function Mem",MatchSource.WIKI,root/html604/ROOT__Math__VavilovFast.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VavilovFast.html
https://root.cern/root/html604/ROOT__Math__VegasParameters.html:1022,Modifiability,Inherit,Inheritance,1022,". ROOT::Math::VegasParameters. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::VegasParameters. class ROOT::Math::VegasParameters. Function Members (Methods); public:. ~VegasParameters(); ROOT::Math::IOptions*operator()() const; ROOT::Math::VegasParameters&operator=(const ROOT::Math::IOptions& opt); ROOT::Math::VegasParameters&operator=(const ROOT::Math::VegasParameters&); ROOT::Math::VegasParameters&operator=(ROOT::Math::VegasParameters&&); voidSetDefaultValues(); ROOT::Math::VegasParametersVegasParameters(); ROOT::Math::VegasParametersVegasParameters(const ROOT::Math::IOptions& opt); ROOT::Math::VegasParametersVegasParameters(const ROOT::Math::VegasParameters&); ROOT::Math::VegasParametersVegasParameters(ROOT::Math::VegasParameters&&). Data Members; public:. doublealpha; size_titerations; intmode; intstage; intverbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VegasParameters(); constructor of default parameters. { SetDefaultValues(); }. VegasParameters(const ROOT::Math::IOptions& opt); construct from GenAlgoOptions; parameter not specified are ignored. void SetDefaultValues(). VegasParameters & operator=(const ROOT::Math::IOptions& opt). ROOT::Math::IOptions * operator()() const; convert to options (return object is managed by the user). MiserParameters & operator=(const ROOT::Math::IOptions& opt). » Author: Magdalena Slawinska 08/2007 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VegasParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VegasParameters.html
https://root.cern/root/html604/ROOT__Math__VegasParameters.html:1035,Modifiability,Inherit,Inherited,1035,". ROOT::Math::VegasParameters. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::VegasParameters. class ROOT::Math::VegasParameters. Function Members (Methods); public:. ~VegasParameters(); ROOT::Math::IOptions*operator()() const; ROOT::Math::VegasParameters&operator=(const ROOT::Math::IOptions& opt); ROOT::Math::VegasParameters&operator=(const ROOT::Math::VegasParameters&); ROOT::Math::VegasParameters&operator=(ROOT::Math::VegasParameters&&); voidSetDefaultValues(); ROOT::Math::VegasParametersVegasParameters(); ROOT::Math::VegasParametersVegasParameters(const ROOT::Math::IOptions& opt); ROOT::Math::VegasParametersVegasParameters(const ROOT::Math::VegasParameters&); ROOT::Math::VegasParametersVegasParameters(ROOT::Math::VegasParameters&&). Data Members; public:. doublealpha; size_titerations; intmode; intstage; intverbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VegasParameters(); constructor of default parameters. { SetDefaultValues(); }. VegasParameters(const ROOT::Math::IOptions& opt); construct from GenAlgoOptions; parameter not specified are ignored. void SetDefaultValues(). VegasParameters & operator=(const ROOT::Math::IOptions& opt). ROOT::Math::IOptions * operator()() const; convert to options (return object is managed by the user). MiserParameters & operator=(const ROOT::Math::IOptions& opt). » Author: Magdalena Slawinska 08/2007 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VegasParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VegasParameters.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:1121,Availability,avail,available,1121,"er file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. i",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:1792,Availability,Error,Error,1792,"ived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return -1; }. » Author: Magdalena Slawinska 10/2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:1855,Availability,Error,Error,1855,"ived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return -1; }. » Author: Magdalena Slawinska 10/2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:1944,Availability,Error,Error,1944,"ived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return -1; }. » Author: Magdalena Slawinska 10/2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:1995,Availability,Error,Error,1995,"ived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return -1; }. » Author: Magdalena Slawinska 10/2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:2066,Availability,Error,Error,2066,"ived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return -1; }. » Author: Magdalena Slawinska 10/2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:345,Deployability,integrat,integration,345,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:442,Deployability,integrat,integrator,442,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:573,Deployability,integrat,integration,573,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:673,Deployability,integrat,integration,673,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:912,Deployability,Integrat,IntegratorOneDim,912,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:945,Deployability,Integrat,IntegratorMultiDim,945,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:974,Deployability,Integrat,Integration,974,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:2203,Deployability,integrat,integrator,2203,"ived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return -1; }. » Author: Magdalena Slawinska 10/2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:345,Integrability,integrat,integration,345,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:385,Integrability,Interface,Interface,385,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:442,Integrability,integrat,integrator,442,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:573,Integrability,integrat,integration,573,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:673,Integrability,integrat,integration,673,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:912,Integrability,Integrat,IntegratorOneDim,912,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:945,Integrability,Integrat,IntegratorMultiDim,945,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:974,Integrability,Integrat,Integration,974,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:2203,Integrability,integrat,integrator,2203,"ived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return -1; }. » Author: Magdalena Slawinska 10/2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:816,Modifiability,plug-in,plug-in,816,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:1599,Modifiability,Inherit,Inheritance,1599,"ived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return -1; }. » Author: Magdalena Slawinska 10/2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html:1612,Modifiability,Inherit,Inherited,1612,"ived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const; ROOT::Math::VirtualIntegratorVirtualIntegrator(); ROOT::Math::VirtualIntegratorVirtualIntegrator(const ROOT::Math::VirtualIntegrator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return -1; }. » Author: Magdalena Slawinska 10/2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegrator.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:1183,Availability,avail,available,1183,"n; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::IntegrationMultiDim::TypeType() const; ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(); ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::Vi",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:1299,Availability,Error,Error,1299,"; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::IntegrationMultiDim::TypeType() const; ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(); ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(const ROOT::Math::VirtualIntegrator&); ROOT::Math::VirtualIntegratorMultiDimVirtualIntegratorMultiDim(); ROOT::Math::VirtualIntegratorMultiDimVirtualIntegratorMultiDim(const ROOT::Math::VirtualIntegratorMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double Integral(const double* , const double* ); evaluate integral. void SetFunction(const ROOT::Math::IMultiGenFunction& ); set integration function. return Options(). void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options; (should be re-implemented by derived classes -if more option",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:2818,Availability,toler,tolerance,2818,"l~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::IntegrationMultiDim::TypeType() const; ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(); ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(const ROOT::Math::VirtualIntegrator&); ROOT::Math::VirtualIntegratorMultiDimVirtualIntegratorMultiDim(); ROOT::Math::VirtualIntegratorMultiDimVirtualIntegratorMultiDim(const ROOT::Math::VirtualIntegratorMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double Integral(const double* , const double* ); evaluate integral. void SetFunction(const ROOT::Math::IMultiGenFunction& ); set integration function. return Options(). void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options; (should be re-implemented by derived classes -if more options than tolerance exist. virtual ~VirtualIntegratorMultiDim(); destructor: no operation. {}. » Author: Magdalena Slawinska 10/2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:407,Deployability,integrat,integration,407,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:504,Deployability,integrat,integrator,504,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:635,Deployability,integrat,integration,635,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:735,Deployability,integrat,integration,735,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:974,Deployability,Integrat,IntegratorOneDim,974,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:1007,Deployability,Integrat,IntegratorMultiDim,1007,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:1036,Deployability,Integrat,Integration,1036,"im. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::IntegrationMultiDim::TypeType() const; ROOT",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:1540,Deployability,Integrat,IntegratorMultiDimOptionsOptions,1540,"; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::IntegrationMultiDim::TypeType() const; ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(); ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(const ROOT::Math::VirtualIntegrator&); ROOT::Math::VirtualIntegratorMultiDimVirtualIntegratorMultiDim(); ROOT::Math::VirtualIntegratorMultiDimVirtualIntegratorMultiDim(const ROOT::Math::VirtualIntegratorMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double Integral(const double* , const double* ); evaluate integral. void SetFunction(const ROOT::Math::IMultiGenFunction& ); set integration function. return Options(). void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options; (should be re-implemented by derived classes -if more option",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:1815,Deployability,Integrat,IntegratorMultiDimOptions,1815,"; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::IntegrationMultiDim::TypeType() const; ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(); ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(const ROOT::Math::VirtualIntegrator&); ROOT::Math::VirtualIntegratorMultiDimVirtualIntegratorMultiDim(); ROOT::Math::VirtualIntegratorMultiDimVirtualIntegratorMultiDim(const ROOT::Math::VirtualIntegratorMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double Integral(const double* , const double* ); evaluate integral. void SetFunction(const ROOT::Math::IMultiGenFunction& ); set integration function. return Options(). void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options; (should be re-implemented by derived classes -if more option",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:1994,Deployability,Integrat,IntegrationMultiDim,1994,"; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::IntegrationMultiDim::TypeType() const; ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(); ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(const ROOT::Math::VirtualIntegrator&); ROOT::Math::VirtualIntegratorMultiDimVirtualIntegratorMultiDim(); ROOT::Math::VirtualIntegratorMultiDimVirtualIntegratorMultiDim(const ROOT::Math::VirtualIntegratorMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double Integral(const double* , const double* ); evaluate integral. void SetFunction(const ROOT::Math::IMultiGenFunction& ); set integration function. return Options(). void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options; (should be re-implemented by derived classes -if more option",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:2627,Deployability,integrat,integration,2627,"l~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::IntegrationMultiDim::TypeType() const; ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(); ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(const ROOT::Math::VirtualIntegrator&); ROOT::Math::VirtualIntegratorMultiDimVirtualIntegratorMultiDim(); ROOT::Math::VirtualIntegratorMultiDimVirtualIntegratorMultiDim(const ROOT::Math::VirtualIntegratorMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double Integral(const double* , const double* ); evaluate integral. void SetFunction(const ROOT::Math::IMultiGenFunction& ); set integration function. return Options(). void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options; (should be re-implemented by derived classes -if more options than tolerance exist. virtual ~VirtualIntegratorMultiDim(); destructor: no operation. {}. » Author: Magdalena Slawinska 10/2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:2701,Deployability,Integrat,IntegratorMultiDimOptions,2701,"l~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::IntegrationMultiDim::TypeType() const; ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(); ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(const ROOT::Math::VirtualIntegrator&); ROOT::Math::VirtualIntegratorMultiDimVirtualIntegratorMultiDim(); ROOT::Math::VirtualIntegratorMultiDimVirtualIntegratorMultiDim(const ROOT::Math::VirtualIntegratorMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double Integral(const double* , const double* ); evaluate integral. void SetFunction(const ROOT::Math::IMultiGenFunction& ); set integration function. return Options(). void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options; (should be re-implemented by derived classes -if more options than tolerance exist. virtual ~VirtualIntegratorMultiDim(); destructor: no operation. {}. » Author: Magdalena Slawinska 10/2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:407,Integrability,integrat,integration,407,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:447,Integrability,Interface,Interface,447,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:504,Integrability,integrat,integrator,504,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:635,Integrability,integrat,integration,635,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:735,Integrability,integrat,integration,735,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:974,Integrability,Integrat,IntegratorOneDim,974,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:1007,Integrability,Integrat,IntegratorMultiDim,1007,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html:1036,Integrability,Integrat,Integration,1036,"im. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::IntegrationMultiDim::TypeType() const; ROOT",MatchSource.WIKI,root/html604/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/ROOT__Math__VirtualIntegratorMultiDim.html
