id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/qutip/qutip/tree/v5.0.4/setup.py:215,Deployability,release,release,215,"""""""; Determine all runtime options, returning a dictionary of the results. The; keys are:; 'rootdir': str; The root directory of the setup. Almost certainly the directory; that this setup.py file is contained in.; 'release': bool; Is this a release build (True) or a local development build (False); 'openmp': bool; Should we build our OpenMP extensions and attempt to link in OpenMP; libraries? (Not supported in this version.); 'cflags': list of str; Flags to be passed to the C++ compiler.; 'ldflags': list of str; Flags to be passed to the linker.; 'include': list of str; Additional directories to be added to the header files include; path. These files will be detected by Cython as dependencies, so; changes to them will trigger recompilation of .pyx files, whereas; includes added in 'cflags' as '-I/path/to/include' may not.; """"""",MatchSource.CODE_COMMENT,setup.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py
https://github.com/qutip/qutip/tree/v5.0.4/setup.py:241,Deployability,release,release,241,"""""""; Determine all runtime options, returning a dictionary of the results. The; keys are:; 'rootdir': str; The root directory of the setup. Almost certainly the directory; that this setup.py file is contained in.; 'release': bool; Is this a release build (True) or a local development build (False); 'openmp': bool; Should we build our OpenMP extensions and attempt to link in OpenMP; libraries? (Not supported in this version.); 'cflags': list of str; Flags to be passed to the C++ compiler.; 'ldflags': list of str; Flags to be passed to the linker.; 'include': list of str; Additional directories to be added to the header files include; path. These files will be detected by Cython as dependencies, so; changes to them will trigger recompilation of .pyx files, whereas; includes added in 'cflags' as '-I/path/to/include' may not.; """"""",MatchSource.CODE_COMMENT,setup.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py
https://github.com/qutip/qutip/tree/v5.0.4/setup.py:689,Integrability,depend,dependencies,689,"""""""; Determine all runtime options, returning a dictionary of the results. The; keys are:; 'rootdir': str; The root directory of the setup. Almost certainly the directory; that this setup.py file is contained in.; 'release': bool; Is this a release build (True) or a local development build (False); 'openmp': bool; Should we build our OpenMP extensions and attempt to link in OpenMP; libraries? (Not supported in this version.); 'cflags': list of str; Flags to be passed to the C++ compiler.; 'ldflags': list of str; Flags to be passed to the linker.; 'include': list of str; Additional directories to be added to the header files include; path. These files will be detected by Cython as dependencies, so; changes to them will trigger recompilation of .pyx files, whereas; includes added in 'cflags' as '-I/path/to/include' may not.; """"""",MatchSource.CODE_COMMENT,setup.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py
https://github.com/qutip/qutip/tree/v5.0.4/setup.py:667,Safety,detect,detected,667,"""""""; Determine all runtime options, returning a dictionary of the results. The; keys are:; 'rootdir': str; The root directory of the setup. Almost certainly the directory; that this setup.py file is contained in.; 'release': bool; Is this a release build (True) or a local development build (False); 'openmp': bool; Should we build our OpenMP extensions and attempt to link in OpenMP; libraries? (Not supported in this version.); 'cflags': list of str; Flags to be passed to the C++ compiler.; 'ldflags': list of str; Flags to be passed to the linker.; 'include': list of str; Additional directories to be added to the header files include; path. These files will be detected by Cython as dependencies, so; changes to them will trigger recompilation of .pyx files, whereas; includes added in 'cflags' as '-I/path/to/include' may not.; """"""",MatchSource.CODE_COMMENT,setup.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py
https://github.com/qutip/qutip/tree/v5.0.4/setup.py:46,Modifiability,variab,variable,46,"""""""; Get a boolean value from the environment variable `var`. This evalutes to; `default` if the environment variable is not present. The false-y values; are '0', 'false', 'none' and empty string, insensitive to case. All other; values are truth-y.; """"""",MatchSource.CODE_COMMENT,setup.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py
https://github.com/qutip/qutip/tree/v5.0.4/setup.py:109,Modifiability,variab,variable,109,"""""""; Get a boolean value from the environment variable `var`. This evalutes to; `default` if the environment variable is not present. The false-y values; are '0', 'false', 'none' and empty string, insensitive to case. All other; values are truth-y.; """"""",MatchSource.CODE_COMMENT,setup.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py
https://github.com/qutip/qutip/tree/v5.0.4/setup.py:107,Modifiability,variab,variables,107,"""""""; Add the 'openmp' option to the collection, based on the passed command-line; arguments or environment variables. If using PEP517 builds, one can pass these options on the command-line; using, for example:. python -m build \; --wheel \; --config-setting=""--global-option=--with-openmp""; """"""",MatchSource.CODE_COMMENT,setup.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py
https://github.com/qutip/qutip/tree/v5.0.4/setup.py:243,Modifiability,config,config-setting,243,"""""""; Add the 'openmp' option to the collection, based on the passed command-line; arguments or environment variables. If using PEP517 builds, one can pass these options on the command-line; using, for example:. python -m build \; --wheel \; --config-setting=""--global-option=--with-openmp""; """"""",MatchSource.CODE_COMMENT,setup.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py
https://github.com/qutip/qutip/tree/v5.0.4/setup.py:45,Modifiability,variab,variable,45,"# Remove -Wstrict-prototypes from the CFLAGS variable that the Python build; # process uses in addition to user-specified ones; the flag is not valid; # for C++ compiles, but CFLAGS gets appended to those compiles anyway.",MatchSource.CODE_COMMENT,setup.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py
https://github.com/qutip/qutip/tree/v5.0.4/setup.py:46,Deployability,release,release,46,"""""""; Adds the 'short_version', 'version' and 'release' options. Read from the VERSION file to discover the version. This should be a; single line file containing valid Python package public identifier (see PEP; 440), for example; 4.5.2rc2; 5.0.0; 5.1.1a1; We do that here rather than in setup.cfg so we can apply the local; versioning number as well.; """"""",MatchSource.CODE_COMMENT,setup.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py
https://github.com/qutip/qutip/tree/v5.0.4/setup.py:225,Availability,error,error,225,"# CalledProcessError is for if the git command fails for internal; # reasons (e.g. we're not in a git repository), OSError is for if; # something goes wrong when trying to run git (e.g. it's not installed,; # or a permission error).",MatchSource.CODE_COMMENT,setup.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py
https://github.com/qutip/qutip/tree/v5.0.4/setup.py:195,Deployability,install,installed,195,"# CalledProcessError is for if the git command fails for internal; # reasons (e.g. we're not in a git repository), OSError is for if; # something goes wrong when trying to run git (e.g. it's not installed,; # or a permission error).",MatchSource.CODE_COMMENT,setup.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py
https://github.com/qutip/qutip/tree/v5.0.4/setup.py:237,Availability,error,error,237,"# In development (at least for QuTiP ~4.5 and ~5.0) sometimes the; # Cythonised time-dependent coefficients would get dropped in the; # qutip directory if you weren't careful - this is just trying to; # minimise the occasional developer error.",MatchSource.CODE_COMMENT,setup.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py
https://github.com/qutip/qutip/tree/v5.0.4/setup.py:85,Integrability,depend,dependent,85,"# In development (at least for QuTiP ~4.5 and ~5.0) sometimes the; # Cythonised time-dependent coefficients would get dropped in the; # qutip directory if you weren't careful - this is just trying to; # minimise the occasional developer error.",MatchSource.CODE_COMMENT,setup.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:13,Deployability,configurat,configuration,13,"# -- General configuration ------------------------------------------------; # If your documentation needs a minimal Sphinx version, state it here.; #",MatchSource.CODE_COMMENT,doc/conf.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:13,Modifiability,config,configuration,13,"# -- General configuration ------------------------------------------------; # If your documentation needs a minimal Sphinx version, state it here.; #",MatchSource.CODE_COMMENT,doc/conf.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:97,Deployability,release,release,97,"# The version info for the project you're documenting, acts as replacement for; # |version| and |release|, also used in various other places throughout the; # built documents.; # The full version, including alpha/beta/rc tags.",MatchSource.CODE_COMMENT,doc/conf.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:112,Availability,avail,available,112,"# Theme options are theme-specific and customize the look and feel of a theme; # further. For a list of options available for each theme, see the; # documentation.",MatchSource.CODE_COMMENT,doc/conf.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:163,Deployability,release,release,163,"# Add any paths that contain custom themes here, relative to this directory.; # The name for this set of Sphinx documents. If None, it defaults to; # ""<project> v<release> documentation"".",MatchSource.CODE_COMMENT,doc/conf.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:21,Deployability,update,updated,21,"# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,; # using the given strftime format.",MatchSource.CODE_COMMENT,doc/conf.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:95,Performance,load,loads,95,"# -- Configure MathJax for maths output in HTML targets; # Currently (2021-04-10) Sphinx 3.5.3 loads MathJax 2.7, which does not have; # support for the 'physics' package. MathJax 3 does, so once Sphinx is using; # that (should be in Sphinx 4), you will be able to swap to using that. In the; # meantime, we just have to define all the functions we're going to use.; #; # See:; # - https://docs.mathjax.org/en/v3.0-latest/input/tex/extensions/physics.html",MatchSource.CODE_COMMENT,doc/conf.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:2,Deployability,configurat,configuration,2,"# configuration declares the location of the examples directory for; # Sphinx Gallery",MatchSource.CODE_COMMENT,doc/conf.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:2,Modifiability,config,configuration,2,"# configuration declares the location of the examples directory for; # Sphinx Gallery",MatchSource.CODE_COMMENT,doc/conf.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:2,Safety,abort,abort,2,"# abort if exception occurs",MatchSource.CODE_COMMENT,doc/conf.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/qpt.py:30,Safety,avoid,avoid,30,"# make small numbers real, to avoid random colors",MatchSource.CODE_COMMENT,doc/contrib/qpt.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/qpt.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:68,Availability,error,error,68,"'''; Code for simulating secure key rate, twofolds, and quantum bit error rate; Written in Python and QuTIP by Catherine Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:25,Security,secur,secure,25,"'''; Code for simulating secure key rate, twofolds, and quantum bit error rate; Written in Python and QuTIP by Catherine Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:44,Safety,detect,detector,44,"""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:13,Safety,detect,detector,13,"""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:181,Safety,detect,detectors,181,"""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:426,Safety,detect,detection,426,"""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:61,Safety,detect,detection,61,"#APD (Bucket Detector) un_detector (=gives probability for 0-detection)",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:36,Safety,detect,detector,36,"#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:62,Safety,detect,detector,62,"#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:43,Deployability,configurat,configurations,43,"#expectation values for different detector configurations",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:43,Modifiability,config,configurations,43,"#expectation values for different detector configurations",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:34,Safety,detect,detector,34,"#expectation values for different detector configurations",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:854,Availability,error,error,854,"""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:154,Energy Efficiency,power,power,154,"""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:387,Safety,detect,detection,387,"""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:448,Safety,detect,detection,448,"""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:666,Safety,detect,detection,666,"""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:802,Security,secur,secure,802,"""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:8,Safety,detect,detectors,8,"# model detectors",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:9,Safety,detect,detection,9,"#measure detection probabilities",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:30,Safety,detect,detection,30,"#Determine QBER from returned detection probabilities",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:11,Availability,error,error,11,"# estimate error correction efficiency from the CASCADE algorithm ",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:1,Security,secur,security,1,"#security analysis - calculate skr in infinite key limit; #See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; #to understand where this equation comes from",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:73,Availability,error,error,73,"#Lets look at what happens to the secure key rate and ; #the quantum bit error rate as the loss gets worse.; #Analogous to distance with fiber optic links.; #define the fock space",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:34,Security,secur,secure,34,"#Lets look at what happens to the secure key rate and ; #the quantum bit error rate as the loss gets worse.; #Analogous to distance with fiber optic links.; #define the fock space",MatchSource.CODE_COMMENT,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/ex_bloch_animation.py:2,Modifiability,evolve,evolve,2,"# evolve and calculate expectation values",MatchSource.CODE_COMMENT,doc/guide/scripts/ex_bloch_animation.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/ex_bloch_animation.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/ex_steady.py:2,Modifiability,coupling,coupling,2,"# coupling to oscillator; # collapse operators",MatchSource.CODE_COMMENT,doc/guide/scripts/ex_steady.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/ex_steady.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/floquet_ex1.py:41,Integrability,depend,dependent,41,"# Create the floquet system for the time-dependent hamiltonian",MatchSource.CODE_COMMENT,doc/guide/scripts/floquet_ex1.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/floquet_ex1.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/floquet_ex2.py:38,Integrability,depend,dependent,38,"# find the floquet modes for the time-dependent hamiltonian",MatchSource.CODE_COMMENT,doc/guide/scripts/floquet_ex2.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/floquet_ex2.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/floquet_ex3.py:8,Energy Efficiency,power,power,8,"# noise power spectrum",MatchSource.CODE_COMMENT,doc/guide/scripts/floquet_ex3.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/floquet_ex3.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/spectrum_ex1.py:2,Modifiability,coupling,coupling,2,"# coupling strength",MatchSource.CODE_COMMENT,doc/guide/scripts/spectrum_ex1.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/spectrum_ex1.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/spectrum_ex1.py:16,Energy Efficiency,power,power,16,"# calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default)",MatchSource.CODE_COMMENT,doc/guide/scripts/spectrum_ex1.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/spectrum_ex1.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py:292,Security,access,access,292,"# This script currently relies on all packages being imported by the; # import qutip; # command. If in the future some packages are not imported, then you'll need; # to add more import lines below it to make sure they're all in. We do this; # rather than file-based discovery so we have more access to information; # included by the import system, such as which names are meant to be public.; # It also means that we can import Cythonised modules to investigate their; # internals as well.",MatchSource.CODE_COMMENT,doc/QuTiP_tree_plot/qutip-structure.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py:337,Modifiability,inherit,inherit,337,"# This list needs to populated manually at the moment. Each element of the; # list is a two-tuple (colour, modules), where the `colour` is the text colour; # in the output, and `modules` is a set of module names that will be that; # colour. You can also put package names into the set of modules---any; # submodules of that package will inherit the same colour. You don't need to; # include the ""qutip."" prefix to the modules. It's a list not a dictionary; # because the order is important to the output.",MatchSource.CODE_COMMENT,doc/QuTiP_tree_plot/qutip-structure.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py:86,Safety,detect,detected,86,"# Set of modules that we don't want to include in the output. Any modules that; # are detected inside `qutip` but are not either in this set or the; # `module_groups` list will generate a warning when the script is run.",MatchSource.CODE_COMMENT,doc/QuTiP_tree_plot/qutip-structure.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py:17,Security,access,access,17,"""""""; Recursively access every accessible element of the given module, building; up a complete tree structure where the keys are the parts of the module; name, and the eventual leaves are public functions and classes defined in; that particular module (so ignoring any names that leak in from other; imports). For example,; >>> import qutip; >>> python_object_tree(qutip); {; ""mesolve"" : {; ""mesolve"": <function qutip.mesolve.mesolve(...)>,; },; ...; }; """"""",MatchSource.CODE_COMMENT,doc/QuTiP_tree_plot/qutip-structure.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py:30,Security,access,accessible,30,"""""""; Recursively access every accessible element of the given module, building; up a complete tree structure where the keys are the parts of the module; name, and the eventual leaves are public functions and classes defined in; that particular module (so ignoring any names that leak in from other; imports). For example,; >>> import qutip; >>> python_object_tree(qutip); {; ""mesolve"" : {; ""mesolve"": <function qutip.mesolve.mesolve(...)>,; },; ...; }; """"""",MatchSource.CODE_COMMENT,doc/QuTiP_tree_plot/qutip-structure.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py
https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py:184,Security,access,accessible,184,"# Also do our parent package, if we have one. In theory it's possible to; # get into a situation with packages and overzealous use of ""del"" in init; # scripts where a submodule may be accessible but its parent isn't.",MatchSource.CODE_COMMENT,doc/QuTiP_tree_plot/qutip-structure.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/about.py:53,Integrability,depend,dependencies,53,"""""""; Command line output of information on QuTiP and dependencies.; """"""",MatchSource.CODE_COMMENT,qutip/about.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/about.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/animation.py:369,Energy Efficiency,green,green,369,"""""""; Animation of the Fock distribution for a density matrix (or ket); that describes an oscillator mode. Parameters; ----------; rhos : :class:`.Result` or list of :class:`.Qobj`; The density matrix (or ket) of the state to visualize. fock_numbers : list of strings, optional; list of x ticklabels to represent fock numbers. color : color or list of colors, default: ""green""; The colors of the bar faces. unit_y_range : bool, default: True; Set y-axis limits [0, 1] or not. fig : a matplotlib Figure instance, optional; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance, optional; The axes context in which the plot will be drawn. Returns; -------; fig, ani : tuple; A tuple of the matplotlib figure and the animation instance; used to produce the figure.; """"""",MatchSource.CODE_COMMENT,qutip/animation.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/animation.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/animation.py:1862,Security,access,access,1862,"""""""; Animation of Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension. Allows to see entanglement between first; 2k particles and the rest. .. note::. colorblind_safe does not apply because of its unique colormap. Parameters; ----------; kets : :class:`.Result` or list of :class:`.Qobj`; Pure states for animation. theme : str {'light', 'dark'}, default: 'light'; Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : str {'pairs', 'pairs_skewed', 'before_after'}, default: 'pairs'; Type of Qubism plotting. Options:. - 'pairs' - typical coordinates,; - 'pairs_skewed' - for ferromagnetic/antriferromagnetic plots,; - 'before_after' - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int, default: 1; Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int or 'grid_iteration' or 'all', default: 0; Show labels for first ``2*legend_iteration`` particles. Option; 'grid_iteration' sets the same number of particles as for; grid_iteration. Option 'all' makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance, optional; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance, optional; The axis context in which the plot will be drawn. Returns; -------; fig, ani : tuple; A tuple of the matplotlib figure and the animation instance; used to produce the figure. Notes; -----; See also [1]_. References; ----------; .. [1] J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein; and G. Sierra, *Qubism: self-similar visualization of many-body; wavefunctions*, `New J. Phys. 14 053028; <https://dx.doi.org/10.1088/1367-2630/14/5/053028>`_, arXiv:1112.3560; (2012), open access.; """"""",MatchSource.CODE_COMMENT,qutip/animation.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/animation.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py:48,Usability,simpl,simple,48,"# Style of Bloch vectors, default = '-\|>' (or 'simple')",MatchSource.CODE_COMMENT,qutip/bloch.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py:6,Modifiability,variab,variable,6,"# Old variable used in V4 to customise the color of the points",MatchSource.CODE_COMMENT,qutip/bloch.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py:44,Safety,avoid,avoid,44,"# We immediately close the inline figure do avoid displaying; # the figure twice when .show() calls display.",MatchSource.CODE_COMMENT,qutip/bloch.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py:13,Deployability,update,update,13,"# Trigger an update of the Bloch sphere if it is already shown:",MatchSource.CODE_COMMENT,qutip/bloch.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py:426,Usability,simpl,simplest,426,"""""""; Display Bloch sphere and corresponding data sets. Notes; -----. When using inline plotting in Jupyter notebooks, any figure created; in a notebook cell is displayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; ``b = Bloch(..., fig=fig)`` and then call ``b.show()`` in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call ``.show()``; in the cell you create the figure in.; """"""",MatchSource.CODE_COMMENT,qutip/bloch.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py:14,Modifiability,variab,variable,14,"# Conditional variable for first argument to savefig; # that is set in subsequent if-elses",MatchSource.CODE_COMMENT,qutip/bloch.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/continuous_variables.py:65,Deployability,continuous,continuous,65,"""""""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """"""",MatchSource.CODE_COMMENT,qutip/continuous_variables.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/continuous_variables.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/continuous_variables.py:76,Modifiability,variab,variable,76,"""""""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """"""",MatchSource.CODE_COMMENT,qutip/continuous_variables.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/continuous_variables.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/continuous_variables.py:20,Testability,log,logarithmic,20,"""""""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : ndarray; The covariance matrix. g : float, default: sqrt(2); Scaling factor for ``a = 0.5 * g * (x + iy)``, default ``g = sqrt(2)``.; The value of ``g`` is related to the value of ``hbar`` in the; commutation relation ``[x, y] = i * hbar`` via ``hbar=2/g ** 2`` giving; the default value ``hbar=1``. Returns; -------. N : float; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""",MatchSource.CODE_COMMENT,qutip/continuous_variables.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/continuous_variables.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/continuous_variables.py:614,Testability,log,logarithmic,614,"""""""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : ndarray; The covariance matrix. g : float, default: sqrt(2); Scaling factor for ``a = 0.5 * g * (x + iy)``, default ``g = sqrt(2)``.; The value of ``g`` is related to the value of ``hbar`` in the; commutation relation ``[x, y] = i * hbar`` via ``hbar=2/g ** 2`` giving; the default value ``hbar=1``. Returns; -------. N : float; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""",MatchSource.CODE_COMMENT,qutip/continuous_variables.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/continuous_variables.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/distributions.py:57,Integrability,depend,depending,57,"""""""; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution. Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,. ax : matplotlib Axes instance; If given, render the visualization using this axis instance. figsize : tuple; Size of the new Figure instance, if one needs to be created. colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations. style : string; Type of visualization: 'colormap' (default) or 'surface'. Returns; -------. fig, ax : tuple; A tuple of matplotlib figure and axes instances. """"""",MatchSource.CODE_COMMENT,qutip/distributions.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/distributions.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/distributions.py:129,Energy Efficiency,reduce,reduced,129,"""""""; Calculate the marginal distribution function along the dimension; `dim`. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns; -------. d : Distributions; A new instances of Distribution that describes the marginal; distribution. """"""",MatchSource.CODE_COMMENT,qutip/distributions.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/distributions.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/distributions.py:144,Energy Efficiency,reduce,reduced-dimensionality,144,"""""""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""",MatchSource.CODE_COMMENT,qutip/distributions.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/distributions.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:132,Testability,log,logarithm,132,"""""""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e, 2}, default: e; Base of logarithm.; sparse : bool, default: False; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""",MatchSource.CODE_COMMENT,qutip/entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:19,Performance,concurren,concurrence,19,"""""""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] `https://en.wikipedia.org/wiki/Concurrence_(quantum_computing)`. """"""",MatchSource.CODE_COMMENT,qutip/entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:9,Safety,avoid,avoid,9,"# abs to avoid problems with sqrt for very small negative numbers",MatchSource.CODE_COMMENT,qutip/entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:38,Testability,log,logarithm,38,"# Return the negativity value (or its logarithm if specified)",MatchSource.CODE_COMMENT,qutip/entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:380,Testability,log,logarithm,380,"""""""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e, 2}, default: e; Base of logarithm.; sparse : bool, default: False; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""",MatchSource.CODE_COMMENT,qutip/entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:555,Safety,detect,detect,555,"""""""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e, 2}, default: e; Base of logarithm. Defaults to e.; sparse : bool, default: False; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float, default: 1e-12; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""",MatchSource.CODE_COMMENT,qutip/entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:342,Testability,log,logarithm,342,"""""""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e, 2}, default: e; Base of logarithm. Defaults to e.; sparse : bool, default: False; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float, default: 1e-12; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""",MatchSource.CODE_COMMENT,qutip/entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:1059,Testability,log,log,1059,"""""""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e, 2}, default: e; Base of logarithm. Defaults to e.; sparse : bool, default: False; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float, default: 1e-12; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""",MatchSource.CODE_COMMENT,qutip/entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:30,Testability,log,log,30,"# S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).",MatchSource.CODE_COMMENT,qutip/entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:57,Testability,log,log,57,"# S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).",MatchSource.CODE_COMMENT,qutip/entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:18,Testability,log,log,18,"# Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway",MatchSource.CODE_COMMENT,qutip/entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:93,Safety,avoid,avoid,93,"# the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.",MatchSource.CODE_COMMENT,qutip/entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:274,Testability,log,logarithm,274,"""""""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e, 2}, default: e; Base of logarithm.; sparse : bool, default: False; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""",MatchSource.CODE_COMMENT,qutip/entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:30,Energy Efficiency,power,power,30,"""""""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 2/9 for maximally entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 2/9). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """"""",MatchSource.CODE_COMMENT,qutip/entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:263,Energy Efficiency,power,power,263,"""""""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 2/9 for maximally entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 2/9). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """"""",MatchSource.CODE_COMMENT,qutip/entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/fileio.py:146,Performance,load,loaded,146,"""""""; Loads data file from file ``filename`` in current directory. Parameters; ----------; filename : str or pathlib.Path; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""",MatchSource.CODE_COMMENT,qutip/fileio.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/fileio.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:18,Integrability,rout,routines,18,"#IPython parallel routines moved to ipyparallel in V4; #IPython parallel routines not in Anaconda by default",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:73,Integrability,rout,routines,73,"#IPython parallel routines moved to ipyparallel in V4; #IPython parallel routines not in Anaconda by default",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:373,Deployability,install,install,373,"""""""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Parameters; ----------; verbose : bool, default: False; Add extra information about install location. Returns; -------; version_table: str; Return an HTML-formatted string containing version information for; QuTiP dependencies. """"""",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:75,Integrability,depend,dependencies,75,"""""""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Parameters; ----------; verbose : bool, default: False; Add extra information about install location. Returns; -------; version_table: str; Return an HTML-formatted string containing version information for; QuTiP dependencies. """"""",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:503,Integrability,depend,dependencies,503,"""""""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Parameters; ----------; verbose : bool, default: False; Add extra information about install location. Returns; -------; version_table: str; Return an HTML-formatted string containing version information for; QuTiP dependencies. """"""",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:26,Energy Efficiency,schedul,scheduling,26,"""""""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:926,Energy Efficiency,schedul,scheduling,926,"""""""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """"""",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:1281,Energy Efficiency,schedul,scheduled,1281,"""""""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """"""",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:273,Performance,load,load-balanced,273,"""""""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """"""",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:985,Performance,load,load-balanced,985,"""""""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """"""",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:1397,Usability,progress bar,progress bar,1397,"""""""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """"""",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:952,Energy Efficiency,schedul,scheduling,952,"""""""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:1307,Energy Efficiency,schedul,scheduled,1307,"""""""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:246,Performance,load,load-balanced,246,"""""""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:1011,Performance,load,load-balanced,1011,"""""""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:1423,Usability,progress bar,progress bar,1423,"""""""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:21,Availability,avail,available,21,"# make sure qutip is available at engines",MatchSource.CODE_COMMENT,qutip/ipynbtools.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/matplotlib_utilities.py:49,Modifiability,enhance,enhance,49,"""""""; This module contains utility functions that enhance Matplotlib; in one way or another.; """"""",MatchSource.CODE_COMMENT,qutip/matplotlib_utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/matplotlib_utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/matplotlib_utilities.py:68,Modifiability,variab,variables,68,"""""""; Create a cyclic colormap for representing the phase of complex variables. Returns; -------; cmap :; A matplotlib linear segmented colormap.; """"""",MatchSource.CODE_COMMENT,qutip/matplotlib_utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/matplotlib_utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/measurement.py:1277,Availability,down,down,1277,"the given state. This function simulates the classic quantum measurement described in many; introductory texts on quantum mechanics. The measurement collapses the; state to one of the eigenstates of the given operator and the result of the; measurement is the corresponding eigenvalue. Parameters; ----------; state : :class:`.Qobj`; The ket or density matrix specifying the state to measure. op : :class:`.Qobj`; The measurement operator. tol : float, optional; Smallest value for the probabilities.; Default is qutip's core settings' ``atol``. Returns; -------; measured_value : float; The result of the measurement (one of the eigenvalues of op). state : :class:`.Qobj`; The new state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""",MatchSource.CODE_COMMENT,qutip/measurement.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/measurement.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/measurement.py:1783,Availability,down,down,1783,"the given state. This function simulates the classic quantum measurement described in many; introductory texts on quantum mechanics. The measurement collapses the; state to one of the eigenstates of the given operator and the result of the; measurement is the corresponding eigenvalue. Parameters; ----------; state : :class:`.Qobj`; The ket or density matrix specifying the state to measure. op : :class:`.Qobj`; The measurement operator. tol : float, optional; Smallest value for the probabilities.; Default is qutip's core settings' ``atol``. Returns; -------; measured_value : float; The result of the measurement (one of the eigenvalues of op). state : :class:`.Qobj`; The new state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""",MatchSource.CODE_COMMENT,qutip/measurement.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/measurement.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/measurement.py:1637,Performance,perform,perform,1637,"the given state. This function simulates the classic quantum measurement described in many; introductory texts on quantum mechanics. The measurement collapses the; state to one of the eigenstates of the given operator and the result of the; measurement is the corresponding eigenvalue. Parameters; ----------; state : :class:`.Qobj`; The ket or density matrix specifying the state to measure. op : :class:`.Qobj`; The measurement operator. tol : float, optional; Smallest value for the probabilities.; Default is qutip's core settings' ``atol``. Returns; -------; measured_value : float; The result of the measurement (one of the eigenvalues of op). state : :class:`.Qobj`; The new state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""",MatchSource.CODE_COMMENT,qutip/measurement.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/measurement.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/measurement.py:1689,Performance,perform,perform,1689,"the given state. This function simulates the classic quantum measurement described in many; introductory texts on quantum mechanics. The measurement collapses the; state to one of the eigenstates of the given operator and the result of the; measurement is the corresponding eigenvalue. Parameters; ----------; state : :class:`.Qobj`; The ket or density matrix specifying the state to measure. op : :class:`.Qobj`; The measurement operator. tol : float, optional; Smallest value for the probabilities.; Default is qutip's core settings' ``atol``. Returns; -------; measured_value : float; The result of the measurement (one of the eigenvalues of op). state : :class:`.Qobj`; The new state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""",MatchSource.CODE_COMMENT,qutip/measurement.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/measurement.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py:68,Availability,mask,mask,68,"""""""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`.Qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str {""dense"", ""sparse""}, default: ""dense""; Choice of method. The ""sparse"" implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`.Qobj`; A density matrix with the selected subsystems transposed. """"""",MatchSource.CODE_COMMENT,qutip/partial_transpose.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py:210,Availability,mask,mask,210,"""""""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`.Qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str {""dense"", ""sparse""}, default: ""dense""; Choice of method. The ""sparse"" implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`.Qobj`; A density matrix with the selected subsystems transposed. """"""",MatchSource.CODE_COMMENT,qutip/partial_transpose.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py:309,Availability,mask,mask,309,"""""""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`.Qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str {""dense"", ""sparse""}, default: ""dense""; Choice of method. The ""sparse"" implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`.Qobj`; A density matrix with the selected subsystems transposed. """"""",MatchSource.CODE_COMMENT,qutip/partial_transpose.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py:501,Availability,mask,mask,501,"""""""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`.Qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str {""dense"", ""sparse""}, default: ""dense""; Choice of method. The ""sparse"" implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`.Qobj`; A density matrix with the selected subsystems transposed. """"""",MatchSource.CODE_COMMENT,qutip/partial_transpose.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py:528,Availability,mask,mask,528,"""""""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`.Qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str {""dense"", ""sparse""}, default: ""dense""; Choice of method. The ""sparse"" implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`.Qobj`; A density matrix with the selected subsystems transposed. """"""",MatchSource.CODE_COMMENT,qutip/partial_transpose.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py:83,Performance,perform,performs,83,"""""""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """"""",MatchSource.CODE_COMMENT,qutip/partial_transpose.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py:156,Testability,test,testing,156,"""""""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """"""",MatchSource.CODE_COMMENT,qutip/partial_transpose.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:72,Integrability,rout,routines,72,"""""""; Total flattened size and operator dimensions for operator creation routines; that automatically perform tensor products. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); First dimension of an operator which can create an implicit tensor; product. If the type is `int`, it is promoted first to `[dimensions]`.; From there, it should be one of the two-elements `dims` parameter of a; `qutip.Qobj` representing an `oper` or `super`, with possible tensor; products. Returns; -------; size : int; Dimension of backing matrix required to represent operator.; dimensions : list; Dimension list in the form required by ``Qobj`` creation.; """"""",MatchSource.CODE_COMMENT,qutip/random_objects.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:101,Performance,perform,perform,101,"""""""; Total flattened size and operator dimensions for operator creation routines; that automatically perform tensor products. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); First dimension of an operator which can create an implicit tensor; product. If the type is `int`, it is promoted first to `[dimensions]`.; From there, it should be one of the two-elements `dims` parameter of a; `qutip.Qobj` representing an `oper` or `super`, with possible tensor; products. Returns; -------; size : int; Dimension of backing matrix required to represent operator.; dimensions : list; Dimension list in the form required by ``Qobj`` creation.; """"""",MatchSource.CODE_COMMENT,qutip/random_objects.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:48,Usability,simpl,simplify,48,"# TODO: coo_array from sicpy 1.8 would allow to simplify this.",MatchSource.CODE_COMMENT,qutip/random_objects.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:357,Integrability,depend,depending,357,"""""""Creates a random sparse Hermitian quantum object. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. density : float, default: 0.30; Density between [0,1] of output Hermitian operator. distribution : str {""fill"", ""pos_def"", ""eigen""}, default: ""fill""; Method used to obtain the density matrices. - ""fill"" : Uses :math:`H=0.5*(X+X^{+})` where :math:`X` is a randomly; generated quantum operator with elements uniformly distributed; between ``[-1, 1] + [-1j, 1j]``.; - ""eigen"" : A density matrix with the given ``eigenvalues``. It uses; random complex Jacobi rotations to shuffle the operator.; - ""pos_def"" : Return a positive semi-definite matrix by diagonal; dominance. eigenvalues : array_like, optional; Eigenvalues of the output Hermitian matrix. The len must match the; shape of the matrix. seed : int, SeedSequence, Generator, optional; Seed to create the random number generator or a pre prepared; generator. When none is suplied, a default generator is used. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; oper : :obj:`.Qobj`; Hermitian quantum operator. Notes; -----; If given a list of eigenvalues the object is created using complex Jacobi; rotations. While this method is fast for small matrices, it should not be; repeatedly used for generating matrices larger than ~1000x1000.; """"""",MatchSource.CODE_COMMENT,qutip/random_objects.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:336,Integrability,depend,depending,336,"""""""Creates a random ket vector. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. density : float, default: 1; Density between [0,1] of output ket state when using the ``fill``; method. distribution : str {""haar"", ""fill""}, default: ""haar""; Method used to obtain the kets. - haar : Haar random pure state obtained by applying a Haar random; unitary to a fixed pure state.; - fill : Fill the ket with uniformly distributed random complex number. seed : int, SeedSequence, Generator, optional; Seed to create the random number generator or a pre prepared; generator. When none is suplied, a default generator is used. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; oper : qobj; Ket quantum state vector.; """"""",MatchSource.CODE_COMMENT,qutip/random_objects.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:385,Integrability,depend,depending,385,"""""""; Creates a random CPTP map on an N-dimensional Hilbert space in Kraus; form. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. seed : int, SeedSequence, Generator, optional; Seed to create the random number generator or a pre prepared; generator. When none is suplied, a default generator is used. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; oper_list : list of qobj; N^2 x N x N qobj operators. """"""",MatchSource.CODE_COMMENT,qutip/random_objects.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:393,Integrability,depend,depending,393,"""""""; Returns a randomly drawn superoperator acting on operators acting on; N dimensions. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. superrop : str, default: ""super""; Representation of the super operator. seed : int, SeedSequence, Generator, optional; Seed to create the random number generator or a pre prepared; generator. When none is suplied, a default generator is used. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted.; """"""",MatchSource.CODE_COMMENT,qutip/random_objects.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:100,Safety,avoid,avoid,100,"# We do the partial trace over the first index by using dense reshape; # operations, so that we can avoid bouncing to a sparse representation; # and back.",MatchSource.CODE_COMMENT,qutip/random_objects.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:345,Integrability,depend,depending,345,"""""""Generates a random stochastic matrix. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. density : float, default: 0.75; Density between [0,1] of output density matrix. kind : str {""left"", ""right""}, default: ""left""; Generate 'left' or 'right' stochastic matrix. seed : int, SeedSequence, Generator, optional; Seed to create the random number generator or a pre prepared; generator. When none is suplied, a default generator is used. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; oper : qobj; Quantum operator form of stochastic matrix.; """"""",MatchSource.CODE_COMMENT,qutip/random_objects.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:62,Availability,avail,available,62,"""""""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""",MatchSource.CODE_COMMENT,qutip/settings.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:31,Deployability,install,installation,31,""""""" Whether qutip found an mkl installation. """"""",MatchSource.CODE_COMMENT,qutip/settings.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:24,Deployability,install,installation,24,""""""" Location of the mkl installation. """"""",MatchSource.CODE_COMMENT,qutip/settings.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:28,Availability,reliab,reliable,28,"""""""; Whether `eigh` call is reliable.; Some implementation of blas have some issues on some OS.; """"""",MatchSource.CODE_COMMENT,qutip/settings.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:110,Deployability,update,updated,110,"""""""; Location in which qutip place cython string coefficient folders.; The default is ""$HOME/.qutip"".; Can be updated.; """"""",MatchSource.CODE_COMMENT,qutip/settings.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:129,Deployability,update,updated,129,"""""""; Location in which qutip save cython string coefficient files.; Usually ""{qutip.settings.tmproot}/qutip_coeffs_X.X"".; Can be updated.; """"""",MatchSource.CODE_COMMENT,qutip/settings.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:19,Safety,detect,detected,19,"""""""; Number of cpu detected.; Use the solver options to control the number of cpus used.; """"""",MatchSource.CODE_COMMENT,qutip/settings.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:79,Safety,detect,detection,79,"""""""; Define whether log handler should be:; - default: switch based on IPython detection; - stream: set up non-propagating StreamHandler; - basic: call basicConfig; - null: leave logging to the user; """"""",MatchSource.CODE_COMMENT,qutip/settings.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:20,Testability,log,log,20,"""""""; Define whether log handler should be:; - default: switch based on IPython detection; - stream: set up non-propagating StreamHandler; - basic: call basicConfig; - null: leave logging to the user; """"""",MatchSource.CODE_COMMENT,qutip/settings.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:179,Testability,log,logging,179,"""""""; Define whether log handler should be:; - default: switch based on IPython detection; - stream: set up non-propagating StreamHandler; - basic: call basicConfig; - null: leave logging to the user; """"""",MatchSource.CODE_COMMENT,qutip/settings.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/simdiag.py:347,Safety,detect,detecting,347,"""""""Simultaneous diagonalization of commuting Hermitian matrices. Parameters; ----------; ops : list, array; ``list`` or ``array`` of qobjs representing commuting Hermitian; operators. evals : bool, default: True; Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tol : float, default: 1e-14; Tolerance for detecting degenerate eigenstates. safe_mode : bool, default: True; Whether to check that all ops are Hermitian and commuting. If set to; ``False`` and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns; -------; eigs : tuple; Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. """"""",MatchSource.CODE_COMMENT,qutip/simdiag.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/simdiag.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/simdiag.py:8,Modifiability,rewrite,rewrite,8,"# TODO: rewrite using Data object",MatchSource.CODE_COMMENT,qutip/simdiag.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/simdiag.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py:13,Testability,test,test,13,"""""""; Run the test scripts for QuTiP. Parameters; ----------; full: bool; If True run all test (30 min). Otherwise skip few variants of the; slowest tests.; """"""",MatchSource.CODE_COMMENT,qutip/testing.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py:89,Testability,test,test,89,"""""""; Run the test scripts for QuTiP. Parameters; ----------; full: bool; If True run all test (30 min). Otherwise skip few variants of the; slowest tests.; """"""",MatchSource.CODE_COMMENT,qutip/testing.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py:148,Testability,test,tests,148,"""""""; Run the test scripts for QuTiP. Parameters; ----------; full: bool; If True run all test (30 min). Otherwise skip few variants of the; slowest tests.; """"""",MatchSource.CODE_COMMENT,qutip/testing.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py:50,Testability,test,tests,50,"# Call about to get all version info printed with tests",MatchSource.CODE_COMMENT,qutip/testing.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py:184,Testability,test,tested,184,"# real_num_cpu = qset.num_cpus; # real_thresh = qset.openmp_thresh; # if qset.has_openmp:; # For travis which VMs have only 1 cpu.; # Make sure the openmp version of the functions are tested.; # qset.num_cpus = 2; # qset.openmp_thresh = 100",MatchSource.CODE_COMMENT,qutip/testing.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py:7,Testability,test,tests,7,"# runs tests in qutip.tests module only; # Restore previous settings; # if qset.has_openmp:; # qset.num_cpus = real_num_cpu; # qset.openmp_thresh = real_thresh",MatchSource.CODE_COMMENT,qutip/testing.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py:22,Testability,test,tests,22,"# runs tests in qutip.tests module only; # Restore previous settings; # if qset.has_openmp:; # qset.num_cpus = real_num_cpu; # qset.openmp_thresh = real_thresh",MatchSource.CODE_COMMENT,qutip/testing.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:50,Modifiability,coupling,coupling,50,"""""""Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters; ----------; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns; -------; cg_coeff : float; Requested Clebsch-Gordan coefficient. """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,Energy Efficiency,energy,energy,16,"""""""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : str, {""J"", ""eV"", ""meV"", ""GHz"", ""mK""}, default: ""meV""; The name of the original unit. to : str, {""J"", ""eV"", ""meV"", ""GHz"", ""mK""}, default: ""GHz""; The name of the new unit. Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:105,Energy Efficiency,energy,energy,105,"""""""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : str, {""J"", ""eV"", ""meV"", ""GHz"", ""mK""}, default: ""meV""; The name of the original unit. to : str, {""J"", ""eV"", ""meV"", ""GHz"", ""mK""}, default: ""GHz""; The name of the new unit. Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:360,Energy Efficiency,energy,energy,360,"""""""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : str, {""J"", ""eV"", ""meV"", ""GHz"", ""mK""}, default: ""meV""; The name of the original unit. to : str, {""J"", ""eV"", ""meV"", ""GHz"", ""mK""}, default: ""GHz""; The name of the new unit. Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,Energy Efficiency,energy,energy,16,"""""""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:97,Energy Efficiency,energy,energy,97,"""""""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:171,Energy Efficiency,energy,energy,171,"""""""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,Energy Efficiency,energy,energy,16,"""""""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:97,Energy Efficiency,energy,energy,97,"""""""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:171,Energy Efficiency,energy,energy,171,"""""""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,Energy Efficiency,energy,energy,16,"""""""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:95,Energy Efficiency,energy,energy,95,"""""""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:169,Energy Efficiency,energy,energy,169,"""""""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,Energy Efficiency,energy,energy,16,"""""""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:95,Energy Efficiency,energy,energy,95,"""""""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:169,Energy Efficiency,energy,energy,169,"""""""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,Energy Efficiency,energy,energy,16,"""""""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:96,Energy Efficiency,energy,energy,96,"""""""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:170,Energy Efficiency,energy,energy,170,"""""""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,Energy Efficiency,energy,energy,16,"""""""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:96,Energy Efficiency,energy,energy,96,"""""""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:170,Energy Efficiency,energy,energy,170,"""""""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,Energy Efficiency,energy,energy,16,"""""""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:96,Energy Efficiency,energy,energy,96,"""""""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:170,Energy Efficiency,energy,energy,170,"""""""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,Energy Efficiency,energy,energy,16,"""""""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:96,Energy Efficiency,energy,energy,96,"""""""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:170,Energy Efficiency,energy,energy,170,"""""""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""",MatchSource.CODE_COMMENT,qutip/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:67,Deployability,patch,patching,67,"""""""; removes margins about z = 0 and improves the style; by monkey patching; """"""",MatchSource.CODE_COMMENT,qutip/visualization.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:5,Deployability,update,updates,5,"""""""; updates the y-axis; """"""",MatchSource.CODE_COMMENT,qutip/visualization.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:5,Deployability,update,updates,5,"""""""; updates the x-axis; """"""",MatchSource.CODE_COMMENT,qutip/visualization.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:5,Deployability,update,updates,5,"""""""; updates the z-axis; """"""",MatchSource.CODE_COMMENT,qutip/visualization.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:2,Deployability,update,update,2,"# update default_opts from input options",MatchSource.CODE_COMMENT,qutip/visualization.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:14,Energy Efficiency,energy,energy,14,"""""""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. h_lables : List of string, optional; A list of xticklabels for each Hamiltonian. energy_levels : List of string, optional; A list of yticklabels to the left of energy levels of the initial; Hamiltonian. N : int, default: 0; The number of energy levels to plot. fig : a matplotlib Figure instance, optional; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance, optional; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """"""",MatchSource.CODE_COMMENT,qutip/visualization.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:81,Energy Efficiency,energy,energy,81,"""""""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. h_lables : List of string, optional; A list of xticklabels for each Hamiltonian. energy_levels : List of string, optional; A list of yticklabels to the left of energy levels of the initial; Hamiltonian. N : int, default: 0; The number of energy levels to plot. fig : a matplotlib Figure instance, optional; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance, optional; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """"""",MatchSource.CODE_COMMENT,qutip/visualization.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:128,Energy Efficiency,energy,energy,128,"""""""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. h_lables : List of string, optional; A list of xticklabels for each Hamiltonian. energy_levels : List of string, optional; A list of yticklabels to the left of energy levels of the initial; Hamiltonian. N : int, default: 0; The number of energy levels to plot. fig : a matplotlib Figure instance, optional; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance, optional; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """"""",MatchSource.CODE_COMMENT,qutip/visualization.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:490,Energy Efficiency,energy,energy,490,"""""""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. h_lables : List of string, optional; A list of xticklabels for each Hamiltonian. energy_levels : List of string, optional; A list of yticklabels to the left of energy levels of the initial; Hamiltonian. N : int, default: 0; The number of energy levels to plot. fig : a matplotlib Figure instance, optional; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance, optional; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """"""",MatchSource.CODE_COMMENT,qutip/visualization.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:568,Energy Efficiency,energy,energy,568,"""""""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. h_lables : List of string, optional; A list of xticklabels for each Hamiltonian. energy_levels : List of string, optional; A list of yticklabels to the left of energy levels of the initial; Hamiltonian. N : int, default: 0; The number of energy levels to plot. fig : a matplotlib Figure instance, optional; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance, optional; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """"""",MatchSource.CODE_COMMENT,qutip/visualization.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:330,Energy Efficiency,green,green,330,"""""""; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :obj:`.Qobj`; The density matrix (or ket) of the state to visualize. fock_numbers : list of strings, optional; list of x ticklabels to represent fock numbers. color : color or list of colors, default: ""green""; The colors of the bar faces. unit_y_range : bool, default: True; Set y-axis limits [0, 1] or not. fig : a matplotlib Figure instance, optional; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance, optional; The axes context in which the plot will be drawn. Returns; -------; fig, output : tuple; A tuple of the matplotlib figure and the axes instance or animation; instance used to produce the figure.; """"""",MatchSource.CODE_COMMENT,qutip/visualization.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:1829,Security,access,access,1829,"""""""; Qubism plot for pure states of many qudits. Works best for spin chains,; especially with even number of particles of the same dimension. Allows to; see entanglement between first 2k particles and the rest. .. note::. colorblind_safe does not apply because of its unique colormap. Parameters; ----------; ket : Qobj; Pure state for plotting. theme : str {'light', 'dark'}, default: 'light'; Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : str {'pairs', 'pairs_skewed' or 'before_after'}, default: 'pairs'; Type of Qubism plotting. Options:. - 'pairs' - typical coordinates,; - 'pairs_skewed' - for ferromagnetic/antriferromagnetic plots,; - 'before_after' - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int, default: 1; Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int or 'grid_iteration' or 'all', default: 0; Show labels for first ``2*legend_iteration`` particles. Option; 'grid_iteration' sets the same number of particles as for; grid_iteration. Option 'all' makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance, optional; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance, optional; The axis context in which the plot will be drawn. Returns; -------; fig, output : tuple; A tuple of the matplotlib figure and the axes instance or animation; instance used to produce the figure. Notes; -----; See also [1]_. References; ----------; .. [1] J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein; and G. Sierra, *Qubism: self-similar visualization of many-body; wavefunctions*, `New J. Phys. 14 053028; <https://dx.doi.org/10.1088/1367-2630/14/5/053028>`_, arXiv:1112.3560; (2012), open access.; """"""",MatchSource.CODE_COMMENT,qutip/visualization.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:1014,Availability,error,errors,1014,"""""""takes the density matrix or state vector of any finite state and; generates the Wigner function for that state on a sphere, generating a spin; Wigner function useful for displaying the quasi-probability for a qubit or; any qudit. For the standard, continuous-variable Wigner function for; position and momentum variables, wigner() should be used. Parameters; ----------; psi : qobj; a state vector or density matrix.; j : int; the total angular momentum of the quantum state.; fullparity : bool; should the parity of the full SU space be used?; steps : int; number of points at which the Wigner transform is calculated.; slicearray : list of str; the angle slice to be used for each particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors. Notes; ------; See example notebook wigner_visualisation. References; ------; [1] T. Tilma, M. J. Everitt, J. H. Samson, W. J. Munro,; and K. Nemoto, Phys. Rev. Lett. 117, 180401 (2016).; [2] R. P. Rundle, P. W. Mills, T. Tilma, J. H. Samson, and; M. J. Everitt, Phys. Rev. A 96, 022117 (2017).; """"""",MatchSource.CODE_COMMENT,qutip/wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:251,Deployability,continuous,continuous-variable,251,"""""""takes the density matrix or state vector of any finite state and; generates the Wigner function for that state on a sphere, generating a spin; Wigner function useful for displaying the quasi-probability for a qubit or; any qudit. For the standard, continuous-variable Wigner function for; position and momentum variables, wigner() should be used. Parameters; ----------; psi : qobj; a state vector or density matrix.; j : int; the total angular momentum of the quantum state.; fullparity : bool; should the parity of the full SU space be used?; steps : int; number of points at which the Wigner transform is calculated.; slicearray : list of str; the angle slice to be used for each particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors. Notes; ------; See example notebook wigner_visualisation. References; ------; [1] T. Tilma, M. J. Everitt, J. H. Samson, W. J. Munro,; and K. Nemoto, Phys. Rev. Lett. 117, 180401 (2016).; [2] R. P. Rundle, P. W. Mills, T. Tilma, J. H. Samson, and; M. J. Everitt, Phys. Rev. A 96, 022117 (2017).; """"""",MatchSource.CODE_COMMENT,qutip/wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:262,Modifiability,variab,variable,262,"""""""takes the density matrix or state vector of any finite state and; generates the Wigner function for that state on a sphere, generating a spin; Wigner function useful for displaying the quasi-probability for a qubit or; any qudit. For the standard, continuous-variable Wigner function for; position and momentum variables, wigner() should be used. Parameters; ----------; psi : qobj; a state vector or density matrix.; j : int; the total angular momentum of the quantum state.; fullparity : bool; should the parity of the full SU space be used?; steps : int; number of points at which the Wigner transform is calculated.; slicearray : list of str; the angle slice to be used for each particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors. Notes; ------; See example notebook wigner_visualisation. References; ------; [1] T. Tilma, M. J. Everitt, J. H. Samson, W. J. Munro,; and K. Nemoto, Phys. Rev. Lett. 117, 180401 (2016).; [2] R. P. Rundle, P. W. Mills, T. Tilma, J. H. Samson, and; M. J. Everitt, Phys. Rev. A 96, 022117 (2017).; """"""",MatchSource.CODE_COMMENT,qutip/wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:314,Modifiability,variab,variables,314,"""""""takes the density matrix or state vector of any finite state and; generates the Wigner function for that state on a sphere, generating a spin; Wigner function useful for displaying the quasi-probability for a qubit or; any qudit. For the standard, continuous-variable Wigner function for; position and momentum variables, wigner() should be used. Parameters; ----------; psi : qobj; a state vector or density matrix.; j : int; the total angular momentum of the quantum state.; fullparity : bool; should the parity of the full SU space be used?; steps : int; number of points at which the Wigner transform is calculated.; slicearray : list of str; the angle slice to be used for each particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors. Notes; ------; See example notebook wigner_visualisation. References; ------; [1] T. Tilma, M. J. Everitt, J. H. Samson, W. J. Munro,; and K. Nemoto, Phys. Rev. Lett. 117, 180401 (2016).; [2] R. P. Rundle, P. W. Mills, T. Tilma, J. H. Samson, and; M. J. Everitt, Phys. Rev. A 96, 022117 (2017).; """"""",MatchSource.CODE_COMMENT,qutip/wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:1117,Energy Efficiency,efficient,efficient,1117,"eters; ----------. state : qobj; A state vector or density matrix. xvec : array_like; x-coordinates at which to calculate the Wigner function. yvec : array_like; y-coordinates at which to calculate the Wigner function. Does not; apply to the 'fft' method. g : float, default: sqrt(2); Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation; relation `[x, y] = i * hbar` via `hbar=2/g^2` giving the default; value `hbar=1`. method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}, default: 'clenshaw'; Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw'; and 'iterative' use an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'clenshaw' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). 'clenshaw' is a fast and numerically stable method. sparse : bool, optional; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parfor : bool, optional; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-coordinates ",MatchSource.CODE_COMMENT,qutip/wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:1615,Performance,perform,performance,1615,"vec : array_like; y-coordinates at which to calculate the Wigner function. Does not; apply to the 'fft' method. g : float, default: sqrt(2); Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation; relation `[x, y] = i * hbar` via `hbar=2/g^2` giving the default; value `hbar=1`. method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}, default: 'clenshaw'; Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw'; and 'iterative' use an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'clenshaw' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). 'clenshaw' is a fast and numerically stable method. sparse : bool, optional; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parfor : bool, optional; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally. References; ----------. Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). """"""",MatchSource.CODE_COMMENT,qutip/wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:907,Availability,toler,tolerance,907,"""""""; Internal function to compute coherent state operators corresponding to a; grid of complex values in phase space. For efficiency reasons, this class; produces the adjoint of the coherent states, to save allocations when; calculating inner products later. Examples; --------; Initialise the grid calculator. >>> xvec = yvec = np.linspace(-1, 1, 21); >>> g = np.sqrt(0.5); >>> max_ns = 10; >>> grid = _QFuncCoherentGrid(xvec, yvec, g). The naive construction of the grid is. >>> xs, ys = np.meshgrid(xvec, yvec); >>> all_alphas = 0.5 * g * (xs + 1j*ys); >>> naive = np.array([; ... [; ... qutip.coherent(max_ns, alpha, method='analytic'); ... .dag().full().ravel(); ... for alpha in x_alphas; ... ]; ... for y_alphas in all_alphas; ... ]). The naive approach is typically several of orders of magnitude slower than; this class, which uses much simpler vectorised operations. The outputs are; within close tolerance, however:. >>> np.allclose(naive, grid(max_ns)); True; >>> np.allclose(naive[:, :, 4:7], grid(4, 7)); True; """"""",MatchSource.CODE_COMMENT,qutip/wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:846,Usability,simpl,simpler,846,"""""""; Internal function to compute coherent state operators corresponding to a; grid of complex values in phase space. For efficiency reasons, this class; produces the adjoint of the coherent states, to save allocations when; calculating inner products later. Examples; --------; Initialise the grid calculator. >>> xvec = yvec = np.linspace(-1, 1, 21); >>> g = np.sqrt(0.5); >>> max_ns = 10; >>> grid = _QFuncCoherentGrid(xvec, yvec, g). The naive construction of the grid is. >>> xs, ys = np.meshgrid(xvec, yvec); >>> all_alphas = 0.5 * g * (xs + 1j*ys); >>> naive = np.array([; ... [; ... qutip.coherent(max_ns, alpha, method='analytic'); ... .dag().full().ravel(); ... for alpha in x_alphas; ... ]; ... for y_alphas in all_alphas; ... ]). The naive approach is typically several of orders of magnitude slower than; this class, which uses much simpler vectorised operations. The outputs are; within close tolerance, however:. >>> np.allclose(naive, grid(max_ns)); True; >>> np.allclose(naive[:, :, 4:7], grid(4, 7)); True; """"""",MatchSource.CODE_COMMENT,qutip/wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:23,Safety,avoid,avoid,23,"# Technically we could avoid hitting the limits of floating-point; # exponents for longer by doing all this in logarithmic space (using; # scipy.special.gammaln), but that ends up involving more; # floating-point operations overall, and needs special care around the; # point alpha = 0 to avoid nan appearing, due to how Python handles; # mixed-width arithmetic operations.",MatchSource.CODE_COMMENT,qutip/wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:289,Safety,avoid,avoid,289,"# Technically we could avoid hitting the limits of floating-point; # exponents for longer by doing all this in logarithmic space (using; # scipy.special.gammaln), but that ends up involving more; # floating-point operations overall, and needs special care around the; # point alpha = 0 to avoid nan appearing, due to how Python handles; # mixed-width arithmetic operations.",MatchSource.CODE_COMMENT,qutip/wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:111,Testability,log,logarithmic,111,"# Technically we could avoid hitting the limits of floating-point; # exponents for longer by doing all this in logarithmic space (using; # scipy.special.gammaln), but that ends up involving more; # floating-point operations overall, and needs special care around the; # point alpha = 0 to avoid nan appearing, due to how Python handles; # mixed-width arithmetic operations.",MatchSource.CODE_COMMENT,qutip/wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:37,Safety,avoid,avoid,37,"# We don't use Qobj.eigenstates() to avoid building many unnecessary; # CSR versions of dense matrices.",MatchSource.CODE_COMMENT,qutip/wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:37,Safety,avoid,avoid,37,"# We don't use Qobj.eigenstates() to avoid building many unnecessary CSR; # versions of dense matrices.",MatchSource.CODE_COMMENT,qutip/wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/__init__.py:143,Modifiability,variab,variable,143,"# -----------------------------------------------------------------------------; # Look to see if we are running with OPENMP; #; # Set environ variable to determin if running in parallel mode; # (i.e. in parfor or parallel_map)",MatchSource.CODE_COMMENT,qutip/__init__.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/__init__.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/__init__.py:139,Deployability,configurat,configuration,139,"# -----------------------------------------------------------------------------; # Check that import modules are compatible with requested configuration; #; # Check for Matplotlib",MatchSource.CODE_COMMENT,qutip/__init__.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/__init__.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/__init__.py:139,Modifiability,config,configuration,139,"# -----------------------------------------------------------------------------; # Check that import modules are compatible with requested configuration; #; # Check for Matplotlib",MatchSource.CODE_COMMENT,qutip/__init__.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/__init__.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:1586,Energy Efficiency,efficient,efficient,1586,"""""""; Calculates the Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system's coupling to its environment. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used; for array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list; List of system collapse operators. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :class:`qutip.Qobj`, tuple of :class:`qutip.Qobj`; If ``fock_basis``, return the Bloch Redfield tensor in the laboratory; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column.; """"""",MatchSource.CODE_COMMENT,qutip/core/blochredfield.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:772,Integrability,depend,depend,772,"""""""; Calculates the Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system's coupling to its environment. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used; for array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list; List of system collapse operators. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :class:`qutip.Qobj`, tuple of :class:`qutip.Qobj`; If ``fock_basis``, return the Bloch Redfield tensor in the laboratory; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column.; """"""",MatchSource.CODE_COMMENT,qutip/core/blochredfield.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:147,Modifiability,coupling,coupling,147,"""""""; Calculates the Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system's coupling to its environment. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used; for array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list; List of system collapse operators. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :class:`qutip.Qobj`, tuple of :class:`qutip.Qobj`; If ``fock_basis``, return the Bloch Redfield tensor in the laboratory; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column.; """"""",MatchSource.CODE_COMMENT,qutip/core/blochredfield.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:468,Modifiability,coupling,coupling,468,"""""""; Calculates the Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system's coupling to its environment. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used; for array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list; List of system collapse operators. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :class:`qutip.Qobj`, tuple of :class:`qutip.Qobj`; If ``fock_basis``, return the Bloch Redfield tensor in the laboratory; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column.; """"""",MatchSource.CODE_COMMENT,qutip/core/blochredfield.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:1257,Modifiability,coupling,coupling,1257,"""""""; Calculates the Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system's coupling to its environment. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used; for array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list; List of system collapse operators. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :class:`qutip.Qobj`, tuple of :class:`qutip.Qobj`; If ``fock_basis``, return the Bloch Redfield tensor in the laboratory; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column.; """"""",MatchSource.CODE_COMMENT,qutip/core/blochredfield.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:31,Integrability,depend,dependent,31,"# When the Hamiltonian is time-dependent, the transformation of `L` to; # eigenbasis is not optimized.",MatchSource.CODE_COMMENT,qutip/core/blochredfield.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:92,Performance,optimiz,optimized,92,"# When the Hamiltonian is time-dependent, the transformation of `L` to; # eigenbasis is not optimized.",MatchSource.CODE_COMMENT,qutip/core/blochredfield.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:1194,Energy Efficiency,efficient,efficient,1194,"""""""; Calculates the contribution of one coupling operator to the Bloch-Redfield; tensor. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used for; array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. coefficient('w>0', args={""w"": 0}); SpectraCoefficient(coefficient(array, tlist=...)). sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver on the Hamiltonian. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :obj:`.Qobj`, :obj:`.QobjEvo` or tuple; If ``fock_basis``, return the Bloch Redfield tensor in the outside; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column. The tensors and, if given, evecs, will be :obj:`.QobjEvo` if; the ``H`` and ``a_op`` is time dependent, :obj:`.Qobj` otherwise.; """"""",MatchSource.CODE_COMMENT,qutip/core/blochredfield.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:551,Integrability,depend,depend,551,"""""""; Calculates the contribution of one coupling operator to the Bloch-Redfield; tensor. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used for; array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. coefficient('w>0', args={""w"": 0}); SpectraCoefficient(coefficient(array, tlist=...)). sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver on the Hamiltonian. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :obj:`.Qobj`, :obj:`.QobjEvo` or tuple; If ``fock_basis``, return the Bloch Redfield tensor in the outside; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column. The tensors and, if given, evecs, will be :obj:`.QobjEvo` if; the ``H`` and ``a_op`` is time dependent, :obj:`.Qobj` otherwise.; """"""",MatchSource.CODE_COMMENT,qutip/core/blochredfield.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:1586,Integrability,depend,dependent,1586,"""""""; Calculates the contribution of one coupling operator to the Bloch-Redfield; tensor. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used for; array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. coefficient('w>0', args={""w"": 0}); SpectraCoefficient(coefficient(array, tlist=...)). sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver on the Hamiltonian. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :obj:`.Qobj`, :obj:`.QobjEvo` or tuple; If ``fock_basis``, return the Bloch Redfield tensor in the outside; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column. The tensors and, if given, evecs, will be :obj:`.QobjEvo` if; the ``H`` and ``a_op`` is time dependent, :obj:`.Qobj` otherwise.; """"""",MatchSource.CODE_COMMENT,qutip/core/blochredfield.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:40,Modifiability,coupling,coupling,40,"""""""; Calculates the contribution of one coupling operator to the Bloch-Redfield; tensor. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used for; array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. coefficient('w>0', args={""w"": 0}); SpectraCoefficient(coefficient(array, tlist=...)). sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver on the Hamiltonian. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :obj:`.Qobj`, :obj:`.QobjEvo` or tuple; If ``fock_basis``, return the Bloch Redfield tensor in the outside; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column. The tensors and, if given, evecs, will be :obj:`.QobjEvo` if; the ``H`` and ``a_op`` is time dependent, :obj:`.Qobj` otherwise.; """"""",MatchSource.CODE_COMMENT,qutip/core/blochredfield.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:247,Modifiability,coupling,coupling,247,"""""""; Calculates the contribution of one coupling operator to the Bloch-Redfield; tensor. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used for; array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. coefficient('w>0', args={""w"": 0}); SpectraCoefficient(coefficient(array, tlist=...)). sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver on the Hamiltonian. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :obj:`.Qobj`, :obj:`.QobjEvo` or tuple; If ``fock_basis``, return the Bloch Redfield tensor in the outside; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column. The tensors and, if given, evecs, will be :obj:`.QobjEvo` if; the ``H`` and ``a_op`` is time dependent, :obj:`.Qobj` otherwise.; """"""",MatchSource.CODE_COMMENT,qutip/core/blochredfield.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:846,Modifiability,coupling,coupling,846,"""""""; Calculates the contribution of one coupling operator to the Bloch-Redfield; tensor. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used for; array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. coefficient('w>0', args={""w"": 0}); SpectraCoefficient(coefficient(array, tlist=...)). sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver on the Hamiltonian. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :obj:`.Qobj`, :obj:`.QobjEvo` or tuple; If ``fock_basis``, return the Bloch Redfield tensor in the outside; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column. The tensors and, if given, evecs, will be :obj:`.QobjEvo` if; the ``H`` and ``a_op`` is time dependent, :obj:`.Qobj` otherwise.; """"""",MatchSource.CODE_COMMENT,qutip/core/blochredfield.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:34,Integrability,depend,dependent,34,"""""""Build ``Coefficient`` for time dependent systems:. ```; QobjEvo = Qobj + Qobj * Coefficient + Qobj * Coefficient + ...; ```. The coefficients can be a function, a string or a numpy array. Other; packages may add support for other kind of coefficients. For function based coefficients, the function signature must be either:. * ``f(t, ...)`` where the other arguments are supplied as ordinary; ""pythonic"" arguments (e.g. ``f(t, w, a=5)``); * ``f(t, args)`` where the arguments are supplied in a ""dict"" named; ``args``. By default the signature style is controlled by the; ``qutip.settings.core[""function_coefficient_style""]`` setting, but it; may be overriden here by specifying either ``function_style=""pythonic""``; or ``function_style=""dict""``. *Examples*:. - pythonic style function signature::. def f1_t(t, w):; return np.exp(-1j * t * w). coeff1 = coefficient(f1_t, args={""w"": 1.}). - dict style function signature::. def f2_t(t, args):; return np.exp(-1j * t * args[""w""]). coeff2 = coefficient(f2_t, args={""w"": 1.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin, cos, tan, asin, acos, atan, pi,; sinh, cosh, tanh, asinh, acosh, atanh,; exp, log, log10, erf, zerf, sqrt,; real, imag, conj, abs, norm, arg, proj,; numpy as np,; scipy.special as spe (python interface); and cython_special (scipy cython interface). *Examples*::. coeff = coefficient('exp(-1j*w1*t)', args={""w1"":1.}). 'args' is needed for string coefficient at compilation.; It is a dict of (name:object). The keys must be a valid variables string. Compilation options can be passed as ""compile_opt=CompilationOptions(...)"". For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline int",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:1356,Integrability,interface,interface,1356,"e supplied as ordinary; ""pythonic"" arguments (e.g. ``f(t, w, a=5)``); * ``f(t, args)`` where the arguments are supplied in a ""dict"" named; ``args``. By default the signature style is controlled by the; ``qutip.settings.core[""function_coefficient_style""]`` setting, but it; may be overriden here by specifying either ``function_style=""pythonic""``; or ``function_style=""dict""``. *Examples*:. - pythonic style function signature::. def f1_t(t, w):; return np.exp(-1j * t * w). coeff1 = coefficient(f1_t, args={""w"": 1.}). - dict style function signature::. def f2_t(t, args):; return np.exp(-1j * t * args[""w""]). coeff2 = coefficient(f2_t, args={""w"": 1.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin, cos, tan, asin, acos, atan, pi,; sinh, cosh, tanh, asinh, acosh, atanh,; exp, log, log10, erf, zerf, sqrt,; real, imag, conj, abs, norm, arg, proj,; numpy as np,; scipy.special as spe (python interface); and cython_special (scipy cython interface). *Examples*::. coeff = coefficient('exp(-1j*w1*t)', args={""w1"":1.}). 'args' is needed for string coefficient at compilation.; It is a dict of (name:object). The keys must be a valid variables string. Compilation options can be passed as ""compile_opt=CompilationOptions(...)"". For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline interpolation will be used to compute the; coefficient at time t. The keyword ``order`` sets the order of the; interpolation. When ``order = 0``, the interpolation is step function that; evaluates to the most recent value. *Examples*::. tlist = np.logspace(-5,0,100); H = QobjEvo(np.exp(-1j*tlist), tlist=tlist). ``scipy.interpolate``'s ``CubicSpline``, ``PPoly`` and ``Bspli",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:1401,Integrability,interface,interface,1401,"e supplied as ordinary; ""pythonic"" arguments (e.g. ``f(t, w, a=5)``); * ``f(t, args)`` where the arguments are supplied in a ""dict"" named; ``args``. By default the signature style is controlled by the; ``qutip.settings.core[""function_coefficient_style""]`` setting, but it; may be overriden here by specifying either ``function_style=""pythonic""``; or ``function_style=""dict""``. *Examples*:. - pythonic style function signature::. def f1_t(t, w):; return np.exp(-1j * t * w). coeff1 = coefficient(f1_t, args={""w"": 1.}). - dict style function signature::. def f2_t(t, args):; return np.exp(-1j * t * args[""w""]). coeff2 = coefficient(f2_t, args={""w"": 1.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin, cos, tan, asin, acos, atan, pi,; sinh, cosh, tanh, asinh, acosh, atanh,; exp, log, log10, erf, zerf, sqrt,; real, imag, conj, abs, norm, arg, proj,; numpy as np,; scipy.special as spe (python interface); and cython_special (scipy cython interface). *Examples*::. coeff = coefficient('exp(-1j*w1*t)', args={""w1"":1.}). 'args' is needed for string coefficient at compilation.; It is a dict of (name:object). The keys must be a valid variables string. Compilation options can be passed as ""compile_opt=CompilationOptions(...)"". For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline interpolation will be used to compute the; coefficient at time t. The keyword ``order`` sets the order of the; interpolation. When ``order = 0``, the interpolation is step function that; evaluates to the most recent value. *Examples*::. tlist = np.logspace(-5,0,100); H = QobjEvo(np.exp(-1j*tlist), tlist=tlist). ``scipy.interpolate``'s ``CubicSpline``, ``PPoly`` and ``Bspli",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:1594,Modifiability,variab,variables,1594,"s.core[""function_coefficient_style""]`` setting, but it; may be overriden here by specifying either ``function_style=""pythonic""``; or ``function_style=""dict""``. *Examples*:. - pythonic style function signature::. def f1_t(t, w):; return np.exp(-1j * t * w). coeff1 = coefficient(f1_t, args={""w"": 1.}). - dict style function signature::. def f2_t(t, args):; return np.exp(-1j * t * args[""w""]). coeff2 = coefficient(f2_t, args={""w"": 1.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin, cos, tan, asin, acos, atan, pi,; sinh, cosh, tanh, asinh, acosh, atanh,; exp, log, log10, erf, zerf, sqrt,; real, imag, conj, abs, norm, arg, proj,; numpy as np,; scipy.special as spe (python interface); and cython_special (scipy cython interface). *Examples*::. coeff = coefficient('exp(-1j*w1*t)', args={""w1"":1.}). 'args' is needed for string coefficient at compilation.; It is a dict of (name:object). The keys must be a valid variables string. Compilation options can be passed as ""compile_opt=CompilationOptions(...)"". For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline interpolation will be used to compute the; coefficient at time t. The keyword ``order`` sets the order of the; interpolation. When ``order = 0``, the interpolation is step function that; evaluates to the most recent value. *Examples*::. tlist = np.logspace(-5,0,100); H = QobjEvo(np.exp(-1j*tlist), tlist=tlist). ``scipy.interpolate``'s ``CubicSpline``, ``PPoly`` and ``Bspline`` are; also converted to interpolated coefficients (the same kind of coefficient; created from ``ndarray``). Other interpolation methods from; scipy are converted to a function-based coefficient (the same kind of; ",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:1242,Testability,log,log,1242,"ficients. For function based coefficients, the function signature must be either:. * ``f(t, ...)`` where the other arguments are supplied as ordinary; ""pythonic"" arguments (e.g. ``f(t, w, a=5)``); * ``f(t, args)`` where the arguments are supplied in a ""dict"" named; ``args``. By default the signature style is controlled by the; ``qutip.settings.core[""function_coefficient_style""]`` setting, but it; may be overriden here by specifying either ``function_style=""pythonic""``; or ``function_style=""dict""``. *Examples*:. - pythonic style function signature::. def f1_t(t, w):; return np.exp(-1j * t * w). coeff1 = coefficient(f1_t, args={""w"": 1.}). - dict style function signature::. def f2_t(t, args):; return np.exp(-1j * t * args[""w""]). coeff2 = coefficient(f2_t, args={""w"": 1.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin, cos, tan, asin, acos, atan, pi,; sinh, cosh, tanh, asinh, acosh, atanh,; exp, log, log10, erf, zerf, sqrt,; real, imag, conj, abs, norm, arg, proj,; numpy as np,; scipy.special as spe (python interface); and cython_special (scipy cython interface). *Examples*::. coeff = coefficient('exp(-1j*w1*t)', args={""w1"":1.}). 'args' is needed for string coefficient at compilation.; It is a dict of (name:object). The keys must be a valid variables string. Compilation options can be passed as ""compile_opt=CompilationOptions(...)"". For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline interpolation will be used to compute the; coefficient at time t. The keyword ``order`` sets the order of the; interpolation. When ``order = 0``, the interpolation is step function that; evaluates to the most recent value. *Examples*::. tlist = np.",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:2246,Testability,log,logspace,2246,", sqrt,; real, imag, conj, abs, norm, arg, proj,; numpy as np,; scipy.special as spe (python interface); and cython_special (scipy cython interface). *Examples*::. coeff = coefficient('exp(-1j*w1*t)', args={""w1"":1.}). 'args' is needed for string coefficient at compilation.; It is a dict of (name:object). The keys must be a valid variables string. Compilation options can be passed as ""compile_opt=CompilationOptions(...)"". For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline interpolation will be used to compute the; coefficient at time t. The keyword ``order`` sets the order of the; interpolation. When ``order = 0``, the interpolation is step function that; evaluates to the most recent value. *Examples*::. tlist = np.logspace(-5,0,100); H = QobjEvo(np.exp(-1j*tlist), tlist=tlist). ``scipy.interpolate``'s ``CubicSpline``, ``PPoly`` and ``Bspline`` are; also converted to interpolated coefficients (the same kind of coefficient; created from ``ndarray``). Other interpolation methods from; scipy are converted to a function-based coefficient (the same kind of; coefficient created from callables). Parameters; ----------; base : object; Base object to make into a Coefficient. args : dict, optional; Dictionary of arguments to pass to the function or string coefficient. order : int, default=3; Order of the spline for array based coefficient. tlist : iterable, optional; Times for each element of an array based coefficient. function_style : str {""dict"", ""pythonic"", None}, optional; Function signature of function based coefficients. args_ctypes : dict, optional; C type for the args when compiling array based coefficients. compile_opt : CompilationOptions, optional; Sets of options for the compilation of string based coefficients",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:366,Deployability,upgrade,upgrade,366,"""""""; Compilation options:. use_cython: bool; Whether to compile strings as cython code or use python's ``exec``. try_parse: bool [True]; Whether to try parsing the string for reuse and static typing. static_types : bool [True]; Whether to use C types for constant and args. accept_int : None, bool; Whether to use the type ``int`` for integer constants and args or; upgrade it to ``float`` or ``complex``.; If `None`, it will only use ``int`` when subscription is found in the; code. accept_float : bool; Whether to use the type ``float`` or upgrade them to ``complex``. recompile : bool; Do not use previously made files but build a new one. compiler_flags : str; Flags to pass to the compiler, ex: ""-Wall -O3""...; Flags not matching your comiler and OS may cause compilation to fail.; Use ""recompile=True"", when trying to if the string pattern was; previously used. link_flags : str; Libraries to link to pass to the compiler. They can not be used to add; function to the string coefficient. extra_import : str; Cython code to add at the head of the file. Can be used to add extra; import or cimport code, ex:; extra_import=""from scipy.linalg import det""; extra_import=""from qutip.core.data cimport CSR"". clean_on_error : bool [True]; When writing a cython file that cannot be imported, erase it. build_dir: str [None]; cythonize's build_dir.; """"""",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:542,Deployability,upgrade,upgrade,542,"""""""; Compilation options:. use_cython: bool; Whether to compile strings as cython code or use python's ``exec``. try_parse: bool [True]; Whether to try parsing the string for reuse and static typing. static_types : bool [True]; Whether to use C types for constant and args. accept_int : None, bool; Whether to use the type ``int`` for integer constants and args or; upgrade it to ``float`` or ``complex``.; If `None`, it will only use ``int`` when subscription is found in the; code. accept_float : bool; Whether to use the type ``float`` or upgrade them to ``complex``. recompile : bool; Do not use previously made files but build a new one. compiler_flags : str; Flags to pass to the compiler, ex: ""-Wall -O3""...; Flags not matching your comiler and OS may cause compilation to fail.; Use ""recompile=True"", when trying to if the string pattern was; previously used. link_flags : str; Libraries to link to pass to the compiler. They can not be used to add; function to the string coefficient. extra_import : str; Cython code to add at the head of the file. Can be used to add extra; import or cimport code, ex:; extra_import=""from scipy.linalg import det""; extra_import=""from qutip.core.data cimport CSR"". clean_on_error : bool [True]; When writing a cython file that cannot be imported, erase it. build_dir: str [None]; cythonize's build_dir.; """"""",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:11,Safety,sanity check,sanity check,11,"# First, a sanity check before thinking of compiling",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:38,Availability,avail,available,38,"# Previously compiled coefficient not available: create the cython code",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:164,Safety,safe,safe,164,"# Files with the same name, but differents extension than the pyx file, are; # erased during cythonization process, breaking filelock.; # Adding a prefix make them safe to use.",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:29,Deployability,release,released,29,"# We wait for the lock to be released and then retry the import.",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:65,Modifiability,variab,variable,65,"""""""Look for floating and complex constants and replace them with variable.; """"""",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:49,Modifiability,variab,variable,49,"""""""replace the constant following a pattern with variable""""""",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:23,Modifiability,rewrite,rewrite,23,"""""""; Read the code and rewrite it in a reutilisable form:; Ins:; '2.*cos(a*t)', {""a"":5+1j}; Outs:; code = 'self._cte_dbl0 * cos ( self._arg_cpl0 * t )'; variables = [('self._arg_cpl0', 'a', 'complex')]; ordered_constants = [('self._cte_dbl0', 2, 'double')]; """"""",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:153,Modifiability,variab,variables,153,"""""""; Read the code and rewrite it in a reutilisable form:; Ins:; '2.*cos(a*t)', {""a"":5+1j}; Outs:; code = 'self._cte_dbl0 * cos ( self._arg_cpl0 * t )'; variables = [('self._arg_cpl0', 'a', 'complex')]; ordered_constants = [('self._cte_dbl0', 2, 'double')]; """"""",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:62,Safety,safe,safe,62,"# If there is a subscript: a[b] int are always accepted to be safe; # with TypeError",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:20,Modifiability,variab,variable,20,"# find first if the variable is use more than once and reuse",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:54,Usability,usab,usable,54,"""""""; Try to parse and verify that the result is still usable.; """"""",MatchSource.CODE_COMMENT,qutip/core/coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/dimensions.py:53,Availability,avail,available,53,"# Everything should be explicitly imported, not made available by default.",MatchSource.CODE_COMMENT,qutip/core/dimensions.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/dimensions.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/dimensions.py:135,Availability,down,down,135,"""""""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists or a dimension object,; flattens it down to a list of the scalars within the original list. Parameters; ----------; l : scalar, list, Space, Dimension; Object to flatten. Examples; --------. >>> flatten([[[0], 1], 2]) # doctest: +SKIP; [0, 1, 2]. Notes; -----; Any scalar will be returned wrapped in a list: ``flaten(1) == [1]``.; A non-list iterable will not be treated as a list by flatten. For example, flatten would treat a tuple; as a scalar.; """"""",MatchSource.CODE_COMMENT,qutip/core/dimensions.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/dimensions.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/dimensions.py:388,Integrability,wrap,wrapped,388,"""""""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists or a dimension object,; flattens it down to a list of the scalars within the original list. Parameters; ----------; l : scalar, list, Space, Dimension; Object to flatten. Examples; --------. >>> flatten([[[0], 1], 2]) # doctest: +SKIP; [0, 1, 2]. Notes; -----; Any scalar will be returned wrapped in a list: ``flaten(1) == [1]``.; A non-list iterable will not be treated as a list by flatten. For example, flatten would treat a tuple; as a scalar.; """"""",MatchSource.CODE_COMMENT,qutip/core/dimensions.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/dimensions.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/gates.py:27,Energy Efficiency,power,powers,27,"""""""; Generator that yields powers of an operator `op`,; through to `N`.; """"""",MatchSource.CODE_COMMENT,qutip/core/gates.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/gates.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/gates.py:10,Energy Efficiency,reduce,reduce,10,"# partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add).; # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k.",MatchSource.CODE_COMMENT,qutip/core/gates.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/gates.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/gates.py:156,Energy Efficiency,reduce,reduce,156,"# partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add).; # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k.",MatchSource.CODE_COMMENT,qutip/core/gates.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/gates.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/gates.py:306,Energy Efficiency,reduce,reduce,306,"# partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add).; # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k.",MatchSource.CODE_COMMENT,qutip/core/gates.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/gates.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:621,Testability,test,testing,621,"""""""; Calculates the fidelity (pseudo-metric) between two density matrices. Notes; -----; Uses the definition from Nielsen & Chuang, ""Quantum Computation and Quantum; Information"". It is the square root of the fidelity defined in; R. Jozsa, Journal of Modern Optics, 41:12, 2315 (1994), used in; :func:`qutip.core.metrics.process_fidelity`. Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""",MatchSource.CODE_COMMENT,qutip/core/metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:31,Energy Efficiency,reduce,reduces,31,"# The fidelity for pure states reduces to the modulus of their; # inner product.",MatchSource.CODE_COMMENT,qutip/core/metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:82,Safety,avoid,avoid,82,"# Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.",MatchSource.CODE_COMMENT,qutip/core/metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:175,Safety,avoid,avoid,175,"# We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.",MatchSource.CODE_COMMENT,qutip/core/metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:567,Testability,test,testing,567,"""""""; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------!=; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A.; tol : float, default: 0; Tolerance used by sparse eigensolver, if used. (0 = Machine precision); sparse : bool, default: False; Use sparse eigensolver. Returns; -------; tracedist : float; Trace distance between A and B. Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971); """"""",MatchSource.CODE_COMMENT,qutip/core/metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:21,Safety,avoid,avoid,21,"# np.maximum() is to avoid nan appearing sometimes due to numerical; # instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1 when; # hellinger_dist(A, B) is called for A=B",MatchSource.CODE_COMMENT,qutip/core/metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:71,Usability,simpl,simplified,71,"""""""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat13]_. The diamond norm SDP is solved by using `CVXPY <https://www.cvxpy.org/>`_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is taken instead.; solver : str {""CVXOPT"", ""SCS""}, default: ""CVXOPT""; Solver to use with CVXPY. ""SCS"" tends to be significantly faster, but; somewhat less accurate.; verbose : bool, default: False; If True, prints additional information about the solution.; force_solve : bool, default: False; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument.; sparse : bool, default: True; Whether to use sparse matrices in the convex optimisation problem.; Default True. Returns; -------; dn : float; Diamond norm of q_oper. Raises; ------; ImportError; If CVXPY cannot be imported. """"""",MatchSource.CODE_COMMENT,qutip/core/metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:765,Performance,optimiz,optimization,765,"# We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.); # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_ = || A B - I ||_.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B - I ||_ = max_{i, j} | \lambda_i(A B) - \lambda_j(A B) |,; # where \lambda_i(U) is the ith eigenvalue of U.; # There's a lot of conditions to check for this path. Only check if they; # aren't superoperators. The difference of unitaries optimization is; # currently only implemented for d == 2. Much of the code below is more; # general, though, in anticipation of generalizing the optimization.",MatchSource.CODE_COMMENT,qutip/core/metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:910,Performance,optimiz,optimization,910,"# We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.); # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_ = || A B - I ||_.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B - I ||_ = max_{i, j} | \lambda_i(A B) - \lambda_j(A B) |,; # where \lambda_i(U) is the ith eigenvalue of U.; # There's a lot of conditions to check for this path. Only check if they; # aren't superoperators. The difference of unitaries optimization is; # currently only implemented for d == 2. Much of the code below is more; # general, though, in anticipation of generalizing the optimization.",MatchSource.CODE_COMMENT,qutip/core/metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:43,Usability,simpl,simpler,43,"# We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.); # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_ = || A B - I ||_.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B - I ||_ = max_{i, j} | \lambda_i(A B) - \lambda_j(A B) |,; # where \lambda_i(U) is the ith eigenvalue of U.; # There's a lot of conditions to check for this path. Only check if they; # aren't superoperators. The difference of unitaries optimization is; # currently only implemented for d == 2. Much of the code below is more; # general, though, in anticipation of generalizing the optimization.",MatchSource.CODE_COMMENT,qutip/core/metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:33,Availability,error,error,33,"# Compare to B first, so that an error is raised; # as soon as possible.",MatchSource.CODE_COMMENT,qutip/core/metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:257,Performance,optimiz,optimization,257,"# Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).",MatchSource.CODE_COMMENT,qutip/core/metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:144,Performance,cache,cache,144,"# Pauli spin-1/2 operators.; #; # These are so common in quantum information that we want them to be; # near-instantaneous to initialise, so we cache them at package import, and; # just return copies when someone requests one.",MatchSource.CODE_COMMENT,qutip/core/operators.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:8,Availability,error,error,8,"# raise error if N not integer",MatchSource.CODE_COMMENT,qutip/core/operators.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:8,Availability,error,error,8,"# raise error if N not integer",MatchSource.CODE_COMMENT,qutip/core/operators.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:2,Safety,sanity check,sanity check,2,"# sanity check",MatchSource.CODE_COMMENT,qutip/core/operators.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:338,Integrability,depend,depending,338,"""""""; Zero operator. Parameters; ----------; dimensions : int, list of int, list of list of int, Space; Number of basis states in the Hilbert space. If provided as a list of; ints, then the dimension is the product over this list, but the; ``dims`` property of the new Qobj are set to this list. This can; produce either `oper` or `super` depending on the passed `dimensions`. dims_right : int, list of int, list of list of int, Space, optional; Number of basis states in the right Hilbert space when the operator is; rectangular. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; qzero : qobj; Zero operator Qobj. """"""",MatchSource.CODE_COMMENT,qutip/core/operators.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:352,Integrability,depend,depending,352,"""""""; Identity operator. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int), Space; Number of basis states in the Hilbert space. If provided as a list of; ints, then the dimension is the product over this list, but the; ``dims`` property of the new Qobj are set to this list. This can; produce either `oper` or `super` depending on the passed `dimensions`. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; oper : qobj; Identity operator Qobj. Examples; --------; >>> qeye(3) # doctest: +SKIP; Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, \; isherm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 1. 0.]; [ 0. 0. 1.]]; >>> qeye([2,2]) # doctest: +SKIP; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, \; isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 1. 0.]; [0. 0. 0. 1.]]. """"""",MatchSource.CODE_COMMENT,qutip/core/operators.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:27,Energy Efficiency,charge,charge,27,"""""""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int, default: -Nmax; Lowest charge state to consider. frac : float, default: 1; Specify fractional charge if needed. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; C : Qobj; Charge operator over [Nmin, Nmax]. Notes; -----; .. versionadded:: 3.2. """"""",MatchSource.CODE_COMMENT,qutip/core/operators.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:48,Energy Efficiency,charge,charge,48,"""""""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int, default: -Nmax; Lowest charge state to consider. frac : float, default: 1; Specify fractional charge if needed. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; C : Qobj; Charge operator over [Nmin, Nmax]. Notes; -----; .. versionadded:: 3.2. """"""",MatchSource.CODE_COMMENT,qutip/core/operators.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:126,Energy Efficiency,charge,charge,126,"""""""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int, default: -Nmax; Lowest charge state to consider. frac : float, default: 1; Specify fractional charge if needed. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; C : Qobj; Charge operator over [Nmin, Nmax]. Notes; -----; .. versionadded:: 3.2. """"""",MatchSource.CODE_COMMENT,qutip/core/operators.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:187,Energy Efficiency,charge,charge,187,"""""""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int, default: -Nmax; Lowest charge state to consider. frac : float, default: 1; Specify fractional charge if needed. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; C : Qobj; Charge operator over [Nmin, Nmax]. Notes; -----; .. versionadded:: 3.2. """"""",MatchSource.CODE_COMMENT,qutip/core/operators.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:258,Energy Efficiency,charge,charge,258,"""""""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int, default: -Nmax; Lowest charge state to consider. frac : float, default: 1; Specify fractional charge if needed. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; C : Qobj; Charge operator over [Nmin, Nmax]. Notes; -----; .. versionadded:: 3.2. """"""",MatchSource.CODE_COMMENT,qutip/core/operators.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:79,Integrability,wrap,wrap,79,"""""""; Class for basic functionality for qutip's options. Define basic method to wrap an ``options`` dict.; Default options are in a class _options dict.; """"""",MatchSource.CODE_COMMENT,qutip/core/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:51,Availability,toler,tolerance,51,"""""""; Options used by the core of qutip such as the tolerance of :obj:`.Qobj`; comparison or coefficient's format. Values can be changed in ``qutip.settings.core`` or by using context:; ``with CoreOptions(atol=1e-6): ...``. Options; -------; auto_tidyup : bool; Whether to tidyup during sparse operations. auto_tidyup_dims : bool [False]; Use auto tidyup dims on multiplication, tensor, etc.; Without auto_tidyup_dims:; ``basis([2, 2]).dims == [[2, 2], [1, 1]]``; With auto_tidyup_dims:; ``basis([2, 2]).dims == [[2, 2], [1]]``. auto_herm : boolTrue; detect hermiticity. atol : float {1e-12}; General absolute tolerance. rtol : float {1e-12}; General relative tolerance; Used to choose QobjEvo.expect output type. auto_tidyup_atol : float {1e-14}; The absolute tolerance used in automatic tidyup (see the; ``auto_tidyup`` parameter above) and the default value of ``atol`` used; in :meth:`Qobj.tidyup`. function_coefficient_style : str {""auto""}; The signature expected by function coefficients. The options are:. - ""pythonic"": the signature should be ``f(t, ...)`` where ``t``; is the time and the ``...`` are the remaining arguments passed; directly into the function. E.g. ``f(t, w, b=5)``. - ""dict"": the signature shoule be ``f(t, args)`` where ``t`` is; the time and ``args`` is a dict containing the remaining arguments.; E.g. ``f(t, {""w"": w, ""b"": 5})``. - ""auto"": select automatically between the two options above based; on the signature of the supplied function. If the function signature; is exactly ``f(t, args)`` then ``dict`` is used. Otherwise; ``pythonic`` is used. default_dtype : Nonetype, str, type {None}; When set, functions creating :obj:`.Qobj`, such as :func:""qeye"" or; :func:""rand_herm"", will use the specified data type. Any data-layer; known to ``qutip.data.to`` is accepted. When ``None``, these functions; will default to a sensible data type.; """"""",MatchSource.CODE_COMMENT,qutip/core/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:609,Availability,toler,tolerance,609,"""""""; Options used by the core of qutip such as the tolerance of :obj:`.Qobj`; comparison or coefficient's format. Values can be changed in ``qutip.settings.core`` or by using context:; ``with CoreOptions(atol=1e-6): ...``. Options; -------; auto_tidyup : bool; Whether to tidyup during sparse operations. auto_tidyup_dims : bool [False]; Use auto tidyup dims on multiplication, tensor, etc.; Without auto_tidyup_dims:; ``basis([2, 2]).dims == [[2, 2], [1, 1]]``; With auto_tidyup_dims:; ``basis([2, 2]).dims == [[2, 2], [1]]``. auto_herm : boolTrue; detect hermiticity. atol : float {1e-12}; General absolute tolerance. rtol : float {1e-12}; General relative tolerance; Used to choose QobjEvo.expect output type. auto_tidyup_atol : float {1e-14}; The absolute tolerance used in automatic tidyup (see the; ``auto_tidyup`` parameter above) and the default value of ``atol`` used; in :meth:`Qobj.tidyup`. function_coefficient_style : str {""auto""}; The signature expected by function coefficients. The options are:. - ""pythonic"": the signature should be ``f(t, ...)`` where ``t``; is the time and the ``...`` are the remaining arguments passed; directly into the function. E.g. ``f(t, w, b=5)``. - ""dict"": the signature shoule be ``f(t, args)`` where ``t`` is; the time and ``args`` is a dict containing the remaining arguments.; E.g. ``f(t, {""w"": w, ""b"": 5})``. - ""auto"": select automatically between the two options above based; on the signature of the supplied function. If the function signature; is exactly ``f(t, args)`` then ``dict`` is used. Otherwise; ``pythonic`` is used. default_dtype : Nonetype, str, type {None}; When set, functions creating :obj:`.Qobj`, such as :func:""qeye"" or; :func:""rand_herm"", will use the specified data type. Any data-layer; known to ``qutip.data.to`` is accepted. When ``None``, these functions; will default to a sensible data type.; """"""",MatchSource.CODE_COMMENT,qutip/core/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:659,Availability,toler,tolerance,659,"""""""; Options used by the core of qutip such as the tolerance of :obj:`.Qobj`; comparison or coefficient's format. Values can be changed in ``qutip.settings.core`` or by using context:; ``with CoreOptions(atol=1e-6): ...``. Options; -------; auto_tidyup : bool; Whether to tidyup during sparse operations. auto_tidyup_dims : bool [False]; Use auto tidyup dims on multiplication, tensor, etc.; Without auto_tidyup_dims:; ``basis([2, 2]).dims == [[2, 2], [1, 1]]``; With auto_tidyup_dims:; ``basis([2, 2]).dims == [[2, 2], [1]]``. auto_herm : boolTrue; detect hermiticity. atol : float {1e-12}; General absolute tolerance. rtol : float {1e-12}; General relative tolerance; Used to choose QobjEvo.expect output type. auto_tidyup_atol : float {1e-14}; The absolute tolerance used in automatic tidyup (see the; ``auto_tidyup`` parameter above) and the default value of ``atol`` used; in :meth:`Qobj.tidyup`. function_coefficient_style : str {""auto""}; The signature expected by function coefficients. The options are:. - ""pythonic"": the signature should be ``f(t, ...)`` where ``t``; is the time and the ``...`` are the remaining arguments passed; directly into the function. E.g. ``f(t, w, b=5)``. - ""dict"": the signature shoule be ``f(t, args)`` where ``t`` is; the time and ``args`` is a dict containing the remaining arguments.; E.g. ``f(t, {""w"": w, ""b"": 5})``. - ""auto"": select automatically between the two options above based; on the signature of the supplied function. If the function signature; is exactly ``f(t, args)`` then ``dict`` is used. Otherwise; ``pythonic`` is used. default_dtype : Nonetype, str, type {None}; When set, functions creating :obj:`.Qobj`, such as :func:""qeye"" or; :func:""rand_herm"", will use the specified data type. Any data-layer; known to ``qutip.data.to`` is accepted. When ``None``, these functions; will default to a sensible data type.; """"""",MatchSource.CODE_COMMENT,qutip/core/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:760,Availability,toler,tolerance,760,"""""""; Options used by the core of qutip such as the tolerance of :obj:`.Qobj`; comparison or coefficient's format. Values can be changed in ``qutip.settings.core`` or by using context:; ``with CoreOptions(atol=1e-6): ...``. Options; -------; auto_tidyup : bool; Whether to tidyup during sparse operations. auto_tidyup_dims : bool [False]; Use auto tidyup dims on multiplication, tensor, etc.; Without auto_tidyup_dims:; ``basis([2, 2]).dims == [[2, 2], [1, 1]]``; With auto_tidyup_dims:; ``basis([2, 2]).dims == [[2, 2], [1]]``. auto_herm : boolTrue; detect hermiticity. atol : float {1e-12}; General absolute tolerance. rtol : float {1e-12}; General relative tolerance; Used to choose QobjEvo.expect output type. auto_tidyup_atol : float {1e-14}; The absolute tolerance used in automatic tidyup (see the; ``auto_tidyup`` parameter above) and the default value of ``atol`` used; in :meth:`Qobj.tidyup`. function_coefficient_style : str {""auto""}; The signature expected by function coefficients. The options are:. - ""pythonic"": the signature should be ``f(t, ...)`` where ``t``; is the time and the ``...`` are the remaining arguments passed; directly into the function. E.g. ``f(t, w, b=5)``. - ""dict"": the signature shoule be ``f(t, args)`` where ``t`` is; the time and ``args`` is a dict containing the remaining arguments.; E.g. ``f(t, {""w"": w, ""b"": 5})``. - ""auto"": select automatically between the two options above based; on the signature of the supplied function. If the function signature; is exactly ``f(t, args)`` then ``dict`` is used. Otherwise; ``pythonic`` is used. default_dtype : Nonetype, str, type {None}; When set, functions creating :obj:`.Qobj`, such as :func:""qeye"" or; :func:""rand_herm"", will use the specified data type. Any data-layer; known to ``qutip.data.to`` is accepted. When ``None``, these functions; will default to a sensible data type.; """"""",MatchSource.CODE_COMMENT,qutip/core/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:550,Safety,detect,detect,550,"""""""; Options used by the core of qutip such as the tolerance of :obj:`.Qobj`; comparison or coefficient's format. Values can be changed in ``qutip.settings.core`` or by using context:; ``with CoreOptions(atol=1e-6): ...``. Options; -------; auto_tidyup : bool; Whether to tidyup during sparse operations. auto_tidyup_dims : bool [False]; Use auto tidyup dims on multiplication, tensor, etc.; Without auto_tidyup_dims:; ``basis([2, 2]).dims == [[2, 2], [1, 1]]``; With auto_tidyup_dims:; ``basis([2, 2]).dims == [[2, 2], [1]]``. auto_herm : boolTrue; detect hermiticity. atol : float {1e-12}; General absolute tolerance. rtol : float {1e-12}; General relative tolerance; Used to choose QobjEvo.expect output type. auto_tidyup_atol : float {1e-14}; The absolute tolerance used in automatic tidyup (see the; ``auto_tidyup`` parameter above) and the default value of ``atol`` used; in :meth:`Qobj.tidyup`. function_coefficient_style : str {""auto""}; The signature expected by function coefficients. The options are:. - ""pythonic"": the signature should be ``f(t, ...)`` where ``t``; is the time and the ``...`` are the remaining arguments passed; directly into the function. E.g. ``f(t, w, b=5)``. - ""dict"": the signature shoule be ``f(t, args)`` where ``t`` is; the time and ``args`` is a dict containing the remaining arguments.; E.g. ``f(t, {""w"": w, ""b"": 5})``. - ""auto"": select automatically between the two options above based; on the signature of the supplied function. If the function signature; is exactly ``f(t, args)`` then ``dict`` is used. Otherwise; ``pythonic`` is used. default_dtype : Nonetype, str, type {None}; When set, functions creating :obj:`.Qobj`, such as :func:""qeye"" or; :func:""rand_herm"", will use the specified data type. Any data-layer; known to ``qutip.data.to`` is accepted. When ``None``, these functions; will default to a sensible data type.; """"""",MatchSource.CODE_COMMENT,qutip/core/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:2,Safety,detect,detect,2,"# detect hermiticity",MatchSource.CODE_COMMENT,qutip/core/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:19,Availability,toler,tolerance,19,"# general absolute tolerance",MatchSource.CODE_COMMENT,qutip/core/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:19,Availability,toler,tolerance,19,"# general relative tolerance",MatchSource.CODE_COMMENT,qutip/core/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:27,Availability,toler,tolerance,27,"# use auto tidyup absolute tolerance",MatchSource.CODE_COMMENT,qutip/core/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:2611,Integrability,contract,contract,2611,"ject represents a map, and if that map is; completely positive (CP).; ishp : bool; Indicates if the quantum object represents a map, and if that map is; hermicity preserving (HP).; istp : bool; Indicates if the quantum object represents a map, and if that map is; trace preserving (TP).; iscptp : bool; Indicates if the quantum object represents a map that is completely; positive and trace preserving (CPTP).; isket : bool; Indicates if the quantum object represents a ket.; isbra : bool; Indicates if the quantum object represents a bra.; isoper : bool; Indicates if the quantum object represents an operator.; issuper : bool; Indicates if the quantum object represents a superoperator.; isoperket : bool; Indicates if the quantum object represents an operator in column vector; form.; isoperbra : bool; Indicates if the quantum object represents an operator in row vector; form. Methods; -------; copy(); Create copy of Qobj; conj(); Conjugate of quantum object.; contract(); Contract subspaces of the tensor structure which are 1D.; cosm(); Cosine of quantum object.; dag(); Adjoint (dagger) of quantum object.; data_as(format, copy); Vector / matrix representation of quantum object.; diag(); Diagonal elements of quantum object.; dnorm(); Diamond norm of quantum operator.; dual_chan(); Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(order='C'); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; inv(); Return a Qobj corresponding to the matrix inverse of the operator.; logm(); Matrix logarithm of quantum operator.; matrix_element(bra, ",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:4072,Performance,perform,performing,4072,"ich are 1D.; cosm(); Cosine of quantum object.; dag(); Adjoint (dagger) of quantum object.; data_as(format, copy); Vector / matrix representation of quantum object.; diag(); Diagonal elements of quantum object.; dnorm(); Diamond norm of quantum operator.; dual_chan(); Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(order='C'); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; inv(); Return a Qobj corresponding to the matrix inverse of the operator.; logm(); Matrix logarithm of quantum operator.; matrix_element(bra, ket); Returns the matrix element of operator between `bra` and `ket` vectors.; norm(norm='tr', sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator.; overlap(other); Overlap between two state vectors or two operators.; permute(order); Returns composite qobj with indices reordered.; proj(); Computes the projector for a ket or bra vector.; ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace.; purity(); Calculates the purity of a quantum object.; sinm(); Sine of quantum object.; sqrtm(); Matrix square root of quantum object.; tidyup(atol=1e-12); Removes small elements from quantum object.; tr(); Trace of quantum object.; trans(); Transpose of quantum object.; transform(inpt, inverse=False); Performs a basis transformation defined by `inpt` matrix.; trunc_neg(method='clip'); Removes negative eigenvalues and returns a new Qobj that is; a valid density operator.; unit(norm='tr', sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:3577,Testability,log,logm,3577,"tum object.; contract(); Contract subspaces of the tensor structure which are 1D.; cosm(); Cosine of quantum object.; dag(); Adjoint (dagger) of quantum object.; data_as(format, copy); Vector / matrix representation of quantum object.; diag(); Diagonal elements of quantum object.; dnorm(); Diamond norm of quantum operator.; dual_chan(); Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(order='C'); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; inv(); Return a Qobj corresponding to the matrix inverse of the operator.; logm(); Matrix logarithm of quantum operator.; matrix_element(bra, ket); Returns the matrix element of operator between `bra` and `ket` vectors.; norm(norm='tr', sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator.; overlap(other); Overlap between two state vectors or two operators.; permute(order); Returns composite qobj with indices reordered.; proj(); Computes the projector for a ket or bra vector.; ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace.; purity(); Calculates the purity of a quantum object.; sinm(); Sine of quantum object.; sqrtm(); Matrix square root of quantum object.; tidyup(atol=1e-12); Removes small elements from quantum object.; tr(); Trace of quantum object.; trans(); Transpose of quantum object.; transform(inpt, inverse=False); Performs a basis transformation defined by `inpt` matrix.; trunc_neg(method='clip'); Removes negative eigenvalues and returns a new Qobj that is; a valid density operator.; unit(norm='tr', sparse=",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:3592,Testability,log,logarithm,3592,"tum object.; contract(); Contract subspaces of the tensor structure which are 1D.; cosm(); Cosine of quantum object.; dag(); Adjoint (dagger) of quantum object.; data_as(format, copy); Vector / matrix representation of quantum object.; diag(); Diagonal elements of quantum object.; dnorm(); Diamond norm of quantum operator.; dual_chan(); Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(order='C'); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; inv(); Return a Qobj corresponding to the matrix inverse of the operator.; logm(); Matrix logarithm of quantum operator.; matrix_element(bra, ket); Returns the matrix element of operator between `bra` and `ket` vectors.; norm(norm='tr', sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator.; overlap(other); Overlap between two state vectors or two operators.; permute(order); Returns composite qobj with indices reordered.; proj(); Computes the projector for a ket or bra vector.; ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace.; purity(); Calculates the purity of a quantum object.; sinm(); Sine of quantum object.; sqrtm(); Matrix square root of quantum object.; tidyup(atol=1e-12); Removes small elements from quantum object.; tr(); Trace of quantum object.; trans(); Transpose of quantum object.; transform(inpt, inverse=False); Performs a basis transformation defined by `inpt` matrix.; trunc_neg(method='clip'); Removes negative eigenvalues and returns a new Qobj that is; a valid density operator.; unit(norm='tr', sparse=",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:134,Availability,avail,available,134,"""""""; Convert the underlying data store of this `Qobj` into a different; storage representation. The different storage representations available are the ""data-layer; types"" which are known to :obj:`qutip.core.data.to`. By default, these; are :class:`~qutip.core.data.CSR`, :class:`~qutip.core.data.Dense` and; :class:`~qutip.core.data.Dia`, which respectively construct a; compressed sparse row matrix, diagonal matrix and a dense one. Certain; algorithms and operations may be faster or more accurate when using a; more appropriate data store. Parameters; ----------; data_type : type, str; The data-layer type or its string alias that the data of this; :class:`Qobj` should be converted to. copy : Bool; If the data store is already in the format requested, whether the; function should return returns `self` or a copy. Returns; -------; Qobj; A :class:`Qobj` with the data stored in the requested format.; """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:60,Modifiability,flexible,flexible,60,"# We send other to mul instead of complex(other) to be more flexible.; # The dispatcher can then decide how to handle other and return; # TypeError if it does not know what to do with the type of other.",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:13,Energy Efficiency,power,powers,13,"# calculates powers of Qobj",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:156,Availability,error,errors,156,"# If the system is huge, don't attempt to convert to a dense matrix; # and then to string, because it is pointless and is likely going; # to produce memory errors. Instead print the sparse data string; # representation.",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:142,Usability,simpl,simply,142,"# give complete information on Qobj without print statement in; # command-line we cant realistically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.)",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:28,Performance,load,loading,28,"# defines what happens when loading a pickled Qobj",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:10,Testability,log,logarithm,10,"""""""Matrix logarithm of quantum operator. Input operator must be square. Returns; -------; oper : :class:`.Qobj`; Logarithm of the quantum operator. Raises; ------; TypeError; Quantum operator is not square.; """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:1052,Performance,perform,performs,1052,"""""""; Take the partial trace of the quantum object leaving the selected; subspaces. In other words, trace out all subspaces which are _not_; passed. This is typically a function which acts on operators; bras and kets; will be promoted to density matrices before the operation takes place; since the partial trace is inherently undefined on pure states. For operators which are currently being represented as states in the; superoperator formalism (i.e. the object has type `operator-ket` or; `operator-bra`), the partial trace is applied as if the operator were; in the conventional form. This means that for any operator `x`,; ``operator_to_vector(x).ptrace(0) == operator_to_vector(x.ptrace(0))``; and similar for `operator-bra`. The story is different for full superoperators. In the formalism that; QuTiP uses, if an operator has dimensions (`dims`) of; `[[2, 3], [2, 3]]` then it can be represented as a state on a Hilbert; space of dimensions `[2, 3, 2, 3]`, and a superoperator would be an; operator which acts on this joint space. This function performs the; partial trace on superoperators by letting the selected components; refer to elements of the _joint_ _space_, and then returns a regular; operator (of type `oper`). Parameters; ----------; sel : int or iterable of int; An ``int`` or ``list`` of components to keep after partial trace.; The selected subspaces will _not_ be reordered, no matter order; they are supplied to `ptrace`. Returns; -------; oper : :class:`.Qobj`; Quantum object representing partial trace with selected components; remaining.; """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:208,Integrability,contract,contracted,208,"""""""; Contract subspaces of the tensor structure which are 1D. Not defined; on superoperators. If all dimensions are scalar, a Qobj of dimension; [[1], [1]] is returned, i.e. _multiple_ scalar dimensions are; contracted, but one is left. Parameters; ----------; inplace: bool, optional; If ``True``, modify the dimensions in place. If ``False``, return; a copied object. Returns; -------; out: :class:`.Qobj`; Quantum object with dimensions contracted. Will be ``self`` if; ``inplace`` is ``True``.; """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:440,Integrability,contract,contracted,440,"""""""; Contract subspaces of the tensor structure which are 1D. Not defined; on superoperators. If all dimensions are scalar, a Qobj of dimension; [[1], [1]] is returned, i.e. _multiple_ scalar dimensions are; contracted, but one is left. Parameters; ----------; inplace: bool, optional; If ``True``, modify the dimensions in place. If ``False``, return; a copied object. Returns; -------; out: :class:`.Qobj`; Quantum object with dimensions contracted. Will be ``self`` if; ``inplace`` is ``True``.; """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:100,Availability,toler,tolerance,100,"""""""; Removes small elements from the quantum object. Parameters; ----------; atol : float; Absolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns; -------; oper : :class:`.Qobj`; Quantum object with small elements removed.; """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:278,Usability,simpl,simply,278,"""""""Truncates negative eigenvalues and renormalizes. Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters; ----------; method : str; Algorithm to use to remove negative eigenvalues. ""clip""; simply discards negative eigenvalues, then renormalizes.; ""sgs"" uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns; -------; oper : :class:`.Qobj`; A valid density operator.; """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:378,Energy Efficiency,efficient,efficient,378,"""""""Calculates a matrix element. Gives the matrix element for the quantum object sandwiched between a; `bra` and `ket` vector. Parameters; ----------; bra : :class:`.Qobj`; Quantum object of type 'bra' or 'ket'. ket : :class:`.Qobj`; Quantum object of type 'ket'. Returns; -------; elem : complex; Complex valued matrix element. Notes; -----; It is slightly more computationally efficient to use a ket; vector for the 'bra' input. """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:449,Availability,toler,tolerance,449,"""""""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). phase_fix : int, None; If not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:519,Performance,perform,performed,519,"""""""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). phase_fix : int, None; If not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:436,Availability,toler,tolerance,436,"""""""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:507,Performance,perform,performed,507,"""""""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:279,Availability,toler,tolerance,279,"""""""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it.; """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:350,Performance,perform,performed,350,"""""""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it.; """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:389,Safety,safe,safe,389,"""""""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it.; """"""",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:87,Availability,error,errors,87,"# This tol should be less strick than the tol for the eigensolver; # so it's numerical errors are not seens as degenerate states.",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:26,Performance,cache,cached,26,"# FIXME: this needs to be cached in the same ways as isherm.",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:26,Performance,cache,cached,26,"# FIXME: this needs to be cached in the same ways as isherm.",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:9,Testability,test,test,9,"# We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence preserves; # the CP and TP conditions.",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:54,Testability,test,test,54,"# Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:65,Integrability,depend,dependencies,65,"# TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:50,Safety,avoid,avoid,50,"# TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.",MatchSource.CODE_COMMENT,qutip/core/qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py:35,Modifiability,variab,variables,35,"# Start assembling constraints and variables.",MatchSource.CODE_COMMENT,qutip/core/semidefinite.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py:17,Modifiability,variab,variable,17,"# Make a complex variable for X.",MatchSource.CODE_COMMENT,qutip/core/semidefinite.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py:15,Modifiability,variab,variables,15,"# Make complex variables for rho0 and rho1.",MatchSource.CODE_COMMENT,qutip/core/semidefinite.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py:26,Integrability,depend,depends,26,"# The objective, however, depends on J.",MatchSource.CODE_COMMENT,qutip/core/semidefinite.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py:26,Integrability,depend,depends,26,"# The objective, however, depends on J.",MatchSource.CODE_COMMENT,qutip/core/semidefinite.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py:52,Testability,log,logic,52,"# Promote all parameters to Space to simplify later logic.",MatchSource.CODE_COMMENT,qutip/core/states.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py:37,Usability,simpl,simplify,37,"# Promote all parameters to Space to simplify later logic.",MatchSource.CODE_COMMENT,qutip/core/states.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py:7,Availability,down,down,7,"# spin down",MatchSource.CODE_COMMENT,qutip/core/states.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py:412,Availability,down,down,412,"""""""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int or list of ints, default: 2; Space dimension for each particle:; int if there are the same, list if they are different. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; ket : qobj. Examples; --------; >>> ket(""10"") # doctest: +SKIP; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue"") # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3) # doctest: +SKIP; Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]) # doctest: +SKIP; Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""",MatchSource.CODE_COMMENT,qutip/core/states.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py:412,Availability,down,down,412,"""""""; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:. - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization). Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; bra : qobj. Examples; --------; >>> bra(""10"") # doctest: +SKIP; Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue"") # doctest: +SKIP; Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3) # doctest: +SKIP; Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]) # doctest: +SKIP; Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]; """"""",MatchSource.CODE_COMMENT,qutip/core/states.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py:255,Safety,avoid,avoid,255,"# From here on, excitations is not None; # General idea of algorithm: add excitations one by one in last mode (idx =; # len(dims)-1), and carry over to the next index when the limit is reached.; # Keep track of the number of excitations while doing so to avoid having to; # do explicit sums over the states.",MatchSource.CODE_COMMENT,qutip/core/states.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:111,Modifiability,enhance,enhance,111,"#; # This code was contributed by Ben Criger. Resemblance to; # partial_transpose is intentional, and meant to enhance legibility.; #",MatchSource.CODE_COMMENT,qutip/core/subsystem_apply.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:94,Availability,mask,mask,94,"""""""; Returns the result of applying the propagator `channel` to the; subsystems indicated in `mask`, which comprise the density operator; `state`. Parameters; ----------; state : :class:`.Qobj`; A density matrix or ket. channel : :class:`.Qobj`; A propagator, either an `oper` or `super`. mask : *list* / *array*; A mask that selects which subsystems should be subjected to the; channel. reference : bool; Decides whether explicit Kraus map should be used to evaluate action; of channel. Returns; -------; rho_out: :class:`.Qobj`; A density matrix with the selected subsystems transformed; according to the specified channel.; """"""",MatchSource.CODE_COMMENT,qutip/core/subsystem_apply.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:289,Availability,mask,mask,289,"""""""; Returns the result of applying the propagator `channel` to the; subsystems indicated in `mask`, which comprise the density operator; `state`. Parameters; ----------; state : :class:`.Qobj`; A density matrix or ket. channel : :class:`.Qobj`; A propagator, either an `oper` or `super`. mask : *list* / *array*; A mask that selects which subsystems should be subjected to the; channel. reference : bool; Decides whether explicit Kraus map should be used to evaluate action; of channel. Returns; -------; rho_out: :class:`.Qobj`; A density matrix with the selected subsystems transformed; according to the specified channel.; """"""",MatchSource.CODE_COMMENT,qutip/core/subsystem_apply.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:316,Availability,mask,mask,316,"""""""; Returns the result of applying the propagator `channel` to the; subsystems indicated in `mask`, which comprise the density operator; `state`. Parameters; ----------; state : :class:`.Qobj`; A density matrix or ket. channel : :class:`.Qobj`; A propagator, either an `oper` or `super`. mask : *list* / *array*; A mask that selects which subsystems should be subjected to the; channel. reference : bool; Decides whether explicit Kraus map should be used to evaluate action; of channel. Returns; -------; rho_out: :class:`.Qobj`; A density matrix with the selected subsystems transformed; according to the specified channel.; """"""",MatchSource.CODE_COMMENT,qutip/core/subsystem_apply.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:18,Energy Efficiency,efficient,efficient,18,"# TODO Write more efficient code for single-matrix map on pure states; # TODO Write more efficient code for single-subsystem map . . .",MatchSource.CODE_COMMENT,qutip/core/subsystem_apply.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:89,Energy Efficiency,efficient,efficient,89,"# TODO Write more efficient code for single-matrix map on pure states; # TODO Write more efficient code for single-subsystem map . . .",MatchSource.CODE_COMMENT,qutip/core/subsystem_apply.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:57,Availability,mask,mask,57,"""""""; Applies a channel to every subsystem indicated by a mask, by; repeatedly applying the channel to each affected subsystem.; """"""",MatchSource.CODE_COMMENT,qutip/core/subsystem_apply.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:63,Availability,mask,mask,63,"# checked affected subsystems print arange(len(state.dims[0]))[mask]",MatchSource.CODE_COMMENT,qutip/core/subsystem_apply.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:95,Energy Efficiency,reduce,reduced,95,"""""""; Applies a channel to a state on one subsystem, by breaking it into; blocks and applying a reduced channel to each block.; """"""",MatchSource.CODE_COMMENT,qutip/core/subsystem_apply.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:42,Energy Efficiency,efficient,efficiently,42,"""""""; Uses scalar-matrix multiplication to efficiently apply a channel to; the leftmost register in the tensor product, given a unitary matrix; for a channel.; """"""",MatchSource.CODE_COMMENT,qutip/core/subsystem_apply.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:38,Performance,perform,perform,38,"# If the channel is a super-operator, perform second block decomposition;; # block-size matches Hilbert space of affected subsystem:; # FIXME use state shape?",MatchSource.CODE_COMMENT,qutip/core/subsystem_apply.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py:20,Integrability,depend,dependencies,20,"# To avoid circular dependencies",MatchSource.CODE_COMMENT,qutip/core/superoperator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py:5,Safety,avoid,avoid,5,"# To avoid circular dependencies",MatchSource.CODE_COMMENT,qutip/core/superoperator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py:20,Integrability,depend,dependencies,20,"# To avoid circular dependencies",MatchSource.CODE_COMMENT,qutip/core/superoperator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py:5,Safety,avoid,avoid,5,"# To avoid circular dependencies",MatchSource.CODE_COMMENT,qutip/core/superoperator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py:1116,Integrability,mediat,mediated,1116,"""""""; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. .. math::. \\mathcal{D}[a,b]\\rho = a \\rho b^\\dagger -; \\frac{1}{2}a^\\dagger b\\rho - \\frac{1}{2}\\rho a^\\dagger b. Parameters; ----------; a : Qobj or QobjEvo; Left part of collapse operator. b : Qobj or QobjEvo, optional; Right part of collapse operator. If not specified, b defaults to a. chi : float, optional; In some systems it is possible to determine the statistical moments; (mean, variance, etc) of the probability distribution of the occupation; numbers of states by numerically evaluating the derivatives of the; steady state occupation probability as a function of an artificial; phase parameter ``chi`` which multiplies the ``a \\rho a^dagger`` term; of the dissipator by ``e ^ (i * chi)``. The factor ``e ^ (i * chi)`` is; introduced via the generating function of the statistical moments. For; examples of the technique, see `Full counting statistics of; nano-electromechanical systems; <https://arxiv.org/abs/cond-mat/0410322>`_ and `Photon-mediated; electron transport in hybrid circuit-QED; <https://arxiv.org/abs/1303.7449>`_. This parameter is deprecated and; may be removed in QuTiP 5. data_only : bool, default: False; Return the data object instead of a Qobj. Returns; -------; D : qobj, QobjEvo; Lindblad dissipator superoperator.; """"""",MatchSource.CODE_COMMENT,qutip/core/superoperator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py:20,Integrability,depend,dependencies,20,"# To avoid circular dependencies",MatchSource.CODE_COMMENT,qutip/core/superoperator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py:5,Safety,avoid,avoid,5,"# To avoid circular dependencies",MatchSource.CODE_COMMENT,qutip/core/superoperator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py:20,Integrability,depend,dependencies,20,"# To avoid circular dependencies",MatchSource.CODE_COMMENT,qutip/core/superoperator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py:5,Safety,avoid,avoid,5,"# To avoid circular dependencies",MatchSource.CODE_COMMENT,qutip/core/superoperator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py:30,Integrability,rout,routines,30,"# TODO: revisit when creation routines have dispatching.",MatchSource.CODE_COMMENT,qutip/core/superop_reps.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py:105,Energy Efficiency,efficient,efficient,105,"# Construct the Pauli basis by vertically stacking rows in sparse format.; # The CSR format is much more efficient at handling row-stacking, so we; # actually have to do a little dance through adjoint/transpose to get it; # into the right format.",MatchSource.CODE_COMMENT,qutip/core/superop_reps.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py:59,Energy Efficiency,power,powers,59,"""""""; Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""",MatchSource.CODE_COMMENT,qutip/core/superop_reps.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py:263,Energy Efficiency,power,power,263,"""""""; Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""",MatchSource.CODE_COMMENT,qutip/core/superop_reps.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py:123,Modifiability,extend,extend,123,"""""""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""",MatchSource.CODE_COMMENT,qutip/core/superop_reps.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py:104,Modifiability,extend,extend,104,"""""""; Converts a Chi matrix to a Choi matrix. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""",MatchSource.CODE_COMMENT,qutip/core/superop_reps.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py:103,Availability,down,down,103,"# We use U * S since S is 1-index, such that this is equivalent to; # U . diag(S), but easier to write down.",MatchSource.CODE_COMMENT,qutip/core/superop_reps.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py:102,Integrability,contract,contraction,102,"# axis_idxs.index effectively evaluates the mapping from original index; # labels to the labels after contraction.",MatchSource.CODE_COMMENT,qutip/core/tensor.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py:195,Integrability,contract,contract,195,"""""""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------; qobj: Qobj; Operator to contract subspaces on. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""",MatchSource.CODE_COMMENT,qutip/core/tensor.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py:343,Integrability,contract,contracted,343,"""""""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------; qobj: Qobj; Operator to contract subspaces on. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""",MatchSource.CODE_COMMENT,qutip/core/tensor.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py:432,Integrability,contract,contracted,432,"""""""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------; qobj: Qobj; Operator to contract subspaces on. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""",MatchSource.CODE_COMMENT,qutip/core/tensor.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py:147,Integrability,contract,contracting,147,"# Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.",MatchSource.CODE_COMMENT,qutip/core/tensor.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py:13,Integrability,contract,contracted,13,"# Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.",MatchSource.CODE_COMMENT,qutip/core/tensor.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py:2,Energy Efficiency,allocate,allocate,2,"# allocate the rest qutbits (not targets) to the empty; # position in new_order",MatchSource.CODE_COMMENT,qutip/core/tensor.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/bench_openmp.py:2,Modifiability,coupling,coupling,2,"# coupling strength",MatchSource.CODE_COMMENT,qutip/core/cy/openmp/bench_openmp.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/bench_openmp.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/bench_openmp.py:16,Energy Efficiency,energy,energy,16,"# array of spin energy splittings and coupling strengths. here we use; # uniform parameters, but in general we don't have too",MatchSource.CODE_COMMENT,qutip/core/cy/openmp/bench_openmp.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/bench_openmp.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/bench_openmp.py:38,Modifiability,coupling,coupling,38,"# array of spin energy splittings and coupling strengths. here we use; # uniform parameters, but in general we don't have too",MatchSource.CODE_COMMENT,qutip/core/cy/openmp/bench_openmp.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/bench_openmp.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/bench_openmp.py:2,Energy Efficiency,energy,energy,2,"# energy splitting terms",MatchSource.CODE_COMMENT,qutip/core/cy/openmp/bench_openmp.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/bench_openmp.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/utilities.py:229,Availability,avail,available,229,"""""""; force_omp = False; if qset.has_openmp:; if options.use_openmp is None:; options.use_openmp = True; else:; force_omp = bool(options.use_openmp); elif (not qset.has_openmp) and options.use_openmp:; raise Exception('OPENMP not available.'); else:; options.use_openmp = False; force_omp = False; # Disable OPENMP in parallel mode unless explicitly set.; if not force_omp and os.environ['QUTIP_IN_PARALLEL'] == 'TRUE':; options.use_openmp = False""""""",MatchSource.CODE_COMMENT,qutip/core/cy/openmp/utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/eigen.py:457,Availability,toler,tolerances,457,"""""""; Return eigenvalues and eigenvectors for a CSR matrix. This specialisation; may take some extra keyword arguments in addition to the full documentation; specified in :func:`.eigs`. This method is typically slower and less accurate than the dense eigenvalue; solver; you probably want that, unless memory concerns deem it impossible. Extra keyword arguments; -----------------------; tol : float (0); Tolerance for sparse eigensolver. Sufficiently small tolerances (such; as 0) cause the solver to use machine precision.; maxiter : int (100_000); Max number of iterations used by sparse eigensolver.; """"""",MatchSource.CODE_COMMENT,qutip/core/data/eigen.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/eigen.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/expm.py:54,Energy Efficiency,efficient,efficient,54,"# The scipy solvers for the Pade approximant are more efficient with the; # CSC format than the CSR one.",MatchSource.CODE_COMMENT,qutip/core/data/expm.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/expm.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/expm.py:10,Testability,log,logarithm,10,"""""""Matrix logarithm `ln(A)` for a matrix `A`.""""""",MatchSource.CODE_COMMENT,qutip/core/data/expm.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/expm.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/__init__.py:101,Availability,avail,available,101,"# Set up the data conversions that are known by us. All types covered by; # conversions will be made available for use in the dispatcher functions.",MatchSource.CODE_COMMENT,qutip/core/data/__init__.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/__init__.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/rcsolve.py:233,Modifiability,evolve,evolves,233,"""""""; Function to solve for an open quantum system using the; reaction coordinate (RC) model. Parameters; ----------; Hsys: Qobj; The system hamiltonian.; psi0: Qobj; Initial state of the system.; tlist: List.; Time over which system evolves.; e_ops: list of :class:`.Qobj` / callback function single; Single operator or list of operators for which to evaluate; expectation values.; Q: Qobj; The coupling between system and bath.; wc: Float; Cutoff frequency.; alpha: Float; Coupling strength.; N: Integer; Number of cavity fock states.; w_th: Float; Temperature.; sparse: Boolean; Optional argument to call the sparse eigenstates solver if needed.; options : dict; Options for the solver. Returns; -------; output: Result; System evolution.; """"""",MatchSource.CODE_COMMENT,qutip/legacy/rcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/rcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/rcsolve.py:395,Modifiability,coupling,coupling,395,"""""""; Function to solve for an open quantum system using the; reaction coordinate (RC) model. Parameters; ----------; Hsys: Qobj; The system hamiltonian.; psi0: Qobj; Initial state of the system.; tlist: List.; Time over which system evolves.; e_ops: list of :class:`.Qobj` / callback function single; Single operator or list of operators for which to evaluate; expectation values.; Q: Qobj; The coupling between system and bath.; wc: Float; Cutoff frequency.; alpha: Float; Coupling strength.; N: Integer; Number of cavity fock states.; w_th: Float; Temperature.; sparse: Boolean; Optional argument to call the sparse eigenstates solver if needed.; options : dict; Options for the solver. Returns; -------; output: Result; System evolution.; """"""",MatchSource.CODE_COMMENT,qutip/legacy/rcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/rcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/rcsolve.py:22,Modifiability,coupling,coupling,22,"# reaction coordinate coupling",MatchSource.CODE_COMMENT,qutip/legacy/rcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/rcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:125,Usability,feedback,feedback,125,"""""""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """"""",MatchSource.CODE_COMMENT,qutip/legacy/nonmarkov/memorycascade.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:913,Deployability,integrat,integrator,913,"""""""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`.Qobj` / list of :class:`.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be; faster for long times (i.e., large Hilbert space). options : dict; Generic solver options.; """"""",MatchSource.CODE_COMMENT,qutip/legacy/nonmarkov/memorycascade.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:913,Integrability,integrat,integrator,913,"""""""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`.Qobj` / list of :class:`.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be; faster for long times (i.e., large Hilbert space). options : dict; Generic solver options.; """"""",MatchSource.CODE_COMMENT,qutip/legacy/nonmarkov/memorycascade.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:267,Modifiability,coupling,coupling,267,"""""""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`.Qobj` / list of :class:`.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be; faster for long times (i.e., large Hilbert space). options : dict; Generic solver options.; """"""",MatchSource.CODE_COMMENT,qutip/legacy/nonmarkov/memorycascade.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:413,Modifiability,coupling,coupling,413,"""""""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`.Qobj` / list of :class:`.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be; faster for long times (i.e., large Hilbert space). options : dict; Generic solver options.; """"""",MatchSource.CODE_COMMENT,qutip/legacy/nonmarkov/memorycascade.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:100,Usability,feedback,feedback,100,"""""""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`.Qobj` / list of :class:`.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be; faster for long times (i.e., large Hilbert space). options : dict; Generic solver options.; """"""",MatchSource.CODE_COMMENT,qutip/legacy/nonmarkov/memorycascade.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:285,Usability,feedback,feedback,285,"""""""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`.Qobj` / list of :class:`.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be; faster for long times (i.e., large Hilbert space). options : dict; Generic solver options.; """"""",MatchSource.CODE_COMMENT,qutip/legacy/nonmarkov/memorycascade.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:433,Usability,feedback,feedback,433,"""""""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`.Qobj` / list of :class:`.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be; faster for long times (i.e., large Hilbert space). options : dict; Generic solver options.; """"""",MatchSource.CODE_COMMENT,qutip/legacy/nonmarkov/memorycascade.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:640,Usability,feedback,feedback,640,"""""""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`.Qobj` / list of :class:`.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be; faster for long times (i.e., large Hilbert space). options : dict; Generic solver options.; """"""",MatchSource.CODE_COMMENT,qutip/legacy/nonmarkov/memorycascade.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:460,Energy Efficiency,reduce,reduced,460,"""""""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`.Qobj`; time-propagator for reduced system dynamics; """"""",MatchSource.CODE_COMMENT,qutip/legacy/nonmarkov/memorycascade.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:342,Performance,perform,performed,342,"""""""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`.Qobj`; time-propagator for reduced system dynamics; """"""",MatchSource.CODE_COMMENT,qutip/legacy/nonmarkov/memorycascade.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:17,Energy Efficiency,reduce,reduced,17,"""""""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`.Qobj`; density matrix at time :math:`t`; """"""",MatchSource.CODE_COMMENT,qutip/legacy/nonmarkov/memorycascade.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:10,Modifiability,coupling,coupling,10,"# Cascade coupling",MatchSource.CODE_COMMENT,qutip/legacy/nonmarkov/memorycascade.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:15,Deployability,integrat,integrator,15,"""""""; Basic ode integrator; """"""",MatchSource.CODE_COMMENT,qutip/legacy/nonmarkov/memorycascade.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:15,Integrability,integrat,integrator,15,"""""""; Basic ode integrator; """"""",MatchSource.CODE_COMMENT,qutip/legacy/nonmarkov/memorycascade.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py:146,Integrability,depend,depending,146,"""""""; Check if the input matrix is diagonal. Parameters; ==========; mat: ndarray/Qobj; A 2D numpy array. Returns; =======; diag: bool; True/False depending on whether the input matrix is diagonal.; """"""",MatchSource.CODE_COMMENT,qutip/piqs/piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py:246,Deployability,integrat,integrate,246,"""""""; Solve for diagonal Hamiltonians and initial states faster. Parameters; ==========; initial_state : :class:`.Qobj`; An initial state specified as a density matrix of; `qutip.Qbj` type. tlist: ndarray; A 1D numpy array of list of timesteps to integrate. Returns; =======; result: list; A dictionary of the type `qutip.piqs.Result` which holds the; results of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip/piqs/piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py:246,Integrability,integrat,integrate,246,"""""""; Solve for diagonal Hamiltonians and initial states faster. Parameters; ==========; initial_state : :class:`.Qobj`; An initial state specified as a density matrix of; `qutip.Qbj` type. tlist: ndarray; A 1D numpy array of list of timesteps to integrate. Returns; =======; result: list; A dictionary of the type `qutip.piqs.Result` which holds the; results of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip/piqs/piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py:50,Energy Efficiency,energy,energy,50,"""""""Calculate the number of Dicke states with same energy. The use of the ``Decimals`` class allows to explore N > 1000,; unlike the built-in function ``scipy.special.binom``. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""",MatchSource.CODE_COMMENT,qutip/piqs/piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py:326,Energy Efficiency,energy,energy,326,"""""""Calculate the number of Dicke states with same energy. The use of the ``Decimals`` class allows to explore N > 1000,; unlike the built-in function ``scipy.special.binom``. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""",MatchSource.CODE_COMMENT,qutip/piqs/piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py:373,Energy Efficiency,energy,energy,373,"""""""Calculate the number of Dicke states with same energy. The use of the ``Decimals`` class allows to explore N > 1000,; unlike the built-in function ``scipy.special.binom``. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""",MatchSource.CODE_COMMENT,qutip/piqs/piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py:139,Modifiability,evolve,evolves,139,"""""""; The Permutation Invariant Matrix class. Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state `p` as:. dp/dt = Mp. Parameters; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. collective_dephasing: float; Collective dephasing coefficient.; default: 0.0. Attributes; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_dephasing: float; Collective dephasing coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. M: dict; A nested dictionary of the structure {row: {col: val}} which holds; non zero elements of the matrix M; """"""",MatchSource.CODE_COMMENT,qutip/piqs/piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py:178,Usability,simpl,simple,178,"""""""; Generate the matrix M governing the dynamics for diagonal cases. If the initial density matrix and the Hamiltonian is diagonal, the; evolution of the system is given by the simple ODE: dp/dt = Mp.; """"""",MatchSource.CODE_COMMENT,qutip/piqs/piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:2918,Availability,error,errors,2918,"or which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; List of collapse operators. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. The key ``w`` is reserved for the spectra function. sec_cutoff : float, default: 0.1; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : flo",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3153,Availability,error,error,3153," format), optional; List of collapse operators. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. The key ``w`` is reserved for the spectra function. sec_cutoff : float, default: 0.1; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Retur",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3733,Availability,toler,tolerance,3733," Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by ``tlist``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3167,Deployability,install,installed,3167," format), optional; List of collapse operators. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. The key ``w`` is reserved for the spectra function. sec_cutoff : float, default: 0.1; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Retur",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3657,Deployability,integrat,integration,3657," Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by ``tlist``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3754,Deployability,integrat,integrator,3754," Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by ``tlist``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:4060,Deployability,integrat,integration,4060," Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by ``tlist``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3470,Energy Efficiency,efficient,efficient,3470," Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by ``tlist``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:307,Integrability,depend,dependent,307,"""""""; Solves for the dynamics of a system using the Bloch-Redfield master; equation, given an input Hamiltonian, Hermitian bath-coupling terms and; their associated spectral functions, as well as possible Lindblad collapse; operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, str, func; The corresponding bath spectral responce.; Can be a `Coefficient` using an 'w' args, a function of the; frequence or a string. Coefficient build from a numpy array are; understood as a function of ``w`` instead of ``t``. Function are; expected to be of the signature ``f(w)`` or ``f(t, w, **args)``. The spectra function can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. .. note:; ``Cubic_Spline`` has been replaced by :obj:`.Coefficient`:; ``spline = qutip.coefficient(array, tlist=times)``. Whether the ``a_ops`` is time dependent is decided by the type of; the operator: :obj:`.Qobj` vs :obj:`.QobjEvo` instead of the type; of the spectra. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, sta",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:1206,Integrability,depend,depend,1206," operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, str, func; The corresponding bath spectral responce.; Can be a `Coefficient` using an 'w' args, a function of the; frequence or a string. Coefficient build from a numpy array are; understood as a function of ``w`` instead of ``t``. Function are; expected to be of the signature ``f(w)`` or ``f(t, w, **args)``. The spectra function can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. .. note:; ``Cubic_Spline`` has been replaced by :obj:`.Coefficient`:; ``spline = qutip.coefficient(array, tlist=times)``. Whether the ``a_ops`` is time dependent is decided by the type of; the operator: :obj:`.Qobj` vs :obj:`.QobjEvo` instead of the type; of the spectra. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; List of collapse operators. args : dict, optional; Dictionary of para",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:1664,Integrability,depend,dependent,1664,"ouple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, str, func; The corresponding bath spectral responce.; Can be a `Coefficient` using an 'w' args, a function of the; frequence or a string. Coefficient build from a numpy array are; understood as a function of ``w`` instead of ``t``. Function are; expected to be of the signature ``f(w)`` or ``f(t, w, **args)``. The spectra function can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. .. note:; ``Cubic_Spline`` has been replaced by :obj:`.Coefficient`:; ``spline = qutip.coefficient(array, tlist=times)``. Whether the ``a_ops`` is time dependent is decided by the type of; the operator: :obj:`.Qobj` vs :obj:`.QobjEvo` instead of the type; of the spectra. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; List of collapse operators. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. The key ``w`` is reserved for the spectra function. sec_cutoff : float, default: 0.1; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:2239,Integrability,depend,dependent,2239,"esponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. .. note:; ``Cubic_Spline`` has been replaced by :obj:`.Coefficient`:; ``spline = qutip.coefficient(array, tlist=times)``. Whether the ``a_ops`` is time dependent is decided by the type of; the operator: :obj:`.Qobj` vs :obj:`.QobjEvo` instead of the type; of the spectra. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; List of collapse operators. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. The key ``w`` is reserved for the spectra function. sec_cutoff : float, default: 0.1; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progres",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3657,Integrability,integrat,integration,3657," Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by ``tlist``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3754,Integrability,integrat,integrator,3754," Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by ``tlist``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:4043,Integrability,depend,depending,4043," Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by ``tlist``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:4060,Integrability,integrat,integration,4060," Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by ``tlist``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:127,Modifiability,coupling,coupling,127,"""""""; Solves for the dynamics of a system using the Bloch-Redfield master; equation, given an input Hamiltonian, Hermitian bath-coupling terms and; their associated spectral functions, as well as possible Lindblad collapse; operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, str, func; The corresponding bath spectral responce.; Can be a `Coefficient` using an 'w' args, a function of the; frequence or a string. Coefficient build from a numpy array are; understood as a function of ``w`` instead of ``t``. Function are; expected to be of the signature ``f(w)`` or ``f(t, w, **args)``. The spectra function can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. .. note:; ``Cubic_Spline`` has been replaced by :obj:`.Coefficient`:; ``spline = qutip.coefficient(array, tlist=times)``. Whether the ``a_ops`` is time dependent is decided by the type of; the operator: :obj:`.Qobj` vs :obj:`.QobjEvo` instead of the type; of the spectra. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, sta",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:791,Modifiability,coupling,coupling,791,"""""""; Solves for the dynamics of a system using the Bloch-Redfield master; equation, given an input Hamiltonian, Hermitian bath-coupling terms and; their associated spectral functions, as well as possible Lindblad collapse; operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, str, func; The corresponding bath spectral responce.; Can be a `Coefficient` using an 'w' args, a function of the; frequence or a string. Coefficient build from a numpy array are; understood as a function of ``w`` instead of ``t``. Function are; expected to be of the signature ``f(w)`` or ``f(t, w, **args)``. The spectra function can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. .. note:; ``Cubic_Spline`` has been replaced by :obj:`.Coefficient`:; ``spline = qutip.coefficient(array, tlist=times)``. Whether the ``a_ops`` is time dependent is decided by the type of; the operator: :obj:`.Qobj` vs :obj:`.QobjEvo` instead of the type; of the spectra. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, sta",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:2477,Modifiability,coupling,coupling,2477,".dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. .. note:; ``Cubic_Spline`` has been replaced by :obj:`.Coefficient`:; ``spline = qutip.coefficient(array, tlist=times)``. Whether the ``a_ops`` is time dependent is decided by the type of; the operator: :obj:`.Qobj` vs :obj:`.QobjEvo` instead of the type; of the spectra. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; List of collapse operators. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. The key ``w`` is reserved for the spectra function. sec_cutoff : float, default: 0.1; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse'",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3030,Modifiability,enhance,enhanced,3030,"etail of operator expectation. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; List of collapse operators. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. The key ``w`` is reserved for the spectra function. sec_cutoff : float, default: 0.1; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported ",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:193,Integrability,depend,dependent,193,"""""""; Bloch Redfield equation evolution of a density matrix for a given; Hamiltonian and set of bath coupling operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`; The corresponding bath spectra. As a `Coefficient` using an 'w'; args. Can depend on ``t`` only if a_op is a :obj:`.QobjEvo`.; :obj:`SpectraCoefficient` can be used to conver a coefficient; depending on ``t`` to one depending on ``w``. Example:. .. code-block::. a_ops = [; (a+a.dag(), coefficient('w>0', args={'w':0})),; (QobjEvo([b+b.dag(), lambda t: ...]),; coefficient(lambda t, w: ...), args={""w"": 0}),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list of :obj:`.Qobj`, :obj:`.QobjEvo`; Single collapse operator, or list of collapse operators, or a list; of Lindblad dissipator. None is equivalent to an empty list. options : dict, optional; Options for the solver, see :obj:`BRSolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. Attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:713,Integrability,depend,depend,713,"""""""; Bloch Redfield equation evolution of a density matrix for a given; Hamiltonian and set of bath coupling operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`; The corresponding bath spectra. As a `Coefficient` using an 'w'; args. Can depend on ``t`` only if a_op is a :obj:`.QobjEvo`.; :obj:`SpectraCoefficient` can be used to conver a coefficient; depending on ``t`` to one depending on ``w``. Example:. .. code-block::. a_ops = [; (a+a.dag(), coefficient('w>0', args={'w':0})),; (QobjEvo([b+b.dag(), lambda t: ...]),; coefficient(lambda t, w: ...), args={""w"": 0}),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list of :obj:`.Qobj`, :obj:`.QobjEvo`; Single collapse operator, or list of collapse operators, or a list; of Lindblad dissipator. None is equivalent to an empty list. options : dict, optional; Options for the solver, see :obj:`BRSolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. Attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:828,Integrability,depend,depending,828,"""""""; Bloch Redfield equation evolution of a density matrix for a given; Hamiltonian and set of bath coupling operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`; The corresponding bath spectra. As a `Coefficient` using an 'w'; args. Can depend on ``t`` only if a_op is a :obj:`.QobjEvo`.; :obj:`SpectraCoefficient` can be used to conver a coefficient; depending on ``t`` to one depending on ``w``. Example:. .. code-block::. a_ops = [; (a+a.dag(), coefficient('w>0', args={'w':0})),; (QobjEvo([b+b.dag(), lambda t: ...]),; coefficient(lambda t, w: ...), args={""w"": 0}),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list of :obj:`.Qobj`, :obj:`.QobjEvo`; Single collapse operator, or list of collapse operators, or a list; of Lindblad dissipator. None is equivalent to an empty list. options : dict, optional; Options for the solver, see :obj:`BRSolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. Attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:854,Integrability,depend,depending,854,"""""""; Bloch Redfield equation evolution of a density matrix for a given; Hamiltonian and set of bath coupling operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`; The corresponding bath spectra. As a `Coefficient` using an 'w'; args. Can depend on ``t`` only if a_op is a :obj:`.QobjEvo`.; :obj:`SpectraCoefficient` can be used to conver a coefficient; depending on ``t`` to one depending on ``w``. Example:. .. code-block::. a_ops = [; (a+a.dag(), coefficient('w>0', args={'w':0})),; (QobjEvo([b+b.dag(), lambda t: ...]),; coefficient(lambda t, w: ...), args={""w"": 0}),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list of :obj:`.Qobj`, :obj:`.QobjEvo`; Single collapse operator, or list of collapse operators, or a list; of Lindblad dissipator. None is equivalent to an empty list. options : dict, optional; Options for the solver, see :obj:`BRSolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. Attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:100,Modifiability,coupling,coupling,100,"""""""; Bloch Redfield equation evolution of a density matrix for a given; Hamiltonian and set of bath coupling operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`; The corresponding bath spectra. As a `Coefficient` using an 'w'; args. Can depend on ``t`` only if a_op is a :obj:`.QobjEvo`.; :obj:`SpectraCoefficient` can be used to conver a coefficient; depending on ``t`` to one depending on ``w``. Example:. .. code-block::. a_ops = [; (a+a.dag(), coefficient('w>0', args={'w':0})),; (QobjEvo([b+b.dag(), lambda t: ...]),; coefficient(lambda t, w: ...), args={""w"": 0}),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list of :obj:`.Qobj`, :obj:`.QobjEvo`; Single collapse operator, or list of collapse operators, or a list; of Lindblad dissipator. None is equivalent to an empty list. options : dict, optional; Options for the solver, see :obj:`BRSolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. Attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:559,Modifiability,coupling,coupling,559,"""""""; Bloch Redfield equation evolution of a density matrix for a given; Hamiltonian and set of bath coupling operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`; The corresponding bath spectra. As a `Coefficient` using an 'w'; args. Can depend on ``t`` only if a_op is a :obj:`.QobjEvo`.; :obj:`SpectraCoefficient` can be used to conver a coefficient; depending on ``t`` to one depending on ``w``. Example:. .. code-block::. a_ops = [; (a+a.dag(), coefficient('w>0', args={'w':0})),; (QobjEvo([b+b.dag(), lambda t: ...]),; coefficient(lambda t, w: ...), args={""w"": 0}),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list of :obj:`.Qobj`, :obj:`.QobjEvo`; Single collapse operator, or list of collapse operators, or a list; of Lindblad dissipator. None is equivalent to an empty list. options : dict, optional; Options for the solver, see :obj:`BRSolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. Attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:1573,Modifiability,coupling,coupling,1573,"""""""; Bloch Redfield equation evolution of a density matrix for a given; Hamiltonian and set of bath coupling operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`; The corresponding bath spectra. As a `Coefficient` using an 'w'; args. Can depend on ``t`` only if a_op is a :obj:`.QobjEvo`.; :obj:`SpectraCoefficient` can be used to conver a coefficient; depending on ``t`` to one depending on ``w``. Example:. .. code-block::. a_ops = [; (a+a.dag(), coefficient('w>0', args={'w':0})),; (QobjEvo([b+b.dag(), lambda t: ...]),; coefficient(lambda t, w: ...), args={""w"": 0}),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list of :obj:`.Qobj`, :obj:`.QobjEvo`; Single collapse operator, or list of collapse operators, or a list; of Lindblad dissipator. None is equivalent to an empty list. options : dict, optional; Options for the solver, see :obj:`BRSolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. Attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:420,Availability,error,errors,420,"""""""; Options for bloch redfield solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error if; not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. tensor_type: str ['sparse', 'dense', 'data'], default: ""sparse""; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. sparse_eigensolver: bool, default: False; Whether to use the sparse eigensolver. method: str, default: ""adams""; Which ODE integrator methods are supported.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:590,Availability,error,error,590,"""""""; Options for bloch redfield solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error if; not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. tensor_type: str ['sparse', 'dense', 'data'], default: ""sparse""; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. sparse_eigensolver: bool, default: False; Whether to use the sparse eigensolver. method: str, default: ""adams""; Which ODE integrator methods are supported.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:604,Deployability,install,installed,604,"""""""; Options for bloch redfield solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error if; not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. tensor_type: str ['sparse', 'dense', 'data'], default: ""sparse""; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. sparse_eigensolver: bool, default: False; Whether to use the sparse eigensolver. method: str, default: ""adams""; Which ODE integrator methods are supported.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:1077,Deployability,integrat,integrator,1077,"""""""; Options for bloch redfield solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error if; not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. tensor_type: str ['sparse', 'dense', 'data'], default: ""sparse""; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. sparse_eigensolver: bool, default: False; Whether to use the sparse eigensolver. method: str, default: ""adams""; Which ODE integrator methods are supported.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:944,Energy Efficiency,efficient,efficient,944,"""""""; Options for bloch redfield solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error if; not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. tensor_type: str ['sparse', 'dense', 'data'], default: ""sparse""; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. sparse_eigensolver: bool, default: False; Whether to use the sparse eigensolver. method: str, default: ""adams""; Which ODE integrator methods are supported.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:1077,Integrability,integrat,integrator,1077,"""""""; Options for bloch redfield solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error if; not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. tensor_type: str ['sparse', 'dense', 'data'], default: ""sparse""; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. sparse_eigensolver: bool, default: False; Whether to use the sparse eigensolver. method: str, default: ""adams""; Which ODE integrator methods are supported.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:456,Modifiability,enhance,enhanced,456,"""""""; Options for bloch redfield solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error if; not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. tensor_type: str ['sparse', 'dense', 'data'], default: ""sparse""; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. sparse_eigensolver: bool, default: False; Whether to use the sparse eigensolver. method: str, default: ""adams""; Which ODE integrator methods are supported.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:628,Deployability,integrat,integration,628,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": BRMESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. .. note::. The state will not be in the lab basis, but in the evolution basis. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:49,Integrability,depend,dependent,49,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": BRMESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. .. note::. The state will not be in the lab basis, but in the evolution basis. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:611,Integrability,depend,depending,611,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": BRMESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. .. note::. The state will not be in the lab basis, but in the evolution basis. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:628,Integrability,integrat,integration,628,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": BRMESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. .. note::. The state will not be in the lab basis, but in the evolution basis. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/countstat.py:1889,Availability,avail,available,1889,"s in `L`, but the `c_ops` given here does not; necessarily need to be all collapse operators contributing to dissipation; in the Liouvillian. Optionally, the steadystate density matrix `rhoss`; and the current operators `J_ops` correpsonding to the current collapse; operators `c_ops` can also be specified. If either of; `rhoss` and `J_ops` are omitted, they will be computed internally.; 'wlist' is an optional list of frequencies at which to evaluate the noise; spectrum. Parameters; ----------. L : :class:`.Qobj`; Qobj representing the system Liouvillian. c_ops : array / list; List of current collapse operators. rhoss : :class:`.Qobj` (optional); The steadystate density matrix corresponding the system Liouvillian; `L`. wlist : array / list (optional); List of frequencies at which to evaluate (if none are given, evaluates; at zero frequency). J_ops : array / list (optional); List of current superoperators. sparse : bool [True]; Flag that indicates whether to use sparse or dense matrix methods when; computing the pseudo inverse. Default is false, as sparse solvers; can fail for small systems. For larger systems the sparse solvers; are recommended. method : str, ['direct']; Method used to compute the noise. The default, 'direct' with; ``sparse=True``, compute the noise directly. It is the recommended; method for larger systems. Otherwise, the pseudo inverse is computed; using the given method. Pseudo inverse supports 'splu' and 'spilu' for; sparse matrices and 'direct', 'scipy' and 'numpy' methods for; ``sparse=False``. .. note::; The algoryth is described in page 67 of ""Electrons in nanostructures""; C. Flindt, PhD Thesis, available online:; https://orbit.dtu.dk/en/publications/electrons-in-nanostructures-coherent-manipulation-and-counting-st. Returns; --------; I, S : tuple of arrays; The currents `I` corresponding to each current collapse operator; `c_ops` (or, equivalently, each current superopeator `J_ops`) and the; zero-frequency cross-current correlation `S`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/countstat.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/countstat.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/countstat.py:105,Energy Efficiency,monitor,monitored,105,"""""""; Compute the cross-current noise spectrum for a list of collapse operators; `c_ops` corresponding to monitored currents, given the system; Liouvillian `L`. The current collapse operators `c_ops` should be part; of the dissipative processes in `L`, but the `c_ops` given here does not; necessarily need to be all collapse operators contributing to dissipation; in the Liouvillian. Optionally, the steadystate density matrix `rhoss`; and the current operators `J_ops` correpsonding to the current collapse; operators `c_ops` can also be specified. If either of; `rhoss` and `J_ops` are omitted, they will be computed internally.; 'wlist' is an optional list of frequencies at which to evaluate the noise; spectrum. Parameters; ----------. L : :class:`.Qobj`; Qobj representing the system Liouvillian. c_ops : array / list; List of current collapse operators. rhoss : :class:`.Qobj` (optional); The steadystate density matrix corresponding the system Liouvillian; `L`. wlist : array / list (optional); List of frequencies at which to evaluate (if none are given, evaluates; at zero frequency). J_ops : array / list (optional); List of current superoperators. sparse : bool [True]; Flag that indicates whether to use sparse or dense matrix methods when; computing the pseudo inverse. Default is false, as sparse solvers; can fail for small systems. For larger systems the sparse solvers; are recommended. method : str, ['direct']; Method used to compute the noise. The default, 'direct' with; ``sparse=True``, compute the noise directly. It is the recommended; method for larger systems. Otherwise, the pseudo inverse is computed; using the given method. Pseudo inverse supports 'splu' and 'spilu' for; sparse matrices and 'direct', 'scipy' and 'numpy' methods for; ``sparse=False``. .. note::; The algoryth is described in page 67 of ""Electrons in nanostructures""; C. Flindt, PhD Thesis, available online:; https://orbit.dtu.dk/en/publications/electrons-in-nanostructures-coherent-manipulation-and-co",MatchSource.CODE_COMMENT,qutip/solver/countstat.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/countstat.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:709,Deployability,integrat,integration,709,"""""""; Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, QobjEvo compatible format.; System Hamiltonian, with period `T`. T : float; Period of the Hamiltonian. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict [None]; Options used by sesolve to compute the floquet modes. sparse : bool [False]; Whether to use the sparse eigen solver when computing the; quasi-energies. sort : bool [True]; Whether to sort the quasi-energies. precompute : list [None]; If provided, a list of time at which to store the propagators; for later use when computing modes and states. Default is; ``linspace(0, T, 101)`` corresponding to the default integration; steps used for the floquet tensor computation.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:229,Integrability,depend,dependent,229,"""""""; Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, QobjEvo compatible format.; System Hamiltonian, with period `T`. T : float; Period of the Hamiltonian. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict [None]; Options used by sesolve to compute the floquet modes. sparse : bool [False]; Whether to use the sparse eigen solver when computing the; quasi-energies. sort : bool [True]; Whether to sort the quasi-energies. precompute : list [None]; If provided, a list of time at which to store the propagators; for later use when computing modes and states. Default is; ``linspace(0, T, 101)`` corresponding to the default integration; steps used for the floquet tensor computation.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:709,Integrability,integrat,integration,709,"""""""; Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, QobjEvo compatible format.; System Hamiltonian, with period `T`. T : float; Period of the Hamiltonian. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict [None]; Options used by sesolve to compute the floquet modes. sparse : bool [False]; Whether to use the sparse eigen solver when computing the; quasi-energies. sort : bool [True]; Whether to sort the quasi-energies. precompute : list [None]; If provided, a list of time at which to store the propagators; for later use when computing modes and states. Default is; ``linspace(0, T, 101)`` corresponding to the default integration; steps used for the floquet tensor computation.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:220,Integrability,depend,dependence,220,"""""""; Floquet-Markov master equation X matrices. Parameters; ----------; f_energies : np.ndarray; The Floquet energies. kmax : int; The truncation of the number of sidebands (default 5). T : float; The period of the time-dependence of the Hamiltonian. Returns; -------; delta : np.ndarray; Floquet delta tensor.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:350,Deployability,integrat,integration,350,"""""""; Floquet-Markov master equation X matrices. Parameters; ----------; floquet_basis : :class:`FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. c_ops : list of :obj:`.Qobj`; The collapse operators describing the dissipation. kmax : int; The truncation of the number of sidebands (default 5). ntimes : int [100]; The number of integration steps (for calculating X) within one period. Returns; -------; X : list of dict of :class:`.Data`; A dict of the sidebands ``k`` for the X matrices of each c_ops; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:134,Integrability,wrap,wrapped,134,"""""""; Floquet-Markov master equation X matrices. Parameters; ----------; floquet_basis : :class:`FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. c_ops : list of :obj:`.Qobj`; The collapse operators describing the dissipation. kmax : int; The truncation of the number of sidebands (default 5). ntimes : int [100]; The number of integration steps (for calculating X) within one period. Returns; -------; X : list of dict of :class:`.Data`; A dict of the sidebands ``k`` for the X matrices of each c_ops; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:350,Integrability,integrat,integration,350,"""""""; Floquet-Markov master equation X matrices. Parameters; ----------; floquet_basis : :class:`FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. c_ops : list of :obj:`.Qobj`; The collapse operators describing the dissipation. kmax : int; The truncation of the number of sidebands (default 5). ntimes : int [100]; The number of integration steps (for calculating X) within one period. Returns; -------; X : list of dict of :class:`.Data`; A dict of the sidebands ``k`` for the X matrices of each c_ops; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:329,Energy Efficiency,power,power,329,"""""""; Floquet-Markov master equation gamma matrices. Parameters; ----------; X : list of dict of :class:`.Data`; Floquet X matrices created by :func:`_floquet_X_matrices`. delta : np.ndarray; Floquet delta tensor created by :func:`_floquet_delta_tensor`. J_cb : list of callables; A list callback functions that compute the noise power spectrum as; a function of frequency. The list should contain one callable for each; collapse operator `c_op`, in the same order as the elements of `X`.; Each callable should accept a numpy array of frequencies and return a; numpy array of corresponding noise power. Returns; -------; gammas : dict of :class:`.Data`; A dict mapping the sidebands ``k`` to their gamma matrices.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:595,Energy Efficiency,power,power,595,"""""""; Floquet-Markov master equation gamma matrices. Parameters; ----------; X : list of dict of :class:`.Data`; Floquet X matrices created by :func:`_floquet_X_matrices`. delta : np.ndarray; Floquet delta tensor created by :func:`_floquet_delta_tensor`. J_cb : list of callables; A list callback functions that compute the noise power spectrum as; a function of frequency. The list should contain one callable for each; collapse operator `c_op`, in the same order as the elements of `X`.; Each callable should accept a numpy array of frequencies and return a; numpy array of corresponding noise power. Returns; -------; gammas : dict of :class:`.Data`; A dict mapping the sidebands ``k`` to their gamma matrices.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:803,Deployability,integrat,integration,803,"""""""; Construct a tensor that represents the master equation in the floquet; basis. Simplest RWA approximation [Grifoni et al, Phys.Rep. 304 229 (1998)]. Parameters; ----------; H : :obj:`.QobjEvo`, :obj:`.FloquetBasis`; Periodic Hamiltonian a floquet basis system. T : float, optional; The period of the time-dependence of the hamiltonian. Optional if ``H``; is a ``FloquetBasis`` object. c_ops : list of :class:`.Qobj`; list of collapse operators. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. w_th : float, default: 0.0; The temperature in units of frequency. kmax : int, default: 5; The truncation of the number of sidebands (default 5). nT : int, default: 100; The number of integration steps (for calculating X) within one period. Returns; -------; output : array; The Floquet-Markov master equation tensor `R`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:537,Energy Efficiency,power,power,537,"""""""; Construct a tensor that represents the master equation in the floquet; basis. Simplest RWA approximation [Grifoni et al, Phys.Rep. 304 229 (1998)]. Parameters; ----------; H : :obj:`.QobjEvo`, :obj:`.FloquetBasis`; Periodic Hamiltonian a floquet basis system. T : float, optional; The period of the time-dependence of the hamiltonian. Optional if ``H``; is a ``FloquetBasis`` object. c_ops : list of :class:`.Qobj`; list of collapse operators. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. w_th : float, default: 0.0; The temperature in units of frequency. kmax : int, default: 5; The truncation of the number of sidebands (default 5). nT : int, default: 100; The number of integration steps (for calculating X) within one period. Returns; -------; output : array; The Floquet-Markov master equation tensor `R`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:309,Integrability,depend,dependence,309,"""""""; Construct a tensor that represents the master equation in the floquet; basis. Simplest RWA approximation [Grifoni et al, Phys.Rep. 304 229 (1998)]. Parameters; ----------; H : :obj:`.QobjEvo`, :obj:`.FloquetBasis`; Periodic Hamiltonian a floquet basis system. T : float, optional; The period of the time-dependence of the hamiltonian. Optional if ``H``; is a ``FloquetBasis`` object. c_ops : list of :class:`.Qobj`; list of collapse operators. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. w_th : float, default: 0.0; The temperature in units of frequency. kmax : int, default: 5; The truncation of the number of sidebands (default 5). nT : int, default: 100; The number of integration steps (for calculating X) within one period. Returns; -------; output : array; The Floquet-Markov master equation tensor `R`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:803,Integrability,integrat,integration,803,"""""""; Construct a tensor that represents the master equation in the floquet; basis. Simplest RWA approximation [Grifoni et al, Phys.Rep. 304 229 (1998)]. Parameters; ----------; H : :obj:`.QobjEvo`, :obj:`.FloquetBasis`; Periodic Hamiltonian a floquet basis system. T : float, optional; The period of the time-dependence of the hamiltonian. Optional if ``H``; is a ``FloquetBasis`` object. c_ops : list of :class:`.Qobj`; list of collapse operators. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. w_th : float, default: 0.0; The temperature in units of frequency. kmax : int, default: 5; The truncation of the number of sidebands (default 5). nT : int, default: 100; The number of integration steps (for calculating X) within one period. Returns; -------; output : array; The Floquet-Markov master equation tensor `R`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:1271,Availability,error,errors,1271,"""""""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Periodic system Hamiltonian as :obj:`.QobjEvo`. List of; [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). If an operator is provided,. tlist : *list* / *array*; List of times for :math:`t`. e_ops : list of :class:`.Qobj` / callback function, optional; List of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float, default=tlist[-1]; The period of the time-dependence of the hamiltonian. args : dictionary, optional; Dictionary with variables required to evaluate H. options : dict, optional; Options for the results. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized. Returns; -------; output : :class:`.Result`; An instance of the class :class:`.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:749,Integrability,depend,dependence,749,"""""""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Periodic system Hamiltonian as :obj:`.QobjEvo`. List of; [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). If an operator is provided,. tlist : *list* / *array*; List of times for :math:`t`. e_ops : list of :class:`.Qobj` / callback function, optional; List of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float, default=tlist[-1]; The period of the time-dependence of the hamiltonian. args : dictionary, optional; Dictionary with variables required to evaluate H. options : dict, optional; Options for the results. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized. Returns; -------; output : :class:`.Result`; An instance of the class :class:`.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:825,Modifiability,variab,variables,825,"""""""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Periodic system Hamiltonian as :obj:`.QobjEvo`. List of; [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). If an operator is provided,. tlist : *list* / *array*; List of times for :math:`t`. e_ops : list of :class:`.Qobj` / callback function, optional; List of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float, default=tlist[-1]; The period of the time-dependence of the hamiltonian. args : dictionary, optional; Dictionary with variables required to evaluate H. options : dict, optional; Options for the results. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized. Returns; -------; output : :class:`.Result`; An instance of the class :class:`.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:2170,Availability,error,errors,2170,"`` indicates that the 'tlist' spans a single period of the driving. w_th : float, default: 0.0; The temperature of the environment in units of frequency.; For example, if the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-od",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:2405,Availability,error,error,2405,"s given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; the expectation values for the times specified by ``tlist``, and/or the; state density matrices corresponding to the times.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:2748,Availability,toler,tolerance,2748,"s given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; the expectation values for the times specified by ``tlist``, and/or the; state density matrices corresponding to the times.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:2419,Deployability,install,installed,2419,"s given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; the expectation values for the times specified by ``tlist``, and/or the; state density matrices corresponding to the times.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:2672,Deployability,integrat,integration,2672,"s given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; the expectation values for the times specified by ``tlist``, and/or the; state density matrices corresponding to the times.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:2769,Deployability,integrat,integrator,2769,"s given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; the expectation values for the times specified by ``tlist``, and/or the; state density matrices corresponding to the times.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:3072,Deployability,integrat,integration,3072,"s given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; the expectation values for the times specified by ``tlist``, and/or the; state density matrices corresponding to the times.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:946,Energy Efficiency,power,power,946,"""""""; Solve the dynamics for the system using the Floquet-Markov master equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Periodic system Hamiltonian as :obj:`.QobjEvo`. List of; [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 / psi0 : :class:`.Qobj`; Initial density matrix or state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. c_ops : list of :class:`.Qobj`, optional; List of collapse operators. Time dependent collapse operators are not; supported. Fall back on :func:`fsesolve` if not provided. e_ops : list of :class:`.Qobj` / callback function, optional; List of operators for which to evaluate expectation values.; The states are reverted to the lab basis before applying the. spectra_cb : list callback functions, default: ``lambda w: (w > 0)``; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float, default=tlist[-1]; The period of the time-dependence of the hamiltonian. The default value; ``0`` indicates that the 'tlist' spans a single period of the driving. w_th : float, default: 0.0; The temperature of the environment in units of frequency.; For example, if the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Wheth",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:545,Integrability,depend,dependent,545,"""""""; Solve the dynamics for the system using the Floquet-Markov master equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Periodic system Hamiltonian as :obj:`.QobjEvo`. List of; [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 / psi0 : :class:`.Qobj`; Initial density matrix or state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. c_ops : list of :class:`.Qobj`, optional; List of collapse operators. Time dependent collapse operators are not; supported. Fall back on :func:`fsesolve` if not provided. e_ops : list of :class:`.Qobj` / callback function, optional; List of operators for which to evaluate expectation values.; The states are reverted to the lab basis before applying the. spectra_cb : list callback functions, default: ``lambda w: (w > 0)``; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float, default=tlist[-1]; The period of the time-dependence of the hamiltonian. The default value; ``0`` indicates that the 'tlist' spans a single period of the driving. w_th : float, default: 0.0; The temperature of the environment in units of frequency.; For example, if the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Wheth",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:1081,Integrability,depend,dependence,1081,"r equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Periodic system Hamiltonian as :obj:`.QobjEvo`. List of; [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 / psi0 : :class:`.Qobj`; Initial density matrix or state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. c_ops : list of :class:`.Qobj`, optional; List of collapse operators. Time dependent collapse operators are not; supported. Fall back on :func:`fsesolve` if not provided. e_ops : list of :class:`.Qobj` / callback function, optional; List of operators for which to evaluate expectation values.; The states are reverted to the lab basis before applying the. spectra_cb : list callback functions, default: ``lambda w: (w > 0)``; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float, default=tlist[-1]; The period of the time-dependence of the hamiltonian. The default value; ``0`` indicates that the 'tlist' spans a single period of the driving. w_th : float, default: 0.0; The temperature of the environment in units of frequency.; For example, if the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``r",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:1589,Integrability,depend,dependent,1589,"rs are not; supported. Fall back on :func:`fsesolve` if not provided. e_ops : list of :class:`.Qobj` / callback function, optional; List of operators for which to evaluate expectation values.; The states are reverted to the lab basis before applying the. spectra_cb : list callback functions, default: ``lambda w: (w > 0)``; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float, default=tlist[-1]; The period of the time-dependence of the hamiltonian. The default value; ``0`` indicates that the 'tlist' spans a single period of the driving. w_th : float, default: 0.0; The temperature of the environment in units of frequency.; For example, if the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:2672,Integrability,integrat,integration,2672,"s given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; the expectation values for the times specified by ``tlist``, and/or the; state density matrices corresponding to the times.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:2769,Integrability,integrat,integrator,2769,"s given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; the expectation values for the times specified by ``tlist``, and/or the; state density matrices corresponding to the times.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:3055,Integrability,depend,depending,3055,"s given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; the expectation values for the times specified by ``tlist``, and/or the; state density matrices corresponding to the times.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:3072,Integrability,integrat,integration,3072,"s given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; the expectation values for the times specified by ``tlist``, and/or the; state density matrices corresponding to the times.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:2282,Modifiability,enhance,enhanced,2282,"ample, if the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; the expectation values for the times specified by `",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:272,Deployability,integrat,integrator,272,"""""""; Solver for the Floquet-Markov master equation. .. note ::; Operators (``c_ops`` and ``e_ops``) are in the laboratory basis. Parameters; ----------; floquet_basis : :class:`.FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. Choosing a; different integrator for the ``floquet_basis`` than for the evolution; of the floquet state can improve the performance. a_ops : list of tuple(:class:`.Qobj`, callable); List of collapse operators and the corresponding function for the noise; power spectrum. The collapse operator must be a :obj:`.Qobj` and; cannot be time dependent. The spectrum function must take and return; an numpy array. w_th : float; The temperature of the environment in units of Hamiltonian frequency. kmax : int [5]; The truncation of the number of sidebands.. nT : int [20*kmax]; The number of integration steps (for calculating X) within one period. options : dict, optional; Options for the solver, see :obj:`FMESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:835,Deployability,integrat,integration,835,"""""""; Solver for the Floquet-Markov master equation. .. note ::; Operators (``c_ops`` and ``e_ops``) are in the laboratory basis. Parameters; ----------; floquet_basis : :class:`.FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. Choosing a; different integrator for the ``floquet_basis`` than for the evolution; of the floquet state can improve the performance. a_ops : list of tuple(:class:`.Qobj`, callable); List of collapse operators and the corresponding function for the noise; power spectrum. The collapse operator must be a :obj:`.Qobj` and; cannot be time dependent. The spectrum function must take and return; an numpy array. w_th : float; The temperature of the environment in units of Hamiltonian frequency. kmax : int [5]; The truncation of the number of sidebands.. nT : int [20*kmax]; The number of integration steps (for calculating X) within one period. options : dict, optional; Options for the solver, see :obj:`FMESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:505,Energy Efficiency,power,power,505,"""""""; Solver for the Floquet-Markov master equation. .. note ::; Operators (``c_ops`` and ``e_ops``) are in the laboratory basis. Parameters; ----------; floquet_basis : :class:`.FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. Choosing a; different integrator for the ``floquet_basis`` than for the evolution; of the floquet state can improve the performance. a_ops : list of tuple(:class:`.Qobj`, callable); List of collapse operators and the corresponding function for the noise; power spectrum. The collapse operator must be a :obj:`.Qobj` and; cannot be time dependent. The spectrum function must take and return; an numpy array. w_th : float; The temperature of the environment in units of Hamiltonian frequency. kmax : int [5]; The truncation of the number of sidebands.. nT : int [20*kmax]; The number of integration steps (for calculating X) within one period. options : dict, optional; Options for the solver, see :obj:`FMESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:216,Integrability,wrap,wrapped,216,"""""""; Solver for the Floquet-Markov master equation. .. note ::; Operators (``c_ops`` and ``e_ops``) are in the laboratory basis. Parameters; ----------; floquet_basis : :class:`.FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. Choosing a; different integrator for the ``floquet_basis`` than for the evolution; of the floquet state can improve the performance. a_ops : list of tuple(:class:`.Qobj`, callable); List of collapse operators and the corresponding function for the noise; power spectrum. The collapse operator must be a :obj:`.Qobj` and; cannot be time dependent. The spectrum function must take and return; an numpy array. w_th : float; The temperature of the environment in units of Hamiltonian frequency. kmax : int [5]; The truncation of the number of sidebands.. nT : int [20*kmax]; The number of integration steps (for calculating X) within one period. options : dict, optional; Options for the solver, see :obj:`FMESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:272,Integrability,integrat,integrator,272,"""""""; Solver for the Floquet-Markov master equation. .. note ::; Operators (``c_ops`` and ``e_ops``) are in the laboratory basis. Parameters; ----------; floquet_basis : :class:`.FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. Choosing a; different integrator for the ``floquet_basis`` than for the evolution; of the floquet state can improve the performance. a_ops : list of tuple(:class:`.Qobj`, callable); List of collapse operators and the corresponding function for the noise; power spectrum. The collapse operator must be a :obj:`.Qobj` and; cannot be time dependent. The spectrum function must take and return; an numpy array. w_th : float; The temperature of the environment in units of Hamiltonian frequency. kmax : int [5]; The truncation of the number of sidebands.. nT : int [20*kmax]; The number of integration steps (for calculating X) within one period. options : dict, optional; Options for the solver, see :obj:`FMESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:586,Integrability,depend,dependent,586,"""""""; Solver for the Floquet-Markov master equation. .. note ::; Operators (``c_ops`` and ``e_ops``) are in the laboratory basis. Parameters; ----------; floquet_basis : :class:`.FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. Choosing a; different integrator for the ``floquet_basis`` than for the evolution; of the floquet state can improve the performance. a_ops : list of tuple(:class:`.Qobj`, callable); List of collapse operators and the corresponding function for the noise; power spectrum. The collapse operator must be a :obj:`.Qobj` and; cannot be time dependent. The spectrum function must take and return; an numpy array. w_th : float; The temperature of the environment in units of Hamiltonian frequency. kmax : int [5]; The truncation of the number of sidebands.. nT : int [20*kmax]; The number of integration steps (for calculating X) within one period. options : dict, optional; Options for the solver, see :obj:`FMESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:835,Integrability,integrat,integration,835,"""""""; Solver for the Floquet-Markov master equation. .. note ::; Operators (``c_ops`` and ``e_ops``) are in the laboratory basis. Parameters; ----------; floquet_basis : :class:`.FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. Choosing a; different integrator for the ``floquet_basis`` than for the evolution; of the floquet state can improve the performance. a_ops : list of tuple(:class:`.Qobj`, callable); List of collapse operators and the corresponding function for the noise; power spectrum. The collapse operator must be a :obj:`.Qobj` and; cannot be time dependent. The spectrum function must take and return; an numpy array. w_th : float; The temperature of the environment in units of Hamiltonian frequency. kmax : int [5]; The truncation of the number of sidebands.. nT : int [20*kmax]; The number of integration steps (for calculating X) within one period. options : dict, optional; Options for the solver, see :obj:`FMESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:370,Performance,perform,performance,370,"""""""; Solver for the Floquet-Markov master equation. .. note ::; Operators (``c_ops`` and ``e_ops``) are in the laboratory basis. Parameters; ----------; floquet_basis : :class:`.FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. Choosing a; different integrator for the ``floquet_basis`` than for the evolution; of the floquet state can improve the performance. a_ops : list of tuple(:class:`.Qobj`, callable); List of collapse operators and the corresponding function for the noise; power spectrum. The collapse operator must be a :obj:`.Qobj` and; cannot be time dependent. The spectrum function must take and return; an numpy array. w_th : float; The temperature of the environment in units of Hamiltonian frequency. kmax : int [5]; The truncation of the number of sidebands.. nT : int [20*kmax]; The number of integration steps (for calculating X) within one period. options : dict, optional; Options for the solver, see :obj:`FMESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:115,Modifiability,evolve,evolve,115,"""""""; Evolve the state to ``t`` and return the state as a :obj:`.Qobj`. Parameters; ----------; t : double; Time to evolve to, must be higher than the last call. copy : bool, optional {True}; Whether to return a copy of the data or the data in the ODE solver. floquet : bool, optional {False}; Whether to return the state in the floquet basis or laboratory; basis. args : dict, optional {None}; Not supported. Notes; -----; The state must be initialized first by calling ``start`` or; ``run``. If ``run`` is called, ``step`` will continue from the last; time and state obtained.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:28,Deployability,integrat,integrator,28,"# TODO: It would be nice if integrator could give evolution statistics; # stats.update(_integrator.stats)",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:80,Deployability,update,update,80,"# TODO: It would be nice if integrator could give evolution statistics; # stats.update(_integrator.stats)",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:28,Integrability,integrat,integrator,28,"# TODO: It would be nice if integrator could give evolution statistics; # stats.update(_integrator.stats)",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:63,Integrability,depend,dependent,63,"""""""; Expect of the state of the evolution to be used in a time-dependent; operator. Not not implemented for FMESolver; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:49,Integrability,depend,dependent,49,"""""""; State of the evolution to be used in a time-dependent operator. Not not implemented for FMESolver; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py:117,Integrability,depend,dependence,117,"""""""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Deprecated from qutip v5. Use :class:`.FloquetBasis` instead:. f_modes_table_t = fbasis = FloquetBasis(...); f_mode_t = f_modes_table_t.mode(t); """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet_bwcomp.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py:789,Energy Efficiency,power,power,789,"""""""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note ::. Deprecated. For the Floquet-Markov master equation's tensor, use; :func:`floquet_tensor`. For the rates matrices, use; :func:`floquet_delta_tensor`, :func:`floquet_X_matrices`,; :func:`floquet_gamma_matrices` and/or s:func:`floquet_A_matrix`. Parameters; ----------; f_modes_0 : Any; No longer used.; f_energies : Any; No longer used.; c_op : :class:`.Qobj`; The collapse operators describing the dissipation.; H : :class:`.Qobj`; System Hamiltonian, time-dependent with period `T`.; T : float; The period of the time-dependence of the hamiltonian.; args : dictionary; Dictionary with variables required to evaluate H.; J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`.; w_th : float; The temperature in units of frequency.; kmax : int, default=5; The truncation of the number of sidebands.; f_modes_table_t : Any; No longer used. Returns; -------; output : list; A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet_bwcomp.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py:554,Integrability,depend,dependent,554,"""""""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note ::. Deprecated. For the Floquet-Markov master equation's tensor, use; :func:`floquet_tensor`. For the rates matrices, use; :func:`floquet_delta_tensor`, :func:`floquet_X_matrices`,; :func:`floquet_gamma_matrices` and/or s:func:`floquet_A_matrix`. Parameters; ----------; f_modes_0 : Any; No longer used.; f_energies : Any; No longer used.; c_op : :class:`.Qobj`; The collapse operators describing the dissipation.; H : :class:`.Qobj`; System Hamiltonian, time-dependent with period `T`.; T : float; The period of the time-dependence of the hamiltonian.; args : dictionary; Dictionary with variables required to evaluate H.; J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`.; w_th : float; The temperature in units of frequency.; kmax : int, default=5; The truncation of the number of sidebands.; f_modes_table_t : Any; No longer used. Returns; -------; output : list; A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet_bwcomp.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py:616,Integrability,depend,dependence,616,"""""""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note ::. Deprecated. For the Floquet-Markov master equation's tensor, use; :func:`floquet_tensor`. For the rates matrices, use; :func:`floquet_delta_tensor`, :func:`floquet_X_matrices`,; :func:`floquet_gamma_matrices` and/or s:func:`floquet_A_matrix`. Parameters; ----------; f_modes_0 : Any; No longer used.; f_energies : Any; No longer used.; c_op : :class:`.Qobj`; The collapse operators describing the dissipation.; H : :class:`.Qobj`; System Hamiltonian, time-dependent with period `T`.; T : float; The period of the time-dependence of the hamiltonian.; args : dictionary; Dictionary with variables required to evaluate H.; J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`.; w_th : float; The temperature in units of frequency.; kmax : int, default=5; The truncation of the number of sidebands.; f_modes_table_t : Any; No longer used. Returns; -------; output : list; A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet_bwcomp.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py:683,Modifiability,variab,variables,683,"""""""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note ::. Deprecated. For the Floquet-Markov master equation's tensor, use; :func:`floquet_tensor`. For the rates matrices, use; :func:`floquet_delta_tensor`, :func:`floquet_X_matrices`,; :func:`floquet_gamma_matrices` and/or s:func:`floquet_A_matrix`. Parameters; ----------; f_modes_0 : Any; No longer used.; f_energies : Any; No longer used.; c_op : :class:`.Qobj`; The collapse operators describing the dissipation.; H : :class:`.Qobj`; System Hamiltonian, time-dependent with period `T`.; T : float; The period of the time-dependence of the hamiltonian.; args : dictionary; Dictionary with variables required to evaluate H.; J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`.; w_th : float; The temperature in units of frequency.; kmax : int, default=5; The truncation of the number of sidebands.; f_modes_table_t : Any; No longer used. Returns; -------; output : list; A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation.; """"""",MatchSource.CODE_COMMENT,qutip/solver/floquet_bwcomp.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2054,Availability,error,errors,2054," also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. krylov_dim: int; Dimension of Krylov approximation subspaces used for the time; evolution approximation. e_ops : :class:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace",MatchSource.CODE_COMMENT,qutip/solver/krylovsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2289,Availability,error,error,2289,"allable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list of array* ``result.expect`` of expectation values for the times; specified by ``tlist``, a",MatchSource.CODE_COMMENT,qutip/solver/krylovsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2485,Availability,toler,tolerance,2485,"te: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list of array* ``result.expect`` of expectation values for the times; specified by ``tlist``, and/or a *list* ``result.states`` of state; vectors or density matrices corresponding to the times in ``tlist`` [if; ``e_ops`` is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip/solver/krylovsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2303,Deployability,install,installed,2303,"allable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list of array* ``result.expect`` of expectation values for the times; specified by ``tlist``, a",MatchSource.CODE_COMMENT,qutip/solver/krylovsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2506,Deployability,integrat,integrator,2506,"te: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list of array* ``result.expect`` of expectation values for the times; specified by ``tlist``, and/or a *list* ``result.states`` of state; vectors or density matrices corresponding to the times in ``tlist`` [if; ``e_ops`` is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip/solver/krylovsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2872,Deployability,integrat,integrator,2872,"te: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list of array* ``result.expect`` of expectation values for the times; specified by ``tlist``, and/or a *list* ``result.states`` of state; vectors or density matrices corresponding to the times in ``tlist`` [if; ``e_ops`` is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip/solver/krylovsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:895,Integrability,depend,dependent,895,"""""""; Schrodinger equation evolution of a state vector for time independent; Hamiltonians using Krylov method. Evolve the state vector (""psi0"") finding an approximation for the time; evolution operator of Hamiltonian (""H"") by obtaining the projection of; the time evolution operator on a set of small dimensional Krylov; subspaces (m << dim(H)). The output is either the state vector or unitary matrix at arbitrary points; in time (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. krylov_dim: int; Dimension of Krylov approximation subspaces used for the time; evolution approximation. e_ops : :class:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : ",MatchSource.CODE_COMMENT,qutip/solver/krylovsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:1605,Integrability,depend,dependent,1605," and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. krylov_dim: int; Dimension of Krylov approximation subspaces used for the time; evolution approximation. e_ops : :class:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allo",MatchSource.CODE_COMMENT,qutip/solver/krylovsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2506,Integrability,integrat,integrator,2506,"te: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list of array* ``result.expect`` of expectation values for the times; specified by ``tlist``, and/or a *list* ``result.states`` of state; vectors or density matrices corresponding to the times in ``tlist`` [if; ``e_ops`` is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip/solver/krylovsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2872,Integrability,integrat,integrator,2872,"te: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list of array* ``result.expect`` of expectation values for the times; specified by ``tlist``, and/or a *list* ``result.states`` of state; vectors or density matrices corresponding to the times in ``tlist`` [if; ``e_ops`` is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip/solver/krylovsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2166,Modifiability,enhance,enhanced,2166,"proximation subspaces used for the time; evolution approximation. e_ops : :class:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list",MatchSource.CODE_COMMENT,qutip/solver/krylovsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2927,Safety,detect,detect,2927,"te: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list of array* ``result.expect`` of expectation values for the times; specified by ``tlist``, and/or a *list* ``result.states`` of state; vectors or density matrices corresponding to the times in ``tlist`` [if; ``e_ops`` is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip/solver/krylovsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:55,Availability,error,error,55,"# This happen when the collapse is caused by numerical error",MatchSource.CODE_COMMENT,qutip/solver/mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:498,Availability,error,error,498,"""""""; Options for monte carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to ",MatchSource.CODE_COMMENT,qutip/solver/mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:1484,Availability,avail,available,1484,"esult class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. improved_sampling: Bool, default: False; Whether to use the improved sampling algorithm; of Abdelhafez et al. PRA (2019); """"""",MatchSource.CODE_COMMENT,qutip/solver/mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:512,Deployability,install,installed,512,"""""""; Options for monte carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to ",MatchSource.CODE_COMMENT,qutip/solver/mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:867,Deployability,integrat,integration,867,"""""""; Options for monte carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to ",MatchSource.CODE_COMMENT,qutip/solver/mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:867,Integrability,integrat,integration,867,"""""""; Options for monte carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to ",MatchSource.CODE_COMMENT,qutip/solver/mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:360,Modifiability,enhance,enhanced,360,"""""""; Options for monte carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to ",MatchSource.CODE_COMMENT,qutip/solver/mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:1462,Safety,detect,detect,1462,"esult class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. improved_sampling: Bool, default: False; Whether to use the improved sampling algorithm; of Abdelhafez et al. PRA (2019); """"""",MatchSource.CODE_COMMENT,qutip/solver/mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:1716,Safety,detect,detect,1716,"esult class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. improved_sampling: Bool, default: False; Whether to use the improved sampling algorithm; of Abdelhafez et al. PRA (2019); """"""",MatchSource.CODE_COMMENT,qutip/solver/mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:50,Integrability,depend,dependent,50,"""""""; Collapse of the trajectory argument for time dependent systems. When used as an args:. ``QobjEvo([op, func], args={""cols"": MCSolver.CollapseFeedback()})``. The ``func`` will receive a list of ``(time, operator number)`` for; each collapses of the trajectory as ``cols``. .. note::. CollapseFeedback can't be added to a running solver when updating; arguments between steps: ``solver.step(..., args={})``. Parameters; ----------; default : callable, default : []; Default function used outside the solver. """"""",MatchSource.CODE_COMMENT,qutip/solver/mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:643,Deployability,integrat,integration,643,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": MCSolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. open : bool, default False; Set to ``True`` when using the monte carlo solver for open systems. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:49,Integrability,depend,dependent,49,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": MCSolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. open : bool, default False; Set to ``True`` when using the monte carlo solver for open systems. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:626,Integrability,depend,depending,626,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": MCSolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. open : bool, default False; Set to ``True`` when using the monte carlo solver for open systems. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:643,Integrability,integrat,integration,643,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": MCSolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. open : bool, default False; Set to ``True`` when using the monte carlo solver for open systems. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3112,Availability,error,errors,3112,"math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); Single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. None is equivalent to an empty list. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-od",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3347,Availability,error,error,3347,"ack function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vector",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3690,Availability,toler,tolerance,3690," Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options]. """"""",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:287,Deployability,integrat,integrating,287,"""""""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (``rho0``) using a given; Hamiltonian or Liouvillian (``H``) and an optional set of collapse operators; (``c_ops``), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. If either ``H`` or the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density ",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:1350,Deployability,integrat,integration,1350,"nitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. If either ``H`` or the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); Single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. None is equivalent to an empty list. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or ",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3361,Deployability,install,installed,3361,"ack function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vector",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3614,Deployability,integrat,integration,3614," Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options]. """"""",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3711,Deployability,integrat,integrator,3711," Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options]. """"""",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:4014,Deployability,integrat,integration,4014," Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options]. """"""",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:287,Integrability,integrat,integrating,287,"""""""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (``rho0``) using a given; Hamiltonian or Liouvillian (``H``) and an optional set of collapse operators; (``c_ops``), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. If either ``H`` or the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density ",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:1034,Integrability,depend,dependent,1034,"ty matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (``rho0``) using a given; Hamiltonian or Liouvillian (``H``) and an optional set of collapse operators; (``c_ops``), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. If either ``H`` or the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density matrix or state vector (ket). tlist : *l",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:1066,Integrability,depend,dependent,1066,"llapse operators, or a Liouvillian. Evolve the state vector or density matrix (``rho0``) using a given; Hamiltonian or Liouvillian (``H``) and an optional set of collapse operators; (``c_ops``), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. If either ``H`` or the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_o",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:1350,Integrability,integrat,integration,1350,"nitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. If either ``H`` or the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); Single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. None is equivalent to an empty list. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or ",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:1783,Integrability,depend,dependent,1783,"r the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); Single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. None is equivalent to an empty list. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store t",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:2639,Integrability,depend,dependent,2639,"ator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); Single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. None is equivalent to an empty list. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method t",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3614,Integrability,integrat,integration,3614," Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options]. """"""",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3711,Integrability,integrat,integrator,3711," Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options]. """"""",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3997,Integrability,depend,depending,3997," Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options]. """"""",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:4014,Integrability,integrat,integration,4014," Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options]. """"""",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:419,Modifiability,evolve,evolved,419,"""""""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (``rho0``) using a given; Hamiltonian or Liouvillian (``H``) and an optional set of collapse operators; (``c_ops``), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. If either ``H`` or the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density ",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3224,Modifiability,enhance,enhanced,3224,"n superoperators. None is equivalent to an empty list. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation valu",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:265,Deployability,integrat,integrating,265,"""""""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. c_ops : list of :obj:`.Qobj`, :obj:`.QobjEvo`; Single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. None is equivalent to an empty list. options : dict, optional; Options for the solver, see :obj:`MESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. Attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:265,Integrability,integrat,integrating,265,"""""""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. c_ops : list of :obj:`.Qobj`, :obj:`.QobjEvo`; Single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. None is equivalent to an empty list. options : dict, optional; Options for the solver, see :obj:`MESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. Attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:650,Integrability,depend,dependent,650,"""""""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. c_ops : list of :obj:`.Qobj`, :obj:`.QobjEvo`; Single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. None is equivalent to an empty list. options : dict, optional; Options for the solver, see :obj:`MESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. Attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:689,Deployability,integrat,integration,689,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": MESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. prop : bool, default : False; Set to True when computing propagators.; The default with take the shape of the propagator instead of a; state. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:49,Integrability,depend,dependent,49,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": MESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. prop : bool, default : False; Set to True when computing propagators.; The default with take the shape of the propagator instead of a; state. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:672,Integrability,depend,depending,672,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": MESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. prop : bool, default : False; Set to True when computing propagators.; The default with take the shape of the propagator instead of a; state. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:689,Integrability,integrat,integration,689,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": MESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. prop : bool, default : False; Set to True when computing propagators.; The default with take the shape of the propagator instead of a; state. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:115,Modifiability,evolve,evolve,115,"""""""; Evolve the state to ``t`` and return the state as a :obj:`.Qobj`. Parameters; ----------; t : double; Time to evolve to, must be higher than the last call. args : dict, optional; Update the ``args`` of the system.; The change is effective from the beginning of the interval.; Changing ``args`` can slow the evolution. copy : bool, default: True; Whether to return a copy of the data or the data in the ODE solver.; """"""",MatchSource.CODE_COMMENT,qutip/solver/multitraj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:1292,Availability,toler,tolerance,1292,"by; ``rhs`` and for each time in ``tlist`` store the state and/or; expectation values in a :class:`.Result`. The evolution method and; stored results are determined by ``options``. Parameters; ----------; state : :obj:`.Qobj`; Initial state of the evolution. tlist : list of double; Time for which to save the results (state and/or expect) of the; evolution. The first element of the list is the initial time of the; evolution. Time in the list must be in increasing order, but does; not need to be uniformly distributed. ntraj : int; Number of trajectories to add. args : dict, optional; Change the ``args`` of the rhs for the evolution. e_ops : list; list of Qobj or QobjEvo to compute the expectation values.; Alternatively, function[s] with the signature f(t, state) -> expect; can be used. timeout : float, optional; Maximum time in seconds for the trajectories to run. Once this time; is reached, the simulation will end even if the number; of trajectories is less than ``ntraj``. The map function, set in; options, can interupt the running trajectory or wait for it to; finish. Set to an arbitrary high number to disable. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance or a pair; of absolute and relative tolerance, in that order. Lastly, it can; be a list of pairs of (atol, rtol) for each e_ops. seeds : {int, SeedSequence, list}, optional; Seed or list of seeds for each trajectories. Returns; -------; results : :class:`.MultiTrajResult`; Results of the evolution. States and/or expect will be saved. You; can control the saved data in the options. .. note:; The simulation will end when the first end condition is reached; between ``ntraj``, ``timeout`` and ``target_tol``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/multitraj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:1371,Availability,error,error,1371,"by; ``rhs`` and for each time in ``tlist`` store the state and/or; expectation values in a :class:`.Result`. The evolution method and; stored results are determined by ``options``. Parameters; ----------; state : :obj:`.Qobj`; Initial state of the evolution. tlist : list of double; Time for which to save the results (state and/or expect) of the; evolution. The first element of the list is the initial time of the; evolution. Time in the list must be in increasing order, but does; not need to be uniformly distributed. ntraj : int; Number of trajectories to add. args : dict, optional; Change the ``args`` of the rhs for the evolution. e_ops : list; list of Qobj or QobjEvo to compute the expectation values.; Alternatively, function[s] with the signature f(t, state) -> expect; can be used. timeout : float, optional; Maximum time in seconds for the trajectories to run. Once this time; is reached, the simulation will end even if the number; of trajectories is less than ``ntraj``. The map function, set in; options, can interupt the running trajectory or wait for it to; finish. Set to an arbitrary high number to disable. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance or a pair; of absolute and relative tolerance, in that order. Lastly, it can; be a list of pairs of (atol, rtol) for each e_ops. seeds : {int, SeedSequence, list}, optional; Seed or list of seeds for each trajectories. Returns; -------; results : :class:`.MultiTrajResult`; Results of the evolution. States and/or expect will be saved. You; can control the saved data in the options. .. note:; The simulation will end when the first end condition is reached; between ``ntraj``, ``timeout`` and ``target_tol``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/multitraj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:1423,Availability,toler,tolerance,1423,"by; ``rhs`` and for each time in ``tlist`` store the state and/or; expectation values in a :class:`.Result`. The evolution method and; stored results are determined by ``options``. Parameters; ----------; state : :obj:`.Qobj`; Initial state of the evolution. tlist : list of double; Time for which to save the results (state and/or expect) of the; evolution. The first element of the list is the initial time of the; evolution. Time in the list must be in increasing order, but does; not need to be uniformly distributed. ntraj : int; Number of trajectories to add. args : dict, optional; Change the ``args`` of the rhs for the evolution. e_ops : list; list of Qobj or QobjEvo to compute the expectation values.; Alternatively, function[s] with the signature f(t, state) -> expect; can be used. timeout : float, optional; Maximum time in seconds for the trajectories to run. Once this time; is reached, the simulation will end even if the number; of trajectories is less than ``ntraj``. The map function, set in; options, can interupt the running trajectory or wait for it to; finish. Set to an arbitrary high number to disable. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance or a pair; of absolute and relative tolerance, in that order. Lastly, it can; be a list of pairs of (atol, rtol) for each e_ops. seeds : {int, SeedSequence, list}, optional; Seed or list of seeds for each trajectories. Returns; -------; results : :class:`.MultiTrajResult`; Results of the evolution. States and/or expect will be saved. You; can control the saved data in the options. .. note:; The simulation will end when the first end condition is reached; between ``ntraj``, ``timeout`` and ``target_tol``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/multitraj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:1506,Availability,error,error,1506,"by; ``rhs`` and for each time in ``tlist`` store the state and/or; expectation values in a :class:`.Result`. The evolution method and; stored results are determined by ``options``. Parameters; ----------; state : :obj:`.Qobj`; Initial state of the evolution. tlist : list of double; Time for which to save the results (state and/or expect) of the; evolution. The first element of the list is the initial time of the; evolution. Time in the list must be in increasing order, but does; not need to be uniformly distributed. ntraj : int; Number of trajectories to add. args : dict, optional; Change the ``args`` of the rhs for the evolution. e_ops : list; list of Qobj or QobjEvo to compute the expectation values.; Alternatively, function[s] with the signature f(t, state) -> expect; can be used. timeout : float, optional; Maximum time in seconds for the trajectories to run. Once this time; is reached, the simulation will end even if the number; of trajectories is less than ``ntraj``. The map function, set in; options, can interupt the running trajectory or wait for it to; finish. Set to an arbitrary high number to disable. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance or a pair; of absolute and relative tolerance, in that order. Lastly, it can; be a list of pairs of (atol, rtol) for each e_ops. seeds : {int, SeedSequence, list}, optional; Seed or list of seeds for each trajectories. Returns; -------; results : :class:`.MultiTrajResult`; Results of the evolution. States and/or expect will be saved. You; can control the saved data in the options. .. note:; The simulation will end when the first end condition is reached; between ``ntraj``, ``timeout`` and ``target_tol``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/multitraj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:1587,Availability,toler,tolerance,1587,"by; ``rhs`` and for each time in ``tlist`` store the state and/or; expectation values in a :class:`.Result`. The evolution method and; stored results are determined by ``options``. Parameters; ----------; state : :obj:`.Qobj`; Initial state of the evolution. tlist : list of double; Time for which to save the results (state and/or expect) of the; evolution. The first element of the list is the initial time of the; evolution. Time in the list must be in increasing order, but does; not need to be uniformly distributed. ntraj : int; Number of trajectories to add. args : dict, optional; Change the ``args`` of the rhs for the evolution. e_ops : list; list of Qobj or QobjEvo to compute the expectation values.; Alternatively, function[s] with the signature f(t, state) -> expect; can be used. timeout : float, optional; Maximum time in seconds for the trajectories to run. Once this time; is reached, the simulation will end even if the number; of trajectories is less than ``ntraj``. The map function, set in; options, can interupt the running trajectory or wait for it to; finish. Set to an arbitrary high number to disable. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance or a pair; of absolute and relative tolerance, in that order. Lastly, it can; be a list of pairs of (atol, rtol) for each e_ops. seeds : {int, SeedSequence, list}, optional; Seed or list of seeds for each trajectories. Returns; -------; results : :class:`.MultiTrajResult`; Results of the evolution. States and/or expect will be saved. You; can control the saved data in the options. .. note:; The simulation will end when the first end condition is reached; between ``ntraj``, ``timeout`` and ``target_tol``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/multitraj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:1633,Availability,toler,tolerance,1633,"by; ``rhs`` and for each time in ``tlist`` store the state and/or; expectation values in a :class:`.Result`. The evolution method and; stored results are determined by ``options``. Parameters; ----------; state : :obj:`.Qobj`; Initial state of the evolution. tlist : list of double; Time for which to save the results (state and/or expect) of the; evolution. The first element of the list is the initial time of the; evolution. Time in the list must be in increasing order, but does; not need to be uniformly distributed. ntraj : int; Number of trajectories to add. args : dict, optional; Change the ``args`` of the rhs for the evolution. e_ops : list; list of Qobj or QobjEvo to compute the expectation values.; Alternatively, function[s] with the signature f(t, state) -> expect; can be used. timeout : float, optional; Maximum time in seconds for the trajectories to run. Once this time; is reached, the simulation will end even if the number; of trajectories is less than ``ntraj``. The map function, set in; options, can interupt the running trajectory or wait for it to; finish. Set to an arbitrary high number to disable. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance or a pair; of absolute and relative tolerance, in that order. Lastly, it can; be a list of pairs of (atol, rtol) for each e_ops. seeds : {int, SeedSequence, list}, optional; Seed or list of seeds for each trajectories. Returns; -------; results : :class:`.MultiTrajResult`; Results of the evolution. States and/or expect will be saved. You; can control the saved data in the options. .. note:; The simulation will end when the first end condition is reached; between ``ntraj``, ``timeout`` and ``target_tol``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/multitraj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:906,Safety,timeout,timeout,906,"""""""; Do the evolution of the Quantum system. For a ``state`` at time ``tlist[0]`` do the evolution as directed by; ``rhs`` and for each time in ``tlist`` store the state and/or; expectation values in a :class:`.Result`. The evolution method and; stored results are determined by ``options``. Parameters; ----------; state : :obj:`.Qobj`; Initial state of the evolution. tlist : list of double; Time for which to save the results (state and/or expect) of the; evolution. The first element of the list is the initial time of the; evolution. Time in the list must be in increasing order, but does; not need to be uniformly distributed. ntraj : int; Number of trajectories to add. args : dict, optional; Change the ``args`` of the rhs for the evolution. e_ops : list; list of Qobj or QobjEvo to compute the expectation values.; Alternatively, function[s] with the signature f(t, state) -> expect; can be used. timeout : float, optional; Maximum time in seconds for the trajectories to run. Once this time; is reached, the simulation will end even if the number; of trajectories is less than ``ntraj``. The map function, set in; options, can interupt the running trajectory or wait for it to; finish. Set to an arbitrary high number to disable. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance or a pair; of absolute and relative tolerance, in that order. Lastly, it can; be a list of pairs of (atol, rtol) for each e_ops. seeds : {int, SeedSequence, list}, optional; Seed or list of seeds for each trajectories. Returns; -------; results : :class:`.MultiTrajResult`; Results of the evolution. States and/or expect will be saved. You; can control the saved data in the options. .. note:; The simula",MatchSource.CODE_COMMENT,qutip/solver/multitraj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:2077,Safety,timeout,timeout,2077,"by; ``rhs`` and for each time in ``tlist`` store the state and/or; expectation values in a :class:`.Result`. The evolution method and; stored results are determined by ``options``. Parameters; ----------; state : :obj:`.Qobj`; Initial state of the evolution. tlist : list of double; Time for which to save the results (state and/or expect) of the; evolution. The first element of the list is the initial time of the; evolution. Time in the list must be in increasing order, but does; not need to be uniformly distributed. ntraj : int; Number of trajectories to add. args : dict, optional; Change the ``args`` of the rhs for the evolution. e_ops : list; list of Qobj or QobjEvo to compute the expectation values.; Alternatively, function[s] with the signature f(t, state) -> expect; can be used. timeout : float, optional; Maximum time in seconds for the trajectories to run. Once this time; is reached, the simulation will end even if the number; of trajectories is less than ``ntraj``. The map function, set in; options, can interupt the running trajectory or wait for it to; finish. Set to an arbitrary high number to disable. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance or a pair; of absolute and relative tolerance, in that order. Lastly, it can; be a list of pairs of (atol, rtol) for each e_ops. seeds : {int, SeedSequence, list}, optional; Seed or list of seeds for each trajectories. Returns; -------; results : :class:`.MultiTrajResult`; Results of the evolution. States and/or expect will be saved. You; can control the saved data in the options. .. note:; The simulation will end when the first end condition is reached; between ``ntraj``, ``timeout`` and ``target_tol``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/multitraj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:86,Availability,error,error,86,"""""""; Read user provided seed(s) and produce one for each trajectory.; Let numpy raise error for inputs that cannot be seeds.; """"""",MatchSource.CODE_COMMENT,qutip/solver/multitraj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:91,Testability,test,testing,91,"# We check for the method, not the type to accept pseudo non-random; # generator for debug/testing purpose.",MatchSource.CODE_COMMENT,qutip/solver/multitraj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1661,Availability,toler,tolerance,1661,"ed deterministically. state : :class:`.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ops_and_rates : list; A ``list`` of tuples ``(L, Gamma)``, where the Lindblad operator ``L``; is a :class:`.Qobj` and ``Gamma`` represents the corresponding; rate, which is allowed to be negative. The Lindblad operators must be; operators even if ``H`` is a superoperator. If none are given, the; solver will defer to ``sesolve`` or ``mesolve``. Each rate ``Gamma``; may be just a number (in the case of a constant rate) or, otherwise,; specified using any format accepted by; :func:`~qutip.core.coefficient.coefficient`. e_ops : list, optional; A ``list`` of operator as Qobj, QobjEvo or callable with signature of; (t, state: Qobj) for calculating expectation values. When no ``e_ops``; are given, the solver will default to save the states. ntraj : int, default: 500; Maximum number of trajectories to run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and r",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2302,Availability,error,error,2302,"e_ops : list, optional; A ``list`` of operator as Qobj, QobjEvo or callable with signature of; (t, state: Qobj) for calculating expectation values. When no ``e_ops``; are given, the solver will default to save the states. ntraj : int, default: 500; Maximum number of trajectories to run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Numbe",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2645,Availability,toler,tolerance,2645,"keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``nor",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:3357,Availability,avail,available,3357," will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.opt",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:3522,Availability,toler,tolerance,3522,", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, ",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:3567,Availability,error,error,3567,"rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4380,Availability,avail,available,4380,", float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; result",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4836,Availability,toler,tolerance,4836," Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; results : :class:`.NmmcResult`; Object storing all results from the simulation. Compared to a result; returned by ``mcsolve``, this result contains the additional field; ``trace`` (and ``runs_trace`` if ``store_final_state`` is set). Note; that the states on the individual trajectories are not normalized. This; field contains the average of their trace, which will converge to one; in the limit of sufficiently",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4915,Availability,error,error,4915,"rmining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; results : :class:`.NmmcResult`; Object storing all results from the simulation. Compared to a result; returned by ``mcsolve``, this result contains the additional field; ``trace`` (and ``runs_trace`` if ``store_final_state`` is set). Note; that the states on the individual trajectories are not normalized. This; field contains the average of their trace, which will converge to one; in the limit of sufficiently many trajectories.; """"""",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4967,Availability,toler,tolerance,4967,"rmining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; results : :class:`.NmmcResult`; Object storing all results from the simulation. Compared to a result; returned by ``mcsolve``, this result contains the additional field; ``trace`` (and ``runs_trace`` if ``store_final_state`` is set). Note; that the states on the individual trajectories are not normalized. This; field contains the average of their trace, which will converge to one; in the limit of sufficiently many trajectories.; """"""",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:5050,Availability,error,error,5050,"rmining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; results : :class:`.NmmcResult`; Object storing all results from the simulation. Compared to a result; returned by ``mcsolve``, this result contains the additional field; ``trace`` (and ``runs_trace`` if ``store_final_state`` is set). Note; that the states on the individual trajectories are not normalized. This; field contains the average of their trace, which will converge to one; in the limit of sufficiently many trajectories.; """"""",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:5131,Availability,toler,tolerance,5131,"rmining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; results : :class:`.NmmcResult`; Object storing all results from the simulation. Compared to a result; returned by ``mcsolve``, this result contains the additional field; ``trace`` (and ``runs_trace`` if ``store_final_state`` is set). Note; that the states on the individual trajectories are not normalized. This; field contains the average of their trace, which will converge to one; in the limit of sufficiently many trajectories.; """"""",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:5177,Availability,toler,tolerance,5177,"rmining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; results : :class:`.NmmcResult`; Object storing all results from the simulation. Compared to a result; returned by ``mcsolve``, this result contains the additional field; ``trace`` (and ``runs_trace`` if ``store_final_state`` is set). Note; that the states on the individual trajectories are not normalized. This; field contains the average of their trace, which will converge to one; in the limit of sufficiently many trajectories.; """"""",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2316,Deployability,install,installed,2316,"e_ops : list, optional; A ``list`` of operator as Qobj, QobjEvo or callable with signature of; (t, state: Qobj) for calculating expectation values. When no ``e_ops``; are given, the solver will default to save the states. ntraj : int, default: 500; Maximum number of trajectories to run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Numbe",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2569,Deployability,integrat,integration,2569," run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2666,Deployability,integrat,integrator,2666,"keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``nor",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4138,Deployability,integrat,integration,4138," to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4439,Deployability,integrat,integration,4439,", float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; result",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4128,Energy Efficiency,adapt,adaptive,4128," to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1746,Integrability,depend,dependent,1746,"e recorded. ops_and_rates : list; A ``list`` of tuples ``(L, Gamma)``, where the Lindblad operator ``L``; is a :class:`.Qobj` and ``Gamma`` represents the corresponding; rate, which is allowed to be negative. The Lindblad operators must be; operators even if ``H`` is a superoperator. If none are given, the; solver will defer to ``sesolve`` or ``mesolve``. Each rate ``Gamma``; may be just a number (in the case of a constant rate) or, otherwise,; specified using any format accepted by; :func:`~qutip.core.coefficient.coefficient`. e_ops : list, optional; A ``list`` of operator as Qobj, QobjEvo or callable with signature of; (t, state: Qobj) for calculating expectation values. When no ``e_ops``; are given, the solver will default to save the states. ntraj : int, default: 500; Maximum number of trajectories to run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowe",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2569,Integrability,integrat,integration,2569," run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2666,Integrability,integrat,integrator,2666,"keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``nor",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4138,Integrability,integrat,integration,4138," to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4390,Integrability,depend,depending,4390,", float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; result",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4439,Integrability,integrat,integration,4439,", float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; result",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2179,Modifiability,enhance,enhanced,2179,"ise,; specified using any format accepted by; :func:`~qutip.core.coefficient.coefficient`. e_ops : list, optional; A ``list`` of operator as Qobj, QobjEvo or callable with signature of; (t, state: Qobj) for calculating expectation values. When no ``e_ops``; are given, the solver will default to save the states. ntraj : int, default: 500; Maximum number of trajectories to run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while """,MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4128,Modifiability,adapt,adaptive,4128," to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1626,Safety,timeout,timeout,1626,"ed deterministically. state : :class:`.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ops_and_rates : list; A ``list`` of tuples ``(L, Gamma)``, where the Lindblad operator ``L``; is a :class:`.Qobj` and ``Gamma`` represents the corresponding; rate, which is allowed to be negative. The Lindblad operators must be; operators even if ``H`` is a superoperator. If none are given, the; solver will defer to ``sesolve`` or ``mesolve``. Each rate ``Gamma``; may be just a number (in the case of a constant rate) or, otherwise,; specified using any format accepted by; :func:`~qutip.core.coefficient.coefficient`. e_ops : list, optional; A ``list`` of operator as Qobj, QobjEvo or callable with signature of; (t, state: Qobj) for calculating expectation values. When no ``e_ops``; are given, the solver will default to save the states. ntraj : int, default: 500; Maximum number of trajectories to run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and r",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:3335,Safety,detect,detect,3335," will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.opt",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:3702,Safety,detect,detect,3702,"umber of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds ar",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:5270,Safety,timeout,timeout,5270,"rmining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; results : :class:`.NmmcResult`; Object storing all results from the simulation. Compared to a result; returned by ``mcsolve``, this result contains the additional field; ``trace`` (and ``runs_trace`` if ``store_final_state`` is set). Note; that the states on the individual trajectories are not normalized. This; field contains the average of their trace, which will converge to one; in the limit of sufficiently many trajectories.; """"""",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:88,Deployability,continuous,continuous,88,"# `cache` may be 'clear', 'keep' or a new list of times for which; # to pre-compute the continuous contribution to the martingale",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:3,Performance,cache,cache,3,"# `cache` may be 'clear', 'keep' or a new list of times for which; # to pre-compute the continuous contribution to the martingale",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:18,Usability,clear,clear,18,"# `cache` may be 'clear', 'keep' or a new list of times for which; # to pre-compute the continuous contribution to the martingale",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:16,Deployability,continuous,continuous,16,"# find value of continuous martingale at given time",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1073,Integrability,depend,dependent,1073,"""""""; Monte Carlo Solver for Lindblad equations with ""rates"" that may be; negative. The ``c_ops`` parameter of :class:`.MCSolver` is replaced by; an ``ops_and_rates`` parameter to allow for negative rates. Options for the; underlying ODE solver are given by the Options class. Parameters; ----------; H : :class:`.Qobj`, :class:`.QobjEvo`, ``list``, callable.; System Hamiltonian as a Qobj, QobjEvo. It can also be any input type; that QobjEvo accepts (see :class:`.QobjEvo` documentation).; ``H`` can also be a superoperator (liouvillian) if some collapse; operators are to be treated deterministically. ops_and_rates : list; A ``list`` of tuples ``(L, Gamma)``, where the Lindblad operator ``L``; is a :class:`.Qobj` and ``Gamma`` represents the corresponding; rate, which is allowed to be negative. The Lindblad operators must be; operators even if ``H`` is a superoperator. Each rate ``Gamma`` may be; just a number (in the case of a constant rate) or, otherwise, specified; using any format accepted by :func:`qutip.coefficient`. args : None / dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : SolverOptions, [optional]; Options for the evolution.; """"""",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:85,Deployability,update,updated,85,"# Many coefficients. These should not be publicly exposed; # and will all need to be updated in _arguments():",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:50,Security,expose,exposed,50,"# Many coefficients. These should not be publicly exposed; # and will all need to be updated in _arguments():",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:133,Deployability,continuous,continuous,133,"""""""; Returns the value of the influence martingale along the current; trajectory. The value of the martingale is the product of the; continuous and the discrete contribution. The current time and the; collapses that have happened are read out from the internal integrator.; """"""",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:261,Deployability,integrat,integrator,261,"""""""; Returns the value of the influence martingale along the current; trajectory. The value of the martingale is the product of the; continuous and the discrete contribution. The current time and the; collapses that have happened are read out from the internal integrator.; """"""",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:261,Integrability,integrat,integrator,261,"""""""; Returns the value of the influence martingale along the current; trajectory. The value of the martingale is the product of the; continuous and the discrete contribution. The current time and the; collapses that have happened are read out from the internal integrator.; """"""",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:151,Deployability,integrat,integrate,151,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:234,Deployability,integrat,integrate,234,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1270,Deployability,continuous,continuous,1270,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:48,Integrability,interface,interfaces,48,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:151,Integrability,integrat,integrate,151,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:234,Integrability,integrat,integrate,234,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:922,Integrability,interface,interface,922,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:986,Integrability,interface,interface,986,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1025,Integrability,interface,interface,1025,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1200,Integrability,interface,interface,1200,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1225,Integrability,interface,interface,1225,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1420,Integrability,interface,interface,1420,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1533,Integrability,interface,interface,1533,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:598,Security,access,accessed,598,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2,Deployability,update,update,2,"# update `args` dictionary before precomputing martingale",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:512,Availability,error,error,512,"""""""; Options for non-Markovian Monte Carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum numbe",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1498,Availability,avail,available,1498,"same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. completeness_rtol: float, default: 1e-5; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). completeness_atol: float, default: 1e-8; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rat",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:526,Deployability,install,installed,526,"""""""; Options for non-Markovian Monte Carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum numbe",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:881,Deployability,integrat,integration,881,"""""""; Options for non-Markovian Monte Carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum numbe",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2612,Deployability,integrat,integration,2612,"esults: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. completeness_rtol: float, default: 1e-5; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). completeness_atol: float, default: 1e-8; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). martingale_quad_limit: float or int, default: 100; An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; """"""",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2602,Energy Efficiency,adapt,adaptive,2602,"esults: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. completeness_rtol: float, default: 1e-5; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). completeness_atol: float, default: 1e-8; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). martingale_quad_limit: float or int, default: 100; An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; """"""",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:881,Integrability,integrat,integration,881,"""""""; Options for non-Markovian Monte Carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum numbe",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2612,Integrability,integrat,integration,2612,"esults: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. completeness_rtol: float, default: 1e-5; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). completeness_atol: float, default: 1e-8; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). martingale_quad_limit: float or int, default: 100; An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; """"""",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:374,Modifiability,enhance,enhanced,374,"""""""; Options for non-Markovian Monte Carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum numbe",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2602,Modifiability,adapt,adaptive,2602,"esults: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. completeness_rtol: float, default: 1e-5; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). completeness_atol: float, default: 1e-8; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). martingale_quad_limit: float or int, default: 100; An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; """"""",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1476,Safety,detect,detect,1476,"same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. completeness_rtol: float, default: 1e-5; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). completeness_atol: float, default: 1e-8; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rat",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1730,Safety,detect,detect,1730,"esults: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. completeness_rtol: float, default: 1e-5; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). completeness_atol: float, default: 1e-8; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). martingale_quad_limit: float or int, default: 100; An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; """"""",MatchSource.CODE_COMMENT,qutip/solver/nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py:42,Deployability,integrat,integrator,42,"""""""; Class to hold options for solver and integrator. Parameters; ----------; default : dict; Default dict, only keys in this will be accepted.; feedback : callable, ``f(keys : set) -> None``, optional; Function to called when an item is updated.; name : str, optional; Name of the solver or integrator that use this. Used in __repr__ only.; doc : str, optional; Overwrite the __doc__ of the instance.; """"""",MatchSource.CODE_COMMENT,qutip/solver/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py:238,Deployability,update,updated,238,"""""""; Class to hold options for solver and integrator. Parameters; ----------; default : dict; Default dict, only keys in this will be accepted.; feedback : callable, ``f(keys : set) -> None``, optional; Function to called when an item is updated.; name : str, optional; Name of the solver or integrator that use this. Used in __repr__ only.; doc : str, optional; Overwrite the __doc__ of the instance.; """"""",MatchSource.CODE_COMMENT,qutip/solver/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py:292,Deployability,integrat,integrator,292,"""""""; Class to hold options for solver and integrator. Parameters; ----------; default : dict; Default dict, only keys in this will be accepted.; feedback : callable, ``f(keys : set) -> None``, optional; Function to called when an item is updated.; name : str, optional; Name of the solver or integrator that use this. Used in __repr__ only.; doc : str, optional; Overwrite the __doc__ of the instance.; """"""",MatchSource.CODE_COMMENT,qutip/solver/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py:42,Integrability,integrat,integrator,42,"""""""; Class to hold options for solver and integrator. Parameters; ----------; default : dict; Default dict, only keys in this will be accepted.; feedback : callable, ``f(keys : set) -> None``, optional; Function to called when an item is updated.; name : str, optional; Name of the solver or integrator that use this. Used in __repr__ only.; doc : str, optional; Overwrite the __doc__ of the instance.; """"""",MatchSource.CODE_COMMENT,qutip/solver/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py:292,Integrability,integrat,integrator,292,"""""""; Class to hold options for solver and integrator. Parameters; ----------; default : dict; Default dict, only keys in this will be accepted.; feedback : callable, ``f(keys : set) -> None``, optional; Function to called when an item is updated.; name : str, optional; Name of the solver or integrator that use this. Used in __repr__ only.; doc : str, optional; Overwrite the __doc__ of the instance.; """"""",MatchSource.CODE_COMMENT,qutip/solver/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py:145,Usability,feedback,feedback,145,"""""""; Class to hold options for solver and integrator. Parameters; ----------; default : dict; Default dict, only keys in this will be accepted.; feedback : callable, ``f(keys : set) -> None``, optional; Function to called when an item is updated.; name : str, optional; Name of the solver or integrator that use this. Used in __repr__ only.; doc : str, optional; Overwrite the __doc__ of the instance.; """"""",MatchSource.CODE_COMMENT,qutip/solver/options.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1302,Availability,error,error,1302,"""""""; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of :func:`parallel_map`. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional argument to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword argument to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each tasks instead of; storing a them in a list. It should return None or a number.; When returning a number, it represent the estimation of the number of; task left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing:; - timeout: float, Maximum time (sec) for the whole map.; - fail_fast: bool, Raise an error at the first. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for each; value in ``values``. If a ``reduce_func`` is provided, and empty list; will be returned. """"""",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1219,Safety,timeout,timeout,1219,"""""""; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of :func:`parallel_map`. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional argument to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword argument to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each tasks instead of; storing a them in a list. It should return None or a number.; When returning a number, it represent the estimation of the number of; task left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing:; - timeout: float, Maximum time (sec) for the whole map.; - fail_fast: bool, Raise an error at the first. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for each; value in ``values``. If a ``reduce_func`` is provided, and empty list; will be returned. """"""",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1154,Usability,progress bar,progress bar,1154,"""""""; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of :func:`parallel_map`. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional argument to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword argument to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each tasks instead of; storing a them in a list. It should return None or a number.; When returning a number, it represent the estimation of the number of; task left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing:; - timeout: float, Maximum time (sec) for the whole map.; - fail_fast: bool, Raise an error at the first. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for each; value in ``values``. If a ``reduce_func`` is provided, and empty list; will be returned. """"""",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:627,Availability,error,error,627,"""""""; Common functionality for parallel_map, loky_pmap and mpi_pmap.; The parameters `setup_executor`, `extract_result` and `shutdown_executor`; are callback functions with the following signatures:. setup_executor: () -> ProcessPoolExecutor. extract_result: Future -> (Any, BaseException); If there was an exception e, returns (None, e).; Otherwise returns (result, None). shutdown_executor: (executor: ProcessPoolExecutor,; active_tasks: set[Future]) -> None; executor: The ProcessPoolExecutor that was created in setup_executor; active_tasks: A set of Futures that are currently still being executed; (non-empty if: timeout, error, or reduce_func requesting exit); """"""",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:618,Safety,timeout,timeout,618,"""""""; Common functionality for parallel_map, loky_pmap and mpi_pmap.; The parameters `setup_executor`, `extract_result` and `shutdown_executor`; are callback functions with the following signatures:. setup_executor: () -> ProcessPoolExecutor. extract_result: Future -> (Any, BaseException); If there was an exception e, returns (None, e).; Otherwise returns (result, None). shutdown_executor: (executor: ProcessPoolExecutor,; active_tasks: set[Future]) -> None; executor: The ProcessPoolExecutor that was created in setup_executor; active_tasks: A set of Futures that are currently still being executed; (non-empty if: timeout, error, or reduce_func requesting exit); """"""",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:17,Availability,avail,available,17,"# space and time available, add tasks",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:16,Safety,avoid,avoid,16,"# small hack to avoid add_done_callback not supporting; # extra arguments and closures inside loops retaining; # a reference not a value:",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:115,Availability,down,down,115,"# all tasks have been submitted, timeout has not been reaches; # -> wait for all workers to finish before shutting down",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:33,Safety,timeout,timeout,33,"# all tasks have been submitted, timeout has not been reaches; # -> wait for all workers to finish before shutting down",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1330,Availability,error,error,1330,"""""""; Parallel execution of a mapping of ``values`` to the function ``task``.; This is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1188,Safety,timeout,timeout,1188,"""""""; Parallel execution of a mapping of ``values`` to the function ``task``.; This is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1113,Usability,progress bar,progress bar,1113,"""""""; Parallel execution of a mapping of ``values`` to the function ``task``.; This is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1378,Availability,error,error,1378,"""""""; Parallel execution of a mapping of ``values`` to the function ``task``.; This is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Use the loky module instead of multiprocessing. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1236,Safety,timeout,timeout,1236,"""""""; Parallel execution of a mapping of ``values`` to the function ``task``.; This is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Use the loky module instead of multiprocessing. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1161,Usability,progress bar,progress bar,1161,"""""""; Parallel execution of a mapping of ``values`` to the function ``task``.; This is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Use the loky module instead of multiprocessing. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:11,Safety,abort,aborted,11,"# Task was aborted due to timeout etc",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:26,Safety,timeout,timeout,26,"# Task was aborted due to timeout etc",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1985,Availability,error,error,1985,"documentation of mpi4py and; the mpi4py.MPIPoolExecutor class. Note: in keeping consistent with the API of `parallel_map`, the parameter; determining the number of requested worker processes is called `num_cpus`.; The value of `map_kw['num_cpus']` is passed to the MPIPoolExecutor as its; `max_workers` argument.; If this parameter is not provided, the environment variable; `QUTIP_NUM_PROCESSES` is used instead. If this environment variable is not; set either, QuTiP will use default values that might be unsuitable for MPI; applications. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error.; All remaining entries of map_kw will be passed to the; mpi4py.MPIPoolExecutor constructor. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:666,Modifiability,variab,variable,666,"""""""; Parallel execution of a mapping of ``values`` to the function ``task``.; This is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Uses the mpi4py module to execute the tasks asynchronously with MPI; processes. For more information, consult the documentation of mpi4py and; the mpi4py.MPIPoolExecutor class. Note: in keeping consistent with the API of `parallel_map`, the parameter; determining the number of requested worker processes is called `num_cpus`.; The value of `map_kw['num_cpus']` is passed to the MPIPoolExecutor as its; `max_workers` argument.; If this parameter is not provided, the environment variable; `QUTIP_NUM_PROCESSES` is used instead. If this environment variable is not; set either, QuTiP will use default values that might be unsuitable for MPI; applications. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error.; All rema",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:735,Modifiability,variab,variable,735,"""""""; Parallel execution of a mapping of ``values`` to the function ``task``.; This is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Uses the mpi4py module to execute the tasks asynchronously with MPI; processes. For more information, consult the documentation of mpi4py and; the mpi4py.MPIPoolExecutor class. Note: in keeping consistent with the API of `parallel_map`, the parameter; determining the number of requested worker processes is called `num_cpus`.; The value of `map_kw['num_cpus']` is passed to the MPIPoolExecutor as its; `max_workers` argument.; If this parameter is not provided, the environment variable; `QUTIP_NUM_PROCESSES` is used instead. If this environment variable is not; set either, QuTiP will use default values that might be unsuitable for MPI; applications. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error.; All rema",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1843,Safety,timeout,timeout,1843,"documentation of mpi4py and; the mpi4py.MPIPoolExecutor class. Note: in keeping consistent with the API of `parallel_map`, the parameter; determining the number of requested worker processes is called `num_cpus`.; The value of `map_kw['num_cpus']` is passed to the MPIPoolExecutor as its; `max_workers` argument.; If this parameter is not provided, the environment variable; `QUTIP_NUM_PROCESSES` is used instead. If this environment variable is not; set either, QuTiP will use default values that might be unsuitable for MPI; applications. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error.; All remaining entries of map_kw will be passed to the; mpi4py.MPIPoolExecutor constructor. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1768,Usability,progress bar,progress bar,1768,"documentation of mpi4py and; the mpi4py.MPIPoolExecutor class. Note: in keeping consistent with the API of `parallel_map`, the parameter; determining the number of requested worker processes is called `num_cpus`.; The value of `map_kw['num_cpus']` is passed to the MPIPoolExecutor as its; `max_workers` argument.; If this parameter is not provided, the environment variable; `QUTIP_NUM_PROCESSES` is used instead. If this environment variable is not; set either, QuTiP will use default values that might be unsuitable for MPI; applications. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error.; All remaining entries of map_kw will be passed to the; mpi4py.MPIPoolExecutor constructor. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:297,Security,access,access,297,"# If the provided num_cpus is None, we use the default value instead.; # We thus intentionally make it impossible to call; # MPIPoolExecutor(max_workers=None, ...); # in which case mpi4py would determine a default value. That would be; # useful, but unfortunately mpi4py provides no public API to access the; # actual number of workers that is used in that case, which we would need.",MatchSource.CODE_COMMENT,qutip/solver/parallel.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:1099,Availability,toler,tolerance,1099,"""""""; A generator of propagator for a system. Usage:. U = Propagator(H, c_ops). psi_t = U(t) @ psi_0. Save some previously computed propagator are stored to speed up subsequent; computation. Changing ``args`` will erase these stored probagator. Parameters; ----------; system : :obj:`.Qobj`, :obj:`.QobjEvo`, :class:`.Solver`; Possibly time-dependent system driving the evolution, either already; packaged in a solver, such as :class:`.SESolver` or :class:`.BRSolver`,; or the Liouvillian or Hamiltonian as a :obj:`.Qobj`,; :obj:`.QobjEvo`. ``list`` of [:obj:`.Qobj`, :obj:`.Coefficient`]; or callable that can be made into :obj:`.QobjEvo` are also accepted. Solvers that run non-deterministacilly, such as :class:`.MCSolver`, are; not supported. c_ops : list, optional; List of :obj:`.Qobj` or :obj:`.QobjEvo` collapse operators. args : dictionary, optional; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Options for the solver. memoize : int, default: 10; Max number of propagator to save. tol : float, default: 1e-14; Absolute tolerance for the time. If a previous propagator was computed; at a time within tolerance, that propagator will be returned. Notes; -----; The :class:`Propagator` is not a :obj:`.QobjEvo` so; it cannot be used for operations with :obj:`.Qobj` or; :obj:`.QobjEvo`. It can be made into a; :obj:`.QobjEvo` with ::. U = QobjEvo(Propagator(H)). """"""",MatchSource.CODE_COMMENT,qutip/solver/propagator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:1179,Availability,toler,tolerance,1179,"""""""; A generator of propagator for a system. Usage:. U = Propagator(H, c_ops). psi_t = U(t) @ psi_0. Save some previously computed propagator are stored to speed up subsequent; computation. Changing ``args`` will erase these stored probagator. Parameters; ----------; system : :obj:`.Qobj`, :obj:`.QobjEvo`, :class:`.Solver`; Possibly time-dependent system driving the evolution, either already; packaged in a solver, such as :class:`.SESolver` or :class:`.BRSolver`,; or the Liouvillian or Hamiltonian as a :obj:`.Qobj`,; :obj:`.QobjEvo`. ``list`` of [:obj:`.Qobj`, :obj:`.Coefficient`]; or callable that can be made into :obj:`.QobjEvo` are also accepted. Solvers that run non-deterministacilly, such as :class:`.MCSolver`, are; not supported. c_ops : list, optional; List of :obj:`.Qobj` or :obj:`.QobjEvo` collapse operators. args : dictionary, optional; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Options for the solver. memoize : int, default: 10; Max number of propagator to save. tol : float, default: 1e-14; Absolute tolerance for the time. If a previous propagator was computed; at a time within tolerance, that propagator will be returned. Notes; -----; The :class:`Propagator` is not a :obj:`.QobjEvo` so; it cannot be used for operations with :obj:`.Qobj` or; :obj:`.QobjEvo`. It can be made into a; :obj:`.QobjEvo` with ::. U = QobjEvo(Propagator(H)). """"""",MatchSource.CODE_COMMENT,qutip/solver/propagator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:340,Integrability,depend,dependent,340,"""""""; A generator of propagator for a system. Usage:. U = Propagator(H, c_ops). psi_t = U(t) @ psi_0. Save some previously computed propagator are stored to speed up subsequent; computation. Changing ``args`` will erase these stored probagator. Parameters; ----------; system : :obj:`.Qobj`, :obj:`.QobjEvo`, :class:`.Solver`; Possibly time-dependent system driving the evolution, either already; packaged in a solver, such as :class:`.SESolver` or :class:`.BRSolver`,; or the Liouvillian or Hamiltonian as a :obj:`.Qobj`,; :obj:`.QobjEvo`. ``list`` of [:obj:`.Qobj`, :obj:`.Coefficient`]; or callable that can be made into :obj:`.QobjEvo` are also accepted. Solvers that run non-deterministacilly, such as :class:`.MCSolver`, are; not supported. c_ops : list, optional; List of :obj:`.Qobj` or :obj:`.QobjEvo` collapse operators. args : dictionary, optional; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Options for the solver. memoize : int, default: 10; Max number of propagator to save. tol : float, default: 1e-14; Absolute tolerance for the time. If a previous propagator was computed; at a time within tolerance, that propagator will be returned. Notes; -----; The :class:`Propagator` is not a :obj:`.QobjEvo` so; it cannot be used for operations with :obj:`.Qobj` or; :obj:`.QobjEvo`. It can be made into a; :obj:`.QobjEvo` with ::. U = QobjEvo(Propagator(H)). """"""",MatchSource.CODE_COMMENT,qutip/solver/propagator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:901,Integrability,depend,dependent,901,"""""""; A generator of propagator for a system. Usage:. U = Propagator(H, c_ops). psi_t = U(t) @ psi_0. Save some previously computed propagator are stored to speed up subsequent; computation. Changing ``args`` will erase these stored probagator. Parameters; ----------; system : :obj:`.Qobj`, :obj:`.QobjEvo`, :class:`.Solver`; Possibly time-dependent system driving the evolution, either already; packaged in a solver, such as :class:`.SESolver` or :class:`.BRSolver`,; or the Liouvillian or Hamiltonian as a :obj:`.Qobj`,; :obj:`.QobjEvo`. ``list`` of [:obj:`.Qobj`, :obj:`.Coefficient`]; or callable that can be made into :obj:`.QobjEvo` are also accepted. Solvers that run non-deterministacilly, such as :class:`.MCSolver`, are; not supported. c_ops : list, optional; List of :obj:`.Qobj` or :obj:`.QobjEvo` collapse operators. args : dictionary, optional; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Options for the solver. memoize : int, default: 10; Max number of propagator to save. tol : float, default: 1e-14; Absolute tolerance for the time. If a previous propagator was computed; at a time within tolerance, that propagator will be returned. Notes; -----; The :class:`Propagator` is not a :obj:`.QobjEvo` so; it cannot be used for operations with :obj:`.Qobj` or; :obj:`.QobjEvo`. It can be made into a; :obj:`.QobjEvo` with ::. U = QobjEvo(Propagator(H)). """"""",MatchSource.CODE_COMMENT,qutip/solver/propagator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:19,Performance,cache,cache,19,"""""""; Get U(t) from cache or compute it.; """"""",MatchSource.CODE_COMMENT,qutip/solver/propagator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:283,Integrability,depend,dependent,283,"""""""; Get the propagator from ``t_start`` to ``t``. Parameters; ----------; t : float; Time at which to compute the propagator.; t_start: float [0]; Time at which the propagator start such that:; ``psi[t] = U.prop(t, t_start) @ psi[t_start]``; args : dict; Argument to pass to a time dependent Hamiltonian.; Updating ``args`` take effect since ``t=0`` and the new ``args``; will be used in future call.; """"""",MatchSource.CODE_COMMENT,qutip/solver/propagator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:207,Integrability,depend,dependent,207,"""""""; Get the inverse of the propagator at ``t``, such that; ``psi_0 = U.inv(t) @ psi_t``. Parameters; ----------; t : float; Time at which to compute the propagator.; args : dict; Argument to pass to a time dependent Hamiltonian.; Updating ``args`` take effect since ``t=0`` and the new ``args``; will be used in future call.; """"""",MatchSource.CODE_COMMENT,qutip/solver/propagator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:52,Deployability,integrat,integrator,52,"# Evolving backward in time is not supported by all integrator.",MatchSource.CODE_COMMENT,qutip/solver/propagator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:52,Integrability,integrat,integrator,52,"# Evolving backward in time is not supported by all integrator.",MatchSource.CODE_COMMENT,qutip/solver/propagator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:1768,Availability,avail,available,1768,"olver : str or None; The name of the solver generating these results. stats : dict or None; The stats generated by the solver while producing these results. Note; that the solver may update the stats directly while producing results. kw : dict; Additional parameters specific to a result sub-class. Attributes; ----------; times : list; A list of the times at which the expectation values and states were; recorded. states : list of :obj:`.Qobj`; The state at each time ``t`` (if the recording of the state was; requested). final_state : :obj:`.Qobj`:; The final state (if the recording of the final state was requested). expect : list of arrays of expectation values; A list containing the values of each ``e_op``. The list is in; the same order in which the ``e_ops`` were supplied and empty if; no ``e_ops`` were given. Each element is itself a list and contains the values of the; corresponding ``e_op``, with one value for each time in ``.times``. The same lists of values may be accessed via the ``.e_data`` dictionary; and the original ``e_ops`` are available via the ``.e_ops`` attribute. e_data : dict; A dictionary containing the values of each ``e_op``. If the ``e_ops``; were supplied as a dictionary, the keys are the same as in; that dictionary. Otherwise the keys are the index of the ``e_op``; in the ``.expect`` list. The lists of expectation values returned are the *same* lists as; those returned by ``.expect``. e_ops : dict; A dictionary containing the supplied e_ops as ``ExpectOp`` instances.; The keys of the dictionary are the same as for ``.e_data``.; Each value is object where ``.e_ops[k](t, state)`` calculates the; value of ``e_op`` ``k`` at time ``t`` and the given ``state``, and; ``.e_ops[k].op`` is the original object supplied to create the; ``e_op``. solver : str or None; The name of the solver generating these results. stats : dict or None; The stats generated by the solver while producing these results. options : dict; The options for this result class.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:894,Deployability,update,update,894,"""""""; Base class for storing solver results. Parameters; ----------; e_ops : :obj:`.Qobj`, :obj:`.QobjEvo`, function or list or dict of these; The ``e_ops`` parameter defines the set of values to record at; each time step ``t``. If an element is a :obj:`.Qobj` or; :obj:`.QobjEvo` the value recorded is the expectation value of that; operator given the state at ``t``. If the element is a function, ``f``,; the value recorded is ``f(t, state)``. The values are recorded in the ``e_data`` and ``expect`` attributes of; this result object. ``e_data`` is a dictionary and ``expect`` is a; list, where each item contains the values of the corresponding; ``e_op``. options : dict; The options for this result class. solver : str or None; The name of the solver generating these results. stats : dict or None; The stats generated by the solver while producing these results. Note; that the solver may update the stats directly while producing results. kw : dict; Additional parameters specific to a result sub-class. Attributes; ----------; times : list; A list of the times at which the expectation values and states were; recorded. states : list of :obj:`.Qobj`; The state at each time ``t`` (if the recording of the state was; requested). final_state : :obj:`.Qobj`:; The final state (if the recording of the final state was requested). expect : list of arrays of expectation values; A list containing the values of each ``e_op``. The list is in; the same order in which the ``e_ops`` were supplied and empty if; no ``e_ops`` were given. Each element is itself a list and contains the values of the; corresponding ``e_op``, with one value for each time in ``.times``. The same lists of values may be accessed via the ``.e_data`` dictionary; and the original ``e_ops`` are available via the ``.e_ops`` attribute. e_data : dict; A dictionary containing the values of each ``e_op``. If the ``e_ops``; were supplied as a dictionary, the keys are the same as in; that dictionary. Otherwise the keys are the ind",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:1696,Security,access,accessed,1696,"r this result class. solver : str or None; The name of the solver generating these results. stats : dict or None; The stats generated by the solver while producing these results. Note; that the solver may update the stats directly while producing results. kw : dict; Additional parameters specific to a result sub-class. Attributes; ----------; times : list; A list of the times at which the expectation values and states were; recorded. states : list of :obj:`.Qobj`; The state at each time ``t`` (if the recording of the state was; requested). final_state : :obj:`.Qobj`:; The final state (if the recording of the final state was requested). expect : list of arrays of expectation values; A list containing the values of each ``e_op``. The list is in; the same order in which the ``e_ops`` were supplied and empty if; no ``e_ops`` were given. Each element is itself a list and contains the values of the; corresponding ``e_op``, with one value for each time in ``.times``. The same lists of values may be accessed via the ``.e_data`` dictionary; and the original ``e_ops`` are available via the ``.e_ops`` attribute. e_data : dict; A dictionary containing the values of each ``e_op``. If the ``e_ops``; were supplied as a dictionary, the keys are the same as in; that dictionary. Otherwise the keys are the index of the ``e_op``; in the ``.expect`` list. The lists of expectation values returned are the *same* lists as; those returned by ``.expect``. e_ops : dict; A dictionary containing the supplied e_ops as ``ExpectOp`` instances.; The keys of the dictionary are the same as for ``.e_data``.; Each value is object where ``.e_ops[k](t, state)`` calculates the; value of ``e_op`` ``k`` at time ``t`` and the given ``state``, and; ``.e_ops[k].op`` is the original object supplied to create the; ``e_op``. solver : str or None; The name of the solver generating these results. stats : dict or None; The stats generated by the solver while producing these results. options : dict; The options for th",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:2786,Availability,avail,available,2786,"verage_expect : list of array of expectation values; A list containing the values of each ``e_op`` averaged over each; trajectories. The list is in the same order in which the ``e_ops`` were; supplied and empty if no ``e_ops`` were given. Each element is itself an array and contains the values of the; corresponding ``e_op``, with one value for each time in ``.times``. std_expect : list of array of expectation values; A list containing the standard derivation of each ``e_op`` over each; trajectories. The list is in the same order in which the ``e_ops`` were; supplied and empty if no ``e_ops`` were given. Each element is itself an array and contains the values of the; corresponding ``e_op``, with one value for each time in ``.times``. runs_expect : list of array of expectation values; A list containing the values of each ``e_op`` for each trajectories.; The list is in the same order in which the ``e_ops`` were; supplied and empty if no ``e_ops`` were given. Only available if the; storing of trajectories was requested. The order of the elements is ``runs_expect[e_ops][trajectory][time]``. Each element is itself an array and contains the values of the; corresponding ``e_op``, with one value for each time in ``.times``. average_e_data : dict; A dictionary containing the values of each ``e_op`` averaged over each; trajectories. If the ``e_ops`` were supplied as a dictionary, the keys; are the same as in that dictionary. Otherwise the keys are the index of; the ``e_op`` in the ``.expect`` list. The lists of expectation values returned are the *same* lists as; those returned by ``.expect``. average_e_data : dict; A dictionary containing the standard derivation of each ``e_op`` over; each trajectories. If the ``e_ops`` were supplied as a dictionary, the; keys are the same as in that dictionary. Otherwise the keys are the; index of the ``e_op`` in the ``.expect`` list. The lists of expectation values returned are the *same* lists as; those returned by ``.expect``. runs_e_data",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:4070,Availability,avail,available,4070,"h time in ``.times``. runs_expect : list of array of expectation values; A list containing the values of each ``e_op`` for each trajectories.; The list is in the same order in which the ``e_ops`` were; supplied and empty if no ``e_ops`` were given. Only available if the; storing of trajectories was requested. The order of the elements is ``runs_expect[e_ops][trajectory][time]``. Each element is itself an array and contains the values of the; corresponding ``e_op``, with one value for each time in ``.times``. average_e_data : dict; A dictionary containing the values of each ``e_op`` averaged over each; trajectories. If the ``e_ops`` were supplied as a dictionary, the keys; are the same as in that dictionary. Otherwise the keys are the index of; the ``e_op`` in the ``.expect`` list. The lists of expectation values returned are the *same* lists as; those returned by ``.expect``. average_e_data : dict; A dictionary containing the standard derivation of each ``e_op`` over; each trajectories. If the ``e_ops`` were supplied as a dictionary, the; keys are the same as in that dictionary. Otherwise the keys are the; index of the ``e_op`` in the ``.expect`` list. The lists of expectation values returned are the *same* lists as; those returned by ``.expect``. runs_e_data : dict; A dictionary containing the values of each ``e_op`` for each; trajectories. If the ``e_ops`` were supplied as a dictionary, the keys; are the same as in that dictionary. Otherwise the keys are the index of; the ``e_op`` in the ``.expect`` list. Only available if the storing; of trajectories was requested. The order of the elements is ``runs_expect[e_ops][trajectory][time]``. The lists of expectation values returned are the *same* lists as; those returned by ``.expect``. solver : str or None; The name of the solver generating these results. stats : dict or None; The stats generated by the solver while producing these results. options : :obj:`~SolverResultsOptions`; The options for this result class.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:952,Deployability,update,update,952,"""""""; Base class for storing results for solver using multiple trajectories. Parameters; ----------; e_ops : :obj:`.Qobj`, :obj:`.QobjEvo`, function or list or dict of these; The ``e_ops`` parameter defines the set of values to record at; each time step ``t``. If an element is a :obj:`.Qobj` or; :obj:`.QobjEvo` the value recorded is the expectation value of that; operator given the state at ``t``. If the element is a function, ``f``,; the value recorded is ``f(t, state)``. The values are recorded in the ``.expect`` attribute of this result; object. ``.expect`` is a list, where each item contains the values; of the corresponding ``e_op``. Function ``e_ops`` must return a number so the average can be computed. options : dict; The options for this result class. solver : str or None; The name of the solver generating these results. stats : dict or None; The stats generated by the solver while producing these results. Note; that the solver may update the stats directly while producing results. kw : dict; Additional parameters specific to a result sub-class. Attributes; ----------; times : list; A list of the times at which the expectation values and states were; recorded. average_states : list of :obj:`.Qobj`; The state at each time ``t`` (if the recording of the state was; requested) averaged over all trajectories as a density matrix. runs_states : list of list of :obj:`.Qobj`; The state for each trajectory and each time ``t`` (if the recording of; the states and trajectories was requested). final_state : :obj:`.Qobj`:; The final state (if the recording of the final state was requested); averaged over all trajectories as a density matrix. runs_final_state : list of :obj:`.Qobj`; The final state for each trajectory (if the recording of the final; state and trajectories was requested). average_expect : list of array of expectation values; A list containing the values of each ``e_op`` averaged over each; trajectories. The list is in the same order in which the ``e_ops`` were",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:100,Availability,error,error,100,"# mean(expect**2) - mean(expect)**2 can something be very small; # negative (-1e-15) which raise an error for float sqrt.",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:17,Availability,error,error,17,"""""""; Compute the error on the expectation values using jackknife resampling.; Return the approximate number of trajectories needed to have this; error within the tolerance fot all e_ops and times.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:145,Availability,error,error,145,"""""""; Compute the error on the expectation values using jackknife resampling.; Return the approximate number of trajectories needed to have this; error within the tolerance fot all e_ops and times.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:162,Availability,toler,tolerance,162,"""""""; Compute the error on the expectation values using jackknife resampling.; Return the approximate number of trajectories needed to have this; error within the tolerance fot all e_ops and times.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:466,Availability,toler,tolerance,466,"""""""; Add a trajectory to the evolution. Trajectories can be saved or average canbe extracted depending on the; options ``keep_runs_results``. Parameters; ----------; trajectory_info : tuple of seed and trajectory; - seed: int, SeedSequence; Seed used to generate the trajectory.; - trajectory : :class:`Result`; Run result for one evolution over the times. Returns; -------; remaing_traj : number; Return the number of trajectories still needed to reach the target; tolerance. If no tolerance is provided, return infinity.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:483,Availability,toler,tolerance,483,"""""""; Add a trajectory to the evolution. Trajectories can be saved or average canbe extracted depending on the; options ``keep_runs_results``. Parameters; ----------; trajectory_info : tuple of seed and trajectory; - seed: int, SeedSequence; Seed used to generate the trajectory.; - trajectory : :class:`Result`; Run result for one evolution over the times. Returns; -------; remaing_traj : number; Return the number of trajectories still needed to reach the target; tolerance. If no tolerance is provided, return infinity.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:93,Integrability,depend,depending,93,"""""""; Add a trajectory to the evolution. Trajectories can be saved or average canbe extracted depending on the; options ``keep_runs_results``. Parameters; ----------; trajectory_info : tuple of seed and trajectory; - seed: int, SeedSequence; Seed used to generate the trajectory.; - trajectory : :class:`Result`; Run result for one evolution over the times. Returns; -------; remaing_traj : number; Return the number of trajectories still needed to reach the target; tolerance. If no tolerance is provided, return infinity.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:272,Availability,toler,tolerance,272,"""""""; Set the condition to stop the computing trajectories when the certain; condition are fullfilled.; Supported end condition for multi trajectories computation are:. - Reaching a number of trajectories.; - Error bar on the expectation values reach smaller than a given; tolerance. Parameters; ----------; ntraj : int; Number of trajectories expected. target_tol : float, array_like, [optional]; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance, a pair of; absolute and relative tolerance, in that order. Lastly, it can be a; list of pairs of (atol, rtol) for each e_ops. Error estimation is done with jackknife resampling.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:404,Availability,toler,tolerance,404,"""""""; Set the condition to stop the computing trajectories when the certain; condition are fullfilled.; Supported end condition for multi trajectories computation are:. - Reaching a number of trajectories.; - Error bar on the expectation values reach smaller than a given; tolerance. Parameters; ----------; ntraj : int; Number of trajectories expected. target_tol : float, array_like, [optional]; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance, a pair of; absolute and relative tolerance, in that order. Lastly, it can be a; list of pairs of (atol, rtol) for each e_ops. Error estimation is done with jackknife resampling.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:483,Availability,error,error,483,"""""""; Set the condition to stop the computing trajectories when the certain; condition are fullfilled.; Supported end condition for multi trajectories computation are:. - Reaching a number of trajectories.; - Error bar on the expectation values reach smaller than a given; tolerance. Parameters; ----------; ntraj : int; Number of trajectories expected. target_tol : float, array_like, [optional]; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance, a pair of; absolute and relative tolerance, in that order. Lastly, it can be a; list of pairs of (atol, rtol) for each e_ops. Error estimation is done with jackknife resampling.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:535,Availability,toler,tolerance,535,"""""""; Set the condition to stop the computing trajectories when the certain; condition are fullfilled.; Supported end condition for multi trajectories computation are:. - Reaching a number of trajectories.; - Error bar on the expectation values reach smaller than a given; tolerance. Parameters; ----------; ntraj : int; Number of trajectories expected. target_tol : float, array_like, [optional]; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance, a pair of; absolute and relative tolerance, in that order. Lastly, it can be a; list of pairs of (atol, rtol) for each e_ops. Error estimation is done with jackknife resampling.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:550,Availability,error,error,550,"""""""; Set the condition to stop the computing trajectories when the certain; condition are fullfilled.; Supported end condition for multi trajectories computation are:. - Reaching a number of trajectories.; - Error bar on the expectation values reach smaller than a given; tolerance. Parameters; ----------; ntraj : int; Number of trajectories expected. target_tol : float, array_like, [optional]; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance, a pair of; absolute and relative tolerance, in that order. Lastly, it can be a; list of pairs of (atol, rtol) for each e_ops. Error estimation is done with jackknife resampling.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:631,Availability,toler,tolerance,631,"""""""; Set the condition to stop the computing trajectories when the certain; condition are fullfilled.; Supported end condition for multi trajectories computation are:. - Reaching a number of trajectories.; - Error bar on the expectation values reach smaller than a given; tolerance. Parameters; ----------; ntraj : int; Number of trajectories expected. target_tol : float, array_like, [optional]; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance, a pair of; absolute and relative tolerance, in that order. Lastly, it can be a; list of pairs of (atol, rtol) for each e_ops. Error estimation is done with jackknife resampling.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:675,Availability,toler,tolerance,675,"""""""; Set the condition to stop the computing trajectories when the certain; condition are fullfilled.; Supported end condition for multi trajectories computation are:. - Reaching a number of trajectories.; - Error bar on the expectation values reach smaller than a given; tolerance. Parameters; ----------; ntraj : int; Number of trajectories expected. target_tol : float, array_like, [optional]; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance, a pair of; absolute and relative tolerance, in that order. Lastly, it can be a; list of pairs of (atol, rtol) for each e_ops. Error estimation is done with jackknife resampling.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:26,Availability,avail,available,26,"""""""; Runs final states if available, average otherwise.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:26,Availability,avail,available,26,"""""""; Runs final states if available, average otherwise.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:871,Deployability,update,update,871,"""""""; Class for storing Monte-Carlo solver results. Parameters; ----------; e_ops : :obj:`.Qobj`, :obj:`.QobjEvo`, function or list or dict of these; The ``e_ops`` parameter defines the set of values to record at; each time step ``t``. If an element is a :obj:`.Qobj` or; :obj:`.QobjEvo` the value recorded is the expectation value of that; operator given the state at ``t``. If the element is a function, ``f``,; the value recorded is ``f(t, state)``. The values are recorded in the ``.expect`` attribute of this result; object. ``.expect`` is a list, where each item contains the values; of the corresponding ``e_op``. options : :obj:`~SolverResultsOptions`; The options for this result class. solver : str or None; The name of the solver generating these results. stats : dict; The stats generated by the solver while producing these results. Note; that the solver may update the stats directly while producing results.; Must include a value for ""num_collapse"". kw : dict; Additional parameters specific to a result sub-class. Attributes; ----------; collapse : list; For each runs, a list of every collapse as a tuple of the time it; happened and the corresponding ``c_ops`` index.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:100,Availability,error,error,100,"# mean(expect**2) - mean(expect)**2 can something be very small; # negative (-1e-15) which raise an error for float sqrt.",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:159,Usability,simpl,simply,159,"# This gets called during the Monte-Carlo simulation of the associated; # completely positive master equation. To obtain the state of the actual; # system, we simply multiply the provided state with the current martingale; # before storing it / computing expectation values.",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:896,Deployability,update,update,896,"""""""; Class for storing the results of the non-Markovian Monte-Carlo solver. Parameters; ----------; e_ops : :obj:`.Qobj`, :obj:`.QobjEvo`, function or list or dict of these; The ``e_ops`` parameter defines the set of values to record at; each time step ``t``. If an element is a :obj:`.Qobj` or; :obj:`.QobjEvo` the value recorded is the expectation value of that; operator given the state at ``t``. If the element is a function, ``f``,; the value recorded is ``f(t, state)``. The values are recorded in the ``.expect`` attribute of this result; object. ``.expect`` is a list, where each item contains the values; of the corresponding ``e_op``. options : :obj:`~SolverResultsOptions`; The options for this result class. solver : str or None; The name of the solver generating these results. stats : dict; The stats generated by the solver while producing these results. Note; that the solver may update the stats directly while producing results.; Must include a value for ""num_collapse"". kw : dict; Additional parameters specific to a result sub-class. Attributes; ----------; average_trace : list; The average trace (i.e., averaged over all trajectories) at each time. std_trace : list; The standard deviation of the trace at each time. runs_trace : list of lists; For each recorded trajectory, the trace at each time.; Only present if ``keep_runs_results`` is set in the options.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:52,Integrability,depend,depending,52,"""""""; Refers to ``average_trace`` or ``runs_trace``, depending on whether; ``keep_runs_results`` is set in the options.; """"""",MatchSource.CODE_COMMENT,qutip/solver/result.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py:187,Deployability,configurat,configuration,187,"""""""; Photon scattering in quantum optical systems. This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).; """"""",MatchSource.CODE_COMMENT,qutip/solver/scattering.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py:187,Modifiability,config,configuration,187,"""""""; Photon scattering in quantum optical systems. This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).; """"""",MatchSource.CODE_COMMENT,qutip/solver/scattering.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py:17,Deployability,integrat,integrated,17,"""""""; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters; ----------; H : :class:`.Qobj` or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; `c_ops`.; psi0 : :class:`.Qobj`; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`.; n_emissions : int; Number of photons emitted by the system (into any combination of; waveguides).; c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zero_state : :class:`.Qobj`, optional; State representing zero excitations in the system. Defaults to; `basis(systemDims, 0)`.; construct_effective_hamiltonian : bool, default: True; Whether an effective Hamiltonian should be constructed from H and; c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; scattering_prob : float; The probability of scattering n photons from the system over the time; range specified.; """"""",MatchSource.CODE_COMMENT,qutip/solver/scattering.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py:17,Integrability,integrat,integrated,17,"""""""; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters; ----------; H : :class:`.Qobj` or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; `c_ops`.; psi0 : :class:`.Qobj`; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`.; n_emissions : int; Number of photons emitted by the system (into any combination of; waveguides).; c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zero_state : :class:`.Qobj`, optional; State representing zero excitations in the system. Defaults to; `basis(systemDims, 0)`.; construct_effective_hamiltonian : bool, default: True; Whether an effective Hamiltonian should be constructed from H and; c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; scattering_prob : float; The probability of scattering n photons from the system over the time; range specified.; """"""",MatchSource.CODE_COMMENT,qutip/solver/scattering.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py:14,Deployability,integrat,integrate,14,"# Iteratively integrate to obtain single value",MatchSource.CODE_COMMENT,qutip/solver/scattering.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py:14,Integrability,integrat,integrate,14,"# Iteratively integrate to obtain single value",MatchSource.CODE_COMMENT,qutip/solver/scattering.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2199,Availability,error,errors,2199,".Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :obj:`.Qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-od",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2434,Availability,error,error,2434,"allable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vector",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2777,Availability,toler,tolerance,2777,"e.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:172,Deployability,integrat,integrating,172,"""""""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (``psi0``) using a given; Hamiltonian (``H``), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :obj:`.Qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to ",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2448,Deployability,install,installed,2448,"allable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vector",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2701,Deployability,integrat,integration,2701,"e.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2798,Deployability,integrat,integrator,2798,"e.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:3101,Deployability,integrat,integration,3101,"e.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:172,Integrability,integrat,integrating,172,"""""""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (``psi0``) using a given; Hamiltonian (``H``), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :obj:`.Qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to ",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:754,Integrability,depend,dependent,754,"""""""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (``psi0``) using a given; Hamiltonian (``H``), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :obj:`.Qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to ",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:786,Integrability,depend,dependent,786,"""""""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (``psi0``) using a given; Hamiltonian (``H``), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :obj:`.Qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to ",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:1109,Integrability,depend,dependent,1109,"n. Evolve the state vector (``psi0``) using a given; Hamiltonian (``H``), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :obj:`.Qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectat",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:1750,Integrability,depend,dependent,1750,"ator equation. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :obj:`.Qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | ",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2701,Integrability,integrat,integration,2701,"e.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2798,Integrability,integrat,integrator,2798,"e.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:3084,Integrability,depend,depending,3084,"e.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:3101,Integrability,integrat,integration,3101,"e.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:266,Modifiability,evolve,evolve,266,"""""""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (``psi0``) using a given; Hamiltonian (``H``), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :obj:`.Qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to ",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2311,Modifiability,enhance,enhanced,2311," `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation valu",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:206,Integrability,depend,dependent,206,"""""""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. options : dict, optional; Options for the solver, see :obj:`SESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:402,Availability,error,errors,402,"""""""; Solver's options:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: True; Normalize output state to hide ODE numerical errors. progress_bar: str {""text"", ""enhanced"", ""tqdm"", """"}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:572,Availability,error,error,572,"""""""; Solver's options:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: True; Normalize output state to hide ODE numerical errors. progress_bar: str {""text"", ""enhanced"", ""tqdm"", """"}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:586,Deployability,install,installed,586,"""""""; Solver's options:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: True; Normalize output state to hide ODE numerical errors. progress_bar: str {""text"", ""enhanced"", ""tqdm"", """"}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:834,Deployability,integrat,integration,834,"""""""; Solver's options:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: True; Normalize output state to hide ODE numerical errors. progress_bar: str {""text"", ""enhanced"", ""tqdm"", """"}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:834,Integrability,integrat,integration,834,"""""""; Solver's options:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: True; Normalize output state to hide ODE numerical errors. progress_bar: str {""text"", ""enhanced"", ""tqdm"", """"}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:438,Modifiability,enhance,enhanced,438,"""""""; Solver's options:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: True; Normalize output state to hide ODE numerical errors. progress_bar: str {""text"", ""enhanced"", ""tqdm"", """"}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:623,Deployability,integrat,integration,623,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": SESolver.StateFeedback()})``. The ``func`` will receive the ket as ``state`` during the evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. prop : bool, default : False; Set to True when using sesolve for computing propagators. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:49,Integrability,depend,dependent,49,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": SESolver.StateFeedback()})``. The ``func`` will receive the ket as ``state`` during the evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. prop : bool, default : False; Set to True when using sesolve for computing propagators. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:606,Integrability,depend,depending,606,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": SESolver.StateFeedback()})``. The ``func`` will receive the ket as ``state`` during the evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. prop : bool, default : False; Set to True when using sesolve for computing propagators. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:623,Integrability,integrat,integration,623,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": SESolver.StateFeedback()})``. The ``func`` will receive the ket as ``state`` during the evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. prop : bool, default : False; Set to True when using sesolve for computing propagators. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:141,Availability,toler,tolerance,141,"# Don't normalize output if input is not normalized.; # Use the settings atol instead of the solver one since the second; # refer to the ODE tolerance and some integrator do not use it.",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:160,Deployability,integrat,integrator,160,"# Don't normalize output if input is not normalized.; # Use the settings atol instead of the solver one since the second; # refer to the ODE tolerance and some integrator do not use it.",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:160,Integrability,integrat,integrator,160,"# Don't normalize output if input is not normalized.; # Use the settings atol instead of the solver one since the second; # refer to the ODE tolerance and some integrator do not use it.",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:28,Deployability,integrat,integrator,28,"# TODO: It would be nice if integrator could give evolution statistics; # stats.update(_integrator.stats)",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:80,Deployability,update,update,80,"# TODO: It would be nice if integrator could give evolution statistics; # stats.update(_integrator.stats)",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:28,Integrability,integrat,integrator,28,"# TODO: It would be nice if integrator could give evolution statistics; # stats.update(_integrator.stats)",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:115,Modifiability,evolve,evolve,115,"""""""; Evolve the state to ``t`` and return the state as a :obj:`.Qobj`. Parameters; ----------; t : double; Time to evolve to, must be higher than the last call. args : dict, optional {None}; Update the ``args`` of the system.; The change is effective from the beginning of the interval.; Changing ``args`` can slow the evolution. copy : bool, optional {True}; Whether to return a copy of the data or the data in the ODE solver. Notes; -----; The state must be initialized first by calling :meth:`start` or; :meth:`run`. If :meth:`run` is called, :meth:`step` will continue from; the last time and state obtained. """"""",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:26,Deployability,integrat,integrator,26,""""""" Return the initialted integrator. """"""",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:26,Integrability,integrat,integrator,26,""""""" Return the initialted integrator. """"""",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:55,Deployability,integrat,integration,55,"""""""; method: str; Which ordinary differential equation integration method to use.; """"""",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:55,Integrability,integrat,integration,55,"""""""; method: str; Which ordinary differential equation integration method to use.; """"""",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:136,Deployability,update,update,136,"""""""; Method called when options are changed, either through; ``solver.options[key] = value`` or ``solver.options = options``.; Allow to update the solver with the new options; """"""",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:35,Deployability,integrat,integrator,35,"# Some of the keys are used by the integrator.",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:35,Integrability,integrat,integrator,35,"# Some of the keys are used by the integrator.",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:17,Deployability,integrat,integrator,17,"""""""; Register an integrator. Parameters; ----------; integrator : Integrator; The ODE solver to register. keys : list of str; Values of the method options that refer to this integrator.; """"""",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:53,Deployability,integrat,integrator,53,"""""""; Register an integrator. Parameters; ----------; integrator : Integrator; The ODE solver to register. keys : list of str; Values of the method options that refer to this integrator.; """"""",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:174,Deployability,integrat,integrator,174,"""""""; Register an integrator. Parameters; ----------; integrator : Integrator; The ODE solver to register. keys : list of str; Values of the method options that refer to this integrator.; """"""",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:17,Integrability,integrat,integrator,17,"""""""; Register an integrator. Parameters; ----------; integrator : Integrator; The ODE solver to register. keys : list of str; Values of the method options that refer to this integrator.; """"""",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:53,Integrability,integrat,integrator,53,"""""""; Register an integrator. Parameters; ----------; integrator : Integrator; The ODE solver to register. keys : list of str; Values of the method options that refer to this integrator.; """"""",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:174,Integrability,integrat,integrator,174,"""""""; Register an integrator. Parameters; ----------; integrator : Integrator; The ODE solver to register. keys : list of str; Values of the method options that refer to this integrator.; """"""",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:89,Integrability,depend,dependent,89,"""""""; Expectation value of the instantaneous state of the evolution to be; used by a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""E0"": Solver.ExpectFeedback(oper)})``. The ``func`` will receive ``expect(oper, state)`` as ``E0`` during the; evolution. Parameters; ----------; operator : Qobj, QobjEvo; Operator to compute the expectation values of. default : float, default : 0.; Initial value to be used at setup.; """"""",MatchSource.CODE_COMMENT,qutip/solver/solver_base.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/spectrum.py:19,Energy Efficiency,power,power,19,"""""""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: bool, default: False; boolean parameter for using a positive exponent in the Fourier; Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """"""",MatchSource.CODE_COMMENT,qutip/solver/spectrum.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/spectrum.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/spectrum.py:536,Energy Efficiency,power,power,536,"""""""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: bool, default: False; boolean parameter for using a positive exponent in the Fourier; Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """"""",MatchSource.CODE_COMMENT,qutip/solver/spectrum.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/spectrum.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:1247,Availability,avail,available,1247,"an then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str, {""direct"", ""eigen"", ""svd"", ""power""}, default: ""direct""; The allowed methods are composed of 2 parts, the steadystate method:; - ""direct"": Solving ``L(rho_ss) = 0``; - ""eigen"" : Eigenvalue problem; - ""svd"" : Singular value decomposition; - ""power"" : Inverse-power method. solver : str, optional; 'direct' and 'power' methods only.; Solver to use when solving the ``L(rho_ss) = 0`` equation.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for the solution when using the 'power' method. power_maxiter : int, default: 10; Maximum number of iteration to use when looking for a solution when; using the 'power' method. power_eps: double, default: 1e-",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:497,Energy Efficiency,power,power,497,"""""""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str, {""direct"", ""eigen"", ""svd"", ""power""}, default: ""direct""; The allowed methods are composed of 2 parts, the steadystate method:; - ""direct"": Solving ``L(rho_ss) = 0``; - ""eigen"" : Eigenvalue problem; - ""svd"" : Singular value decomposition; - ""power"" : Inverse-power method. solver : str, optional; 'direct' and 'power' methods only.; Solver to use when solving the ``L(rho_ss) = 0`` equation.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:709,Energy Efficiency,power,power,709,"""""""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str, {""direct"", ""eigen"", ""svd"", ""power""}, default: ""direct""; The allowed methods are composed of 2 parts, the steadystate method:; - ""direct"": Solving ``L(rho_ss) = 0``; - ""eigen"" : Eigenvalue problem; - ""svd"" : Singular value decomposition; - ""power"" : Inverse-power method. solver : str, optional; 'direct' and 'power' methods only.; Solver to use when solving the ``L(rho_ss) = 0`` equation.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:726,Energy Efficiency,power,power,726,"""""""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str, {""direct"", ""eigen"", ""svd"", ""power""}, default: ""direct""; The allowed methods are composed of 2 parts, the steadystate method:; - ""direct"": Solving ``L(rho_ss) = 0``; - ""eigen"" : Eigenvalue problem; - ""svd"" : Singular value decomposition; - ""power"" : Inverse-power method. solver : str, optional; 'direct' and 'power' methods only.; Solver to use when solving the ``L(rho_ss) = 0`` equation.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:778,Energy Efficiency,power,power,778,"""""""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str, {""direct"", ""eigen"", ""svd"", ""power""}, default: ""direct""; The allowed methods are composed of 2 parts, the steadystate method:; - ""direct"": Solving ``L(rho_ss) = 0``; - ""eigen"" : Eigenvalue problem; - ""svd"" : Singular value decomposition; - ""power"" : Inverse-power method. solver : str, optional; 'direct' and 'power' methods only.; Solver to use when solving the ``L(rho_ss) = 0`` equation.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:1481,Energy Efficiency,power,power,1481,"ct"", ""eigen"", ""svd"", ""power""}, default: ""direct""; The allowed methods are composed of 2 parts, the steadystate method:; - ""direct"": Solving ``L(rho_ss) = 0``; - ""eigen"" : Eigenvalue problem; - ""svd"" : Singular value decomposition; - ""power"" : Inverse-power method. solver : str, optional; 'direct' and 'power' methods only.; Solver to use when solving the ``L(rho_ss) = 0`` equation.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for the solution when using the 'power' method. power_maxiter : int, default: 10; Maximum number of iteration to use when looking for a solution when; using the 'power' method. power_eps: double, default: 1e-15; Small weight used in the ""power"" method. sparse: bool, default: True; Whether to use the sparse eigen solver with the ""eigen"" method; (default sparse). With ""direct"" and ""power"" method, when the solver is; not specified, it is used to set whether ""solve"" or ""spsolve",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:1692,Energy Efficiency,power,power,1692,"lue decomposition; - ""power"" : Inverse-power method. solver : str, optional; 'direct' and 'power' methods only.; Solver to use when solving the ``L(rho_ss) = 0`` equation.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for the solution when using the 'power' method. power_maxiter : int, default: 10; Maximum number of iteration to use when looking for a solution when; using the 'power' method. power_eps: double, default: 1e-15; Small weight used in the ""power"" method. sparse: bool, default: True; Whether to use the sparse eigen solver with the ""eigen"" method; (default sparse). With ""direct"" and ""power"" method, when the solver is; not specified, it is used to set whether ""solve"" or ""spsolve"" is; used as default solver. **kwargs :; Extra options to pass to the linear system solver. See the; documentation of the used solver in ``numpy.linalg`` or; ``scipy.sparse.linalg`` to see what extra arguments ",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:2031,Energy Efficiency,power,power,2031,"g; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for the solution when using the 'power' method. power_maxiter : int, default: 10; Maximum number of iteration to use when looking for a solution when; using the 'power' method. power_eps: double, default: 1e-15; Small weight used in the ""power"" method. sparse: bool, default: True; Whether to use the sparse eigen solver with the ""eigen"" method; (default sparse). With ""direct"" and ""power"" method, when the solver is; not specified, it is used to set whether ""solve"" or ""spsolve"" is; used as default solver. **kwargs :; Extra options to pass to the linear system solver. See the; documentation of the used solver in ``numpy.linalg`` or; ``scipy.sparse.linalg`` to see what extra arguments are supported. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:2160,Energy Efficiency,power,power,2160,"g; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for the solution when using the 'power' method. power_maxiter : int, default: 10; Maximum number of iteration to use when looking for a solution when; using the 'power' method. power_eps: double, default: 1e-15; Small weight used in the ""power"" method. sparse: bool, default: True; Whether to use the sparse eigen solver with the ""eigen"" method; (default sparse). With ""direct"" and ""power"" method, when the solver is; not specified, it is used to set whether ""solve"" or ""spsolve"" is; used as default solver. **kwargs :; Extra options to pass to the linear system solver. See the; documentation of the used solver in ``numpy.linalg`` or; ``scipy.sparse.linalg`` to see what extra arguments are supported. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:2236,Energy Efficiency,power,power,2236,"g; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for the solution when using the 'power' method. power_maxiter : int, default: 10; Maximum number of iteration to use when looking for a solution when; using the 'power' method. power_eps: double, default: 1e-15; Small weight used in the ""power"" method. sparse: bool, default: True; Whether to use the sparse eigen solver with the ""eigen"" method; (default sparse). With ""direct"" and ""power"" method, when the solver is; not specified, it is used to set whether ""solve"" or ""spsolve"" is; used as default solver. **kwargs :; Extra options to pass to the linear system solver. See the; documentation of the used solver in ``numpy.linalg`` or; ``scipy.sparse.linalg`` to see what extra arguments are supported. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:2381,Energy Efficiency,power,power,2381,"g; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for the solution when using the 'power' method. power_maxiter : int, default: 10; Maximum number of iteration to use when looking for a solution when; using the 'power' method. power_eps: double, default: 1e-15; Small weight used in the ""power"" method. sparse: bool, default: True; Whether to use the sparse eigen solver with the ""eigen"" method; (default sparse). With ""direct"" and ""power"" method, when the solver is; not specified, it is used to set whether ""solve"" or ""spsolve"" is; used as default solver. **kwargs :; Extra options to pass to the linear system solver. See the; documentation of the used solver in ``numpy.linalg`` or; ``scipy.sparse.linalg`` to see what extra arguments are supported. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:19,Energy Efficiency,power,power-gmres,19,"# to support v4's ""power-gmres"" method",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:47,Availability,avail,available,47,"# Find the weight, no good dispatched function available...",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:99,Performance,optimiz,optimization,99,"# Dia is bad at vector, the following matmul is 10x slower with Dia; # than CSR and Dia is missing optimization such as `use_wbm`.",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:76,Integrability,depend,dependent,76,"""""""; Calculates the effective steady state for a driven; system with a time-dependent cosinusoidal term:. .. math::. \\mathcal{\\hat{H}}(t) = \\hat{H}_0 +; \\mathcal{\\hat{O}} \\cos(\\omega_d t). Parameters; ----------; H_0 : :obj:`.Qobj`; A Hamiltonian or Liouvillian operator. c_ops : list; A list of collapse operators. Op_t : :obj:`.Qobj`; The the interaction operator which is multiplied by the cosine. w_d : float, default: 1.0; The frequency of the drive. n_it : int, default: 3; The number of iterations for the solver. sparse : bool, default: False; Solve for the steady state using sparse algorithms. solver : str, optional; Solver to use when solving the linear system.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extensions to qutip, such as qutip-tensorflow, may provide their own; solvers. When ``H_0`` and ``c_ops`` use these data backends, see their; documentation for the names and details of additional solvers they may; provide. **kwargs:; Extra options to pass to the linear system solver. See the; documentation of the used solver in ``numpy.linalg`` or; ``scipy.sparse.linalg`` to see what extra arguments are supported. Returns; -------; dm : qobj; Steady state density matrix. Notes; -----; See: Sze Meng Tan,; https://painterlab.caltech.edu/wp-content/uploads/2019/06/qe_quantum_optics_toolbox.pdf,; Section (16). """"""",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:1206,Availability,avail,available,1206,"-----; L : Qobj; A Liouvillian superoperator for which to compute the pseudo inverse. rhoss : Qobj, optional; A steadystate density matrix as Qobj instance, for the Liouvillian; superoperator L. w : double, optional; frequency at which to evaluate pseudo-inverse. Can be zero for dense; systems and large sparse systems. Small sparse systems can fail for; zero frequencies. sparse : bool, optional; Flag that indicate whether to use sparse or dense matrix methods when; computing the pseudo inverse. method : str, optional; Method used to compte matrix inverse.; Choice are 'pinv' to use scipy's function of the same name, or a linear; system solver.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab"", ""splu""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve"",; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``L`` use these data backends, see the corresponding; libraries ``linalg`` for available solver. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. kwargs : dictionary; Additional keyword arguments for setting parameters for solver methods. Returns; -------; R : Qobj; Returns a Qobj instance representing the pseudo inverse of L. Notes; -----; In general the inverse of a sparse matrix will be dense. If you; are applying the inverse to a density matrix then it is better to; cast the problem as an Ax=b type problem where the explicit calculation; of the inverse is not required. See page 67 of ""Electrons in; nanostructures"" C. Flindt, PhD Thesis available online:; https://orbit.dtu.dk/en/publications/electrons-in-nanostructures-coherent-manipulation-and-counting-st. Note also that the definition of the pseudo-inverse herein is different; from numpys pinv() alone, as it includes pre and post projection onto; the subspace defined by the projector Q. """"""",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:1860,Availability,avail,available,1860,"------; L : Qobj; A Liouvillian superoperator for which to compute the pseudo inverse. rhoss : Qobj, optional; A steadystate density matrix as Qobj instance, for the Liouvillian; superoperator L. w : double, optional; frequency at which to evaluate pseudo-inverse. Can be zero for dense; systems and large sparse systems. Small sparse systems can fail for; zero frequencies. sparse : bool, optional; Flag that indicate whether to use sparse or dense matrix methods when; computing the pseudo inverse. method : str, optional; Method used to compte matrix inverse.; Choice are 'pinv' to use scipy's function of the same name, or a linear; system solver.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab"", ""splu""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve"",; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``L`` use these data backends, see the corresponding; libraries ``linalg`` for available solver. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. kwargs : dictionary; Additional keyword arguments for setting parameters for solver methods. Returns; -------; R : Qobj; Returns a Qobj instance representing the pseudo inverse of L. Notes; -----; In general the inverse of a sparse matrix will be dense. If you; are applying the inverse to a density matrix then it is better to; cast the problem as an Ax=b type problem where the explicit calculation; of the inverse is not required. See page 67 of ""Electrons in; nanostructures"" C. Flindt, PhD Thesis available online:; https://orbit.dtu.dk/en/publications/electrons-in-nanostructures-coherent-manipulation-and-counting-st. Note also that the definition of the pseudo-inverse herein is different; from numpys pinv() alone, as it includes pre and post projection onto; the subspace defined by the projector Q. """"""",MatchSource.CODE_COMMENT,qutip/solver/steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:123,Safety,detect,detection,123,"""""""; Wiener processes for each stochastic collapse operators. The output shape is; (len(sc_ops), len(tlist)); for homodyne detection, and; (len(sc_ops), 2, len(tlist)); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:184,Safety,detect,detection,184,"""""""; Wiener processes for each stochastic collapse operators. The output shape is; (len(sc_ops), len(tlist)); for homodyne detection, and; (len(sc_ops), 2, len(tlist)); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:125,Safety,detect,detection,125,"""""""; Wiener increment for each stochastic collapse operators. The output shape is; (len(sc_ops), len(tlist)-1); for homodyne detection, and; (len(sc_ops), 2, len(tlist)-1); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:188,Safety,detect,detection,188,"""""""; Wiener increment for each stochastic collapse operators. The output shape is; (len(sc_ops), len(tlist)-1); for homodyne detection, and; (len(sc_ops), 2, len(tlist)-1); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:121,Safety,detect,detection,121,"""""""; Measurements for each stochastic collapse operators. The output shape is; (len(sc_ops), len(tlist)-1); for homodyne detection, and; (len(sc_ops), 2, len(tlist)-1); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:184,Safety,detect,detection,184,"""""""; Measurements for each stochastic collapse operators. The output shape is; (len(sc_ops), len(tlist)-1); for homodyne detection, and; (len(sc_ops), 2, len(tlist)-1); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:145,Safety,detect,detection,145,"""""""; Measurements for each trajectories and stochastic collapse operators. The output shape is; (ntraj, len(sc_ops), len(tlist)-1); for homodyne detection, and; (ntraj, len(sc_ops), 2, len(tlist)-1); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:215,Safety,detect,detection,215,"""""""; Measurements for each trajectories and stochastic collapse operators. The output shape is; (ntraj, len(sc_ops), len(tlist)-1); for homodyne detection, and; (ntraj, len(sc_ops), 2, len(tlist)-1); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:150,Safety,detect,detection,150,"""""""; Wiener increment for each trajectories and stochastic collapse; operators. The output shape is; (ntraj, len(sc_ops), len(tlist)-1); for homodyne detection, and; (ntraj, len(sc_ops), 2, len(tlist)-1); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:220,Safety,detect,detection,220,"""""""; Wiener increment for each trajectories and stochastic collapse; operators. The output shape is; (ntraj, len(sc_ops), len(tlist)-1); for homodyne detection, and; (ntraj, len(sc_ops), 2, len(tlist)-1); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:150,Safety,detect,detection,150,"""""""; Wiener processes for each trajectories and stochastic collapse; operators. The output shape is; (ntraj, len(sc_ops), len(tlist)-1); for homodyne detection, and; (ntraj, len(sc_ops), 2, len(tlist)-1); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:220,Safety,detect,detection,220,"""""""; Wiener processes for each trajectories and stochastic collapse; operators. The output shape is; (ntraj, len(sc_ops), len(tlist)-1); for homodyne detection, and; (ntraj, len(sc_ops), 2, len(tlist)-1); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:286,Deployability,integrat,integrator,286,"""""""; In between object to store the stochastic system. It store the Hamiltonian (not Liouvillian when possible), and sc_ops.; dims and flags are provided to be usable the the base ``Solver`` class. We don't want to use the cython rhs (``StochasticOpenSystem``, etc.) since; the rouchon integrator need the part but does not use the usual drift and; diffusion computation.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:286,Integrability,integrat,integrator,286,"""""""; In between object to store the stochastic system. It store the Hamiltonian (not Liouvillian when possible), and sc_ops.; dims and flags are provided to be usable the the base ``Solver`` class. We don't want to use the cython rhs (``StochasticOpenSystem``, etc.) since; the rouchon integrator need the part but does not use the usual drift and; diffusion computation.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:160,Usability,usab,usable,160,"""""""; In between object to store the stochastic system. It store the Hamiltonian (not Liouvillian when possible), and sc_ops.; dims and flags are provided to be usable the the base ``Solver`` class. We don't want to use the cython rhs (``StochasticOpenSystem``, etc.) since; the rouchon integrator need the part but does not use the usual drift and; diffusion computation.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1667,Availability,toler,tolerance,1667,"bjEvo`, :obj:`.QobjEvo` compatible format); List of stochastic collapse operators. e_ops : : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`.expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1746,Availability,error,error,1746,"ss:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`.expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : boo",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1798,Availability,toler,tolerance,1798,"ss:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`.expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : boo",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1881,Availability,error,error,1881,"e.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`.expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE nu",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1962,Availability,toler,tolerance,1962,"t` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already norma",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:2008,Availability,toler,tolerance,2008,"t` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already norma",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:2909,Availability,error,errors,2909,"``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integ",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3144,Availability,error,error,3144,"ional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation in",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3791,Availability,avail,available,3791,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:4064,Availability,avail,available,4064,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3158,Deployability,install,installed,3158,"ional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation in",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3371,Deployability,integrat,integration,3371,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3869,Deployability,integrat,integration,3869,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3922,Deployability,integrat,integrator,3922,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:4123,Deployability,integrat,integration,4123,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:183,Integrability,depend,dependent,183,"""""""; Solve stochastic master equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. rho0 : :class:`.Qobj`; Initial density matrix or state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); List of stochastic collapse operators. e_ops : : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`.expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; re",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1080,Integrability,depend,dependent,1080,"Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. rho0 : :class:`.Qobj`; Initial density matrix or state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); List of stochastic collapse operators. e_ops : : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`.expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3371,Integrability,integrat,integration,3371,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3869,Integrability,integrat,integration,3869,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3905,Integrability,depend,depending,3905,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3922,Integrability,integrat,integrator,3922,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:4074,Integrability,depend,depending,4074,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:4123,Integrability,integrat,integration,4123,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3021,Modifiability,enhance,enhanced,3021,"Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.opti",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1263,Safety,detect,detection,1263,":obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. rho0 : :class:`.Qobj`; Initial density matrix or state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); List of stochastic collapse operators. e_ops : : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`.expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Ove",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:2105,Safety,timeout,timeout,2105,"t, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and rais",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3769,Safety,detect,detect,3769,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1407,Availability,toler,tolerance,1407," *array*; List of times for :math:`t`. sc_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); List of stochastic collapse operators. e_ops : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to st",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1486,Availability,error,error,1486,"ble format); List of stochastic collapse operators. e_ops : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1538,Availability,toler,tolerance,1538,"ble format); List of stochastic collapse operators. e_ops : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1621,Availability,error,error,1621,"h to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state t",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1702,Availability,toler,tolerance,1702,"ignature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is ",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1748,Availability,toler,tolerance,1748,"ignature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is ",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:2662,Availability,error,errors,2662," is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integ",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:2897,Availability,error,error,2897,"me for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation in",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3544,Availability,avail,available,3544,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3817,Availability,avail,available,3817,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:2911,Deployability,install,installed,2911,"me for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation in",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3124,Deployability,integrat,integration,3124,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3622,Deployability,integrat,integration,3622,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3675,Deployability,integrat,integrator,3675,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3876,Deployability,integrat,integration,3876,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:188,Integrability,depend,dependent,188,"""""""; Solve stochastic Schrodinger equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. sc_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); List of stochastic collapse operators. e_ops : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:883,Integrability,depend,dependent,883,"""""""; Solve stochastic Schrodinger equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. sc_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); List of stochastic collapse operators. e_ops : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3124,Integrability,integrat,integration,3124,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3622,Integrability,integrat,integration,3622,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3658,Integrability,depend,depending,3658,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3675,Integrability,integrat,integrator,3675,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3827,Integrability,depend,depending,3827,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3876,Integrability,integrat,integration,3876,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:2774,Modifiability,enhance,enhanced,2774,"n be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.opti",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1066,Safety,detect,detection,1066,"equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. sc_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); List of stochastic collapse operators. e_ops : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dicti",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1841,Safety,timeout,timeout,1841,"for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the s",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3522,Safety,detect,detect,3522,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:87,Safety,detect,detection,87,"""""""; Measurements operators. Default are:. m_ops = sc_ops + sc_ops.dag(). for homodyne detection, and. m_ops = sc_ops + sc_ops.dag(), -1j*(sc_ops - sc_ops.dag()). for heterodyne detection. Measurements opput is computed as:. expect(m_ops_i, state(t)) + dW_i / dt * dW_factors. Where ``dW`` follows a gaussian distribution with norm 0 and derivation; of ``dt**0.5``. ``dt`` is the time difference between step in the; ``tlist``. ``m_ops`` can be overwritten, but the number of operators must be; constant.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:178,Safety,detect,detection,178,"""""""; Measurements operators. Default are:. m_ops = sc_ops + sc_ops.dag(). for homodyne detection, and. m_ops = sc_ops + sc_ops.dag(), -1j*(sc_ops - sc_ops.dag()). for heterodyne detection. Measurements opput is computed as:. expect(m_ops_i, state(t)) + dW_i / dt * dW_factors. Where ``dW`` follows a gaussian distribution with norm 0 and derivation; of ``dt**0.5``. ``dt`` is the time difference between step in the; ``tlist``. ``m_ops`` can be overwritten, but the number of operators must be; constant.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:700,Availability,error,error,700,"""""""; Options for stochastic solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: None, bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. store_measurement: bool, default: False; Whether to store the measurement for each trajectories.; Storing measurements will also store the wiener process, or; brownian noise for each trajectories. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress. 'tqdm' uses the python module; of the same name and raise an error if not installed. Empty string; or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. normalize_output: bool; Normalize output state to hide ODE numerical errors. method: str, default: ""platen""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int, default: None; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64DXSM"", ...}, default: None; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1079,Availability,error,errors,1079,"""""""; Options for stochastic solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: None, bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. store_measurement: bool, default: False; Whether to store the measurement for each trajectories.; Storing measurements will also store the wiener process, or; brownian noise for each trajectories. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress. 'tqdm' uses the python module; of the same name and raise an error if not installed. Empty string; or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. normalize_output: bool; Normalize output state to hide ODE numerical errors. method: str, default: ""platen""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int, default: None; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64DXSM"", ...}, default: None; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1779,Availability,avail,available,1779,"""""""; Options for stochastic solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: None, bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. store_measurement: bool, default: False; Whether to store the measurement for each trajectories.; Storing measurements will also store the wiener process, or; brownian noise for each trajectories. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress. 'tqdm' uses the python module; of the same name and raise an error if not installed. Empty string; or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. normalize_output: bool; Normalize output state to hide ODE numerical errors. method: str, default: ""platen""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int, default: None; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64DXSM"", ...}, default: None; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:713,Deployability,install,installed,713,"""""""; Options for stochastic solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: None, bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. store_measurement: bool, default: False; Whether to store the measurement for each trajectories.; Storing measurements will also store the wiener process, or; brownian noise for each trajectories. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress. 'tqdm' uses the python module; of the same name and raise an error if not installed. Empty string; or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. normalize_output: bool; Normalize output state to hide ODE numerical errors. method: str, default: ""platen""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int, default: None; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64DXSM"", ...}, default: None; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1147,Deployability,integrat,integration,1147,"""""""; Options for stochastic solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: None, bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. store_measurement: bool, default: False; Whether to store the measurement for each trajectories.; Storing measurements will also store the wiener process, or; brownian noise for each trajectories. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress. 'tqdm' uses the python module; of the same name and raise an error if not installed. Empty string; or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. normalize_output: bool; Normalize output state to hide ODE numerical errors. method: str, default: ""platen""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int, default: None; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64DXSM"", ...}, default: None; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1147,Integrability,integrat,integration,1147,"""""""; Options for stochastic solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: None, bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. store_measurement: bool, default: False; Whether to store the measurement for each trajectories.; Storing measurements will also store the wiener process, or; brownian noise for each trajectories. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress. 'tqdm' uses the python module; of the same name and raise an error if not installed. Empty string; or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. normalize_output: bool; Normalize output state to hide ODE numerical errors. method: str, default: ""platen""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int, default: None; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64DXSM"", ...}, default: None; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:562,Modifiability,enhance,enhanced,562,"""""""; Options for stochastic solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: None, bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. store_measurement: bool, default: False; Whether to store the measurement for each trajectories.; Storing measurements will also store the wiener process, or; brownian noise for each trajectories. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress. 'tqdm' uses the python module; of the same name and raise an error if not installed. Empty string; or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. normalize_output: bool; Normalize output state to hide ODE numerical errors. method: str, default: ""platen""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int, default: None; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64DXSM"", ...}, default: None; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1757,Safety,detect,detect,1757,"""""""; Options for stochastic solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: None, bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. store_measurement: bool, default: False; Whether to store the measurement for each trajectories.; Storing measurements will also store the wiener process, or; brownian noise for each trajectories. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress. 'tqdm' uses the python module; of the same name and raise an error if not installed. Empty string; or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. normalize_output: bool; Normalize output state to hide ODE numerical errors. method: str, default: ""platen""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int, default: None; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64DXSM"", ...}, default: None; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used.; """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:57,Integrability,depend,dependent,57,"""""""; Wiener function of the trajectory argument for time dependent systems. When used as an args:. ``QobjEvo([op, func], args={""W"": SMESolver.WienerFeedback()})``. The ``func`` will receive a function as ``W`` that return an array of; wiener processes values at ``t``. The wiener process for the i-th; sc_ops is the i-th element for homodyne detection and the (2i, 2i+1); pairs of process in heterodyne detection. The process is a step; function with step of length ``options[""dt""]``. .. note::. WienerFeedback can't be added to a running solver when updating; arguments between steps: ``solver.step(..., args={})``. Parameters; ----------; default : callable, optional; Default function used outside the solver.; When not passed, a function returning ``np.array([0])`` is used. """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:342,Safety,detect,detection,342,"""""""; Wiener function of the trajectory argument for time dependent systems. When used as an args:. ``QobjEvo([op, func], args={""W"": SMESolver.WienerFeedback()})``. The ``func`` will receive a function as ``W`` that return an array of; wiener processes values at ``t``. The wiener process for the i-th; sc_ops is the i-th element for homodyne detection and the (2i, 2i+1); pairs of process in heterodyne detection. The process is a step; function with step of length ``options[""dt""]``. .. note::. WienerFeedback can't be added to a running solver when updating; arguments between steps: ``solver.step(..., args={})``. Parameters; ----------; default : callable, optional; Default function used outside the solver.; When not passed, a function returning ``np.array([0])`` is used. """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:403,Safety,detect,detection,403,"""""""; Wiener function of the trajectory argument for time dependent systems. When used as an args:. ``QobjEvo([op, func], args={""W"": SMESolver.WienerFeedback()})``. The ``func`` will receive a function as ``W`` that return an array of; wiener processes values at ``t``. The wiener process for the i-th; sc_ops is the i-th element for homodyne detection and the (2i, 2i+1); pairs of process in heterodyne detection. The process is a step; function with step of length ``options[""dt""]``. .. note::. WienerFeedback can't be added to a running solver when updating; arguments between steps: ``solver.step(..., args={})``. Parameters; ----------; default : callable, optional; Default function used outside the solver.; When not passed, a function returning ``np.array([0])`` is used. """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:600,Deployability,integrat,integration,600,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": SMESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. .. note::. Not supported by the ``rouchon`` mehtod. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method. """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:49,Integrability,depend,dependent,49,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": SMESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. .. note::. Not supported by the ``rouchon`` mehtod. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method. """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:583,Integrability,depend,depending,583,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": SMESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. .. note::. Not supported by the ``rouchon`` mehtod. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method. """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:600,Integrability,integrat,integration,600,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": SMESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. .. note::. Not supported by the ``rouchon`` mehtod. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method. """"""",MatchSource.CODE_COMMENT,qutip/solver/stochastic.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:59,Availability,toler,tolerance,59,""""""" Return true if Q1 and Q2 are equal to within the given tolerance. """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:2026,Availability,avail,available,2026,"on mode) within the; decomposition of the correlation functions of a bath. Parameters; ----------; type : {""R"", ""I"", ""RI"", ""+"", ""-""} or BathExponent.ExponentType; The type of bath exponent. ""R"" and ""I"" are bosonic bath exponents that appear in the real and; imaginary parts of the correlation expansion. ""RI"" is combined bosonic bath exponent that appears in both the real; and imaginary parts of the correlation expansion. The combined exponent; has a single ``vk``. The ``ck`` is the coefficient in the real; expansion and ``ck2`` is the coefficient in the imaginary expansion. ""+"" and ""-"" are fermionic bath exponents. These fermionic bath; exponents must specify ``sigma_bar_k_offset`` which specifies; the amount to add to ``k`` (the exponent index within the bath of this; exponent) to determine the ``k`` of the corresponding exponent with; the opposite sign (i.e. ""-"" or ""+""). dim : int or None; The dimension (i.e. maximum number of excitations for this exponent).; Usually ``2`` for fermionic exponents or ``None`` (i.e. unlimited) for; bosonic exponents. Q : Qobj; The coupling operator for this excitation mode. vk : complex; The frequency of the exponent of the excitation term. ck : complex; The coefficient of the excitation term. ck2 : optional, complex; For exponents of type ""RI"" this is the coefficient of the term in the; imaginary expansion (and ``ck`` is the coefficient in the real; expansion). sigma_bar_k_offset : optional, int; For exponents of type ""+"" this gives the offset (within the list of; exponents within the bath) of the corresponding ""-"" bath exponent.; For exponents of type ""-"" it gives the offset of the corresponding; ""+"" exponent. tag : optional, str, tuple or any other object; A label for the exponent (often the name of the bath). It; defaults to None. Attributes; ----------; fermionic : bool; True if the type of the exponent is a Fermionic type (i.e. either; ""+"" or ""-"") and False otherwise. All of the parameters are also available as attributes.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:1135,Modifiability,coupling,coupling,1135,"on mode) within the; decomposition of the correlation functions of a bath. Parameters; ----------; type : {""R"", ""I"", ""RI"", ""+"", ""-""} or BathExponent.ExponentType; The type of bath exponent. ""R"" and ""I"" are bosonic bath exponents that appear in the real and; imaginary parts of the correlation expansion. ""RI"" is combined bosonic bath exponent that appears in both the real; and imaginary parts of the correlation expansion. The combined exponent; has a single ``vk``. The ``ck`` is the coefficient in the real; expansion and ``ck2`` is the coefficient in the imaginary expansion. ""+"" and ""-"" are fermionic bath exponents. These fermionic bath; exponents must specify ``sigma_bar_k_offset`` which specifies; the amount to add to ``k`` (the exponent index within the bath of this; exponent) to determine the ``k`` of the corresponding exponent with; the opposite sign (i.e. ""-"" or ""+""). dim : int or None; The dimension (i.e. maximum number of excitations for this exponent).; Usually ``2`` for fermionic exponents or ``None`` (i.e. unlimited) for; bosonic exponents. Q : Qobj; The coupling operator for this excitation mode. vk : complex; The frequency of the exponent of the excitation term. ck : complex; The coefficient of the excitation term. ck2 : optional, complex; For exponents of type ""RI"" this is the coefficient of the term in the; imaginary expansion (and ``ck`` is the coefficient in the real; expansion). sigma_bar_k_offset : optional, int; For exponents of type ""+"" this gives the offset (within the list of; exponents within the bath) of the corresponding ""-"" bath exponent.; For exponents of type ""-"" it gives the offset of the corresponding; ""+"" exponent. tag : optional, str, tuple or any other object; A label for the exponent (often the name of the bath). It; defaults to None. Attributes; ----------; fermionic : bool; True if the type of the exponent is a Fermionic type (i.e. either; ""+"" or ""-"") and False otherwise. All of the parameters are also available as attributes.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:223,Availability,avail,available,223,"""""""; Represents a list of bath expansion exponents. Parameters; ----------; exponents : list of BathExponent; The exponents of the correlation function describing the bath. Attributes; ----------. All of the parameters are available as attributes.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:602,Modifiability,coupling,coupling,602,"""""""; A helper class for constructing a bosonic bath from the expansion; coefficients and frequencies for the real and imaginary parts of; the bath correlation function. If the correlation functions ``C(t)`` is split into real and imaginary; parts::. C(t) = C_real(t) + i * C_imag(t). then::. C_real(t) = sum(ck_real * exp(- vk_real * t)); C_imag(t) = sum(ck_imag * exp(- vk_imag * t)). Defines the coefficients ``ck`` and the frequencies ``vk``. Note that the ``ck`` and ``vk`` may be complex, even through ``C_real(t)``; and ``C_imag(t)`` (i.e. the sum) is real. Parameters; ----------; Q : Qobj; The coupling operator for the bath. ck_real : list of complex; The coefficients of the expansion terms for the real part of the; correlation function. The corresponding frequencies are passed as; vk_real. vk_real : list of complex; The frequencies (exponents) of the expansion terms for the real part of; the correlation function. The corresponding ceofficients are passed as; ck_real. ck_imag : list of complex; The coefficients of the expansion terms in the imaginary part of the; correlation function. The corresponding frequencies are passed as; vk_imag. vk_imag : list of complex; The frequencies (exponents) of the expansion terms for the imaginary; part of the correlation function. The corresponding ceofficients are; passed as ck_imag. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:1431,Modifiability,coupling,coupling,1431,"""""""; A helper class for constructing a bosonic bath from the expansion; coefficients and frequencies for the real and imaginary parts of; the bath correlation function. If the correlation functions ``C(t)`` is split into real and imaginary; parts::. C(t) = C_real(t) + i * C_imag(t). then::. C_real(t) = sum(ck_real * exp(- vk_real * t)); C_imag(t) = sum(ck_imag * exp(- vk_imag * t)). Defines the coefficients ``ck`` and the frequencies ``vk``. Note that the ``ck`` and ``vk`` may be complex, even through ``C_real(t)``; and ``C_imag(t)`` (i.e. the sum) is real. Parameters; ----------; Q : Qobj; The coupling operator for the bath. ck_real : list of complex; The coefficients of the expansion terms for the real part of the; correlation function. The corresponding frequencies are passed as; vk_real. vk_real : list of complex; The frequencies (exponents) of the expansion terms for the real part of; the correlation function. The corresponding ceofficients are passed as; ck_real. ck_imag : list of complex; The coefficients of the expansion terms in the imaginary part of the; correlation function. The corresponding frequencies are passed as; vk_imag. vk_imag : list of complex; The frequencies (exponents) of the expansion terms for the imaginary; part of the correlation function. The corresponding ceofficients are; passed as ck_imag. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:506,Availability,toler,tolerance,506,"""""""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; -------; list of BathExponent; The new reduced list of exponents.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:619,Availability,toler,tolerance,619,"""""""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; -------; list of BathExponent; The new reduced list of exponents.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:739,Energy Efficiency,reduce,reduced,739,"""""""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; -------; list of BathExponent; The new reduced list of exponents.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:187,Modifiability,coupling,coupling,187,"""""""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; -------; list of BathExponent; The new reduced list of exponents.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:558,Modifiability,coupling,coupling,558,"""""""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; -------; list of BathExponent; The new reduced list of exponents.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:671,Modifiability,coupling,coupling,671,"""""""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; -------; list of BathExponent; The new reduced list of exponents.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:174,Modifiability,coupling,coupling,174,"""""""; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:503,Modifiability,coupling,coupling,503,"""""""; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:780,Modifiability,coupling,coupling,780,"""""""; A helper class for constructing a Pad expansion for a Drude-Lorentz; bosonic bath from the bath parameters (see parameters below). A Pad approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Pad method to spectrum decompoisitions is described; in ""Pad spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`DrudeLorentzBath` which constructs; a simpler exponential expansion. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. T : float; Bath temperature. Nk : int; Number of Pad exponentials terms used to approximate the bath; correlation functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:1115,Modifiability,coupling,coupling,1115,"""""""; A helper class for constructing a Pad expansion for a Drude-Lorentz; bosonic bath from the bath parameters (see parameters below). A Pad approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Pad method to spectrum decompoisitions is described; in ""Pad spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`DrudeLorentzBath` which constructs; a simpler exponential expansion. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. T : float; Bath temperature. Nk : int; Number of Pad exponentials terms used to approximate the bath; correlation functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:691,Usability,simpl,simpler,691,"""""""; A helper class for constructing a Pad expansion for a Drude-Lorentz; bosonic bath from the bath parameters (see parameters below). A Pad approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Pad method to spectrum decompoisitions is described; in ""Pad spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`DrudeLorentzBath` which constructs; a simpler exponential expansion. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. T : float; Bath temperature. Nk : int; Number of Pad exponentials terms used to approximate the bath; correlation functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:174,Modifiability,coupling,coupling,174,"""""""; A helper class for constructing an under-damped bosonic bath from the; bath parameters (see parameters below). Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. w0 : float; Bath spectral density resonance frequency. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:558,Modifiability,coupling,coupling,558,"""""""; A helper class for constructing an under-damped bosonic bath from the; bath parameters (see parameters below). Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. w0 : float; Bath spectral density resonance frequency. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:829,Modifiability,coupling,coupling,829,"""""""; A helper class for constructing a fermionic bath from the expansion; coefficients and frequencies for the ``+`` and ``-`` modes of; the bath correlation function. There must be the same number of ``+`` and ``-`` modes and their; coefficients must be specified in the same order so that ``ck_plus[i],; vk_plus[i]`` are the plus coefficient and frequency corresponding; to the minus mode ``ck_minus[i], vk_minus[i]``. In the fermionic case the order in which excitations are created or; destroyed is important, resulting in two different correlation functions; labelled ``C_plus(t)`` and ``C_plus(t)``::. C_plus(t) = sum(ck_plus * exp(- vk_plus * t)); C_minus(t) = sum(ck_minus * exp(- vk_minus * t)). where the expansions above define the coeffiients ``ck`` and the; frequencies ``vk``. Parameters; ----------; Q : Qobj; The coupling operator for the bath. ck_plus : list of complex; The coefficients of the expansion terms for the ``+`` part of the; correlation function. The corresponding frequencies are passed as; vk_plus. vk_plus : list of complex; The frequencies (exponents) of the expansion terms for the ``+`` part; of the correlation function. The corresponding ceofficients are passed; as ck_plus. ck_minus : list of complex; The coefficients of the expansion terms for the ``-`` part of the; correlation function. The corresponding frequencies are passed as; vk_minus. vk_minus : list of complex; The frequencies (exponents) of the expansion terms for the ``-`` part; of the correlation function. The corresponding ceofficients are passed; as ck_minus. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:393,Modifiability,coupling,coupling,393,"""""""; A helper class for constructing a Lorentzian fermionic bath from the; bath parameters (see parameters below). .. note::. This Matsubara expansion used in this bath converges very slowly; and ``Nk > 20`` may be required to get good convergence. The; Pad expansion used by :class:`LorentzianPadeBath` converges much; more quickly. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float; The coupling strength between the system and the bath. w : float; The width of the environment. mu : float; The chemical potential of the bath. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:446,Modifiability,coupling,coupling,446,"""""""; A helper class for constructing a Lorentzian fermionic bath from the; bath parameters (see parameters below). .. note::. This Matsubara expansion used in this bath converges very slowly; and ``Nk > 20`` may be required to get good convergence. The; Pad expansion used by :class:`LorentzianPadeBath` converges much; more quickly. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float; The coupling strength between the system and the bath. w : float; The width of the environment. mu : float; The chemical potential of the bath. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:832,Modifiability,coupling,coupling,832,"""""""; A helper class for constructing a Pad expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below). A Pad approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Pad method to spectrum decompoisitions is described; in ""Pad spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`LorentzianBath` which constructs; a simpler exponential expansion that converges much more slowly in; this particular case. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float; The coupling strength between the system and the bath. w : float; The width of the environment. mu : float; The chemical potential of the bath. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:885,Modifiability,coupling,coupling,885,"""""""; A helper class for constructing a Pad expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below). A Pad approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Pad method to spectrum decompoisitions is described; in ""Pad spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`LorentzianBath` which constructs; a simpler exponential expansion that converges much more slowly in; this particular case. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float; The coupling strength between the system and the bath. w : float; The width of the environment. mu : float; The chemical potential of the bath. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:686,Usability,simpl,simpler,686,"""""""; A helper class for constructing a Pad expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below). A Pad approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Pad method to spectrum decompoisitions is described; in ""Pad spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`LorentzianBath` which constructs; a simpler exponential expansion that converges much more slowly in; this particular case. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float; The coupling strength between the system and the bath. w : float; The width of the environment. mu : float; The chemical potential of the bath. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:341,Safety,avoid,avoid,341,"""""""; Return the index of the ADO label within the list of labels,; i.e. within ``self.labels``. Parameters; ----------; label : tuple; The label to look up. Returns; -------; int; The index of the label within the list of ADO labels. Notes; -----; This implementation of the ``.idx(...)`` method is just for; reference and documentation. To avoid the cost of a Python; function call, it is replaced with; ``self._label_idx.__getitem__`` when the instance is created.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:684,Availability,avail,available,684,"""""""; Provides convenient access to the full hierarchy ADO state at a particular; point in time, ``t``. Parameters; ----------; rho : :class:`.Qobj`; The current state of the system (i.e. the 0th component of the; hierarchy).; ados : :class:`HierarchyADOs`; The description of the hierarchy.; ado_state : numpy.array; The full state of the hierarchy. Attributes; ----------; rho : Qobj; The system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly. See :class:`HierarchyADOs` for a full list of the available attributes; and methods.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:25,Security,access,access,25,"""""""; Provides convenient access to the full hierarchy ADO state at a particular; point in time, ``t``. Parameters; ----------; rho : :class:`.Qobj`; The current state of the system (i.e. the 0th component of the; hierarchy).; ados : :class:`HierarchyADOs`; The description of the hierarchy.; ado_state : numpy.array; The full state of the hierarchy. Attributes; ----------; rho : Qobj; The system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly. See :class:`HierarchyADOs` for a full list of the available attributes; and methods.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:561,Security,access,access,561,"""""""; Provides convenient access to the full hierarchy ADO state at a particular; point in time, ``t``. Parameters; ----------; rho : :class:`.Qobj`; The current state of the system (i.e. the 0th component of the; hierarchy).; ados : :class:`HierarchyADOs`; The description of the hierarchy.; ado_state : numpy.array; The full state of the hierarchy. Attributes; ----------; rho : Qobj; The system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly. See :class:`HierarchyADOs` for a full list of the available attributes; and methods.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:2925,Availability,error,errors,2925," None, optional; A list or dictionary of operators as :obj:`.Qobj`,; :obj:`.QobjEvo` and/or callable functions (they can be mixed) or; a single operator or callable function. For an operator ``op``, the; result will be computed using ``(state * op).tr()`` and the state; at each time ``t``. For callable functions, ``f``, the result is; computed using ``f(t, ado_state)``. The values are stored in the; ``expect`` and ``e_data`` attributes of the result (see the return; section below). args : dict, optional; Change the ``args`` of the RHS for the evolution. options : dict, optional; Generic solver options. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lengh",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3160,Availability,error,error,3160,")`` and the state; at each time ``t``. For callable functions, ``f``, the result is; computed using ``f(t, ado_state)``. The values are stored in the; ``expect`` and ``e_data`` attributes of the result (see the return; section below). args : dict, optional; Change the ``args`` of the RHS for the evolution. options : dict, optional; Generic solver options. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t``",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3720,Availability,toler,tolerance,3720,"`None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list containing the values of each ``e_ops`` at; time ``t``. * ``e_data``: a dic",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:4220,Availability,avail,available,4220,"te is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list containing the values of each ``e_ops`` at; time ``t``. * ``e_data``: a dictionary containing the values of each ``e_ops``; at tme ``t``. The keys are those given by ``e_ops`` if it was; a dict, otherwise they are the indexes of the supplied ``e_ops``. See :class:`~HEOMResult` and :class:`.Result` for the complete; list of attributes.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:4377,Availability,avail,available,4377,"te is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list containing the values of each ``e_ops`` at; time ``t``. * ``e_data``: a dictionary containing the values of each ``e_ops``; at tme ``t``. The keys are those given by ``e_ops`` if it was; a dict, otherwise they are the indexes of the supplied ``e_ops``. See :class:`~HEOMResult` and :class:`.Result` for the complete; list of attributes.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3174,Deployability,install,installed,3174,")`` and the state; at each time ``t``. For callable functions, ``f``, the result is; computed using ``f(t, ado_state)``. The values are stored in the; ``expect`` and ``e_data`` attributes of the result (see the return; section below). args : dict, optional; Change the ``args`` of the RHS for the evolution. options : dict, optional; Generic solver options. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t``",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3504,Deployability,integrat,integrator,3504," : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3644,Deployability,integrat,integration,3644,"; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list conta",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3741,Deployability,integrat,integrator,3741,"`None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list containing the values of each ``e_ops`` at; time ``t``. * ``e_data``: a dic",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:410,Integrability,depend,dependent,410,"""""""; Hierarchical Equations of Motion (HEOM) solver that supports multiple; baths. The baths must be all either bosonic or fermionic baths. If you need to run many evolutions of the same system and bath, consider; using :class:`HEOMSolver` directly to avoid having to continually; reconstruct the equation hierarchy for every evolution. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. bath : Bath or list of Bath; A :obj:`Bath` containing the exponents of the expansion of the; bath correlation funcion and their associated coefficients; and coupling operators, or a list of baths. If multiple baths are given, they must all be either fermionic; or bosonic baths. max_depth : int; The maximum depth of the heirarchy (i.e. the maximum number of bath; exponent ""excitations"" to retain). state0 : :obj:`.Qobj` or :class:`~HierarchyADOsState` or array-like; If ``rho0`` is a :obj:`.Qobj` the it is the initial state; of the system (i.e. a :obj:`.Qobj` density matrix). If it is a :class:`~HierarchyADOsState` or array-like, then; ``rho0`` gives the initial state of all ADOs. Usually the state of the ADOs would be determine from a previous; call to ``.run(...)`` with the solver results option ``store_ados``; set to True. For example, ``result = solver.run(...)`` could be; followed by ``solver.run(result.ado_states[-1], tlist)``. If a numpy array-like is passed its shape must be; ``(number_of_ados, n, n)`` where ``(n, n)`` is the system shape; (i.e. shape of the system density matrix) and the ADOs must; be in the same order as in ``.ados.labels``. tlist : list; An ordered list of times at which to return the value of the state. e_ops : Qobj / QobjEvo / callable / list / dict / None, optional; A list or dictionary of operators as :obj:`.Qobj`,; :obj:`.QobjEvo` and/or callable functions (",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3504,Integrability,integrat,integrator,3504," : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3644,Integrability,integrat,integration,3644,"; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list conta",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3741,Integrability,integrat,integrator,3741,"`None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list containing the values of each ``e_ops`` at; time ``t``. * ``e_data``: a dic",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:748,Modifiability,coupling,coupling,748,"""""""; Hierarchical Equations of Motion (HEOM) solver that supports multiple; baths. The baths must be all either bosonic or fermionic baths. If you need to run many evolutions of the same system and bath, consider; using :class:`HEOMSolver` directly to avoid having to continually; reconstruct the equation hierarchy for every evolution. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. bath : Bath or list of Bath; A :obj:`Bath` containing the exponents of the expansion of the; bath correlation funcion and their associated coefficients; and coupling operators, or a list of baths. If multiple baths are given, they must all be either fermionic; or bosonic baths. max_depth : int; The maximum depth of the heirarchy (i.e. the maximum number of bath; exponent ""excitations"" to retain). state0 : :obj:`.Qobj` or :class:`~HierarchyADOsState` or array-like; If ``rho0`` is a :obj:`.Qobj` the it is the initial state; of the system (i.e. a :obj:`.Qobj` density matrix). If it is a :class:`~HierarchyADOsState` or array-like, then; ``rho0`` gives the initial state of all ADOs. Usually the state of the ADOs would be determine from a previous; call to ``.run(...)`` with the solver results option ``store_ados``; set to True. For example, ``result = solver.run(...)`` could be; followed by ``solver.run(result.ado_states[-1], tlist)``. If a numpy array-like is passed its shape must be; ``(number_of_ados, n, n)`` where ``(n, n)`` is the system shape; (i.e. shape of the system density matrix) and the ADOs must; be in the same order as in ``.ados.labels``. tlist : list; An ordered list of times at which to return the value of the state. e_ops : Qobj / QobjEvo / callable / list / dict / None, optional; A list or dictionary of operators as :obj:`.Qobj`,; :obj:`.QobjEvo` and/or callable functions (",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3037,Modifiability,enhance,enhanced,3037,"ble function. For an operator ``op``, the; result will be computed using ``(state * op).tr()`` and the state; at each time ``t``. For callable functions, ``f``, the result is; computed using ``f(t, ado_state)``. The values are stored in the; ``expect`` and ``e_data`` attributes of the result (see the return; section below). args : dict, optional; Change the ``args`` of the RHS for the evolution. options : dict, optional; Generic solver options. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of ",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:252,Safety,avoid,avoid,252,"""""""; Hierarchical Equations of Motion (HEOM) solver that supports multiple; baths. The baths must be all either bosonic or fermionic baths. If you need to run many evolutions of the same system and bath, consider; using :class:`HEOMSolver` directly to avoid having to continually; reconstruct the equation hierarchy for every evolution. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. bath : Bath or list of Bath; A :obj:`Bath` containing the exponents of the expansion of the; bath correlation funcion and their associated coefficients; and coupling operators, or a list of baths. If multiple baths are given, they must all be either fermionic; or bosonic baths. max_depth : int; The maximum depth of the heirarchy (i.e. the maximum number of bath; exponent ""excitations"" to retain). state0 : :obj:`.Qobj` or :class:`~HierarchyADOsState` or array-like; If ``rho0`` is a :obj:`.Qobj` the it is the initial state; of the system (i.e. a :obj:`.Qobj` density matrix). If it is a :class:`~HierarchyADOsState` or array-like, then; ``rho0`` gives the initial state of all ADOs. Usually the state of the ADOs would be determine from a previous; call to ``.run(...)`` with the solver results option ``store_ados``; set to True. For example, ``result = solver.run(...)`` could be; followed by ``solver.run(result.ado_states[-1], tlist)``. If a numpy array-like is passed its shape must be; ``(number_of_ados, n, n)`` where ``(n, n)`` is the system shape; (i.e. shape of the system density matrix) and the ADOs must; be in the same order as in ``.ados.labels``. tlist : list; An ordered list of times at which to return the value of the state. e_ops : Qobj / QobjEvo / callable / list / dict / None, optional; A list or dictionary of operators as :obj:`.Qobj`,; :obj:`.QobjEvo` and/or callable functions (",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:177,Integrability,depend,dependent,177,"""""""; HEOM solver that supports multiple baths. The baths must be all either bosonic or fermionic baths. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. bath : Bath or list of Bath; A :obj:`Bath` containing the exponents of the expansion of the; bath correlation funcion and their associated coefficients; and coupling operators, or a list of baths. If multiple baths are given, they must all be either fermionic; or bosonic baths. max_depth : int; The maximum depth of the heirarchy (i.e. the maximum number of bath; exponent ""excitations"" to retain). options : dict, optional; Generic solver options.; If set to None the default options will be used. Keyword only.; Default: None. Attributes; ----------; ados : :obj:`HierarchyADOs`; The description of the hierarchy constructed from the given bath; and maximum depth. rhs : :obj:`.QobjEvo`; The right-hand side (RHS) of the hierarchy evolution ODE. Internally; the system and bath coupling operators are converted to; :class:`qutip.data.CSR` instances during construction of the RHS,; so the operators in the ``rhs`` will all be sparse.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:515,Modifiability,coupling,coupling,515,"""""""; HEOM solver that supports multiple baths. The baths must be all either bosonic or fermionic baths. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. bath : Bath or list of Bath; A :obj:`Bath` containing the exponents of the expansion of the; bath correlation funcion and their associated coefficients; and coupling operators, or a list of baths. If multiple baths are given, they must all be either fermionic; or bosonic baths. max_depth : int; The maximum depth of the heirarchy (i.e. the maximum number of bath; exponent ""excitations"" to retain). options : dict, optional; Generic solver options.; If set to None the default options will be used. Keyword only.; Default: None. Attributes; ----------; ados : :obj:`HierarchyADOs`; The description of the hierarchy constructed from the given bath; and maximum depth. rhs : :obj:`.QobjEvo`; The right-hand side (RHS) of the hierarchy evolution ODE. Internally; the system and bath coupling operators are converted to; :class:`qutip.data.CSR` instances during construction of the RHS,; so the operators in the ``rhs`` will all be sparse.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:1139,Modifiability,coupling,coupling,1139,"""""""; HEOM solver that supports multiple baths. The baths must be all either bosonic or fermionic baths. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. bath : Bath or list of Bath; A :obj:`Bath` containing the exponents of the expansion of the; bath correlation funcion and their associated coefficients; and coupling operators, or a list of baths. If multiple baths are given, they must all be either fermionic; or bosonic baths. max_depth : int; The maximum depth of the heirarchy (i.e. the maximum number of bath; exponent ""excitations"" to retain). options : dict, optional; Generic solver options.; If set to None the default options will be used. Keyword only.; Default: None. Attributes; ----------; ados : :obj:`HierarchyADOs`; The description of the hierarchy constructed from the given bath; and maximum depth. rhs : :obj:`.QobjEvo`; The right-hand side (RHS) of the hierarchy evolution ODE. Internally; the system and bath coupling operators are converted to; :class:`qutip.data.CSR` instances during construction of the RHS,; so the operators in the ``rhs`` will all be sparse.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:14,Integrability,depend,dependent,14,"# In the time dependent case, we construct the parameters; # for the ODE gradient function under the assumption that; #; # RHSmat(t) = RHSmat + time dependent terms that only affect the; # diagonal blocks of the RHS matrix.; #; # This assumption holds because only _grad_n dependents on; # the system Liouvillian (and not _grad_prev or _grad_next) and; # the bath coupling operators are not time-dependent.",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:149,Integrability,depend,dependent,149,"# In the time dependent case, we construct the parameters; # for the ODE gradient function under the assumption that; #; # RHSmat(t) = RHSmat + time dependent terms that only affect the; # diagonal blocks of the RHS matrix.; #; # This assumption holds because only _grad_n dependents on; # the system Liouvillian (and not _grad_prev or _grad_next) and; # the bath coupling operators are not time-dependent.",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:273,Integrability,depend,dependents,273,"# In the time dependent case, we construct the parameters; # for the ODE gradient function under the assumption that; #; # RHSmat(t) = RHSmat + time dependent terms that only affect the; # diagonal blocks of the RHS matrix.; #; # This assumption holds because only _grad_n dependents on; # the system Liouvillian (and not _grad_prev or _grad_next) and; # the bath coupling operators are not time-dependent.",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:396,Integrability,depend,dependent,396,"# In the time dependent case, we construct the parameters; # for the ODE gradient function under the assumption that; #; # RHSmat(t) = RHSmat + time dependent terms that only affect the; # diagonal blocks of the RHS matrix.; #; # This assumption holds because only _grad_n dependents on; # the system Liouvillian (and not _grad_prev or _grad_next) and; # the bath coupling operators are not time-dependent.",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:364,Modifiability,coupling,coupling,364,"# In the time dependent case, we construct the parameters; # for the ODE gradient function under the assumption that; #; # RHSmat(t) = RHSmat + time dependent terms that only affect the; # diagonal blocks of the RHS matrix.; #; # This assumption holds because only _grad_n dependents on; # the system Liouvillian (and not _grad_prev or _grad_next) and; # the bath coupling operators are not time-dependent.",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:178,Deployability,integrat,integrator,178,"# The assertion that rhs_mat has data type CSR is just a sanity; # check on the RHS creation. The base solver class will still; # convert the RHS to the type required by the ODE integrator if; # needed.",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:178,Integrability,integrat,integrator,178,"# The assertion that rhs_mat has data type CSR is just a sanity; # check on the RHS creation. The base solver class will still; # convert the RHS to the type required by the ODE integrator if; # needed.",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:6,Testability,assert,assertion,6,"# The assertion that rhs_mat has data type CSR is just a sanity; # check on the RHS creation. The base solver class will still; # convert the RHS to the type required by the ODE integrator if; # needed.",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:671,Availability,reliab,reliability,671,"""""""; Compute the steady state of the system. Parameters; ----------; use_mkl : bool, default=False; Whether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refine : int; Specifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs. For a complete description, see iparm(7) in; https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html. mkl_weighted_matching : bool; MKL PARDISO can use a maximum weighted matching algorithm to; permute large elements close the diagonal. This strategy adds an; additional level of reliability to the factorization methods. For a complete description, see iparm(12) in; https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html. Returns; -------; steady_state : Qobj; The steady state density matrix of the system. steady_ados : :class:`HierarchyADOsState`; The steady state of the full ADO hierarchy. A particular ADO may be; extracted from the full state by calling; :meth:`extract`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:141,Deployability,install,installed,141,"""""""; Compute the steady state of the system. Parameters; ----------; use_mkl : bool, default=False; Whether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refine : int; Specifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs. For a complete description, see iparm(7) in; https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html. mkl_weighted_matching : bool; MKL PARDISO can use a maximum weighted matching algorithm to; permute large elements close the diagonal. This strategy adds an; additional level of reliability to the factorization methods. For a complete description, see iparm(12) in; https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html. Returns; -------; steady_state : Qobj; The steady state density matrix of the system. steady_ados : :class:`HierarchyADOsState`; The steady state of the full ADO hierarchy. A particular ADO may be; extracted from the full state by calling; :meth:`extract`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:327,Performance,perform,performs,327,"""""""; Compute the steady state of the system. Parameters; ----------; use_mkl : bool, default=False; Whether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refine : int; Specifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs. For a complete description, see iparm(7) in; https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html. mkl_weighted_matching : bool; MKL PARDISO can use a maximum weighted matching algorithm to; permute large elements close the diagonal. This strategy adds an; additional level of reliability to the factorization methods. For a complete description, see iparm(12) in; https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html. Returns; -------; steady_state : Qobj; The steady state density matrix of the system. steady_ados : :class:`HierarchyADOsState`; The steady state of the full ADO hierarchy. A particular ADO may be; extracted from the full state by calling; :meth:`extract`.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:1763,Availability,avail,available,1763," ``result = solver.run(...)`` could be; followed by ``solver.run(result.ado_states[-1], tlist)``. If a numpy array-like is passed its shape must be; ``(number_of_ados, n, n)`` where ``(n, n)`` is the system shape; (i.e. shape of the system density matrix) and the ADOs must; be in the same order as in ``.ados.labels``. tlist : list; An ordered list of times at which to return the value of the state. args : dict, optional {None}; Change the ``args`` of the RHS for the evolution. e_ops : Qobj / QobjEvo / callable / list / dict / None, optional; A list or dictionary of operators as :obj:`.Qobj`,; :obj:`.QobjEvo` and/or callable functions (they can be mixed) or; a single operator or callable function. For an operator ``op``, the; result will be computed using ``(state * op).tr()`` and the state; at each time ``t``. For callable functions, ``f``, the result is; computed using ``f(t, ado_state)``. The values are stored in the; ``expect`` and ``e_data`` attributes of the result (see the return; section below). Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list containing the values of each ``e_ops`` at; time ``t``. * ``e_data``: a dictionary containing the values of each ``e_ops``; at tme ``t``. The keys are those given by ``e_ops`` if it was; a dict, otherwise they are the indexes of the supplied ``e_ops``. See :class:`~HEOMResult` and :class:`.Result` for the complete; list of attributes.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:1920,Availability,avail,available,1920," ``result = solver.run(...)`` could be; followed by ``solver.run(result.ado_states[-1], tlist)``. If a numpy array-like is passed its shape must be; ``(number_of_ados, n, n)`` where ``(n, n)`` is the system shape; (i.e. shape of the system density matrix) and the ADOs must; be in the same order as in ``.ados.labels``. tlist : list; An ordered list of times at which to return the value of the state. args : dict, optional {None}; Change the ``args`` of the RHS for the evolution. e_ops : Qobj / QobjEvo / callable / list / dict / None, optional; A list or dictionary of operators as :obj:`.Qobj`,; :obj:`.QobjEvo` and/or callable functions (they can be mixed) or; a single operator or callable function. For an operator ``op``, the; result will be computed using ``(state * op).tr()`` and the state; at each time ``t``. For callable functions, ``f``, the result is; computed using ``f(t, ado_state)``. The values are stored in the; ``expect`` and ``e_data`` attributes of the result (see the return; section below). Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list containing the values of each ``e_ops`` at; time ``t``. * ``e_data``: a dictionary containing the values of each ``e_ops``; at tme ``t``. The keys are those given by ``e_ops`` if it was; a dict, otherwise they are the indexes of the supplied ``e_ops``. See :class:`~HEOMResult` and :class:`.Result` for the complete; list of attributes.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:409,Availability,error,errors,409,"""""""; Options for HEOMSolver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use. state_data_type: str, default: ""dense""; Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrators; support only work with `Dense`. store_ados : bool, default: False; Whether or not to store the HEOM ADOs. Only relevant when using; the HEOM solver.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:583,Availability,error,error,583,"""""""; Options for HEOMSolver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use. state_data_type: str, default: ""dense""; Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrators; support only work with `Dense`. store_ados : bool, default: False; Whether or not to store the HEOM ADOs. Only relevant when using; the HEOM solver.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:597,Deployability,install,installed,597,"""""""; Options for HEOMSolver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use. state_data_type: str, default: ""dense""; Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrators; support only work with `Dense`. store_ados : bool, default: False; Whether or not to store the HEOM ADOs. Only relevant when using; the HEOM solver.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:845,Deployability,integrat,integration,845,"""""""; Options for HEOMSolver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use. state_data_type: str, default: ""dense""; Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrators; support only work with `Dense`. store_ados : bool, default: False; Whether or not to store the HEOM ADOs. Only relevant when using; the HEOM solver.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:1034,Deployability,integrat,integrators,1034,"""""""; Options for HEOMSolver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use. state_data_type: str, default: ""dense""; Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrators; support only work with `Dense`. store_ados : bool, default: False; Whether or not to store the HEOM ADOs. Only relevant when using; the HEOM solver.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:845,Integrability,integrat,integration,845,"""""""; Options for HEOMSolver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use. state_data_type: str, default: ""dense""; Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrators; support only work with `Dense`. store_ados : bool, default: False; Whether or not to store the HEOM ADOs. Only relevant when using; the HEOM solver.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:1034,Integrability,integrat,integrators,1034,"""""""; Options for HEOMSolver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use. state_data_type: str, default: ""dense""; Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrators; support only work with `Dense`. store_ados : bool, default: False; Whether or not to store the HEOM ADOs. Only relevant when using; the HEOM solver.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:445,Modifiability,enhance,enhanced,445,"""""""; Options for HEOMSolver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use. state_data_type: str, default: ""dense""; Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrators; support only work with `Dense`. store_ados : bool, default: False; Whether or not to store the HEOM ADOs. Only relevant when using; the HEOM solver.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:612,Integrability,depend,dependent,612,"""""""; A helper class for creating an :class:`HEOMSolver` that is backwards; compatible with the ``HSolverDL`` provided in ``qutip.nonmarkov.heom``; in QuTiP 4.6 and below. See :class:`HEOMSolver` and :class:`DrudeLorentzBath` for more; descriptions of the underlying solver and bath construction. An exact copy of the QuTiP 4.6 HSolverDL is provided in; ``qutip.nonmarkov.dlheom_solver`` for cases where the functionality of; the older solver is required. The older solver will be completely; removed in QuTiP 5. .. note::. Unlike the version of ``HSolverDL`` in QuTiP 4.6, this solver; supports supplying a time-dependent or Liouvillian ``H_sys``. .. note::. For compatibility with ``HSolverDL`` in QuTiP 4.6 and below, the; parameter ``N_exp`` specifying the number of exponents to keep in; the expansion of the bath correlation function is one more than; the equivalent ``Nk`` used in the :class:`DrudeLorentzBath`. I.e.,; ``Nk = N_exp - 1``. The ``Nk`` parameter in the; :class:`DrudeLorentzBath` does not count the zeroeth exponent in; order to better match common usage in the literature. .. note::. The ``stats`` and ``renorm`` arguments accepted in QuTiP 4.6 and below; are no longer supported. Parameters; ----------; H_sys : Qobj or QobjEvo or list; The system Hamiltonian or Liouvillian. See :class:`HEOMSolver` for; a complete description. coup_op : Qobj; Operator describing the coupling between system and bath.; See parameter ``Q`` in :class:`BosonicBath` for a complete description. coup_strength : float; Coupling strength. Referred to as ``lam`` in :class:`DrudeLorentzBath`. temperature : float; Bath temperature. Referred to as ``T`` in :class:`DrudeLorentzBath`. N_cut : int; The maximum depth of the hierarchy. See ``max_depth`` in; :class:`HEOMSolver` for a full description. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. The equivalent ``Nk`` in :class:`DrudeLorentzBath` is one; less than ``N_exp`` (see note above). cut_freq : f",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:1391,Modifiability,coupling,coupling,1391,"for cases where the functionality of; the older solver is required. The older solver will be completely; removed in QuTiP 5. .. note::. Unlike the version of ``HSolverDL`` in QuTiP 4.6, this solver; supports supplying a time-dependent or Liouvillian ``H_sys``. .. note::. For compatibility with ``HSolverDL`` in QuTiP 4.6 and below, the; parameter ``N_exp`` specifying the number of exponents to keep in; the expansion of the bath correlation function is one more than; the equivalent ``Nk`` used in the :class:`DrudeLorentzBath`. I.e.,; ``Nk = N_exp - 1``. The ``Nk`` parameter in the; :class:`DrudeLorentzBath` does not count the zeroeth exponent in; order to better match common usage in the literature. .. note::. The ``stats`` and ``renorm`` arguments accepted in QuTiP 4.6 and below; are no longer supported. Parameters; ----------; H_sys : Qobj or QobjEvo or list; The system Hamiltonian or Liouvillian. See :class:`HEOMSolver` for; a complete description. coup_op : Qobj; Operator describing the coupling between system and bath.; See parameter ``Q`` in :class:`BosonicBath` for a complete description. coup_strength : float; Coupling strength. Referred to as ``lam`` in :class:`DrudeLorentzBath`. temperature : float; Bath temperature. Referred to as ``T`` in :class:`DrudeLorentzBath`. N_cut : int; The maximum depth of the hierarchy. See ``max_depth`` in; :class:`HEOMSolver` for a full description. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. The equivalent ``Nk`` in :class:`DrudeLorentzBath` is one; less than ``N_exp`` (see note above). cut_freq : float; Bath spectral density cutoff frequency. Referred to as ``gamma`` in; :class:`DrudeLorentzBath`. bnd_cut_approx : bool; Use boundary cut off approximation. If true, the Matsubara; terminator is added to the system Liouvillian (and H_sys is; promoted to a Liouvillian if it was a Hamiltonian). Keyword only.; Default: False. options : dict, optional; Generic solver options.; If set",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:2549,Modifiability,coupling,coupling,2549,". note::. For compatibility with ``HSolverDL`` in QuTiP 4.6 and below, the; parameter ``N_exp`` specifying the number of exponents to keep in; the expansion of the bath correlation function is one more than; the equivalent ``Nk`` used in the :class:`DrudeLorentzBath`. I.e.,; ``Nk = N_exp - 1``. The ``Nk`` parameter in the; :class:`DrudeLorentzBath` does not count the zeroeth exponent in; order to better match common usage in the literature. .. note::. The ``stats`` and ``renorm`` arguments accepted in QuTiP 4.6 and below; are no longer supported. Parameters; ----------; H_sys : Qobj or QobjEvo or list; The system Hamiltonian or Liouvillian. See :class:`HEOMSolver` for; a complete description. coup_op : Qobj; Operator describing the coupling between system and bath.; See parameter ``Q`` in :class:`BosonicBath` for a complete description. coup_strength : float; Coupling strength. Referred to as ``lam`` in :class:`DrudeLorentzBath`. temperature : float; Bath temperature. Referred to as ``T`` in :class:`DrudeLorentzBath`. N_cut : int; The maximum depth of the hierarchy. See ``max_depth`` in; :class:`HEOMSolver` for a full description. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. The equivalent ``Nk`` in :class:`DrudeLorentzBath` is one; less than ``N_exp`` (see note above). cut_freq : float; Bath spectral density cutoff frequency. Referred to as ``gamma`` in; :class:`DrudeLorentzBath`. bnd_cut_approx : bool; Use boundary cut off approximation. If true, the Matsubara; terminator is added to the system Liouvillian (and H_sys is; promoted to a Liouvillian if it was a Hamiltonian). Keyword only.; Default: False. options : dict, optional; Generic solver options.; If set to None the default options will be used. Keyword only.; Default: None. combine : bool, default: True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details.; Keyword only. Default: True.; """"""",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:2,Deployability,upgrade,upgrade,2,"# upgrade H_sys to a Liouvillian if needed and add the; # bath terminator",MatchSource.CODE_COMMENT,qutip/solver/heom/bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:29,Integrability,wrap,wrapper,29,""""""" `Integrator`: ODE solver wrapper to use in qutip's Solver """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:139,Availability,toler,tolerance,139,"""""""Error from the ODE solver being unable to integrate with the given; parameters. Example; -------; - The solver cannot reach the desired tolerance within the maximum number; of steps.; - The step needed to be within desired tolerance is too small.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:226,Availability,toler,tolerance,226,"""""""Error from the ODE solver being unable to integrate with the given; parameters. Example; -------; - The solver cannot reach the desired tolerance within the maximum number; of steps.; - The step needed to be within desired tolerance is too small.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:45,Deployability,integrat,integrate,45,"""""""Error from the ODE solver being unable to integrate with the given; parameters. Example; -------; - The solver cannot reach the desired tolerance within the maximum number; of steps.; - The step needed to be within desired tolerance is too small.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:45,Integrability,integrat,integrate,45,"""""""Error from the ODE solver being unable to integrate with the given; parameters. Example; -------; - The solver cannot reach the desired tolerance within the maximum number; of steps.; - The step needed to be within desired tolerance is too small.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:306,Deployability,integrat,integrator,306,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:382,Deployability,integrat,integrator,382,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:438,Deployability,integrat,integrator,438,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:628,Deployability,integrat,integrator,628,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:830,Deployability,integrat,integrator,830,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:930,Deployability,integrat,integrator,930,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:1103,Deployability,integrat,integrator,1103,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:7,Integrability,wrap,wrapper,7,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:56,Integrability,interface,interface,56,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:306,Integrability,integrat,integrator,306,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:382,Integrability,integrat,integrator,382,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:438,Integrability,integrat,integrator,438,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:628,Integrability,integrat,integrator,628,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:727,Integrability,depend,depending,727,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:830,Integrability,integrat,integrator,830,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:930,Integrability,integrat,integrator,930,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:955,Integrability,depend,dependent,955,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:1103,Integrability,integrat,integrator,1103,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:267,Modifiability,evolve,evolve,267,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:18,Integrability,depend,dependent,18,"# Can evolve time dependent system",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:6,Modifiability,evolve,evolve,6,"# Can evolve time dependent system",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:14,Deployability,integrat,integrator,14,"# Whether the integrator used the system QobjEvo as a blackbox",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:14,Integrability,integrat,integrator,14,"# Whether the integrator used the system QobjEvo as a blackbox",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:18,Deployability,integrat,integrator,18,"# The name of the integrator",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:18,Integrability,integrat,integrator,18,"# The name of the integrator",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:34,Deployability,integrat,integrate,34,"""""""; Evolve to t. Before calling `integrate` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:159,Deployability,integrat,integrate,159,"""""""; Evolve to t. Before calling `integrate` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:34,Integrability,integrat,integrate,34,"""""""; Evolve to t. Before calling `integrate` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:159,Integrability,integrat,integrate,159,"""""""; Evolve to t. Before calling `integrate` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:560,Deployability,integrat,integrate,560,"""""""; Evolve toward the time ``t``. If ``t`` is larger than the present state's ``t``, advance the internal; state toward ``t``. If ``t`` is smaller than the present ``t``, but; larger than the previous one, it does an interpolation step and returns; the state at that time. When advancing the state, it may return it at a; time between present time and the asked ``t`` if more efficent for; subsequent interpolation step. Before calling `mcstep` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. If; the last integrate call was use with ``step=True``, the time can be; between the time at the start of the last call and now. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``. The returned time ``t`` can; differ from the input time only when ``step=True``. .. note:; The default implementation may be overridden by integrators that; can provide a more efficient one.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:628,Deployability,integrat,integrate,628,"""""""; Evolve toward the time ``t``. If ``t`` is larger than the present state's ``t``, advance the internal; state toward ``t``. If ``t`` is smaller than the present ``t``, but; larger than the previous one, it does an interpolation step and returns; the state at that time. When advancing the state, it may return it at a; time between present time and the asked ``t`` if more efficent for; subsequent interpolation step. Before calling `mcstep` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. If; the last integrate call was use with ``step=True``, the time can be; between the time at the start of the last call and now. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``. The returned time ``t`` can; differ from the input time only when ``step=True``. .. note:; The default implementation may be overridden by integrators that; can provide a more efficient one.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:1056,Deployability,integrat,integrators,1056,"""""""; Evolve toward the time ``t``. If ``t`` is larger than the present state's ``t``, advance the internal; state toward ``t``. If ``t`` is smaller than the present ``t``, but; larger than the previous one, it does an interpolation step and returns; the state at that time. When advancing the state, it may return it at a; time between present time and the asked ``t`` if more efficent for; subsequent interpolation step. Before calling `mcstep` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. If; the last integrate call was use with ``step=True``, the time can be; between the time at the start of the last call and now. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``. The returned time ``t`` can; differ from the input time only when ``step=True``. .. note:; The default implementation may be overridden by integrators that; can provide a more efficient one.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:1093,Energy Efficiency,efficient,efficient,1093,"""""""; Evolve toward the time ``t``. If ``t`` is larger than the present state's ``t``, advance the internal; state toward ``t``. If ``t`` is smaller than the present ``t``, but; larger than the previous one, it does an interpolation step and returns; the state at that time. When advancing the state, it may return it at a; time between present time and the asked ``t`` if more efficent for; subsequent interpolation step. Before calling `mcstep` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. If; the last integrate call was use with ``step=True``, the time can be; between the time at the start of the last call and now. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``. The returned time ``t`` can; differ from the input time only when ``step=True``. .. note:; The default implementation may be overridden by integrators that; can provide a more efficient one.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:560,Integrability,integrat,integrate,560,"""""""; Evolve toward the time ``t``. If ``t`` is larger than the present state's ``t``, advance the internal; state toward ``t``. If ``t`` is smaller than the present ``t``, but; larger than the previous one, it does an interpolation step and returns; the state at that time. When advancing the state, it may return it at a; time between present time and the asked ``t`` if more efficent for; subsequent interpolation step. Before calling `mcstep` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. If; the last integrate call was use with ``step=True``, the time can be; between the time at the start of the last call and now. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``. The returned time ``t`` can; differ from the input time only when ``step=True``. .. note:; The default implementation may be overridden by integrators that; can provide a more efficient one.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:628,Integrability,integrat,integrate,628,"""""""; Evolve toward the time ``t``. If ``t`` is larger than the present state's ``t``, advance the internal; state toward ``t``. If ``t`` is smaller than the present ``t``, but; larger than the previous one, it does an interpolation step and returns; the state at that time. When advancing the state, it may return it at a; time between present time and the asked ``t`` if more efficent for; subsequent interpolation step. Before calling `mcstep` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. If; the last integrate call was use with ``step=True``, the time can be; between the time at the start of the last call and now. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``. The returned time ``t`` can; differ from the input time only when ``step=True``. .. note:; The default implementation may be overridden by integrators that; can provide a more efficient one.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:1056,Integrability,integrat,integrators,1056,"""""""; Evolve toward the time ``t``. If ``t`` is larger than the present state's ``t``, advance the internal; state toward ``t``. If ``t`` is smaller than the present ``t``, but; larger than the previous one, it does an interpolation step and returns; the state at that time. When advancing the state, it may return it at a; time between present time and the asked ``t`` if more efficent for; subsequent interpolation step. Before calling `mcstep` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. If; the last integrate call was use with ``step=True``, the time can be; between the time at the start of the last call and now. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``. The returned time ``t`` can; differ from the input time only when ``step=True``. .. note:; The default implementation may be overridden by integrators that; can provide a more efficient one.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:40,Deployability,integrat,integrators,40,"# Options should be overwritten by each integrators.",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:40,Integrability,integrat,integrators,40,"# Options should be overwritten by each integrators.",MatchSource.CODE_COMMENT,qutip/solver/integrator/integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:33,Availability,error,error,33,"# TODO: krylov_dim, max_step and error (atol) are related by; # err ~= exp(-krylov_dim / dt**(1~2)); # We could ask for 2 and determine the third one.",MatchSource.CODE_COMMENT,qutip/solver/integrator/krylov.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:63,Availability,toler,tolerance,63,"""""""; Compute the maximum step length to stay under the desired tolerance.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/krylov.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:49,Availability,error,error,49,"# we divide by atol and take the log so that the error returned is 0; # at atol, which is convenient for calling root_scalar with.",MatchSource.CODE_COMMENT,qutip/solver/integrator/krylov.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:33,Testability,log,log,33,"# we divide by atol and take the log so that the error returned is 0; # at atol, which is convenient for calling root_scalar with.",MatchSource.CODE_COMMENT,qutip/solver/integrator/krylov.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:80,Availability,toler,tolerance,80,"""""""; Supported options by krylov method:. atol : float, default: 1e-7; Absolute tolerance. nsteps : int, default: 100; Max. number of internal steps/call. min_step, max_step : float, default: (1e-5, 1e5); Minimum and maximum step size. krylov_dim: int, default: 0; Dimension of Krylov approximation subspaces used for the time; evolution approximation. If the defaut 0 is given, the dimension is calculated; from the system size N, using `min(int((N + 100)**0.5), N-1)`. sub_system_tol: float, default: 1e-7; Tolerance to detect a happy breakdown. A happy breakdown occurs; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. always_compute_step: bool, default: False; If True, the step length is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/krylov.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:841,Deployability,integrat,integrator,841,"""""""; Supported options by krylov method:. atol : float, default: 1e-7; Absolute tolerance. nsteps : int, default: 100; Max. number of internal steps/call. min_step, max_step : float, default: (1e-5, 1e5); Minimum and maximum step size. krylov_dim: int, default: 0; Dimension of Krylov approximation subspaces used for the time; evolution approximation. If the defaut 0 is given, the dimension is calculated; from the system size N, using `min(int((N + 100)**0.5), N-1)`. sub_system_tol: float, default: 1e-7; Tolerance to detect a happy breakdown. A happy breakdown occurs; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. always_compute_step: bool, default: False; If True, the step length is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/krylov.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:841,Integrability,integrat,integrator,841,"""""""; Supported options by krylov method:. atol : float, default: 1e-7; Absolute tolerance. nsteps : int, default: 100; Max. number of internal steps/call. min_step, max_step : float, default: (1e-5, 1e5); Minimum and maximum step size. krylov_dim: int, default: 0; Dimension of Krylov approximation subspaces used for the time; evolution approximation. If the defaut 0 is given, the dimension is calculated; from the system size N, using `min(int((N + 100)**0.5), N-1)`. sub_system_tol: float, default: 1e-7; Tolerance to detect a happy breakdown. A happy breakdown occurs; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. always_compute_step: bool, default: False; If True, the step length is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/krylov.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:522,Safety,detect,detect,522,"""""""; Supported options by krylov method:. atol : float, default: 1e-7; Absolute tolerance. nsteps : int, default: 100; Max. number of internal steps/call. min_step, max_step : float, default: (1e-5, 1e5); Minimum and maximum step size. krylov_dim: int, default: 0; Dimension of Krylov approximation subspaces used for the time; evolution approximation. If the defaut 0 is given, the dimension is calculated; from the system size N, using `min(int((N + 100)**0.5), N-1)`. sub_system_tol: float, default: 1e-7; Tolerance to detect a happy breakdown. A happy breakdown occurs; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. always_compute_step: bool, default: False; If True, the step length is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/krylov.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:46,Energy Efficiency,efficient,efficient,46,"""""""; QuTiP's implementation of Verner's ""most efficient"" Runge-Kutta method; of order 7. These are Runge-Kutta methods with variable steps and dense; output. The implementation uses QuTiP's Data objects for the state, allowing; sparse, GPU or other data layer objects to be used efficiently by the; solver in their native formats. See https://www.sfu.ca/~jverner/ for a detailed description of the; methods. Usable with ``method=""vern7""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/qutip_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:279,Energy Efficiency,efficient,efficiently,279,"""""""; QuTiP's implementation of Verner's ""most efficient"" Runge-Kutta method; of order 7. These are Runge-Kutta methods with variable steps and dense; output. The implementation uses QuTiP's Data objects for the state, allowing; sparse, GPU or other data layer objects to be used efficiently by the; solver in their native formats. See https://www.sfu.ca/~jverner/ for a detailed description of the; methods. Usable with ``method=""vern7""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/qutip_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:124,Modifiability,variab,variable,124,"""""""; QuTiP's implementation of Verner's ""most efficient"" Runge-Kutta method; of order 7. These are Runge-Kutta methods with variable steps and dense; output. The implementation uses QuTiP's Data objects for the state, allowing; sparse, GPU or other data layer objects to be used efficiently by the; solver in their native formats. See https://www.sfu.ca/~jverner/ for a detailed description of the; methods. Usable with ``method=""vern7""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/qutip_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:80,Availability,toler,tolerance,80,"""""""; Supported options by verner method:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 1000; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). min_step : float, default: 0; Minimum step size (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped. interpolate : bool, default: True; Whether to use interpolation step, faster most of the time.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/qutip_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:129,Availability,toler,tolerance,129,"""""""; Supported options by verner method:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 1000; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). min_step : float, default: 0; Minimum step size (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped. interpolate : bool, default: True; Whether to use interpolation step, faster most of the time.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/qutip_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:46,Energy Efficiency,efficient,efficient,46,"""""""; QuTiP's implementation of Verner's ""most efficient"" Runge-Kutta method; of order 9. These are Runge-Kutta methods with variable steps and dense; output. The implementation uses QuTiP's Data objects for the state, allowing; sparse, GPU or other data layer objects to be used efficiently by the; solver in their native formats. See https://www.sfu.ca/~jverner/ for a detailed description of the; methods. Usable with ``method=""vern9""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/qutip_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:279,Energy Efficiency,efficient,efficiently,279,"""""""; QuTiP's implementation of Verner's ""most efficient"" Runge-Kutta method; of order 9. These are Runge-Kutta methods with variable steps and dense; output. The implementation uses QuTiP's Data objects for the state, allowing; sparse, GPU or other data layer objects to be used efficiently by the; solver in their native formats. See https://www.sfu.ca/~jverner/ for a detailed description of the; methods. Usable with ``method=""vern9""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/qutip_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:124,Modifiability,variab,variable,124,"""""""; QuTiP's implementation of Verner's ""most efficient"" Runge-Kutta method; of order 9. These are Runge-Kutta methods with variable steps and dense; output. The implementation uses QuTiP's Data objects for the state, allowing; sparse, GPU or other data layer objects to be used efficiently by the; solver in their native formats. See https://www.sfu.ca/~jverner/ for a detailed description of the; methods. Usable with ``method=""vern9""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/qutip_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:163,Deployability,integrat,integration,163,"""""""; Integrator solving the ODE by diagonalizing the system and solving; analytically. It can only solve constant system and has a long preparation; time, but the integration is fast. Usable with ``method=""diag""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/qutip_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:163,Integrability,integrat,integration,163,"""""""; Integrator solving the ODE by diagonalizing the system and solving; analytically. It can only solve constant system and has a long preparation; time, but the integration is fast. Usable with ``method=""diag""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/qutip_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:7,Deployability,integrat,integrator,7,"""""""ODE integrator from scipy.""""""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:7,Integrability,integrat,integrator,7,"""""""ODE integrator from scipy.""""""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:45,Deployability,integrat,integrator,45,"""""""; Integrator using Scipy `ode` with zvode integrator using adams method.; Ordinary Differential Equation solver by netlib; (https://www.netlib.org/odepack). Usable with ``method=""adams""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:45,Integrability,integrat,integrator,45,"""""""; Integrator using Scipy `ode` with zvode integrator using adams method.; Ordinary Differential Equation solver by netlib; (https://www.netlib.org/odepack). Usable with ``method=""adams""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:44,Deployability,integrat,integrator,44,"""""""; Do the check for concurrent use of the integrator and reset if used; elsewhere.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:44,Integrability,integrat,integrator,44,"""""""; Do the check for concurrent use of the integrator and reset if used; elsewhere.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:22,Performance,concurren,concurrent,22,"""""""; Do the check for concurrent use of the integrator and reset if used; elsewhere.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:83,Availability,toler,tolerance,83,"""""""; Supported options by zvode integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. order : int, default: 12, 'adams' or 5, 'bdf'; Order of integrator <=12 'adams', <=5 'bdf'. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). min_step : float, default: 0; Minimum step size (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:132,Availability,toler,tolerance,132,"""""""; Supported options by zvode integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. order : int, default: 12, 'adams' or 5, 'bdf'; Order of integrator <=12 'adams', <=5 'bdf'. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). min_step : float, default: 0; Minimum step size (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:32,Deployability,integrat,integrator,32,"""""""; Supported options by zvode integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. order : int, default: 12, 'adams' or 5, 'bdf'; Order of integrator <=12 'adams', <=5 'bdf'. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). min_step : float, default: 0; Minimum step size (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:199,Deployability,integrat,integrator,199,"""""""; Supported options by zvode integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. order : int, default: 12, 'adams' or 5, 'bdf'; Order of integrator <=12 'adams', <=5 'bdf'. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). min_step : float, default: 0; Minimum step size (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:32,Integrability,integrat,integrator,32,"""""""; Supported options by zvode integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. order : int, default: 12, 'adams' or 5, 'bdf'; Order of integrator <=12 'adams', <=5 'bdf'. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). min_step : float, default: 0; Minimum step size (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:199,Integrability,integrat,integrator,199,"""""""; Supported options by zvode integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. order : int, default: 12, 'adams' or 5, 'bdf'; Order of integrator <=12 'adams', <=5 'bdf'. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). min_step : float, default: 0; Minimum step size (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:45,Deployability,integrat,integrator,45,"""""""; Integrator using Scipy `ode` with zvode integrator using bdf method.; Ordinary Differential Equation solver by netlib; (https://www.netlib.org/odepack). Usable with ``method=""bdf""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:45,Integrability,integrat,integrator,45,"""""""; Integrator using Scipy `ode` with zvode integrator using bdf method.; Ordinary Differential Equation solver by netlib; (https://www.netlib.org/odepack). Usable with ``method=""bdf""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:46,Deployability,integrat,integrator,46,"""""""; Integrator using Scipy `ode` with dop853 integrator. Eight order; runge-kutta method by Dormand & Prince. Use fortran implementation; from [E. Hairer, S.P. Norsett and G. Wanner, Solving Ordinary Differential; Equations i. Nonstiff Problems. 2nd edition. Springer Series in; Computational Mathematics, Springer-Verlag (1993)]. Usable with ``method=""dop853""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:46,Integrability,integrat,integrator,46,"""""""; Integrator using Scipy `ode` with dop853 integrator. Eight order; runge-kutta method by Dormand & Prince. Use fortran implementation; from [E. Hairer, S.P. Norsett and G. Wanner, Solving Ordinary Differential; Equations i. Nonstiff Problems. 2nd edition. Springer Series in; Computational Mathematics, Springer-Verlag (1993)]. Usable with ``method=""dop853""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:60,Safety,safe,safe,60,"# Scipy's DOP853 does not have a step function.; # It has a safe step length, but can be 0 if unknown.",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:53,Deployability,integrat,integration,53,"# While DOP853 support changing the direction of the integration,; # it does not do so efficiently. We do it manually.",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:87,Energy Efficiency,efficient,efficiently,87,"# While DOP853 support changing the direction of the integration,; # it does not do so efficiently. We do it manually.",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:53,Integrability,integrat,integration,53,"# While DOP853 support changing the direction of the integration,; # it does not do so efficiently. We do it manually.",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:84,Availability,toler,tolerance,84,"""""""; Supported options by dop853 integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic). ifactor, dfactor : float, default: 6., 0.3; Maximum factor to increase/decrease step size by in one step. beta : float, default: 0; Beta parameter for stabilised step size control. See scipy.integrate.ode ode for more detail; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:133,Availability,toler,tolerance,133,"""""""; Supported options by dop853 integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic). ifactor, dfactor : float, default: 6., 0.3; Maximum factor to increase/decrease step size by in one step. beta : float, default: 0; Beta parameter for stabilised step size control. See scipy.integrate.ode ode for more detail; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:33,Deployability,integrat,integrator,33,"""""""; Supported options by dop853 integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic). ifactor, dfactor : float, default: 6., 0.3; Maximum factor to increase/decrease step size by in one step. beta : float, default: 0; Beta parameter for stabilised step size control. See scipy.integrate.ode ode for more detail; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:535,Deployability,integrat,integrate,535,"""""""; Supported options by dop853 integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic). ifactor, dfactor : float, default: 6., 0.3; Maximum factor to increase/decrease step size by in one step. beta : float, default: 0; Beta parameter for stabilised step size control. See scipy.integrate.ode ode for more detail; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:33,Integrability,integrat,integrator,33,"""""""; Supported options by dop853 integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic). ifactor, dfactor : float, default: 6., 0.3; Maximum factor to increase/decrease step size by in one step. beta : float, default: 0; Beta parameter for stabilised step size control. See scipy.integrate.ode ode for more detail; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:535,Integrability,integrat,integrate,535,"""""""; Supported options by dop853 integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic). ifactor, dfactor : float, default: 6., 0.3; Maximum factor to increase/decrease step size by in one step. beta : float, default: 0; Beta parameter for stabilised step size control. See scipy.integrate.ode ode for more detail; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:45,Deployability,integrat,integrator,45,"""""""; Integrator using Scipy `ode` with lsoda integrator. ODE solver by netlib; (https://www.netlib.org/odepack) Automatically choose between 'Adams' and; 'BDF' methods to solve both stiff and non-stiff systems. Usable with ``method=""lsoda""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:45,Integrability,integrat,integrator,45,"""""""; Integrator using Scipy `ode` with lsoda integrator. ODE solver by netlib; (https://www.netlib.org/odepack) Automatically choose between 'Adams' and; 'BDF' methods to solve both stiff and non-stiff systems. Usable with ``method=""lsoda""``; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:44,Deployability,integrat,integrator,44,"""""""; Do the check for concurrent use of the integrator and reset if used; elsewhere.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:44,Integrability,integrat,integrator,44,"""""""; Do the check for concurrent use of the integrator and reset if used; elsewhere.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:22,Performance,concurren,concurrent,22,"""""""; Do the check for concurrent use of the integrator and reset if used; elsewhere.; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:260,Availability,toler,tolerance,260,"# Here we want to advance up to t doing maximum one step.; # lsoda officially support step, but sometime it does more work than; # needed, so we ask it to advance a fraction of the last step, where it; # will advance one internal step of length allowed by the tolerance and; # interpolate back to the asked time, effictively getting the single; # integration step we want. The first step and abrupt changes in the; # `rhs` can cause exceptions to this, but _backstep catch those cases.",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:347,Deployability,integrat,integration,347,"# Here we want to advance up to t doing maximum one step.; # lsoda officially support step, but sometime it does more work than; # needed, so we ask it to advance a fraction of the last step, where it; # will advance one internal step of length allowed by the tolerance and; # interpolate back to the asked time, effictively getting the single; # integration step we want. The first step and abrupt changes in the; # `rhs` can cause exceptions to this, but _backstep catch those cases.",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:347,Integrability,integrat,integration,347,"# Here we want to advance up to t doing maximum one step.; # lsoda officially support step, but sometime it does more work than; # needed, so we ask it to advance a fraction of the last step, where it; # will advance one internal step of length allowed by the tolerance and; # interpolate back to the asked time, effictively getting the single; # integration step we want. The first step and abrupt changes in the; # `rhs` can cause exceptions to this, but _backstep catch those cases.",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:83,Availability,toler,tolerance,83,"""""""; Supported options by lsoda integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. max_order_ns : int, default: 12; Maximum order used in the nonstiff case (<= 12). max_order_s : int, default: 5; Maximum order used in the stiff case (<= 5). first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped. min_step : float, default: 0; Minimum step size (0 = automatic); """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:132,Availability,toler,tolerance,132,"""""""; Supported options by lsoda integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. max_order_ns : int, default: 12; Maximum order used in the nonstiff case (<= 12). max_order_s : int, default: 5; Maximum order used in the stiff case (<= 5). first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped. min_step : float, default: 0; Minimum step size (0 = automatic); """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:32,Deployability,integrat,integrator,32,"""""""; Supported options by lsoda integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. max_order_ns : int, default: 12; Maximum order used in the nonstiff case (<= 12). max_order_s : int, default: 5; Maximum order used in the stiff case (<= 5). first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped. min_step : float, default: 0; Minimum step size (0 = automatic); """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:32,Integrability,integrat,integrator,32,"""""""; Supported options by lsoda integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. max_order_ns : int, default: 12; Maximum order used in the nonstiff case (<= 12). max_order_s : int, default: 5; Maximum order used in the stiff case (<= 5). first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped. min_step : float, default: 0; Minimum step size (0 = automatic); """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/scipy_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/verner7efficient.py:50,Energy Efficiency,efficient,efficient,50,"""""""; Provide a cython implimentation verner 'most-efficient'; order 7 runge-Kutta method.; See https://www.sfu.ca/~jverner/; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/verner7efficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/verner7efficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/verner9efficient.py:50,Energy Efficiency,efficient,efficient,50,"""""""; Provide a cython implimentation verner 'most-efficient'; order 9 runge-Kutta method.; See https://www.sfu.ca/~jverner/; """"""",MatchSource.CODE_COMMENT,qutip/solver/integrator/verner9efficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/verner9efficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nonmarkov/transfertensor.py:1336,Availability,error,errors,1336,"""""""; Expand time-evolution using the Transfer Tensor Method [1]_, based on a set; of precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`.Qobj`, callable; List of precomputed dynamical maps (superoperators) for the first times; of ``times`` or a callback function that returns the superoperator at a; given time. state0 : :class:`.Qobj`; Initial density matrix or state vector (ket). times : array_like; List of times :math:`t_n` at which to compute results.; Must be uniformily spaced. e_ops : :class:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. num_learning : int, default: 0; Number of times used to construct the dynmaps operators when; ``dynmaps`` is a callable. options : dictionary, optional; Dictionary of options for the solver. - store_final_state : bool; Whether or not to store the final state of the evolution in the; result class.; - store_states : bool, None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - normalize_output : bool; Normalize output state to hide ODE numerical errors.; - threshold : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. Returns; -------; output: :class:`.Result`; An instance of the class :class:`.Result`. .. [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014); """"""",MatchSource.CODE_COMMENT,qutip/solver/nonmarkov/transfertensor.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nonmarkov/transfertensor.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/itotaylor.py:7,Usability,simpl,simple,7,"""""""; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. - Order: 0.5; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/itotaylor.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/itotaylor.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/itotaylor.py:161,Availability,toler,tolerance,161,"""""""; Supported options by Order 1.5 strong Taylor Stochastic Integrators:. dt : float, default: 0.001; Internal time step. tol : float, default: 1e-10; Relative tolerance. derr_dt : float, default: 1e-6; Finite time difference used to compute the derrivative of the; hamiltonian and ``sc_ops``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/itotaylor.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/itotaylor.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/itotaylor.py:164,Usability,usab,usable,164,"""""""; Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than ``taylor15`` but usable when derrivatives cannot be; analytically obtained.; See eq. (2.13) of chapter 11.2 of Peter E. Kloeden and Exkhard Platen,; *Numerical Solution of Stochastic Differential Equations.*. - Order: strong 1.5; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/itotaylor.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/itotaylor.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/rouchon.py:16,Deployability,integrat,integration,16,"""""""; Stochastic integration method keeping the positivity of the density matrix.; See eq. (4) Pierre Rouchon and Jason F. Ralpha,; *Efficient Quantum Filtering for Quantum Feedback Control*,; `arXiv:1410.5345 [quant-ph] <https://arxiv.org/abs/1410.5345>`_,; Phys. Rev. A 91, 012118, (2015). - Order: strong 1. Notes; -----; This method should be used with very small ``dt``. Unlike other; methods that will return unphysical state (negative eigenvalues, Nans); when the time step is too large, this method will return state that; seems normal.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/rouchon.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/rouchon.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/rouchon.py:16,Integrability,integrat,integration,16,"""""""; Stochastic integration method keeping the positivity of the density matrix.; See eq. (4) Pierre Rouchon and Jason F. Ralpha,; *Efficient Quantum Filtering for Quantum Feedback Control*,; `arXiv:1410.5345 [quant-ph] <https://arxiv.org/abs/1410.5345>`_,; Phys. Rev. A 91, 012118, (2015). - Order: strong 1. Notes; -----; This method should be used with very small ``dt``. Unlike other; methods that will return unphysical state (negative eigenvalues, Nans); when the time step is too large, this method will return state that; seems normal.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/rouchon.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/rouchon.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/rouchon.py:144,Availability,toler,tolerance,144,"""""""; Supported options by Rouchon Stochastic Integrators:. dt : float, default: 0.001; Internal time step. tol : float, default: 1e-7; Relative tolerance.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/rouchon.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/rouchon.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:172,Deployability,integrat,integrator,172,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:248,Deployability,integrat,integrator,248,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:304,Deployability,integrat,integrator,304,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:494,Deployability,integrat,integrator,494,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:696,Deployability,integrat,integrator,696,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:796,Deployability,integrat,integrator,796,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:969,Deployability,integrat,integrator,969,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:7,Integrability,wrap,wrapper,7,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:172,Integrability,integrat,integrator,172,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:248,Integrability,integrat,integrator,248,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:304,Integrability,integrat,integrator,304,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:494,Integrability,integrat,integrator,494,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:593,Integrability,depend,depending,593,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:696,Integrability,integrat,integrator,696,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:796,Integrability,integrat,integrator,796,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:821,Integrability,depend,dependent,821,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:969,Integrability,integrat,integrator,969,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:133,Modifiability,evolve,evolve,133,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:34,Deployability,integrat,integrate,34,"""""""; Evolve to t. Before calling `integrate` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. copy : bool [True]; Whether to return a copy of the state or the state itself. Returns; -------; (t, state, noise) : (float, qutip.Data, np.ndarray); The state of the solver at ``t``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:159,Deployability,integrat,integrate,159,"""""""; Evolve to t. Before calling `integrate` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. copy : bool [True]; Whether to return a copy of the state or the state itself. Returns; -------; (t, state, noise) : (float, qutip.Data, np.ndarray); The state of the solver at ``t``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:34,Integrability,integrat,integrate,34,"""""""; Evolve to t. Before calling `integrate` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. copy : bool [True]; Whether to return a copy of the state or the state itself. Returns; -------; (t, state, noise) : (float, qutip.Data, np.ndarray); The state of the solver at ``t``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:159,Integrability,integrat,integrate,159,"""""""; Evolve to t. Before calling `integrate` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. copy : bool [True]; Whether to return a copy of the state or the state itself. Returns; -------; (t, state, noise) : (float, qutip.Data, np.ndarray); The state of the solver at ``t``.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:386,Safety,predict,predictor-corrector,386,"""""""; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of Peter E. Kloeden and Exkhard Platen,; *Numerical Solution of Stochastic Differential Equations*. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` or; ``'pc-euler'``; - Codes to correct both the stochastic and deterministic parts; (:math:`\\alpha=1/2`, :math:`\\eta=1/2`): ``'pc-euler-imp'``,; ``'pc-euler-2'`` or ``'pred-corr-2'``; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/sode.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/_noise.py:39,Testability,test,tests,39,"""""""; Wiener process generator used for tests.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/_noise.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/_noise.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/_noise.py:31,Deployability,integrat,integrators,31,"""""""; Noise used for Ito-Taylor integrators of order up to 1.5.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/_noise.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/_noise.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/_noise.py:31,Integrability,integrat,integrators,31,"""""""; Noise used for Ito-Taylor integrators of order up to 1.5.; """"""",MatchSource.CODE_COMMENT,qutip/solver/sode/_noise.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/_noise.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py:22,Testability,test,test,22,"""""""; Skip the current test item if Cython is unavailable for import, or isn't a; high enough version.; """"""",MatchSource.CODE_COMMENT,qutip/tests/conftest.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py:36,Testability,test,testing,36,"""""""; Taken almost verbatim from `np.testing._private.utils`, except this version; doesn't truncate output if it's longer than three lines. LICENCE; -------; Copyright (c) 2005-2020, NumPy Developers.; All rights reserved. Redistribution and use in source and binary forms, with or without; modification, are permitted provided that the following conditions are met:. - Redistributions of source code must retain the above copyright notice,; this list of conditions and the following disclaimer. - Redistributions in binary form must reproduce the above copyright notice,; this list of conditions and the following disclaimer in the documentation; and/or other materials provided with the distribution. - Neither the name of the NumPy Developers nor the names of any; contributors may be used to endorse or promote products derived from this; software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE); ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE; POSSIBILITY OF SUCH DAMAGE.; """"""",MatchSource.CODE_COMMENT,qutip/tests/conftest.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py:113,Availability,error,error,113,"# Find the private module used by numpy to store its testing utility functions; # so that we can monkeypatch the error messages to be more verbose. QuTiP; # supports numpy from 1.12 upwards, so we have to search.",MatchSource.CODE_COMMENT,qutip/tests/conftest.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py:119,Integrability,message,messages,119,"# Find the private module used by numpy to store its testing utility functions; # so that we can monkeypatch the error messages to be more verbose. QuTiP; # supports numpy from 1.12 upwards, so we have to search.",MatchSource.CODE_COMMENT,qutip/tests/conftest.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py:53,Testability,test,testing,53,"# Find the private module used by numpy to store its testing utility functions; # so that we can monkeypatch the error messages to be more verbose. QuTiP; # supports numpy from 1.12 upwards, so we have to search.",MatchSource.CODE_COMMENT,qutip/tests/conftest.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py:66,Deployability,patch,patch,66,"# If we can't locate it for some reason, then we don't attempt to patch.",MatchSource.CODE_COMMENT,qutip/tests/conftest.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_enr_state_operator.py:128,Energy Efficiency,efficient,efficient,128,"""""""; Calculate the total number of distinct ENR states for a given set of; subspaces. This method is not intended to be fast or efficient, it's; intended to be obviously correct for testing purposes.; """"""",MatchSource.CODE_COMMENT,qutip/tests/test_enr_state_operator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_enr_state_operator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_enr_state_operator.py:182,Testability,test,testing,182,"""""""; Calculate the total number of distinct ENR states for a given set of; subspaces. This method is not intended to be fast or efficient, it's; intended to be obviously correct for testing purposes.; """"""",MatchSource.CODE_COMMENT,qutip/tests/test_enr_state_operator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_enr_state_operator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py:6,Usability,simpl,simplified,6,""""""" A simplified relative entropy implementation for use in; double-checking the optimised implementation within; QuTiP itself.; """"""",MatchSource.CODE_COMMENT,qutip/tests/test_entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py:30,Testability,log,log,30,"# S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i)",MatchSource.CODE_COMMENT,qutip/tests/test_entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py:57,Testability,log,log,57,"# S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i)",MatchSource.CODE_COMMENT,qutip/tests/test_entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py:2,Testability,test,test,2,"# test different shape and dims",MatchSource.CODE_COMMENT,qutip/tests/test_entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py:2,Testability,test,test,2,"# test same shape, difference dims",MatchSource.CODE_COMMENT,qutip/tests/test_entropy.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_fileio.py:214,Testability,test,tests,214,"# qsave _always_ appends a suffix to the file name at the time of writing, but; # in case this changes in the future, to ensure that we never leak a temporary; # file into the user's folders, we simply apply these tests in a temporary; # directory. Windows also does not allow temporary files to be opened multiple; # times, so using a temporary directory is best.",MatchSource.CODE_COMMENT,qutip/tests/test_fileio.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_fileio.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_fileio.py:195,Usability,simpl,simply,195,"# qsave _always_ appends a suffix to the file name at the time of writing, but; # in case this changes in the future, to ensure that we never leak a temporary; # file into the user's folders, we simply apply these tests in a temporary; # directory. Windows also does not allow temporary files to be opened multiple; # times, so using a temporary directory is best.",MatchSource.CODE_COMMENT,qutip/tests/test_fileio.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_fileio.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py:45,Availability,error,errors,45,""""""" measurement_statistics_povm: check input errors """"""",MatchSource.CODE_COMMENT,qutip/tests/test_measurement.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py:51,Availability,error,errors,51,""""""" measurement_statistics_observable: check input errors """"""",MatchSource.CODE_COMMENT,qutip/tests/test_measurement.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py:17,Testability,test,test,17,"""""""measure_povm: test on basis states using different projectors """"""",MatchSource.CODE_COMMENT,qutip/tests/test_measurement.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py:30,Availability,error,errors,30,""""""" measure_povm: check input errors """"""",MatchSource.CODE_COMMENT,qutip/tests/test_measurement.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py:36,Availability,error,errors,36,""""""" measure_observable: check input errors """"""",MatchSource.CODE_COMMENT,qutip/tests/test_measurement.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py:150,Availability,avail,available,150,"# if qset.has_openmp:; # from qutip.core.cy.openmp.benchmark import _spmvpy, _spmvpy_openmp; # @unittest.skipIf(qset.has_openmp == False, 'OPENMP not available.')",MatchSource.CODE_COMMENT,qutip/tests/test_openmp.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py:51,Testability,benchmark,benchmark,51,"# if qset.has_openmp:; # from qutip.core.cy.openmp.benchmark import _spmvpy, _spmvpy_openmp; # @unittest.skipIf(qset.has_openmp == False, 'OPENMP not available.')",MatchSource.CODE_COMMENT,qutip/tests/test_openmp.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py:57,Availability,avail,available,57,"# @unittest.skipIf(qset.has_openmp == False, 'OPENMP not available.')",MatchSource.CODE_COMMENT,qutip/tests/test_openmp.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py:2,Modifiability,coupling,coupling,2,"# coupling strength",MatchSource.CODE_COMMENT,qutip/tests/test_openmp.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py:57,Availability,avail,available,57,"# @unittest.skipIf(qset.has_openmp == False, 'OPENMP not available.')",MatchSource.CODE_COMMENT,qutip/tests/test_openmp.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py:2,Modifiability,coupling,coupling,2,"# coupling strength",MatchSource.CODE_COMMENT,qutip/tests/test_openmp.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_partial_transpose.py:10,Testability,test,tests,10,"""""""; Unit tests for QuTiP partial transpose functions.; """"""",MatchSource.CODE_COMMENT,qutip/tests/test_partial_transpose.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_partial_transpose.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_partial_transpose.py:33,Testability,test,tests,33,"""""""partial transpose: randomized tests on tripartite system""""""",MatchSource.CODE_COMMENT,qutip/tests/test_partial_transpose.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_partial_transpose.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_qip.py:16,Testability,stub,stub,16,"# Make sure the stub modules is the one imported",MatchSource.CODE_COMMENT,qutip/tests/test_qip.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_qip.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_subsys_apply.py:125,Energy Efficiency,efficient,efficient,125,"""""""; A test class for the QuTiP function for applying superoperators to; subsystems.; The four tests below determine whether efficient numerics, naive numerics; and semi-analytic results are identical.; """"""",MatchSource.CODE_COMMENT,qutip/tests/test_subsys_apply.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_subsys_apply.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_subsys_apply.py:7,Testability,test,test,7,"""""""; A test class for the QuTiP function for applying superoperators to; subsystems.; The four tests below determine whether efficient numerics, naive numerics; and semi-analytic results are identical.; """"""",MatchSource.CODE_COMMENT,qutip/tests/test_subsys_apply.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_subsys_apply.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_subsys_apply.py:95,Testability,test,tests,95,"""""""; A test class for the QuTiP function for applying superoperators to; subsystems.; The four tests below determine whether efficient numerics, naive numerics; and semi-analytic results are identical.; """"""",MatchSource.CODE_COMMENT,qutip/tests/test_subsys_apply.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_subsys_apply.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_utilities.py:39,Availability,avail,available,39,"""""""get funtion 'convert_{}_to_{}' when available for coverage """"""",MatchSource.CODE_COMMENT,qutip/tests/test_utilities.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_utilities.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:30,Testability,test,tests,30,"# Use indirection so that the tests can still be collected if there's a bug; # in the generating QuTiP functions.",MatchSource.CODE_COMMENT,qutip/tests/test_wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:11,Testability,test,testing,11,"""""""wigner: testing the SU2 parity of the first Bell state.; """"""",MatchSource.CODE_COMMENT,qutip/tests/test_wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:11,Testability,test,testing,11,"""""""wigner: testing the SU2 parity of the fourth Bell state.; """"""",MatchSource.CODE_COMMENT,qutip/tests/test_wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:11,Testability,test,testing,11,"""""""wigner: testing the parity of the fourth Bell state using the parity of; the full space.; """"""",MatchSource.CODE_COMMENT,qutip/tests/test_wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:11,Testability,test,testing,11,"""""""wigner: testing the parity function.; """"""",MatchSource.CODE_COMMENT,qutip/tests/test_wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:11,Testability,test,testing,11,"""""""wigner: testing the SU2 wigner transformation of a pure state.; """"""",MatchSource.CODE_COMMENT,qutip/tests/test_wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:11,Testability,test,testing,11,"""""""wigner: testing the SU2 wigner transformation of the GHZ state.; """"""",MatchSource.CODE_COMMENT,qutip/tests/test_wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:11,Testability,test,tests,11,"""""""wigner: tests angle slicing.; """"""",MatchSource.CODE_COMMENT,qutip/tests/test_wigner.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_coefficient.py:31,Testability,test,tested,31,"# Ensure the latest version is tested",MatchSource.CODE_COMMENT,qutip/tests/core/test_coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_coefficient.py:15,Deployability,update,update,15,"# Partial args update",MatchSource.CODE_COMMENT,qutip/tests/core/test_coefficient.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_coefficient.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py:71,Testability,test,tests,71,"""""""; Test the deep mapping. To simplify generation of edge-cases, this tests; against an equivalent (but slower) operation of flattening and unflattening; the list. We can get false negatives if the `flatten` or `unflatten`; functions are broken, but other tests should catch those.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_dimensions.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py:257,Testability,test,tests,257,"""""""; Test the deep mapping. To simplify generation of edge-cases, this tests; against an equivalent (but slower) operation of flattening and unflattening; the list. We can get false negatives if the `flatten` or `unflatten`; functions are broken, but other tests should catch those.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_dimensions.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py:31,Usability,simpl,simplify,31,"""""""; Test the deep mapping. To simplify generation of edge-cases, this tests; against an equivalent (but slower) operation of flattening and unflattening; the list. We can get false negatives if the `flatten` or `unflatten`; functions are broken, but other tests should catch those.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_dimensions.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py:86,Testability,test,tested,86,"# This function might not need to be public, and consequently might not; # need to be tested here.",MatchSource.CODE_COMMENT,qutip/tests/core/test_dimensions.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py:86,Testability,test,tested,86,"# This function might not need to be public, and consequently might not; # need to be tested here.",MatchSource.CODE_COMMENT,qutip/tests/core/test_dimensions.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_eigen.py:28,Availability,toler,tolerance,28,"# Allow an average absolute tolerance for each eigenvalue; we expect; # uncertainty in the sum to add in quadrature.",MatchSource.CODE_COMMENT,qutip/tests/core/test_eigen.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_eigen.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_eigenstates.py:114,Testability,log,logic,114,"# Specify parametrisation over a random Hamiltonian by specifying the; # dimensions, rather than duplicating that logic.",MatchSource.CODE_COMMENT,qutip/tests/core/test_eigenstates.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_eigenstates.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:392,Performance,perform,performing,392,"# We want to test the broadcasting rules for `qutip.expect` for a whole bunch; # of different systems, without having to repeatedly specify the systems over; # and over again. We first store a small number of test cases for known; # expectation value in the most bundled-up form, because it's easier to unroll; # these by applying the expected broadcasting rules explicitly ourselves than; # performing the inverse operation.; #; # We store a single test case in a record type, just to keep things neatly; # together while we're munging them, so it's clear at all times what; # constitutes a valid test case.",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:13,Testability,test,test,13,"# We want to test the broadcasting rules for `qutip.expect` for a whole bunch; # of different systems, without having to repeatedly specify the systems over; # and over again. We first store a small number of test cases for known; # expectation value in the most bundled-up form, because it's easier to unroll; # these by applying the expected broadcasting rules explicitly ourselves than; # performing the inverse operation.; #; # We store a single test case in a record type, just to keep things neatly; # together while we're munging them, so it's clear at all times what; # constitutes a valid test case.",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:209,Testability,test,test,209,"# We want to test the broadcasting rules for `qutip.expect` for a whole bunch; # of different systems, without having to repeatedly specify the systems over; # and over again. We first store a small number of test cases for known; # expectation value in the most bundled-up form, because it's easier to unroll; # these by applying the expected broadcasting rules explicitly ourselves than; # performing the inverse operation.; #; # We store a single test case in a record type, just to keep things neatly; # together while we're munging them, so it's clear at all times what; # constitutes a valid test case.",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:450,Testability,test,test,450,"# We want to test the broadcasting rules for `qutip.expect` for a whole bunch; # of different systems, without having to repeatedly specify the systems over; # and over again. We first store a small number of test cases for known; # expectation value in the most bundled-up form, because it's easier to unroll; # these by applying the expected broadcasting rules explicitly ourselves than; # performing the inverse operation.; #; # We store a single test case in a record type, just to keep things neatly; # together while we're munging them, so it's clear at all times what; # constitutes a valid test case.",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:598,Testability,test,test,598,"# We want to test the broadcasting rules for `qutip.expect` for a whole bunch; # of different systems, without having to repeatedly specify the systems over; # and over again. We first store a small number of test cases for known; # expectation value in the most bundled-up form, because it's easier to unroll; # these by applying the expected broadcasting rules explicitly ourselves than; # performing the inverse operation.; #; # We store a single test case in a record type, just to keep things neatly; # together while we're munging them, so it's clear at all times what; # constitutes a valid test case.",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:551,Usability,clear,clear,551,"# We want to test the broadcasting rules for `qutip.expect` for a whole bunch; # of different systems, without having to repeatedly specify the systems over; # and over again. We first store a small number of test cases for known; # expectation value in the most bundled-up form, because it's easier to unroll; # these by applying the expected broadcasting rules explicitly ourselves than; # performing the inverse operation.; #; # We store a single test case in a record type, just to keep things neatly; # together while we're munging them, so it's clear at all times what; # constitutes a valid test case.",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:29,Testability,test,test,29,"# This is the minimal set of test cases, with a Fock system and a qubit system; # both in ket form and dm form. The reference expectations are a 2D array; # which would be found by broadcasting `operator` against `state` and applying; # `qutip.expect` to the pairs.",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:54,Performance,perform,performing,54,"""""""; Perform the parametrisation over the test cases, performing the; explicit broadcasting into separate test cases when required. We detect whether to perform explicit broadcasting over one of the; arguments of the `_Case` by looking for a singular/plural name of the; parameter in the test. If the parameter is singular, then we manually; perform the broadcasting rule for that fixture, and parametrise over; the resulting list, taking care to pick out the correct parts of the; reference array.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:153,Performance,perform,perform,153,"""""""; Perform the parametrisation over the test cases, performing the; explicit broadcasting into separate test cases when required. We detect whether to perform explicit broadcasting over one of the; arguments of the `_Case` by looking for a singular/plural name of the; parameter in the test. If the parameter is singular, then we manually; perform the broadcasting rule for that fixture, and parametrise over; the resulting list, taking care to pick out the correct parts of the; reference array.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:342,Performance,perform,perform,342,"""""""; Perform the parametrisation over the test cases, performing the; explicit broadcasting into separate test cases when required. We detect whether to perform explicit broadcasting over one of the; arguments of the `_Case` by looking for a singular/plural name of the; parameter in the test. If the parameter is singular, then we manually; perform the broadcasting rule for that fixture, and parametrise over; the resulting list, taking care to pick out the correct parts of the; reference array.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:135,Safety,detect,detect,135,"""""""; Perform the parametrisation over the test cases, performing the; explicit broadcasting into separate test cases when required. We detect whether to perform explicit broadcasting over one of the; arguments of the `_Case` by looking for a singular/plural name of the; parameter in the test. If the parameter is singular, then we manually; perform the broadcasting rule for that fixture, and parametrise over; the resulting list, taking care to pick out the correct parts of the; reference array.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:42,Testability,test,test,42,"""""""; Perform the parametrisation over the test cases, performing the; explicit broadcasting into separate test cases when required. We detect whether to perform explicit broadcasting over one of the; arguments of the `_Case` by looking for a singular/plural name of the; parameter in the test. If the parameter is singular, then we manually; perform the broadcasting rule for that fixture, and parametrise over; the resulting list, taking care to pick out the correct parts of the; reference array.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:106,Testability,test,test,106,"""""""; Perform the parametrisation over the test cases, performing the; explicit broadcasting into separate test cases when required. We detect whether to perform explicit broadcasting over one of the; arguments of the `_Case` by looking for a singular/plural name of the; parameter in the test. If the parameter is singular, then we manually; perform the broadcasting rule for that fixture, and parametrise over; the resulting list, taking care to pick out the correct parts of the; reference array.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:288,Testability,test,test,288,"""""""; Perform the parametrisation over the test cases, performing the; explicit broadcasting into separate test cases when required. We detect whether to perform explicit broadcasting over one of the; arguments of the `_Case` by looking for a singular/plural name of the; parameter in the test. If the parameter is singular, then we manually; perform the broadcasting rule for that fixture, and parametrise over; the resulting list, taking care to pick out the correct parts of the; reference array.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:2,Testability,test,test,2,"# test measurement operators based on lambda functions",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:175,Modifiability,layers,layers,175,"""""""This tests ensures that expect still works even if the output of a; specialisation does not have the ``real`` attribute. This is the case for; the tensorflow and cupy data layers.""""""",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:8,Testability,test,tests,8,"""""""This tests ensures that expect still works even if the output of a; specialisation does not have the ``real`` attribute. This is the case for; the tensorflow and cupy data layers.""""""",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:8,Usability,simpl,simply,8,"""""""; We simply return None which does not have the `real` attribute.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_gates.py:6,Availability,toler,tolerance,6,"# Big tolerance because we actually want to test the inverse.",MatchSource.CODE_COMMENT,qutip/tests/core/test_gates.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_gates.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_gates.py:44,Testability,test,test,44,"# Big tolerance because we actually want to test the inverse.",MatchSource.CODE_COMMENT,qutip/tests/core/test_gates.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_gates.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_gates.py:154,Usability,simpl,simply,154,"# Assert that each Clifford gate maps the set of Pauli gates back onto; # itself (though not necessarily in order). This condition is no; # stronger than simply considering each (gate, Pauli) pair separately.",MatchSource.CODE_COMMENT,qutip/tests/core/test_gates.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_gates.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:64,Testability,test,test,64,"# These ones are the metrics functions that we actually want to test.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:215,Testability,test,tests,215,"# There are also some cases in the file where this fixture is explicitly; # overridden by a more local mark. That is deliberate; this dimension is; # intended for non-superoperators, and may cause inordinantly long tests if; # (for example) something uses dimension=100 then makes a superoperator out; # of it.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:73,Testability,test,tests,73,"# Also parametrise left, right as if they're the names of two states for tests; # that need to take two states.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:227,Testability,test,testing,227,"# The class names have an unusual naming convention to make them more; # convenient to use with the `pytest -k ""expr""` selection syntax. They start; # with the standard `Test`, but then are the name of the function they are; # testing in the function naming convention, so it's easy to remember the; # selector to choose a particular function.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:143,Availability,failure,failure,143,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:712,Availability,failure,failures,712,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:1041,Availability,avail,available,1041,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:1067,Integrability,depend,depends,1067,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:844,Modifiability,variab,variables,844,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:8,Testability,test,tests,8,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:132,Testability,test,test-suite,132,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:186,Testability,test,tests,186,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:553,Testability,test,test,553,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:656,Testability,test,test,656,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:756,Testability,test,tests,756,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:1002,Testability,test,tests,1002,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:107,Usability,UX,UXU,107,"# Finally, we add a known case from Johnston's QETLAB documentation,; # || Phi - I ||_,; # where Phi(X) = UXU and U = [[1, 1], [-1, 1]] / sqrt(2).",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:122,Testability,test,test,122,"""""""; Test cases based on comparisons to pre-existing dnorm implementations.; In particular, the targets for the following test cases were generated; using QuantumUtils for MATLAB (https://goo.gl/oWXhO9).; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_metrics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_ptrace.py:16,Testability,test,test,16,"""""""; Regression test for gh-1325. ptrace should work the same independently of; the order of the input; no transposition in done in the trace operation.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_ptrace.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_ptrace.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:12,Performance,cache,cached,12,"# Check the cached isherm, if any exists.",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:23,Performance,cache,cached,23,"# Force a reset of the cached value for isherm.",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:2,Testability,test,test,2,"# test addition of two nonhermitian operators adding up to be hermitian",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:2,Testability,test,test,2,"# test addition of one hermitan and one nonhermitian operator",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:2,Testability,test,test,2,"# test addition of two hermitan operators",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:12,Performance,cache,cached,12,"# Check the cached isunitary.",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:23,Performance,cache,cached,23,"# Force a reset of the cached value for isunitary.",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:30,Usability,clear,clear,30,"# Check some other operations clear unitarity",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:8,Performance,cache,cached,8,"# clear cached values",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:2,Usability,clear,clear,2,"# clear cached values",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:173,Testability,test,test,173,"# We do not allow yet qobj being multiplied by a numpy array that does not; # represent a scalar. If we include the feature of numpy broadcasting an qobj; # as scalar, this test should be removed.",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:17,Testability,test,test,17,"# vector L2-norm test",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:24,Testability,test,test,24,"# vector max (inf) norm test",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:165,Usability,simpl,simply,165,"""""""; Checks that binary ops preserve 'superrep'. .. note::. The random superoperators are not chosen in a way that reflects the; structure of that superrep, but are simply random matrices.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:33,Testability,test,test,33,"# Assume for the purposes of the test that S maps square operators to; # square operators.",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:7,Testability,test,test,7,"# Make test objects.",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:174,Modifiability,layers,layers,174,"""""""This tests ensures that trace still works even if the output of a; specialisation does not have the ``real`` attribute. This is the case for; the tensorflow and cupy data layers.""""""",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:8,Testability,test,tests,8,"""""""This tests ensures that trace still works even if the output of a; specialisation does not have the ``real`` attribute. This is the case for; the tensorflow and cupy data layers.""""""",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:8,Usability,simpl,simply,8,"""""""; We simply return a string which does not have the `real` attribute.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobj.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py:6,Availability,avail,available,6,"# all available QobjEvo types",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobjevo.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py:2,Testability,test,test,2,"# test creation of QobjEvo and call",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobjevo.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py:2,Testability,test,test,2,"# test creation of QobjEvo with Qobj * Coefficient; # Skip pure func: QobjEvo(f(t, args) -> Qobj)",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobjevo.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py:5,Testability,test,test,5,"# We test that the output dtype is a know type: accepted by `to.parse`.",MatchSource.CODE_COMMENT,qutip/tests/core/test_qobjevo.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py:7,Testability,test,test,7,"""""""; A test class for the QuTiP function for matrix/vector conversion.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_superoper.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py:8,Testability,test,test,8,"""""""This test checks that the dtype is properly kept with the; `operation` function.""""""",MatchSource.CODE_COMMENT,qutip/tests/core/test_superoper.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py:8,Testability,test,test,8,"""""""This test checks that the dtype is properly kept with `sprepost`; function.""""""",MatchSource.CODE_COMMENT,qutip/tests/core/test_superoper.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py:7,Testability,test,test,7,"""""""; A test class for the QuTiP superoperator functions.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_superoper.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superop_reps.py:7,Testability,test,test,7,"""""""; A test class for the QuTiP function for applying superoperators to; subsystems.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/test_superop_reps.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superop_reps.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_tensor.py:117,Deployability,canary,canary,117,"# Let's try a weird tensor contraction; this will likely never come up in; # practice, but it should serve as a good canary for more reasonable; # contractions.",MatchSource.CODE_COMMENT,qutip/tests/core/test_tensor.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_tensor.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_tensor.py:27,Integrability,contract,contraction,27,"# Let's try a weird tensor contraction; this will likely never come up in; # practice, but it should serve as a good canary for more reasonable; # contractions.",MatchSource.CODE_COMMENT,qutip/tests/core/test_tensor.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_tensor.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_tensor.py:147,Integrability,contract,contractions,147,"# Let's try a weird tensor contraction; this will likely never come up in; # practice, but it should serve as a good canary for more reasonable; # contractions.",MatchSource.CODE_COMMENT,qutip/tests/core/test_tensor.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_tensor.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/conftest.py:155,Energy Efficiency,efficient,efficient,155,"""""""; Given a scipy.sparse.csr_matrix, shuffle the indices within each row and; return a new array. This should represent the same matrix, but in the less; efficient, ""unsorted"" manner. All mathematical operations should still; work the same after this, but may be slower. This is not guaranteed to change the order of the indices in every case.; If there is at most one value per row, there is no unsorted order. In; general, we attempt to shuffle, and if this returns the same order as; before, we just reverse it to ensure it's different.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/conftest.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/conftest.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_convert.py:6,Testability,test,test,6,"# The test of exactitude is done in test_csr, test_dense.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_convert.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_convert.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:45,Testability,test,test,45,"# We only choose a small subset of dtypes to test so it isn't crazy.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:67,Testability,test,tests,67,"""""""; Test that __init__ does not throw when passed a 3-tuple. Also tests; the as_scipy() method succeeds.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:53,Availability,error,error,53,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that CSR safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:154,Safety,safe,safely,154,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that CSR safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:107,Testability,test,test,107,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that CSR safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:245,Testability,test,tests,245,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that CSR safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:42,Availability,toler,tolerance,42,"# It's not enough to be accurate within a tolerance here - there's no; # mathematics, so they should be _identical_.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:123,Integrability,message,message,123,"# Some matrices _cannot_ be unsorted (e.g. if they have only one entry; # per row), so we add in this additional assertion message just to help; # out.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:113,Testability,assert,assertion,113,"# Some matrices _cannot_ be unsorted (e.g. if they have only one entry; # per row), so we add in this additional assertion message just to help; # out.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:46,Performance,cache,cache,46,"# We test on a copy because scipy attempts to cache; # `has_sorted_indices`, but since it's a view, it has no idea what; # we've done to the indices behind the scenes and typically would not; # notice the change. The copy will return a difference scipy matrix,; # so the cache will not be built.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:271,Performance,cache,cache,271,"# We test on a copy because scipy attempts to cache; # `has_sorted_indices`, but since it's a view, it has no idea what; # we've done to the indices behind the scenes and typically would not; # notice the change. The copy will return a difference scipy matrix,; # so the cache will not be built.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:5,Testability,test,test,5,"# We test on a copy because scipy attempts to cache; # `has_sorted_indices`, but since it's a view, it has no idea what; # we've done to the indices behind the scenes and typically would not; # notice the change. The copy will return a difference scipy matrix,; # so the cache will not be built.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:16,Testability,test,testing,16,"# scale=None is testing that the default value returns the identity.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:22,Testability,test,test,22,"# Build numpy version test.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:86,Safety,avoid,avoid,86,"# users are not expected to be exposed to; # csr.empty directly, but it is good to; # avoid segfaults, so we test passing; # csr.empty(..) blocks here explicitly",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:31,Security,expose,exposed,31,"# users are not expected to be exposed to; # csr.empty directly, but it is good to; # avoid segfaults, so we test passing; # csr.empty(..) blocks here explicitly",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:109,Testability,test,test,109,"# users are not expected to be exposed to; # csr.empty directly, but it is good to; # avoid segfaults, so we test passing; # csr.empty(..) blocks here explicitly",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_csr.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py:53,Availability,error,error,53,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that Dense safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dense.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py:156,Safety,safe,safely,156,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that Dense safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dense.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py:107,Testability,test,test,107,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that Dense safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dense.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py:247,Testability,test,tests,247,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that Dense safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dense.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py:42,Availability,toler,tolerance,42,"# It's not enough to be accurate within a tolerance here - there's no; # mathematics, so they should be _identical_.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dense.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py:16,Testability,test,testing,16,"# scale=None is testing that the default value returns the identity.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dense.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py:22,Testability,test,test,22,"# Build numpy version test.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dense.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py:45,Testability,test,test,45,"# We only choose a small subset of dtypes to test so it isn't crazy.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dia.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py:67,Testability,test,tests,67,"""""""; Test that __init__ does not throw when passed a 3-tuple. Also tests; the as_scipy() method succeeds.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dia.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py:53,Availability,error,error,53,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that Dia safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dia.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py:154,Safety,safe,safely,154,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that Dia safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dia.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py:107,Testability,test,test,107,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that Dia safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dia.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py:245,Testability,test,tests,245,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that Dia safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dia.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py:42,Availability,toler,tolerance,42,"# It's not enough to be accurate within a tolerance here - there's no; # mathematics, so they should be _identical_.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dia.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py:16,Testability,test,testing,16,"# scale=None is testing that the default value returns the identity.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dia.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py:22,Testability,test,test,22,"# Build numpy version test.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_dia.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_expect.py:22,Testability,test,tests,22,"""""""This file provides tests for expect specialisation. For tests at Qobj level; see `qutip/tests/core/test_expect.py`""""""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_expect.py:59,Testability,test,tests,59,"""""""This file provides tests for expect specialisation. For tests at Qobj level; see `qutip/tests/core/test_expect.py`""""""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_expect.py:91,Testability,test,tests,91,"""""""This file provides tests for expect specialisation. For tests at Qobj level; see `qutip/tests/core/test_expect.py`""""""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_expect.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_expect.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:72,Security,access,access,72,"# The ParameterSet is actually a pretty hidden type, so it's easiest to access; # it like this.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:18,Testability,test,test,18,"""""""Base shapes to test for unary functions.""""""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:13,Testability,test,test,13,"# Be sure to test a full spectrum bra-type, ket-type and square and; # non-square operators. Keep the dimension sensible, particularly for; # things like kron, since these shapes are reused to build the shapes for; # higher-order functions too.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:64,Testability,test,tested,64,"# Set up the special cases for each type of matrix that will be tested. These; # should be kept low, because mathematical operations will test a Cartesian; # product of all the cases of the same order as the operation, which can get; # very large very fast. The operations should each complete in a small amount; # of time, so having 10000+ tests in this file still ought to take less than 2; # minutes, but it's easy to accidentally add orders of magnitude on.; #; # There is a layer of indirection---the cases are returned as 0-ary generator; # closures---for two reasons:; # 1. we don't have to store huge amounts of data at test collection time, but; # the matrices are only generated, and subsequently freed, within in each; # individual test.; # 2. each test can be repeated, and new random matrices will be generated for; # each repeat, rather than re-using the same set. This is somewhat; # ""defeating"" pytest fixtures, but here we're not worried about re-usable; # inputs, we just want the managed parametrisation.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:138,Testability,test,test,138,"# Set up the special cases for each type of matrix that will be tested. These; # should be kept low, because mathematical operations will test a Cartesian; # product of all the cases of the same order as the operation, which can get; # very large very fast. The operations should each complete in a small amount; # of time, so having 10000+ tests in this file still ought to take less than 2; # minutes, but it's easy to accidentally add orders of magnitude on.; #; # There is a layer of indirection---the cases are returned as 0-ary generator; # closures---for two reasons:; # 1. we don't have to store huge amounts of data at test collection time, but; # the matrices are only generated, and subsequently freed, within in each; # individual test.; # 2. each test can be repeated, and new random matrices will be generated for; # each repeat, rather than re-using the same set. This is somewhat; # ""defeating"" pytest fixtures, but here we're not worried about re-usable; # inputs, we just want the managed parametrisation.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:341,Testability,test,tests,341,"# Set up the special cases for each type of matrix that will be tested. These; # should be kept low, because mathematical operations will test a Cartesian; # product of all the cases of the same order as the operation, which can get; # very large very fast. The operations should each complete in a small amount; # of time, so having 10000+ tests in this file still ought to take less than 2; # minutes, but it's easy to accidentally add orders of magnitude on.; #; # There is a layer of indirection---the cases are returned as 0-ary generator; # closures---for two reasons:; # 1. we don't have to store huge amounts of data at test collection time, but; # the matrices are only generated, and subsequently freed, within in each; # individual test.; # 2. each test can be repeated, and new random matrices will be generated for; # each repeat, rather than re-using the same set. This is somewhat; # ""defeating"" pytest fixtures, but here we're not worried about re-usable; # inputs, we just want the managed parametrisation.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:628,Testability,test,test,628,"# Set up the special cases for each type of matrix that will be tested. These; # should be kept low, because mathematical operations will test a Cartesian; # product of all the cases of the same order as the operation, which can get; # very large very fast. The operations should each complete in a small amount; # of time, so having 10000+ tests in this file still ought to take less than 2; # minutes, but it's easy to accidentally add orders of magnitude on.; #; # There is a layer of indirection---the cases are returned as 0-ary generator; # closures---for two reasons:; # 1. we don't have to store huge amounts of data at test collection time, but; # the matrices are only generated, and subsequently freed, within in each; # individual test.; # 2. each test can be repeated, and new random matrices will be generated for; # each repeat, rather than re-using the same set. This is somewhat; # ""defeating"" pytest fixtures, but here we're not worried about re-usable; # inputs, we just want the managed parametrisation.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:743,Testability,test,test,743,"# Set up the special cases for each type of matrix that will be tested. These; # should be kept low, because mathematical operations will test a Cartesian; # product of all the cases of the same order as the operation, which can get; # very large very fast. The operations should each complete in a small amount; # of time, so having 10000+ tests in this file still ought to take less than 2; # minutes, but it's easy to accidentally add orders of magnitude on.; #; # There is a layer of indirection---the cases are returned as 0-ary generator; # closures---for two reasons:; # 1. we don't have to store huge amounts of data at test collection time, but; # the matrices are only generated, and subsequently freed, within in each; # individual test.; # 2. each test can be repeated, and new random matrices will be generated for; # each repeat, rather than re-using the same set. This is somewhat; # ""defeating"" pytest fixtures, but here we're not worried about re-usable; # inputs, we just want the managed parametrisation.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:760,Testability,test,test,760,"# Set up the special cases for each type of matrix that will be tested. These; # should be kept low, because mathematical operations will test a Cartesian; # product of all the cases of the same order as the operation, which can get; # very large very fast. The operations should each complete in a small amount; # of time, so having 10000+ tests in this file still ought to take less than 2; # minutes, but it's easy to accidentally add orders of magnitude on.; #; # There is a layer of indirection---the cases are returned as 0-ary generator; # closures---for two reasons:; # 1. we don't have to store huge amounts of data at test collection time, but; # the matrices are only generated, and subsequently freed, within in each; # individual test.; # 2. each test can be repeated, and new random matrices will be generated for; # each repeat, rather than re-using the same set. This is somewhat; # ""defeating"" pytest fixtures, but here we're not worried about re-usable; # inputs, we just want the managed parametrisation.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:964,Usability,usab,usable,964,"# Set up the special cases for each type of matrix that will be tested. These; # should be kept low, because mathematical operations will test a Cartesian; # product of all the cases of the same order as the operation, which can get; # very large very fast. The operations should each complete in a small amount; # of time, so having 10000+ tests in this file still ought to take less than 2; # minutes, but it's easy to accidentally add orders of magnitude on.; #; # There is a layer of indirection---the cases are returned as 0-ary generator; # closures---for two reasons:; # 1. we don't have to store huge amounts of data at test collection time, but; # the matrices are only generated, and subsequently freed, within in each; # individual test.; # 2. each test can be repeated, and new random matrices will be generated for; # each repeat, rather than re-using the same set. This is somewhat; # ""defeating"" pytest fixtures, but here we're not worried about re-usable; # inputs, we just want the managed parametrisation.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:128,Testability,test,test,128,"# Factory methods for generating the cases, mapping type to the function.; # _ALL_CASES is for getting all the special cases to test, _RANDOM is for; # getting just a single case from each.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:106,Testability,test,tested,106,"""""""; Return a list of `pytest.ParameterSet` which is a flat list of all the; special cases that should be tested for this operator specialisation `op`,; which takes in several types `types`, where the arguments have shapes taken; from the iterable of iterables `shapes`. If `out_type` is specified, it; will be added into the output parameter set and its name added to the id,; but is otherwise not used. Parameters; ----------; cases_lookup: Map[Type, (shape: 2-tuple) -> list]; Mapping to get the special case generator from. This is one of; _ALL_CASES or _RANDOM (or similar). The elements of the list returned; from the case generator should all be closures of the form `() -> Data`; (e.g. `lambda: data.csr.identity(10)`), or a `pytest.ParameterSet`; containing exactly one value, which is the same closure type. op: Function; The specialisation of a mathematical operation that is being tested.; This is actually generally unused - it's just added in to the output; ParameterSet at the end so that it will get correctly parametrised. types: Tuple[Type]; A tuple of data.Data subclass types (not instances). This defines the; inputs to this particular specialisation under test. There should be; as many types as there are Data arguments to `op`. shapes: Iterable[Tuple[(int, int) | ParameterSet[(int, int)]]]; An iterable containing several sets of shapes to parameterise over.; Each element of the iterable should be s tuple of shapes, or; `pytest.ParameterSet` instances each containing a single shape. A; shape is a 2-tuple of integers. There should be as many elements of; this inner tuple as there are `types`, since each individual `shape`; goes with a `type`. out_type: Type; The output type for this specialisation. Not used other than its name; being added to the id, and it being added at the end of the; specialisation (if it is given), similarly to `op`. Returns; -------; List[ParameterSet]; A list of individual test cases for parametrisation. Each ParameterSet; will be; [op, *dat",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:893,Testability,test,tested,893,"""""""; Return a list of `pytest.ParameterSet` which is a flat list of all the; special cases that should be tested for this operator specialisation `op`,; which takes in several types `types`, where the arguments have shapes taken; from the iterable of iterables `shapes`. If `out_type` is specified, it; will be added into the output parameter set and its name added to the id,; but is otherwise not used. Parameters; ----------; cases_lookup: Map[Type, (shape: 2-tuple) -> list]; Mapping to get the special case generator from. This is one of; _ALL_CASES or _RANDOM (or similar). The elements of the list returned; from the case generator should all be closures of the form `() -> Data`; (e.g. `lambda: data.csr.identity(10)`), or a `pytest.ParameterSet`; containing exactly one value, which is the same closure type. op: Function; The specialisation of a mathematical operation that is being tested.; This is actually generally unused - it's just added in to the output; ParameterSet at the end so that it will get correctly parametrised. types: Tuple[Type]; A tuple of data.Data subclass types (not instances). This defines the; inputs to this particular specialisation under test. There should be; as many types as there are Data arguments to `op`. shapes: Iterable[Tuple[(int, int) | ParameterSet[(int, int)]]]; An iterable containing several sets of shapes to parameterise over.; Each element of the iterable should be s tuple of shapes, or; `pytest.ParameterSet` instances each containing a single shape. A; shape is a 2-tuple of integers. There should be as many elements of; this inner tuple as there are `types`, since each individual `shape`; goes with a `type`. out_type: Type; The output type for this specialisation. Not used other than its name; being added to the id, and it being added at the end of the; specialisation (if it is given), similarly to `op`. Returns; -------; List[ParameterSet]; A list of individual test cases for parametrisation. Each ParameterSet; will be; [op, *dat",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:1178,Testability,test,test,1178,"op`,; which takes in several types `types`, where the arguments have shapes taken; from the iterable of iterables `shapes`. If `out_type` is specified, it; will be added into the output parameter set and its name added to the id,; but is otherwise not used. Parameters; ----------; cases_lookup: Map[Type, (shape: 2-tuple) -> list]; Mapping to get the special case generator from. This is one of; _ALL_CASES or _RANDOM (or similar). The elements of the list returned; from the case generator should all be closures of the form `() -> Data`; (e.g. `lambda: data.csr.identity(10)`), or a `pytest.ParameterSet`; containing exactly one value, which is the same closure type. op: Function; The specialisation of a mathematical operation that is being tested.; This is actually generally unused - it's just added in to the output; ParameterSet at the end so that it will get correctly parametrised. types: Tuple[Type]; A tuple of data.Data subclass types (not instances). This defines the; inputs to this particular specialisation under test. There should be; as many types as there are Data arguments to `op`. shapes: Iterable[Tuple[(int, int) | ParameterSet[(int, int)]]]; An iterable containing several sets of shapes to parameterise over.; Each element of the iterable should be s tuple of shapes, or; `pytest.ParameterSet` instances each containing a single shape. A; shape is a 2-tuple of integers. There should be as many elements of; this inner tuple as there are `types`, since each individual `shape`; goes with a `type`. out_type: Type; The output type for this specialisation. Not used other than its name; being added to the id, and it being added at the end of the; specialisation (if it is given), similarly to `op`. Returns; -------; List[ParameterSet]; A list of individual test cases for parametrisation. Each ParameterSet; will be; [op, *data_inputs, ?out_type]; where `data_inputs` is of the same length as the input parameter; `types` and represents the Data arguments to the specialisa",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:1932,Testability,test,test,1932,"ise not used. Parameters; ----------; cases_lookup: Map[Type, (shape: 2-tuple) -> list]; Mapping to get the special case generator from. This is one of; _ALL_CASES or _RANDOM (or similar). The elements of the list returned; from the case generator should all be closures of the form `() -> Data`; (e.g. `lambda: data.csr.identity(10)`), or a `pytest.ParameterSet`; containing exactly one value, which is the same closure type. op: Function; The specialisation of a mathematical operation that is being tested.; This is actually generally unused - it's just added in to the output; ParameterSet at the end so that it will get correctly parametrised. types: Tuple[Type]; A tuple of data.Data subclass types (not instances). This defines the; inputs to this particular specialisation under test. There should be; as many types as there are Data arguments to `op`. shapes: Iterable[Tuple[(int, int) | ParameterSet[(int, int)]]]; An iterable containing several sets of shapes to parameterise over.; Each element of the iterable should be s tuple of shapes, or; `pytest.ParameterSet` instances each containing a single shape. A; shape is a 2-tuple of integers. There should be as many elements of; this inner tuple as there are `types`, since each individual `shape`; goes with a `type`. out_type: Type; The output type for this specialisation. Not used other than its name; being added to the id, and it being added at the end of the; specialisation (if it is given), similarly to `op`. Returns; -------; List[ParameterSet]; A list of individual test cases for parametrisation. Each ParameterSet; will be; [op, *data_inputs, ?out_type]; where `data_inputs` is of the same length as the input parameter; `types` and represents the Data arguments to the specialisation `op`.; Each element of `data_inputs` is a generator function which takes no; arguments and returns a data.Data subclass of the correct type and; shape. `out_type` is present in the output only if it were given as a; parameter itself.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:44,Testability,test,test,44,"# Now we start to actually build up all the test cases. Since all the; # mathematical operations are really pretty similar, and most just need the; # basic testing functionality, we do this with a series of mix-in classes which; # provide various components of the testing and test-generation infrastructure.; #; # In each, we use the idiom that ""test_<x>"" is a test function which pytest; # will collect for us, and ""generate_<x>"" a method which will be called by; # `pytest_generate_tests` in order to generate all the parametrisations for the; # given test.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:156,Testability,test,testing,156,"# Now we start to actually build up all the test cases. Since all the; # mathematical operations are really pretty similar, and most just need the; # basic testing functionality, we do this with a series of mix-in classes which; # provide various components of the testing and test-generation infrastructure.; #; # In each, we use the idiom that ""test_<x>"" is a test function which pytest; # will collect for us, and ""generate_<x>"" a method which will be called by; # `pytest_generate_tests` in order to generate all the parametrisations for the; # given test.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:265,Testability,test,testing,265,"# Now we start to actually build up all the test cases. Since all the; # mathematical operations are really pretty similar, and most just need the; # basic testing functionality, we do this with a series of mix-in classes which; # provide various components of the testing and test-generation infrastructure.; #; # In each, we use the idiom that ""test_<x>"" is a test function which pytest; # will collect for us, and ""generate_<x>"" a method which will be called by; # `pytest_generate_tests` in order to generate all the parametrisations for the; # given test.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:277,Testability,test,test-generation,277,"# Now we start to actually build up all the test cases. Since all the; # mathematical operations are really pretty similar, and most just need the; # basic testing functionality, we do this with a series of mix-in classes which; # provide various components of the testing and test-generation infrastructure.; #; # In each, we use the idiom that ""test_<x>"" is a test function which pytest; # will collect for us, and ""generate_<x>"" a method which will be called by; # `pytest_generate_tests` in order to generate all the parametrisations for the; # given test.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:362,Testability,test,test,362,"# Now we start to actually build up all the test cases. Since all the; # mathematical operations are really pretty similar, and most just need the; # basic testing functionality, we do this with a series of mix-in classes which; # provide various components of the testing and test-generation infrastructure.; #; # In each, we use the idiom that ""test_<x>"" is a test function which pytest; # will collect for us, and ""generate_<x>"" a method which will be called by; # `pytest_generate_tests` in order to generate all the parametrisations for the; # given test.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:555,Testability,test,test,555,"# Now we start to actually build up all the test cases. Since all the; # mathematical operations are really pretty similar, and most just need the; # basic testing functionality, we do this with a series of mix-in classes which; # provide various components of the testing and test-generation infrastructure.; #; # In each, we use the idiom that ""test_<x>"" is a test function which pytest; # will collect for us, and ""generate_<x>"" a method which will be called by; # `pytest_generate_tests` in order to generate all the parametrisations for the; # given test.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:791,Availability,toler,tolerance,791,"""""""; Abstract base mix-in which sets up the test generation for the two basic; test operations, and puts in the very generic test generator. This does; not actually define the tests themselves, because subclasses need to define; them so the method arguments can be introspected to parametrise over the; correct number of arguments. The tests `mathematically_correct` and `incorrect_shape_raises` will; parametrise Data types over method arguments which have names `data_*`. The class arguments defined here are effectively parametrising the; mathematical tests. Attributes; ----------; op_numpy: *args -> np.ndarray; Function which takes the same arguments as the mathematical operation,; but with all data arguments numpy arrays, and returns the expected; result. atol: float; The absolute tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. rtol: float; The relative tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. shapes: list of (list of shapes); A list of the sets of shapes which should be used for the tests of; mathematical correctness. Each element of the list is a set of shapes,; each one corresponding to one of the arguments of the operation. bad_shapes: list of (list of shapes); Similar to `shapes`, but these should be shapes which are invalid for; the given mathematical operation. specialisations: list of (function, Type, Type, [Type, ...]); The specialisations of each mathematical function, and the types that; it takes in and returns. For example, the function; add(CSR, Dense) -> Other; would be specified as `(add, CSR, Dense, Other)`.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:898,Availability,toler,tolerance,898,"""""""; Abstract base mix-in which sets up the test generation for the two basic; test operations, and puts in the very generic test generator. This does; not actually define the tests themselves, because subclasses need to define; them so the method arguments can be introspected to parametrise over the; correct number of arguments. The tests `mathematically_correct` and `incorrect_shape_raises` will; parametrise Data types over method arguments which have names `data_*`. The class arguments defined here are effectively parametrising the; mathematical tests. Attributes; ----------; op_numpy: *args -> np.ndarray; Function which takes the same arguments as the mathematical operation,; but with all data arguments numpy arrays, and returns the expected; result. atol: float; The absolute tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. rtol: float; The relative tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. shapes: list of (list of shapes); A list of the sets of shapes which should be used for the tests of; mathematical correctness. Each element of the list is a set of shapes,; each one corresponding to one of the arguments of the operation. bad_shapes: list of (list of shapes); Similar to `shapes`, but these should be shapes which are invalid for; the given mathematical operation. specialisations: list of (function, Type, Type, [Type, ...]); The specialisations of each mathematical function, and the types that; it takes in and returns. For example, the function; add(CSR, Dense) -> Other; would be specified as `(add, CSR, Dense, Other)`.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:965,Availability,toler,tolerance,965,"""""""; Abstract base mix-in which sets up the test generation for the two basic; test operations, and puts in the very generic test generator. This does; not actually define the tests themselves, because subclasses need to define; them so the method arguments can be introspected to parametrise over the; correct number of arguments. The tests `mathematically_correct` and `incorrect_shape_raises` will; parametrise Data types over method arguments which have names `data_*`. The class arguments defined here are effectively parametrising the; mathematical tests. Attributes; ----------; op_numpy: *args -> np.ndarray; Function which takes the same arguments as the mathematical operation,; but with all data arguments numpy arrays, and returns the expected; result. atol: float; The absolute tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. rtol: float; The relative tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. shapes: list of (list of shapes); A list of the sets of shapes which should be used for the tests of; mathematical correctness. Each element of the list is a set of shapes,; each one corresponding to one of the arguments of the operation. bad_shapes: list of (list of shapes); Similar to `shapes`, but these should be shapes which are invalid for; the given mathematical operation. specialisations: list of (function, Type, Type, [Type, ...]); The specialisations of each mathematical function, and the types that; it takes in and returns. For example, the function; add(CSR, Dense) -> Other; would be specified as `(add, CSR, Dense, Other)`.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:1072,Availability,toler,tolerance,1072,"""""""; Abstract base mix-in which sets up the test generation for the two basic; test operations, and puts in the very generic test generator. This does; not actually define the tests themselves, because subclasses need to define; them so the method arguments can be introspected to parametrise over the; correct number of arguments. The tests `mathematically_correct` and `incorrect_shape_raises` will; parametrise Data types over method arguments which have names `data_*`. The class arguments defined here are effectively parametrising the; mathematical tests. Attributes; ----------; op_numpy: *args -> np.ndarray; Function which takes the same arguments as the mathematical operation,; but with all data arguments numpy arrays, and returns the expected; result. atol: float; The absolute tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. rtol: float; The relative tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. shapes: list of (list of shapes); A list of the sets of shapes which should be used for the tests of; mathematical correctness. Each element of the list is a set of shapes,; each one corresponding to one of the arguments of the operation. bad_shapes: list of (list of shapes); Similar to `shapes`, but these should be shapes which are invalid for; the given mathematical operation. specialisations: list of (function, Type, Type, [Type, ...]); The specialisations of each mathematical function, and the types that; it takes in and returns. For example, the function; add(CSR, Dense) -> Other; would be specified as `(add, CSR, Dense, Other)`.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:44,Testability,test,test,44,"""""""; Abstract base mix-in which sets up the test generation for the two basic; test operations, and puts in the very generic test generator. This does; not actually define the tests themselves, because subclasses need to define; them so the method arguments can be introspected to parametrise over the; correct number of arguments. The tests `mathematically_correct` and `incorrect_shape_raises` will; parametrise Data types over method arguments which have names `data_*`. The class arguments defined here are effectively parametrising the; mathematical tests. Attributes; ----------; op_numpy: *args -> np.ndarray; Function which takes the same arguments as the mathematical operation,; but with all data arguments numpy arrays, and returns the expected; result. atol: float; The absolute tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. rtol: float; The relative tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. shapes: list of (list of shapes); A list of the sets of shapes which should be used for the tests of; mathematical correctness. Each element of the list is a set of shapes,; each one corresponding to one of the arguments of the operation. bad_shapes: list of (list of shapes); Similar to `shapes`, but these should be shapes which are invalid for; the given mathematical operation. specialisations: list of (function, Type, Type, [Type, ...]); The specialisations of each mathematical function, and the types that; it takes in and returns. For example, the function; add(CSR, Dense) -> Other; would be specified as `(add, CSR, Dense, Other)`.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:79,Testability,test,test,79,"""""""; Abstract base mix-in which sets up the test generation for the two basic; test operations, and puts in the very generic test generator. This does; not actually define the tests themselves, because subclasses need to define; them so the method arguments can be introspected to parametrise over the; correct number of arguments. The tests `mathematically_correct` and `incorrect_shape_raises` will; parametrise Data types over method arguments which have names `data_*`. The class arguments defined here are effectively parametrising the; mathematical tests. Attributes; ----------; op_numpy: *args -> np.ndarray; Function which takes the same arguments as the mathematical operation,; but with all data arguments numpy arrays, and returns the expected; result. atol: float; The absolute tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. rtol: float; The relative tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. shapes: list of (list of shapes); A list of the sets of shapes which should be used for the tests of; mathematical correctness. Each element of the list is a set of shapes,; each one corresponding to one of the arguments of the operation. bad_shapes: list of (list of shapes); Similar to `shapes`, but these should be shapes which are invalid for; the given mathematical operation. specialisations: list of (function, Type, Type, [Type, ...]); The specialisations of each mathematical function, and the types that; it takes in and returns. For example, the function; add(CSR, Dense) -> Other; would be specified as `(add, CSR, Dense, Other)`.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:125,Testability,test,test,125,"""""""; Abstract base mix-in which sets up the test generation for the two basic; test operations, and puts in the very generic test generator. This does; not actually define the tests themselves, because subclasses need to define; them so the method arguments can be introspected to parametrise over the; correct number of arguments. The tests `mathematically_correct` and `incorrect_shape_raises` will; parametrise Data types over method arguments which have names `data_*`. The class arguments defined here are effectively parametrising the; mathematical tests. Attributes; ----------; op_numpy: *args -> np.ndarray; Function which takes the same arguments as the mathematical operation,; but with all data arguments numpy arrays, and returns the expected; result. atol: float; The absolute tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. rtol: float; The relative tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. shapes: list of (list of shapes); A list of the sets of shapes which should be used for the tests of; mathematical correctness. Each element of the list is a set of shapes,; each one corresponding to one of the arguments of the operation. bad_shapes: list of (list of shapes); Similar to `shapes`, but these should be shapes which are invalid for; the given mathematical operation. specialisations: list of (function, Type, Type, [Type, ...]); The specialisations of each mathematical function, and the types that; it takes in and returns. For example, the function; add(CSR, Dense) -> Other; would be specified as `(add, CSR, Dense, Other)`.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:176,Testability,test,tests,176,"""""""; Abstract base mix-in which sets up the test generation for the two basic; test operations, and puts in the very generic test generator. This does; not actually define the tests themselves, because subclasses need to define; them so the method arguments can be introspected to parametrise over the; correct number of arguments. The tests `mathematically_correct` and `incorrect_shape_raises` will; parametrise Data types over method arguments which have names `data_*`. The class arguments defined here are effectively parametrising the; mathematical tests. Attributes; ----------; op_numpy: *args -> np.ndarray; Function which takes the same arguments as the mathematical operation,; but with all data arguments numpy arrays, and returns the expected; result. atol: float; The absolute tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. rtol: float; The relative tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. shapes: list of (list of shapes); A list of the sets of shapes which should be used for the tests of; mathematical correctness. Each element of the list is a set of shapes,; each one corresponding to one of the arguments of the operation. bad_shapes: list of (list of shapes); Similar to `shapes`, but these should be shapes which are invalid for; the given mathematical operation. specialisations: list of (function, Type, Type, [Type, ...]); The specialisations of each mathematical function, and the types that; it takes in and returns. For example, the function; add(CSR, Dense) -> Other; would be specified as `(add, CSR, Dense, Other)`.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:336,Testability,test,tests,336,"""""""; Abstract base mix-in which sets up the test generation for the two basic; test operations, and puts in the very generic test generator. This does; not actually define the tests themselves, because subclasses need to define; them so the method arguments can be introspected to parametrise over the; correct number of arguments. The tests `mathematically_correct` and `incorrect_shape_raises` will; parametrise Data types over method arguments which have names `data_*`. The class arguments defined here are effectively parametrising the; mathematical tests. Attributes; ----------; op_numpy: *args -> np.ndarray; Function which takes the same arguments as the mathematical operation,; but with all data arguments numpy arrays, and returns the expected; result. atol: float; The absolute tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. rtol: float; The relative tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. shapes: list of (list of shapes); A list of the sets of shapes which should be used for the tests of; mathematical correctness. Each element of the list is a set of shapes,; each one corresponding to one of the arguments of the operation. bad_shapes: list of (list of shapes); Similar to `shapes`, but these should be shapes which are invalid for; the given mathematical operation. specialisations: list of (function, Type, Type, [Type, ...]); The specialisations of each mathematical function, and the types that; it takes in and returns. For example, the function; add(CSR, Dense) -> Other; would be specified as `(add, CSR, Dense, Other)`.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:555,Testability,test,tests,555,"""""""; Abstract base mix-in which sets up the test generation for the two basic; test operations, and puts in the very generic test generator. This does; not actually define the tests themselves, because subclasses need to define; them so the method arguments can be introspected to parametrise over the; correct number of arguments. The tests `mathematically_correct` and `incorrect_shape_raises` will; parametrise Data types over method arguments which have names `data_*`. The class arguments defined here are effectively parametrising the; mathematical tests. Attributes; ----------; op_numpy: *args -> np.ndarray; Function which takes the same arguments as the mathematical operation,; but with all data arguments numpy arrays, and returns the expected; result. atol: float; The absolute tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. rtol: float; The relative tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. shapes: list of (list of shapes); A list of the sets of shapes which should be used for the tests of; mathematical correctness. Each element of the list is a set of shapes,; each one corresponding to one of the arguments of the operation. bad_shapes: list of (list of shapes); Similar to `shapes`, but these should be shapes which are invalid for; the given mathematical operation. specialisations: list of (function, Type, Type, [Type, ...]); The specialisations of each mathematical function, and the types that; it takes in and returns. For example, the function; add(CSR, Dense) -> Other; would be specified as `(add, CSR, Dense, Other)`.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:827,Testability,test,test,827,"""""""; Abstract base mix-in which sets up the test generation for the two basic; test operations, and puts in the very generic test generator. This does; not actually define the tests themselves, because subclasses need to define; them so the method arguments can be introspected to parametrise over the; correct number of arguments. The tests `mathematically_correct` and `incorrect_shape_raises` will; parametrise Data types over method arguments which have names `data_*`. The class arguments defined here are effectively parametrising the; mathematical tests. Attributes; ----------; op_numpy: *args -> np.ndarray; Function which takes the same arguments as the mathematical operation,; but with all data arguments numpy arrays, and returns the expected; result. atol: float; The absolute tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. rtol: float; The relative tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. shapes: list of (list of shapes); A list of the sets of shapes which should be used for the tests of; mathematical correctness. Each element of the list is a set of shapes,; each one corresponding to one of the arguments of the operation. bad_shapes: list of (list of shapes); Similar to `shapes`, but these should be shapes which are invalid for; the given mathematical operation. specialisations: list of (function, Type, Type, [Type, ...]); The specialisations of each mathematical function, and the types that; it takes in and returns. For example, the function; add(CSR, Dense) -> Other; would be specified as `(add, CSR, Dense, Other)`.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:1001,Testability,test,test,1001,"""""""; Abstract base mix-in which sets up the test generation for the two basic; test operations, and puts in the very generic test generator. This does; not actually define the tests themselves, because subclasses need to define; them so the method arguments can be introspected to parametrise over the; correct number of arguments. The tests `mathematically_correct` and `incorrect_shape_raises` will; parametrise Data types over method arguments which have names `data_*`. The class arguments defined here are effectively parametrising the; mathematical tests. Attributes; ----------; op_numpy: *args -> np.ndarray; Function which takes the same arguments as the mathematical operation,; but with all data arguments numpy arrays, and returns the expected; result. atol: float; The absolute tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. rtol: float; The relative tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. shapes: list of (list of shapes); A list of the sets of shapes which should be used for the tests of; mathematical correctness. Each element of the list is a set of shapes,; each one corresponding to one of the arguments of the operation. bad_shapes: list of (list of shapes); Similar to `shapes`, but these should be shapes which are invalid for; the given mathematical operation. specialisations: list of (function, Type, Type, [Type, ...]); The specialisations of each mathematical function, and the types that; it takes in and returns. For example, the function; add(CSR, Dense) -> Other; would be specified as `(add, CSR, Dense, Other)`.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:1205,Testability,test,tests,1205,"""""""; Abstract base mix-in which sets up the test generation for the two basic; test operations, and puts in the very generic test generator. This does; not actually define the tests themselves, because subclasses need to define; them so the method arguments can be introspected to parametrise over the; correct number of arguments. The tests `mathematically_correct` and `incorrect_shape_raises` will; parametrise Data types over method arguments which have names `data_*`. The class arguments defined here are effectively parametrising the; mathematical tests. Attributes; ----------; op_numpy: *args -> np.ndarray; Function which takes the same arguments as the mathematical operation,; but with all data arguments numpy arrays, and returns the expected; result. atol: float; The absolute tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. rtol: float; The relative tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. shapes: list of (list of shapes); A list of the sets of shapes which should be used for the tests of; mathematical correctness. Each element of the list is a set of shapes,; each one corresponding to one of the arguments of the operation. bad_shapes: list of (list of shapes); Similar to `shapes`, but these should be shapes which are invalid for; the given mathematical operation. specialisations: list of (function, Type, Type, [Type, ...]); The specialisations of each mathematical function, and the types that; it takes in and returns. For example, the function; add(CSR, Dense) -> Other; would be specified as `(add, CSR, Dense, Other)`.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:207,Availability,down,down,207,"# For every test function ""test_xyz"", we use the test generator; # ""generate_xyz"" if it exists. This allows derived classes to add; # their own tests and generators without overiding this method, cutting; # down on boilerplate, but also that derived classes _may_ override the; # generation of tests defined in a base class, say if they have; # additional special arguments that need parametrising over.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:12,Testability,test,test,12,"# For every test function ""test_xyz"", we use the test generator; # ""generate_xyz"" if it exists. This allows derived classes to add; # their own tests and generators without overiding this method, cutting; # down on boilerplate, but also that derived classes _may_ override the; # generation of tests defined in a base class, say if they have; # additional special arguments that need parametrising over.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:49,Testability,test,test,49,"# For every test function ""test_xyz"", we use the test generator; # ""generate_xyz"" if it exists. This allows derived classes to add; # their own tests and generators without overiding this method, cutting; # down on boilerplate, but also that derived classes _may_ override the; # generation of tests defined in a base class, say if they have; # additional special arguments that need parametrising over.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:144,Testability,test,tests,144,"# For every test function ""test_xyz"", we use the test generator; # ""generate_xyz"" if it exists. This allows derived classes to add; # their own tests and generators without overiding this method, cutting; # down on boilerplate, but also that derived classes _may_ override the; # generation of tests defined in a base class, say if they have; # additional special arguments that need parametrising over.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:294,Testability,test,tests,294,"# For every test function ""test_xyz"", we use the test generator; # ""generate_xyz"" if it exists. This allows derived classes to add; # their own tests and generators without overiding this method, cutting; # down on boilerplate, but also that derived classes _may_ override the; # generation of tests defined in a base class, say if they have; # additional special arguments that need parametrising over.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:49,Availability,error,error,49,"""""""; Test that the operation produces a suitable error if the shape of the; given operand is not compatible with the operation. Useful for; operations that require square matrices (trace, pow, ...).; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:155,Testability,test,test,155,"""""""; Mix-in for unary mathematical operations on Data instances, but that also; take in a numeric scalar (e.g. scalar multiplication). Only generates; the test `mathematically_correct`, since there can't be a shape mismatch; when there's only one Data argument.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:49,Availability,error,error,49,"""""""; Test that the operation produces a suitable error if the shapes of the; given operands are not compatible.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:49,Availability,error,error,49,"""""""; Test that the operation produces a suitable error if the shapes of the; given operands are not compatible.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:66,Testability,test,tests,66,"# And now finally we get into the meat of the actual mathematical tests.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:162,Testability,test,test,162,"# The inner product is a bit more specialist, since it has to handle inputs; # in a 1D space specially. In order to keep things simple, we just; # generate those test cases completely separately from the standard; # `mathematically_correct`.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:128,Usability,simpl,simple,128,"# The inner product is a bit more specialist, since it has to handle inputs; # in a 1D space specially. In order to keep things simple, we just; # generate those test cases completely separately from the standard; # `mathematically_correct`.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:106,Availability,avail,available,106,"# For 1D subspaces, the special cases don't really matter since there's; # only really one type of matrix available, so this is parametrised; # with only case for each input argument.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:49,Availability,error,error,49,"""""""; Test that the operation produces a suitable error if the shape is not a; square matrix.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_mathematics.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:99,Availability,toler,tolerance,99,"""""""; Regression test for gh-1350, comparing explicitly stored values in the; matrix (but below the tolerance for allowable Hermicity) to implicit; zeros.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_properties.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:16,Testability,test,test,16,"""""""; Regression test for gh-1350, comparing explicitly stored values in the; matrix (but below the tolerance for allowable Hermicity) to implicit; zeros.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_properties.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:78,Testability,test,test,78,"# If this first line fails, the zero has been stored explicitly and so; # the test is invalid.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_properties.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:12,Testability,test,test,12,"# A similar test if the structures are different, but it's not; # Hermitian.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_properties.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:64,Availability,fault,faulty,64,"# Catch possible edge case where it shouldn't be Hermitian, but faulty; # loop logic doesn't fully compare all rows.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_properties.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:79,Testability,log,logic,79,"# Catch possible edge case where it shouldn't be Hermitian, but faulty; # loop logic doesn't fully compare all rows.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_properties.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:105,Availability,toler,tolerance,105,"""""""; Regression test of gh-1350. Larger matrices where all off-diagonal elements are below the; absolute tolerance, so everything should always appear Hermitian, but; with random patterns of non-zero elements. It doesn't matter that it; isn't Hermitian if scaled up; everything is below absolute tolerance,; so it should appear so. We also set the diagonal to be larger to the; tolerance to ensure isherm can't just compare everything to zero.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_properties.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:296,Availability,toler,tolerance,296,"""""""; Regression test of gh-1350. Larger matrices where all off-diagonal elements are below the; absolute tolerance, so everything should always appear Hermitian, but; with random patterns of non-zero elements. It doesn't matter that it; isn't Hermitian if scaled up; everything is below absolute tolerance,; so it should appear so. We also set the diagonal to be larger to the; tolerance to ensure isherm can't just compare everything to zero.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_properties.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:378,Availability,toler,tolerance,378,"""""""; Regression test of gh-1350. Larger matrices where all off-diagonal elements are below the; absolute tolerance, so everything should always appear Hermitian, but; with random patterns of non-zero elements. It doesn't matter that it; isn't Hermitian if scaled up; everything is below absolute tolerance,; so it should appear so. We also set the diagonal to be larger to the; tolerance to ensure isherm can't just compare everything to zero.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_properties.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:16,Testability,test,test,16,"""""""; Regression test of gh-1350. Larger matrices where all off-diagonal elements are below the; absolute tolerance, so everything should always appear Hermitian, but; with random patterns of non-zero elements. It doesn't matter that it; isn't Hermitian if scaled up; everything is below absolute tolerance,; so it should appear so. We also set the diagonal to be larger to the; tolerance to ensure isherm can't just compare everything to zero.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_properties.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:10,Testability,test,test,10,"# Similar test when it must be non-Hermitian. We set the diagonal; # to be real because we want to test off-diagonal implicit zeros,; # and having an imaginary first element would automatically fail.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_properties.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:99,Testability,test,test,99,"# Similar test when it must be non-Hermitian. We set the diagonal; # to be real because we want to test off-diagonal implicit zeros,; # and having an imaginary first element would automatically fail.",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_properties.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_ptrace.py:49,Availability,error,error,49,"""""""; Test that the operation produces a suitable error if the shape of the; operand is not square.; """"""",MatchSource.CODE_COMMENT,qutip/tests/core/data/test_ptrace.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_ptrace.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:10,Testability,test,tests,10,"# Disable tests for python2 as qutip.piqs does not support python2.",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,Testability,test,test,2,"# test 1; # mixed state with non-symmetrical block matrix elements",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,Testability,test,test,2,"# test 2; # all elements in block-diagonal matrix",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:3,Testability,test,test,3,"## test for N odd",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,Testability,test,test,2,"# test trace",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,Testability,test,test,2,"# test with linear function (trace)",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,Testability,test,test,2,"# test with nonlinear function",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:3,Testability,test,test,3,"## test for N even",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,Testability,test,test,2,"# test trace",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,Testability,test,test,2,"# test with linear function (trace)",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,Testability,test,test,2,"# test with nonlinear function",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,Testability,test,tests,2,"# tests 1",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,Testability,test,tests,2,"# tests 2",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:20,Energy Efficiency,energy,energy,20,"""""""; PIQS: Test the energy degeneracy (m) of Dicke state | j, m >.; """"""",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:8,Availability,error,error,8,"# check error",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:8,Availability,error,error,8,"# check error",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:7,Availability,error,error,7,"# test error",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,Testability,test,test,2,"# test error",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,Availability,error,error,2,"# error",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:75,Testability,test,test,75,"""""""; PIQS: Test if the Dicke basis (j, m, m') is constructed correctly. We test the state with for N = 2,. 0 0 0.3 0; 0 0.5 0 0; 0.3 0 0 0; 0 0 0 0.5; """"""",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,Availability,error,error,2,"# error",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:147,Performance,perform,performed,147,"""""""; PIQS: Test the calculation of the correct collapse operators (c_ops) list. In the ""uncoupled"" basis of N two-level system (TLS).; The test is performed for N = 2 and emission = 1.; """"""",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:139,Testability,test,test,139,"""""""; PIQS: Test the calculation of the correct collapse operators (c_ops) list. In the ""uncoupled"" basis of N two-level system (TLS).; The test is performed for N = 2 and emission = 1.; """"""",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,Performance,perform,performed,54,"""""""; PIQS: Test the calculation of gamma2. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,Performance,perform,performed,54,"""""""; PIQS: Test the calculation of gamma3. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,Performance,perform,performed,54,"""""""; PIQS: Test the calculation of gamma4. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,Performance,perform,performed,54,"""""""; PIQS: Test the calculation of gamma5. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,Performance,perform,performed,54,"""""""; PIQS: Test the calculation of gamma6. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,Performance,perform,performed,54,"""""""; PIQS: Test the calculation of gamma7. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,Performance,perform,performed,54,"""""""; PIQS: Test the calculation of gamma8. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,Performance,perform,performed,54,"""""""; PIQS: Test the calculation of gamma9. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip/tests/piqs/test_piqs.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_brmesolve.py:50,Modifiability,coupling,coupling,50,"""""""; Test that the BR solver handles collapse and coupling operators correctly; relative to the standard ME solver.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_brmesolve.py:12,Availability,error,error,12,"# Accept 5% error.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_brmesolve.py:12,Availability,error,error,12,"# Accept 5% error.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_brmesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_brmesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:22,Availability,toler,tolerance,22,"# Massively relax the tolerance for the Monte-Carlo approach to avoid a; # long simulation time.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_correlation.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:64,Safety,avoid,avoid,64,"# Massively relax the tolerance for the Monte-Carlo approach to avoid a; # long simulation time.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_correlation.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:95,Testability,test,tests,95,"# We use the master equation version as a base, but it doesn't actually; # matter - if all the tests fail, it implies that the ""me"" solver might be; # broken, whereas if only one fails, then it implies that only that one is; # broken. We test that all solvers are equivalent by transitive equality; # to the ""me"" solver.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_correlation.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:238,Testability,test,test,238,"# We use the master equation version as a base, but it doesn't actually; # matter - if all the tests fail, it implies that the ""me"" solver might be; # broken, whereas if only one fails, then it implies that only that one is; # broken. We test that all solvers are equivalent by transitive equality; # to the ""me"" solver.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_correlation.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:23,Deployability,integrat,integration,23,"""""""2D trapezium-method integration assuming a square grid.""""""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_correlation.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:23,Integrability,integrat,integration,23,"""""""2D trapezium-method integration assuming a square grid.""""""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_correlation.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:15,Deployability,integrat,integration,15,"""""""; Numerical integration of the correlation function given an array of; expectation values.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_correlation.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:15,Integrability,integrat,integration,15,"""""""; Numerical integration of the correlation function given an array of; expectation values.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_correlation.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:33,Integrability,depend,dependent,33,"""""""; Test correlations with time-dependent operators using a two-level system; (2LS) or a three-level system (3LS).; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_correlation.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:8,Testability,test,test,8,"""""""This test compares the output correlation_2op_1 solution to an analytical; solution.""""""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_correlation.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_floquet.py:7,Testability,test,test,7,"""""""; A test class for the QuTiP functions for Floquet formalism.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_floquet.py:102,Modifiability,coupling,coupling,102,"""""""; Test Floquet-Markov Master Equation for a two-level system; subject to dissipation with multiple coupling operators; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_floquet.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_floquet.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_integrator.py:25,Testability,test,test,25,"# Deactivate warning for test without cython",MatchSource.CODE_COMMENT,qutip/tests/solver/test_integrator.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_integrator.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:20,Testability,test,test,20,"""""""; Mixin class to test the states and expectation values from ``mcsolve``.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:49,Testability,test,tests,49,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:87,Testability,test,test,87,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:172,Testability,test,tested,172,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:216,Testability,test,test,216,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:273,Testability,test,tested,273,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:296,Testability,test,test,296,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:321,Testability,test,testing,321,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:124,Usability,simpl,simplest,124,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:91,Integrability,depend,dependent,91,"""""""; Test that `mcsolve` correctly solves the system when the collapse operators; are time-dependent.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:13,Testability,test,testing,13,"# We're just testing the output value, so it's important whether certain; # things are complex or real, but not what the magnitudes of constants are.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:13,Testability,test,testing,13,"# We're just testing the output value, so it's important whether certain; # things are complex or real, but not what the magnitudes of constants are.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:12,Modifiability,coupling,coupling,12,"# Arbitrary coupling and bath temperature.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py:25,Testability,test,test,25,"# Deactivate warning for test without cython",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py:34,Modifiability,evolve,evolve,34,"# non-hermitean H causes state to evolve non-unitarily",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py:7,Testability,test,test,7,"""""""; A test class for the QuTiP functions for the evolution of JC model; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py:2,Modifiability,evolve,evolve,2,"# evolve and calculate expectation values",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py:2,Modifiability,coupling,coupling,2,"# coupling strength",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py:2,Modifiability,coupling,coupling,2,"# coupling strength",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py:2,Modifiability,coupling,coupling,2,"# coupling strength",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py:2,Modifiability,coupling,coupling,2,"# coupling strength",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py:33,Integrability,depend,dependent,33,"""""""; A Test class for using time-dependent array coefficients; as step functions instead of doing interpolation; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_mesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:13,Testability,test,test,13,"""""""; A rough test that nm_mcsolve agress with mesolve in the; presence of negative rates.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:13,Deployability,integrat,integration,13,"# nm_mcsolve integration",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:13,Integrability,integrat,integration,13,"# nm_mcsolve integration",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:10,Deployability,integrat,integration,10,"# mesolve integration for comparison",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:10,Integrability,integrat,integration,10,"# mesolve integration for comparison",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:2,Testability,test,test,2,"# test using all combinations of the following operators",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:20,Testability,test,test,20,"""""""; Mixin class to test the states and expectation values from nm_mcsolve.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:49,Testability,test,tests,49,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:87,Testability,test,test,87,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:172,Testability,test,tested,172,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:216,Testability,test,test,216,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:273,Testability,test,tested,273,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:296,Testability,test,test,296,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:321,Testability,test,testing,321,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:124,Usability,simpl,simplest,124,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:88,Integrability,depend,dependent,88,"""""""; Test that nm_mcsolve correctly solves the system when the; collapse rates are time-dependent.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:13,Testability,test,testing,13,"# We're just testing the output value, so it's important whether certain; # things are complex or real, but not what the magnitudes of constants are.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:13,Testability,test,testing,13,"# We're just testing the output value, so it's important whether certain; # things are complex or real, but not what the magnitudes of constants are.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:12,Modifiability,coupling,coupling,12,"# Arbitrary coupling and bath temperature.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:20,Deployability,update,updated,20,"""""""Test dynamically updated arguments are usable.""""""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:42,Usability,usab,usable,42,"""""""Test dynamically updated arguments are usable.""""""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_results.py:18,Safety,avoid,avoid,18,"# Fix the seed to avoid failing due to bad luck",MatchSource.CODE_COMMENT,qutip/tests/solver/test_results.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_results.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py:42,Testability,test,testing,42,"""""""; This module includes a collection of testing functions for the QuTiP scattering; module. Tests are approximate with low resolution to minimize runtime.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_scattering.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py:7,Testability,test,test,7,"""""""; A test class for the QuTiP quantum optical scattering module. These tests; only use the two-level system for comparison, since larger systems can; take a long time to run.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_scattering.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py:73,Testability,test,tests,73,"""""""; A test class for the QuTiP quantum optical scattering module. These tests; only use the two-level system for comparison, since larger systems can; take a long time to run.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_scattering.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py:10,Testability,test,test,10,"# Run the test",MatchSource.CODE_COMMENT,qutip/tests/solver/test_scattering.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py:10,Testability,test,test,10,"# Run the test",MatchSource.CODE_COMMENT,qutip/tests/solver/test_scattering.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py:10,Testability,test,test,10,"# Run the test",MatchSource.CODE_COMMENT,qutip/tests/solver/test_scattering.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py:25,Testability,test,test,25,"# Deactivate warning for test without cython",MatchSource.CODE_COMMENT,qutip/tests/solver/test_sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py:13,Deployability,integrat,integrated,13,"""""""; Compare integrated evolution with analytical result; If U0 is not None then operator evo is checked; Otherwise state evo; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py:13,Integrability,integrat,integrated,13,"""""""; Compare integrated evolution with analytical result; If U0 is not None then operator evo is checked; Otherwise state evo; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py:34,Modifiability,evolve,evolve,34,"# non-hermitean H causes state to evolve non-unitarily",MatchSource.CODE_COMMENT,qutip/tests/solver/test_sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py:13,Deployability,integrat,integrated,13,"""""""; Compare integrated evolution with analytical result; If U0 is not None then operator evo is checked; Otherwise state evo; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py:13,Integrability,integrat,integrated,13,"""""""; Compare integrated evolution with analytical result; If U0 is not None then operator evo is checked; Otherwise state evo; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py:13,Deployability,integrat,integrated,13,"""""""; Compare integrated evolution of unitary operator with state evo; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py:13,Integrability,integrat,integrated,13,"""""""; Compare integrated evolution of unitary operator with state evo; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_sesolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sode_method.py:12,Availability,error,error,12,"# The first error term of the method is dt**0.5 greater than the solver; # order.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_sode_method.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sode_method.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_steadystate.py:7,Testability,test,tests,7,"# this tests that simple methods correctly determine the steadystate; # with high accuracy for a small Liouvillian requiring correct weighting.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_steadystate.py:18,Usability,simpl,simple,18,"# this tests that simple methods correctly determine the steadystate; # with high accuracy for a small Liouvillian requiring correct weighting.",MatchSource.CODE_COMMENT,qutip/tests/solver/test_steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_steadystate.py:13,Energy Efficiency,reduce,reduce,13,"# rcm should reduce bandwidth",MatchSource.CODE_COMMENT,qutip/tests/solver/test_steadystate.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_steadystate.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_stochastic_system.py:20,Availability,error,error,20,"""""""; Check that the error is proportional to `dt`.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/test_stochastic_system.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_stochastic_system.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_transfertensor.py:60,Usability,learn,learning,60,"# check that ttm result and exact solution are close in the learning times",MatchSource.CODE_COMMENT,qutip/tests/solver/test_transfertensor.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_transfertensor.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/cy/test_nm_mcsolve.py:51,Testability,test,test,51,""""""" A list of coefficients and a tlist of times to test at. """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/cy/test_nm_mcsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/cy/test_nm_mcsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_baths.py:59,Availability,toler,tolerance,59,""""""" Return true if Q1 and Q2 are equal to within the given tolerance. """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_baths.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_baths.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:69,Integrability,depend,dependent,69,""""""" Assert that calling .steady_state() on a HEOMSolver with; a time-dependent Hamiltonian raises the appropriate exception.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:52,Testability,test,testing,52,""""""" Analytic Drude-Lorentz pure-dephasing model for testing the HEOM; solver.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:48,Safety,avoid,avoid,48,"# we add a very weak system hamiltonian here to avoid having; # singular system that causes problems for the scipy.sparse.linalg; # superLU solver used in spsolve.",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:48,Deployability,integrat,integration,48,"# Calculate the analytical results by numerical integration",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:48,Integrability,integrat,integration,48,"# Calculate the analytical results by numerical integration",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:52,Testability,test,testing,52,""""""" Analytic Drude-Lorentz pure-dephasing model for testing the HEOM; solver.; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:48,Safety,avoid,avoid,48,"# we add a very weak system hamiltonian here to avoid having; # singular system that causes problems for the scipy.sparse.linalg; # superLU solver used in spsolve.",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:46,Testability,test,testing,46,""""""" Analytic discrete level current model for testing the HEOM solver; with a fermionic bath (and optionally a bosonic mode).; """"""",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:2,Energy Efficiency,energy,energy,2,"# energy; # parameters for the fermionic leads",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:28,Modifiability,coupling,coupling,28,"# Construct Hamiltonian and coupling operator",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:20,Modifiability,coupling,coupling,20,"# very weak bosonic coupling which should not affect the dynamics of; # the interaction between the system and the fermionic bath:",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:111,Testability,test,test,111,"# for a single impurity we converge with max_depth = 2; # we specify the bosonic bath first to ensure that the test checks; # that the sums inside HEOMSolver grad-next/prev work when the bosonic; # mode is before the fermionic ones",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:163,Testability,test,test,163,"# First we construct a solver with the boson modelled as part of the; # system and only a single Fermionic bath. This will provide the; # reference result for the test:",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:55,Testability,test,test,55,"# This is an exact copy of the pre-4.7 QuTiP HSolverDL test and; # is repeated here to ensure the new HSolverDL remains compatibile; # with the old one until it is removed.",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:48,Deployability,integrat,integration,48,"# Calculate the analytical results by numerical integration",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:48,Integrability,integrat,integration,48,"# Calculate the analytical results by numerical integration",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_bofin_solvers.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_heom.py:7,Testability,assert,assert,7,"# just assert that the baths are importable",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_heom.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_heom.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_heom.py:7,Testability,assert,assert,7,"# just assert that the solvers and associated classes are importable",MatchSource.CODE_COMMENT,qutip/tests/solver/heom/test_heom.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_heom.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:166,Deployability,update,update,166,"""""""; An abstract progress bar with some shared functionality. Example usage:. n_vec = linspace(0, 10, 100); pbar = TextProgressBar(len(n_vec)); for n in n_vec:; pbar.update(); compute_with_n(n); pbar.finished(). """"""",MatchSource.CODE_COMMENT,qutip/ui/progressbar.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:17,Usability,progress bar,progress bar,17,"""""""; An abstract progress bar with some shared functionality. Example usage:. n_vec = linspace(0, 10, 100); pbar = TextProgressBar(len(n_vec)); for n in n_vec:; pbar.update(); compute_with_n(n); pbar.finished(). """"""",MatchSource.CODE_COMMENT,qutip/ui/progressbar.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:7,Usability,simpl,simple,7,"""""""; A simple text-based progress bar.; """"""",MatchSource.CODE_COMMENT,qutip/ui/progressbar.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:25,Usability,progress bar,progress bar,25,"""""""; A simple text-based progress bar.; """"""",MatchSource.CODE_COMMENT,qutip/ui/progressbar.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:8,Modifiability,enhance,enhanced,8,"""""""; An enhanced text-based progress bar.; """"""",MatchSource.CODE_COMMENT,qutip/ui/progressbar.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:28,Usability,progress bar,progress bar,28,"""""""; An enhanced text-based progress bar.; """"""",MatchSource.CODE_COMMENT,qutip/ui/progressbar.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:7,Usability,progress bar,progress bar,7,"""""""; A progress bar using tqdm module; """"""",MatchSource.CODE_COMMENT,qutip/ui/progressbar.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:281,Deployability,update,update,281,"""""""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(); compute_with_n(n); """"""",MatchSource.CODE_COMMENT,qutip/ui/progressbar.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:7,Usability,simpl,simple,7,"""""""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(); compute_with_n(n); """"""",MatchSource.CODE_COMMENT,qutip/ui/progressbar.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:19,Usability,progress bar,progress bar,19,"""""""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(); compute_with_n(n); """"""",MatchSource.CODE_COMMENT,qutip/ui/progressbar.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/_mkl/spsolve.py:6,Availability,error,error,6,"# Set error messages",MatchSource.CODE_COMMENT,qutip/_mkl/spsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/_mkl/spsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/_mkl/spsolve.py:12,Integrability,message,messages,12,"# Set error messages",MatchSource.CODE_COMMENT,qutip/_mkl/spsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/_mkl/spsolve.py
https://github.com/qutip/qutip/tree/v5.0.4/qutip/_mkl/spsolve.py:347,Energy Efficiency,allocate,allocated,347,"""""""; Object pointing to LU factorization of a sparse matrix; generated by mkl_splu. Methods; -------; solve(b, verbose=False); Solve system of equations using given RHS vector 'b'.; Returns solution ndarray with same shape as input. info(); Returns the statistics of the factorization and; solution in the lu.info attribute. delete(); Deletes the allocated solver memory. """"""",MatchSource.CODE_COMMENT,qutip/_mkl/spsolve.py,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/_mkl/spsolve.py
