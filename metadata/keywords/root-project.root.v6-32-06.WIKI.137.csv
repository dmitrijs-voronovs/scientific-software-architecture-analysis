id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/v632/classTMemFile.html:20721,Security,hash,hash,20721," std::enable_if_t< std::is_base_of< TObject, T >::value, Int_t > WriteObject (const T *obj, const char *name, Option_t *option="""", Int_t bufsize=0);  Write an object with proper type checking. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you ",MatchSource.WIKI,doc/v632/classTMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTMemFile.html
https://root.cern/doc/v632/classTMemFile.html:42932,Security,hash,hashes,42932,"bjects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . Additional Inherited Members;  Static Protected Member Functions inherited from TDirectory; static Bool_t Cd1 (const char *path);  Change current directory to ""path"". ;  ; static SharedGDirectory_t & GetSharedLocalCurrentDirectory ();  Return the (address of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  . #include <TMemFile.h>. Inheritance diagram for TMemFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ ExternalDataPtr_t. using TMemFile::ExternalDataPtr_t = std::shared_ptr<const std::vector<char> >. Definition at line 21 of file TMemFile.h. Member Enumeration Documentation. ◆ EMode. enum class TMemFile::EMode. strongprotected . EnumeratorkCreate ;",MatchSource.WIKI,doc/v632/classTMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTMemFile.html
https://root.cern/doc/v632/classTMemFile.html:7373,Testability,log,logical,7373,"es to prefetch. ;  ; virtual Long64_t GetBytesWritten () const;  Return the total number of bytes written so far to the file. ;  ; TFileCacheRead * GetCacheRead (const TObject *tree=nullptr) const;  Return a pointer to the current read cache. ;  ; TFileCacheWrite * GetCacheWrite () const;  Return a pointer to the current write cache. ;  ; TArrayC * GetClassIndex () const;  ; Int_t GetCompressionAlgorithm () const;  ; Float_t GetCompressionFactor ();  Return the file compression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual const TUrl * GetEndpointUrl () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual TString GetNewUrl ();  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header starting at a certain postion. ;  ; Long64_t GetRelOffset () const;  ; virtual Long64_t GetSeekFree () const;  ; virtual Long64_t GetSeekInfo () const;  ; const TList * GetStreamerInfoCache ();  Returns the cached list of StreamerInfos used in this file. ;  ; virtual TList * GetStreamerInfoList () final;  Read the list of TStreamerInfo objects written to this file. ;  ; Int_t GetVersion () const;  ; virtual void IncrementProcessIDs ();  ; virtual Bool_t IsArchive () const;  ; Bool_t IsBinary () const;  ; virtual Bool_t IsOpen () const;  Returns kTRUE in case file is open and kFALSE if file is not open. ;  ; Bool_t IsRaw () const;  ; void ls (Option_t *option="""") const override;  List file contents. ;  ; virtual void MakeFree (Long64_t first",MatchSource.WIKI,doc/v632/classTMemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTMemFile.html
https://root.cern/doc/v632/classTNamed.html:3832,Availability,error,error,3832,"ject. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:3921,Availability,error,error,3921,"ecord whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual ",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:4076,Availability,error,error,4076,"Name () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute ",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:4373,Availability,error,error,4373,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info ",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:8457,Availability,error,error,8457,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:19597,Availability,error,error,19597,"a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TNamed::HashULong_t Hash() const overrideReturn hash value for this object.Definition TNamed.h:49; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 49 of file TNamed.h. ◆ IsA(). TClass * TNamed::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TXNetFile, TXNetSystem, ROOT::Experimental::XRooFit::xRooHypoSpace, TMVA::TSpline1, TMVA::TSpline2, TMVA::VariableImportance, TMVA::VariableInfo, TRadialGradient, TProcessID, TProcessUUID, TQClass, TRemoteObject, TROOT, TStyle, TSystem, TSystemDirectory, TSystemFile, TTask, TVirtualMonitoringWriter, TVirtualMonitoringReader, TVirtualPS, TVirtualX, TToggle, TToggleGroup, TProtoClass, ROOT::TSchemaRule::TSources, TStreamerElement, TStreamerBase, TStreamerBasicPointer, TStreamerLoop, TStreamerBasicType, TStreamerObject, TStreamerObjectAny, TStreamerObjectPointer, TStreamerObjectAn",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:3838,Integrability,message,message,3838,"ject. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:4379,Integrability,message,message,4379,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info ",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:5369,Integrability,message,message,5369,"ssue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class shou",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:8463,Integrability,message,message,8463,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:8836,Integrability,message,message,8836," Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Prote",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:18572,Integrability,rout,routine,18572,"eySQL, TSQLFile, TKeyXML, TXMLFile, TDirectoryFile, TFile, and TKey.; Definition at line 104 of file TNamed.cxx. ◆ GetName(). const char * TNamed::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Reimplemented in TPackMgr.; Definition at line 47 of file TNamed.h. ◆ GetTitle(). const char * TNamed::GetTitle ; (; ); const. inlineoverridevirtual . Returns title of object. ; This default method returns the class title (i.e. description). Classes that give objects a title should override this method. ; Reimplemented from TObject.; Reimplemented in TPackMgr.; Definition at line 48 of file TNamed.h. ◆ Hash(). ULong_t TNamed::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TNamed::HashULong_t Hash() const overrideReturn hash value for this object.Definition TNamed.h:49; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TROOT::RecursiveRemovevoid RecursiveRemove(TObject ",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:19603,Integrability,message,message,19603,"a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TNamed::HashULong_t Hash() const overrideReturn hash value for this object.Definition TNamed.h:49; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 49 of file TNamed.h. ◆ IsA(). TClass * TNamed::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TXNetFile, TXNetSystem, ROOT::Experimental::XRooFit::xRooHypoSpace, TMVA::TSpline1, TMVA::TSpline2, TMVA::VariableImportance, TMVA::VariableInfo, TRadialGradient, TProcessID, TProcessUUID, TQClass, TRemoteObject, TROOT, TStyle, TSystem, TSystemDirectory, TSystemFile, TTask, TVirtualMonitoringWriter, TVirtualMonitoringReader, TVirtualPS, TVirtualX, TToggle, TToggleGroup, TProtoClass, ROOT::TSchemaRule::TSources, TStreamerElement, TStreamerBase, TStreamerBasicPointer, TStreamerLoop, TStreamerBasicType, TStreamerObject, TStreamerObjectAny, TStreamerObjectPointer, TStreamerObjectAn",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:2375,Modifiability,inherit,inherited,2375,"ide;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:3468,Modifiability,inherit,inheritance,3468,"  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in de",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:5467,Modifiability,inherit,inherits,5467,"e) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:5584,Modifiability,inherit,inherits,5584,"t be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ;  ; virtual Bool_t Notify ();  This method must be overridden to handle object notification (the base ",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:9337,Modifiability,inherit,inherited,9337,"reamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanu",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:9926,Modifiability,inherit,inherited,9926," Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TNamed.h>; Inherits TObject.; Inherited by TProofVectorContainer< TProofDrawListOfGraphs::Point3D_t >, TProofVectorContainer< TPro",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:10567,Modifiability,inherit,inherited,10567,"id *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TNamed.h>; Inherits TObject.; Inherited by TProofVectorContainer< TProofDrawListOfGraphs::Point3D_t >, TProofVectorContainer< TProofDrawListOfPolyMarkers3D::Point4D_t >, MonitoredTFileSummary, ROOT::Experimental::REveGeoShapeExtract, ROOT::Experimental::XRooFit::xRooFit::StoredFitResult, ROOT::Experimental::XRooFit::xRooNLLVar::xRooHypoPoint, ROOT::Experimental::XRooFit::xRooNLLVar::xRooHypoSpace, ROOT::Experimental::XRooFit::xRooNode, ROOT::Internal::TBranchDescriptor, ROOT::Internal::TBranchProxyClassDescriptor, ROOT::Internal::TBranchProxyDescriptor, ROOT::Internal::TFriendProxyDescriptor, ROOT::Internal::THnBaseBrowsable, ROOT::TSchemaRule::TSources, ROOT::v5::TFormula, ROOT::v5::TFormulaPrimitive, RooAbsArg, RooAbsBinning, RooAbsData, RooAbsDataStore, RooAbsGenContext, RooAbsMCStudyModule, RooAbsStudy, RooA",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:10666,Modifiability,inherit,inherited,10666,"id *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TNamed.h>; Inherits TObject.; Inherited by TProofVectorContainer< TProofDrawListOfGraphs::Point3D_t >, TProofVectorContainer< TProofDrawListOfPolyMarkers3D::Point4D_t >, MonitoredTFileSummary, ROOT::Experimental::REveGeoShapeExtract, ROOT::Experimental::XRooFit::xRooFit::StoredFitResult, ROOT::Experimental::XRooFit::xRooNLLVar::xRooHypoPoint, ROOT::Experimental::XRooFit::xRooNLLVar::xRooHypoSpace, ROOT::Experimental::XRooFit::xRooNode, ROOT::Internal::TBranchDescriptor, ROOT::Internal::TBranchProxyClassDescriptor, ROOT::Internal::TBranchProxyDescriptor, ROOT::Internal::TFriendProxyDescriptor, ROOT::Internal::THnBaseBrowsable, ROOT::TSchemaRule::TSources, ROOT::v5::TFormula, ROOT::v5::TFormulaPrimitive, RooAbsArg, RooAbsBinning, RooAbsData, RooAbsDataStore, RooAbsGenContext, RooAbsMCStudyModule, RooAbsStudy, RooA",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:1503,Security,hash,hash,1503,"ost member functions defined in this base class are in general overridden by the derived classes. ; Definition at line 29 of file TNamed.h. Public Member Functions;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:18528,Security,hash,hash,18528,"ne 58 of file TNamed.h. ◆ FillBuffer(). void TNamed::FillBuffer ; (; char *& ; buffer). virtual . Encode TNamed into output buffer. ; Reimplemented in TKeySQL, TSQLFile, TKeyXML, TXMLFile, TDirectoryFile, TFile, and TKey.; Definition at line 104 of file TNamed.cxx. ◆ GetName(). const char * TNamed::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Reimplemented in TPackMgr.; Definition at line 47 of file TNamed.h. ◆ GetTitle(). const char * TNamed::GetTitle ; (; ); const. inlineoverridevirtual . Returns title of object. ; This default method returns the class title (i.e. description). Classes that give objects a title should override this method. ; Reimplemented from TObject.; Reimplemented in TPackMgr.; Definition at line 48 of file TNamed.h. ◆ Hash(). ULong_t TNamed::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TNamed::HashULong_t Hash() const overrideReturn hash value for this object.Definition TNamed.h:49; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Er",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:19399,Security,hash,hash,19399,"plemented in TPackMgr.; Definition at line 48 of file TNamed.h. ◆ Hash(). ULong_t TNamed::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TNamed::HashULong_t Hash() const overrideReturn hash value for this object.Definition TNamed.h:49; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 49 of file TNamed.h. ◆ IsA(). TClass * TNamed::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TXNetFile, TXNetSystem, ROOT::Experimental::XRooFit::xRooHypoSpace, TMVA::TSpline1, TMVA::TSpline2, TMVA::VariableImportance, TMVA::VariableInfo, TRadialGradient, TProcessID, TProcessUUID, TQClass, TRemoteObject, TROOT, TStyle, TSystem, TSystemDirectory, TSystemFile, TTask, TVirtualMonitoringWriter, TVirtualMonitoringReader, TVirtualPS, TVirtualX, TToggle, TToggleGroup, T",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTNamed.html:19103,Testability,log,logarithmic,19103,"ide this method. ; Reimplemented from TObject.; Reimplemented in TPackMgr.; Definition at line 47 of file TNamed.h. ◆ GetTitle(). const char * TNamed::GetTitle ; (; ); const. inlineoverridevirtual . Returns title of object. ; This default method returns the class title (i.e. description). Classes that give objects a title should override this method. ; Reimplemented from TObject.; Reimplemented in TPackMgr.; Definition at line 48 of file TNamed.h. ◆ Hash(). ULong_t TNamed::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TNamed::HashULong_t Hash() const overrideReturn hash value for this object.Definition TNamed.h:49; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 49 of file TNamed.h. ◆ IsA(). TClass * TNamed::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Rei",MatchSource.WIKI,doc/v632/classTNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTNamed.html
https://root.cern/doc/v632/classTObject.html:606,Availability,error,error,606,". ROOT: TObject Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Types |; Protected Member Functions |; Static Private Member Functions |; Private Attributes |; Static Private Attributes |; Friends |; List of all members ; TObject Class ReferenceCore ROOT classes » Base ROOT classes. ; Mother of all ROOT objects. ; The TObject class provides default behaviour and protocol for all objects in the ROOT system. It provides protocol for object I/O, error handling, sorting, inspection, printing, drawing, etc. Every object which inherits from TObject can be stored in the ROOT collection classes.; TObject's bits can be used as flags, bits 0 - 13 and 24-31 are reserved as global bits while bits 14 - 23 can be used in different class hierarchies (watch out for overlaps). ; Definition at line 41 of file TObject.h. Public Types; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; vi",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:3349,Availability,error,error,3349,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:3438,Availability,error,error,3438,"ar *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns strin",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:3593,Availability,error,error,3593,";  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title o",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:3890,Availability,error,error,3890,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:8564,Availability,error,error,8564,"ead (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static voi",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:33270,Availability,error,error,33270,"X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style; X#define X(type, name); angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; styleOption_t Option_t styleDefinition TGWin32VirtualXProxy.cxx:46; TObject::fUniqueIDUInt_t fUniqueIDobject unique identifierDefinition TObject.h:44; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; lineTLine * lineDefinition entrylistblock_figure1.C:235. Reimplemented in TSystemFile, TCollection, TClass, TGFrame, and TGPack.; Definition at line 348 of file TObject.cxx. ◆ Error(). void TObject::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue error message. ; Use ""location"" to specify the method where the error occurred. Accepts standard printf formatting arguments. ; Reimplemented in TFitResult.; Definition at line 987 of file TObject.cxx. ◆ Execute() [1/2]. void TObject::Execute ; (; const char * ; method, . const char * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with the given parameter string, e.g. ; ""3.14,1,\""text\"""". ; Reimplemented in TMethodCall, TCling, TInterpreter, ROOT::R::TRInterface, and TContextMenu.; Definition at line 359 of file TObject.cxx. ◆ Execute() [2/2]. void TObject::Execute ; (; TMethod * ; method, . TObjArray * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with parameters stored in the TObjArray. ; The TObjArray should contain an argv vector like: argv[0] ... argv[n] = the list of TObjString parameters; TObjStringCollectable string class.Definition TObjString.h:28; nconst Int_t nDefinition legend1.C:16. Reimplemented in TClin",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:33334,Availability,error,error,33334,"2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style; X#define X(type, name); angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; styleOption_t Option_t styleDefinition TGWin32VirtualXProxy.cxx:46; TObject::fUniqueIDUInt_t fUniqueIDobject unique identifierDefinition TObject.h:44; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; lineTLine * lineDefinition entrylistblock_figure1.C:235. Reimplemented in TSystemFile, TCollection, TClass, TGFrame, and TGPack.; Definition at line 348 of file TObject.cxx. ◆ Error(). void TObject::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue error message. ; Use ""location"" to specify the method where the error occurred. Accepts standard printf formatting arguments. ; Reimplemented in TFitResult.; Definition at line 987 of file TObject.cxx. ◆ Execute() [1/2]. void TObject::Execute ; (; const char * ; method, . const char * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with the given parameter string, e.g. ; ""3.14,1,\""text\"""". ; Reimplemented in TMethodCall, TCling, TInterpreter, ROOT::R::TRInterface, and TContextMenu.; Definition at line 359 of file TObject.cxx. ◆ Execute() [2/2]. void TObject::Execute ; (; TMethod * ; method, . TObjArray * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with parameters stored in the TObjArray. ; The TObjArray should contain an argv vector like: argv[0] ... argv[n] = the list of TObjString parameters; TObjStringCollectable string class.Definition TObjString.h:28; nconst Int_t nDefinition legend1.C:16. Reimplemented in TCling, TMethodCall, TInterpreter, ROOT::R::TRIn",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:33578,Availability,error,error,33578,"define X(type, name); angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; styleOption_t Option_t styleDefinition TGWin32VirtualXProxy.cxx:46; TObject::fUniqueIDUInt_t fUniqueIDobject unique identifierDefinition TObject.h:44; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; lineTLine * lineDefinition entrylistblock_figure1.C:235. Reimplemented in TSystemFile, TCollection, TClass, TGFrame, and TGPack.; Definition at line 348 of file TObject.cxx. ◆ Error(). void TObject::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue error message. ; Use ""location"" to specify the method where the error occurred. Accepts standard printf formatting arguments. ; Reimplemented in TFitResult.; Definition at line 987 of file TObject.cxx. ◆ Execute() [1/2]. void TObject::Execute ; (; const char * ; method, . const char * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with the given parameter string, e.g. ; ""3.14,1,\""text\"""". ; Reimplemented in TMethodCall, TCling, TInterpreter, ROOT::R::TRInterface, and TContextMenu.; Definition at line 359 of file TObject.cxx. ◆ Execute() [2/2]. void TObject::Execute ; (; TMethod * ; method, . TObjArray * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with parameters stored in the TObjArray. ; The TObjArray should contain an argv vector like: argv[0] ... argv[n] = the list of TObjString parameters; TObjStringCollectable string class.Definition TObjString.h:28; nconst Int_t nDefinition legend1.C:16. Reimplemented in TCling, TMethodCall, TInterpreter, ROOT::R::TRInterface, and TContextMenu.; Definition at line 377 of file TObject.cxx. ◆ ExecuteEvent(). void TObject::ExecuteEvent ; (; Int_t ; event, . Int_t ; px, . Int_t ; py . ). virtual . Execute action corresponding to an event at (px,py). ; This method must be overridden",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:33939,Availability,error,error,33939,"atus wordDefinition TObject.h:45; lineTLine * lineDefinition entrylistblock_figure1.C:235. Reimplemented in TSystemFile, TCollection, TClass, TGFrame, and TGPack.; Definition at line 348 of file TObject.cxx. ◆ Error(). void TObject::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue error message. ; Use ""location"" to specify the method where the error occurred. Accepts standard printf formatting arguments. ; Reimplemented in TFitResult.; Definition at line 987 of file TObject.cxx. ◆ Execute() [1/2]. void TObject::Execute ; (; const char * ; method, . const char * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with the given parameter string, e.g. ; ""3.14,1,\""text\"""". ; Reimplemented in TMethodCall, TCling, TInterpreter, ROOT::R::TRInterface, and TContextMenu.; Definition at line 359 of file TObject.cxx. ◆ Execute() [2/2]. void TObject::Execute ; (; TMethod * ; method, . TObjArray * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with parameters stored in the TObjArray. ; The TObjArray should contain an argv vector like: argv[0] ... argv[n] = the list of TObjString parameters; TObjStringCollectable string class.Definition TObjString.h:28; nconst Int_t nDefinition legend1.C:16. Reimplemented in TCling, TMethodCall, TInterpreter, ROOT::R::TRInterface, and TContextMenu.; Definition at line 377 of file TObject.cxx. ◆ ExecuteEvent(). void TObject::ExecuteEvent ; (; Int_t ; event, . Int_t ; px, . Int_t ; py . ). virtual . Execute action corresponding to an event at (px,py). ; This method must be overridden if an object can react to graphics events. ; Reimplemented in TParallelCoord, TParallelCoordRange, TParallelCoordVar, TGeoManager, TGeoNode, TGeoShape, TGeoVolume, TGeoOverlap, TGeoTrack, TASImage, TASPaletteEditor::LimitLine, TButton, TCanvas, TGroupButton, TPad, TSliderBox, TBox, TCrown, TCurlyArc, TCurlyLine, TDiamond, TEllipse, TFrame, TGraphPolargram, T",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:35599,Availability,error,error,35599,"react to graphics events. ; Reimplemented in TParallelCoord, TParallelCoordRange, TParallelCoordVar, TGeoManager, TGeoNode, TGeoShape, TGeoVolume, TGeoOverlap, TGeoTrack, TASImage, TASPaletteEditor::LimitLine, TButton, TCanvas, TGroupButton, TPad, TSliderBox, TBox, TCrown, TCurlyArc, TCurlyLine, TDiamond, TEllipse, TFrame, TGraphPolargram, TLine, TLink, TMarker, TPave, TPolyLine, TText, TWbox, TGraphEdge, TGraphNode, TAxis3D, TMarker3DBox, TNode, TPolyLine3D, TPolyMarker3D, TView3D, TGL5DDataSet, TGLEventHandler, TGLHistPainter, TGLParametricEquation, TGLTH3Composition, TGLViewer, TAxis, TEfficiency, TF1, TF2, TF3, TGraph, TGraph2D, TH1, TPolyMarker, TScatter, TSpline, THistPainter, TPaletteAxis, TGenerator, TParticle, TPrimary, TFileDrawMap, TTreePerfStats, TSpider, TView, TVirtualHistPainter, TPie, and TGLScenePad.; Definition at line 393 of file TObject.cxx. ◆ Fatal(). void TObject::Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue fatal error message. ; Use ""location"" to specify the method where the fatal error occurred. Accepts standard printf formatting arguments. ; Definition at line 1015 of file TObject.cxx. ◆ FindObject() [1/2]. TObject * TObject::FindObject ; (; const char * ; name); const. virtual . Must be redefined in derived classes. ; This function is typically used with TCollections, but can also be used to find an object by name inside this object. ; Reimplemented in TListOfEnums, TMap, TDirectory, TFolder, TROOT, TListOfTypes, TListOfTypes, TBtree, TCollection, THashList, THashTable, TList, TObjArray, TListOfDataMembers, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, TListOfFunctionTemplates, TViewPubDataMembers, TViewPubFunctions, TPad, TGeometry, THbookFile, TGraph, TGraph2D, TH1, RooAbsCollection, and RooLinkedList.; Definition at line 403 of file TObject.cxx. ◆ FindObject() [2/2]. TObject * TObject::FindObject ; (; const TObject * ; obj); const. vir",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:35669,Availability,error,error,35669,"allelCoord, TParallelCoordRange, TParallelCoordVar, TGeoManager, TGeoNode, TGeoShape, TGeoVolume, TGeoOverlap, TGeoTrack, TASImage, TASPaletteEditor::LimitLine, TButton, TCanvas, TGroupButton, TPad, TSliderBox, TBox, TCrown, TCurlyArc, TCurlyLine, TDiamond, TEllipse, TFrame, TGraphPolargram, TLine, TLink, TMarker, TPave, TPolyLine, TText, TWbox, TGraphEdge, TGraphNode, TAxis3D, TMarker3DBox, TNode, TPolyLine3D, TPolyMarker3D, TView3D, TGL5DDataSet, TGLEventHandler, TGLHistPainter, TGLParametricEquation, TGLTH3Composition, TGLViewer, TAxis, TEfficiency, TF1, TF2, TF3, TGraph, TGraph2D, TH1, TPolyMarker, TScatter, TSpline, THistPainter, TPaletteAxis, TGenerator, TParticle, TPrimary, TFileDrawMap, TTreePerfStats, TSpider, TView, TVirtualHistPainter, TPie, and TGLScenePad.; Definition at line 393 of file TObject.cxx. ◆ Fatal(). void TObject::Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue fatal error message. ; Use ""location"" to specify the method where the fatal error occurred. Accepts standard printf formatting arguments. ; Definition at line 1015 of file TObject.cxx. ◆ FindObject() [1/2]. TObject * TObject::FindObject ; (; const char * ; name); const. virtual . Must be redefined in derived classes. ; This function is typically used with TCollections, but can also be used to find an object by name inside this object. ; Reimplemented in TListOfEnums, TMap, TDirectory, TFolder, TROOT, TListOfTypes, TListOfTypes, TBtree, TCollection, THashList, THashTable, TList, TObjArray, TListOfDataMembers, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, TListOfFunctionTemplates, TViewPubDataMembers, TViewPubFunctions, TPad, TGeometry, THbookFile, TGraph, TGraph2D, TH1, RooAbsCollection, and RooLinkedList.; Definition at line 403 of file TObject.cxx. ◆ FindObject() [2/2]. TObject * TObject::FindObject ; (; const TObject * ; obj); const. virtual . Must be redefined in derived classes. ; Th",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:43167,Availability,error,error,43167,"(; ); const. virtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:515; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented in TEnvRec, TNamed, TObjString, TParameter< AParamType >, TParameter< Long64_t >, TCollection, TPair, TASImagePlugin, TASPluginGS, TPad, TImagePlugin, TPave, TGObject, TGPicture, TIconBoxThumb, TClassDocInfo, THtml::TFileSysEntry, TStatistic, TDrawFeedback, TStatsFeedback, and RooLinkedList.; Definition at line 515 of file TObject.cxx. ◆ HasInconsistentHash(). Bool_t TObject::HasInconsistentHash ; (; ); const. inline . Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ; missing call to RecursiveRemove in destructor).; Note: Since the consistency is only tested for during inserts, this routine will return true for object th",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:86613,Availability,avail,available,86613," TObject::ResetBit ; (; UInt_t ; f). inline . Definition at line 198 of file TObject.h. ◆ SaveAs(). void TObject::SaveAs ; (; const char * ; filename = """", . Option_t * ; option = """" . ); const. virtual . Save this object in the file specified by filename. . if ""filename"" contains "".root"" the object is saved in filename as root binary file.; if ""filename"" contains "".xml"" the object is saved in filename as a xml ascii file.; if ""filename"" contains "".cc"" the object is saved in filename as C code independant from ROOT. The code is generated via SavePrimitive(). Specific code should be implemented in each object to handle this option. Like in TF1::SavePrimitive().; otherwise the object is written to filename as a CINT/C++ script. The C++ code to rebuild this object is generated via SavePrimitive(). The ""option"" parameter is passed to SavePrimitive. By default it is an empty string. It can be used to specify the Draw option in the code generated by SavePrimitive.; The function is available via the object context menu. . Reimplemented in TSpline, TFolder, TGeoVolume, TClassTree, TPad, TPaveClass, TGObject, TSpline3, TSpline5, ROOT::Experimental::XRooFit::xRooNode, TTreePerfStats, TVirtualPad, TGraph, and TH1.; Definition at line 686 of file TObject.cxx. ◆ SavePrimitive(). void TObject::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). virtual . Save a primitive as a C++ statement(s) on output stream ""out"". ; Reimplemented in TGeoTessellated, TGraphEdge, TGraphNode, TGeoIdentity, TStyle, TCurlyArc, TCurlyLine, TGedMarkerSelect, TGedPatternSelect, TGColorSelect, TGFont, TGVerticalLayout, TGHorizontalLayout, TGRowLayout, TGColumnLayout, TGMatrixLayout, TGTileLayout, TGListLayout, TGListDetailsLayout, TGTextLBEntry, TGNumberEntryField, TGNumberEntry, TGTableLayoutHints, TGTableLayout, TGTextEdit, TGTextView, TGXYLayoutHints, TGXYLayout, TRootContainer, TGHtml, TEfficiency, TExec, TMacro, TGeoArb8, TGeoTrap, TGeoGtra, TGeoBBox, TGeoBoolNode, TGeoUnion, T",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:116076,Availability,error,error,116076,"lar, TTree, TTreeCache, TTreeCacheUnzip, TTreeSQL, TVirtualIndex, TVirtualTreePlayer, ROOT::Experimental::TTreeReaderFast, ROOT::Internal::TBranchProxyClassDescriptor, ROOT::Internal::TBranchProxyDescriptor, TChainIndex, TFileDrawMap, ROOT::Internal::TFriendProxyDescriptor, TSelectorDraw, TSelectorEntries, TTreeDrawArgsParser, TTreeFormula, TTreeFormulaManager, TTreeIndex, TTreePerfStats, TTreePlayer, TTreeReader, TParallelCoord, TParallelCoordRange, TParallelCoordSelect, TParallelCoordVar, TSpider, TTreeViewer, TTVRecord, TTVSession, iterplugin, h1analysis, h1analysisTreeReader, PyROOT::RegulatorCleanup, and ROOT::Internal::TCheckHashRecursiveRemoveConsistency.; Definition at line 888 of file TObject.cxx. ◆ StreamerNVirtual(). void TObject::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 243 of file TObject.h. ◆ SysError(). void TObject::SysError ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue system error message. ; Use ""location"" to specify the method where the system error occurred. Accepts standard printf formatting arguments. ; Definition at line 1001 of file TObject.cxx. ◆ TestBit(). R__ALWAYS_INLINE Bool_t TObject::TestBit ; (; UInt_t ; f); const. inline . Definition at line 199 of file TObject.h. ◆ TestBits(). Int_t TObject::TestBits ; (; UInt_t ; f); const. inline . Definition at line 200 of file TObject.h. ◆ UseCurrentStyle(). void TObject::UseCurrentStyle ; (; ). virtual . Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ; Reimplemented in TCanvas, TPad, TFrame, TPaveStats, TPaveText, TAxis3D, TGraph, TH1, and TTree.; Definition at line 801 of file TObject.cxx. ◆ Warning(). void TObject::Warning ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue warning message. ; Use ""location"" to specify the method where the warning occurred. Accepts stand",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:116147,Availability,error,error,116147," TVirtualIndex, TVirtualTreePlayer, ROOT::Experimental::TTreeReaderFast, ROOT::Internal::TBranchProxyClassDescriptor, ROOT::Internal::TBranchProxyDescriptor, TChainIndex, TFileDrawMap, ROOT::Internal::TFriendProxyDescriptor, TSelectorDraw, TSelectorEntries, TTreeDrawArgsParser, TTreeFormula, TTreeFormulaManager, TTreeIndex, TTreePerfStats, TTreePlayer, TTreeReader, TParallelCoord, TParallelCoordRange, TParallelCoordSelect, TParallelCoordVar, TSpider, TTreeViewer, TTVRecord, TTVSession, iterplugin, h1analysis, h1analysisTreeReader, PyROOT::RegulatorCleanup, and ROOT::Internal::TCheckHashRecursiveRemoveConsistency.; Definition at line 888 of file TObject.cxx. ◆ StreamerNVirtual(). void TObject::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 243 of file TObject.h. ◆ SysError(). void TObject::SysError ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue system error message. ; Use ""location"" to specify the method where the system error occurred. Accepts standard printf formatting arguments. ; Definition at line 1001 of file TObject.cxx. ◆ TestBit(). R__ALWAYS_INLINE Bool_t TObject::TestBit ; (; UInt_t ; f); const. inline . Definition at line 199 of file TObject.h. ◆ TestBits(). Int_t TObject::TestBits ; (; UInt_t ; f); const. inline . Definition at line 200 of file TObject.h. ◆ UseCurrentStyle(). void TObject::UseCurrentStyle ; (; ). virtual . Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ; Reimplemented in TCanvas, TPad, TFrame, TPaveStats, TPaveText, TAxis3D, TGraph, TH1, and TTree.; Definition at line 801 of file TObject.cxx. ◆ Warning(). void TObject::Warning ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue warning message. ; Use ""location"" to specify the method where the warning occurred. Accepts standard printf formatting arguments. ; Definition at l",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:18980,Energy Efficiency,allocate,allocated,18980,"ion (See TClass and TTree::Merge) . Definition at line 97 of file TObject.h. ◆ EDeprecatedStatusBits. enum TObject::EDeprecatedStatusBits. EnumeratorkObjInCanvas for backward compatibility only, use kMustCleanup . Definition at line 75 of file TObject.h. ◆ EStatusBits. enum TObject::EStatusBits. EnumeratorkCanDelete if object in a list can be deleted . kMustCleanup if object destructor must call RecursiveRemove() . kIsReferenced if object is referenced by a TRef or TRefArray . kHasUUID if object has a TUUID (its fUniqueID=UUIDNumber) . kCannotPick if object in a pad cannot be picked . kNoContextMenu if object does not want context menu . kInvalidObject if object ctor succeeded but object should not be used . Definition at line 61 of file TObject.h. Constructor & Destructor Documentation. ◆ TObject() [1/2]. TObject::TObject ; (; ). inline . TObject constructor. ; It sets the two data words of TObject to their initial values. The unique ID is set to 0 and the status word is set depending if the object is created on the stack or allocated on the heap. Depending on the ROOT environment variable ""Root.ObjStat"" (see TEnv) the object is added to the global TObjectTable for bookkeeping. ; Definition at line 254 of file TObject.h. ◆ TObject() [2/2]. TObject::TObject ; (; const TObject & ; object). inline . TObject copy ctor. ; Definition at line 272 of file TObject.h. ◆ ~TObject(). TObject::~TObject ; (; ). virtual . TObject destructor. ; Removes object from all canvases and object browsers if observer bit is on and remove from the global object table. ; Definition at line 158 of file TObject.cxx. Member Function Documentation. ◆ AbstractMethod(). void TObject::AbstractMethod ; (; const char * ; method); const. Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; Definition at line 1029 of file TObject.cxx. ◆ AddToTObjectTable(). void TObject::AddToTObjectTable ; (; TObject * ; op). staticprivate . Private helper function which wil",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:27277,Energy Efficiency,allocate,allocated,27277,"extView, TDirectoryFile, TFile, TArc, TArrow, TAxis, TBox, TColor, TCrown, TEllipse, TF1, TFormula, TF12, TF2, TF3, ROOT::v5::TFormula, TFrame, THelix, TAxis3D, TH1, TH1C, TH1S, TH1I, TH1L, TH1F, TH1D, TH2, TH2C, TH2S, TH2I, TH2L, TH2F, TH2D, TH3, TH3C, TH3S, TH3I, TH3L, TH3F, TH3D, TProfile, TProfile2D, TProfile3D, TLine, TMarker, TNamed, TH2Poly, TLegend, TLegendEntry, TF1Convolution, TF1NormSum, TH1K, TF1AbsComposition, TPaletteAxis, TPave, TPaveLabel, TPaveClass, TPolyLine, TPolyLine3D, TPolyMarker3D, TPolyMarker, TPieSlice, TStyle, TLatex, TMathText, TText, TWbox, and TXTRU.; Definition at line 140 of file TObject.cxx. ◆ DeclFileName(). static const char * TObject::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 243 of file TObject.h. ◆ Delete(). void TObject::Delete ; (; Option_t * ; option = """"). virtual . Delete this object. ; Typically called as a command via the interpreter. Normally use ""delete"" operator when object has been allocated on the heap. ; Reimplemented in TDirectory, TDirectoryFile, TFile, TSystemDirectory, TSystemFile, TTreeViewer, TGItemContext, TCanvas, TGFrame, TGTextEdit, TAxis, RooLinkedList, TExMap, TObjectTable, TProtoClass, TKeySQL, TKeyXML, TQCommand, TBtree, TClonesArray, THashList, THashTable, TList, TMap, TObjArray, TOrdCollection, TRefArray, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, TViewPubDataMembers, TViewPubFunctions, TThread, TKey, TMVA::Results, TTree, and TCollection.; Definition at line 248 of file TObject.cxx. ◆ DistancetoPrimitive(). Int_t TObject::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). virtual . Computes distance from point (px,py) to the object. ; This member function must be implemented for each graphics primitive. This default function returns a big number (999999). ; Reimplemented in TGeoTessellated, TStyle, TGeoBBox, TGeoCompositeShape, TGeoCone, TGeoConeSeg, TGeoEltu, TGeoHalfS",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:119167,Energy Efficiency,reduce,reduces,119167,"d buffer is created to hold the compressed buffer.; Reservation of the corresponding space in the file by looking in the TFree list of free blocks of the file.; The buffer is written to the file. Bufsize can be given to force a given buffer size to write this object. By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far.; If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by GetName().; The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete Using the kOverwrite option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the kWriteDelete option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile– the space is simply freed up to be overwritten; in the case of a TTree, it is more complicated. If one opens a TTree, appends some entries, then writes it out, the behaviour is effectively the same. If, however, one creates a new TTree and writes it out in this way, only the metadata is replaced, effectively making the old data invisible without deleting it. TTree::Delete() can be used to mark all disk space occupied by a TTree as free before overwriting its metadata this way. The kSingleKey option is only used by TCollection::Write() to write a container with a single key instead of each object in the container with its own key.; An object is read from the file into memory via TKey::Read() or via TObject::Read().; The function returns the total number of bytes written to the file. It returns 0 if the object cannot be written. ; Reimplemented in TSQLFile, TXMLFile, TDirectory, TBuffer, TFile, TParallelMergingFile, TDirectoryFile, TCollection, TMap, and TTree.; Definition at line 858 of file TObjec",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:524,Integrability,protocol,protocol,524,". ROOT: TObject Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Types |; Protected Member Functions |; Static Private Member Functions |; Private Attributes |; Static Private Attributes |; Friends |; List of all members ; TObject Class ReferenceCore ROOT classes » Base ROOT classes. ; Mother of all ROOT objects. ; The TObject class provides default behaviour and protocol for all objects in the ROOT system. It provides protocol for object I/O, error handling, sorting, inspection, printing, drawing, etc. Every object which inherits from TObject can be stored in the ROOT collection classes.; TObject's bits can be used as flags, bits 0 - 13 and 24-31 are reserved as global bits while bits 14 - 23 can be used in different class hierarchies (watch out for overlaps). ; Definition at line 41 of file TObject.h. Public Types; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; vi",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:581,Integrability,protocol,protocol,581,". ROOT: TObject Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Types |; Protected Member Functions |; Static Private Member Functions |; Private Attributes |; Static Private Attributes |; Friends |; List of all members ; TObject Class ReferenceCore ROOT classes » Base ROOT classes. ; Mother of all ROOT objects. ; The TObject class provides default behaviour and protocol for all objects in the ROOT system. It provides protocol for object I/O, error handling, sorting, inspection, printing, drawing, etc. Every object which inherits from TObject can be stored in the ROOT collection classes.; TObject's bits can be used as flags, bits 0 - 13 and 24-31 are reserved as global bits while bits 14 - 23 can be used in different class hierarchies (watch out for overlaps). ; Definition at line 41 of file TObject.h. Public Types; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; vi",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:3355,Integrability,message,message,3355,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:3896,Integrability,message,message,3896,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:5098,Integrability,message,message,5098,"ived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const ch",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:8570,Integrability,message,message,8570,"ead (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static voi",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:8943,Integrability,message,message,8943,"rimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (prote",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:18929,Integrability,depend,depending,18929,"ion (See TClass and TTree::Merge) . Definition at line 97 of file TObject.h. ◆ EDeprecatedStatusBits. enum TObject::EDeprecatedStatusBits. EnumeratorkObjInCanvas for backward compatibility only, use kMustCleanup . Definition at line 75 of file TObject.h. ◆ EStatusBits. enum TObject::EStatusBits. EnumeratorkCanDelete if object in a list can be deleted . kMustCleanup if object destructor must call RecursiveRemove() . kIsReferenced if object is referenced by a TRef or TRefArray . kHasUUID if object has a TUUID (its fUniqueID=UUIDNumber) . kCannotPick if object in a pad cannot be picked . kNoContextMenu if object does not want context menu . kInvalidObject if object ctor succeeded but object should not be used . Definition at line 61 of file TObject.h. Constructor & Destructor Documentation. ◆ TObject() [1/2]. TObject::TObject ; (; ). inline . TObject constructor. ; It sets the two data words of TObject to their initial values. The unique ID is set to 0 and the status word is set depending if the object is created on the stack or allocated on the heap. Depending on the ROOT environment variable ""Root.ObjStat"" (see TEnv) the object is added to the global TObjectTable for bookkeeping. ; Definition at line 254 of file TObject.h. ◆ TObject() [2/2]. TObject::TObject ; (; const TObject & ; object). inline . TObject copy ctor. ; Definition at line 272 of file TObject.h. ◆ ~TObject(). TObject::~TObject ; (; ). virtual . TObject destructor. ; Removes object from all canvases and object browsers if observer bit is on and remove from the global object table. ; Definition at line 158 of file TObject.cxx. Member Function Documentation. ◆ AbstractMethod(). void TObject::AbstractMethod ; (; const char * ; method); const. Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; Definition at line 1029 of file TObject.cxx. ◆ AddToTObjectTable(). void TObject::AddToTObjectTable ; (; TObject * ; op). staticprivate . Private helper function which wil",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:20009,Integrability,depend,dependency,20009,"nding on the ROOT environment variable ""Root.ObjStat"" (see TEnv) the object is added to the global TObjectTable for bookkeeping. ; Definition at line 254 of file TObject.h. ◆ TObject() [2/2]. TObject::TObject ; (; const TObject & ; object). inline . TObject copy ctor. ; Definition at line 272 of file TObject.h. ◆ ~TObject(). TObject::~TObject ; (; ). virtual . TObject destructor. ; Removes object from all canvases and object browsers if observer bit is on and remove from the global object table. ; Definition at line 158 of file TObject.cxx. Member Function Documentation. ◆ AbstractMethod(). void TObject::AbstractMethod ; (; const char * ; method); const. Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; Definition at line 1029 of file TObject.cxx. ◆ AddToTObjectTable(). void TObject::AddToTObjectTable ; (; TObject * ; op). staticprivate . Private helper function which will dispatch to TObjectTable::AddObj. ; Included here to avoid circular dependency between header files. ; Definition at line 175 of file TObject.cxx. ◆ AppendPad(). void TObject::AppendPad ; (; Option_t * ; option = """"). virtual . Append graphics object to current pad. ; In case no current pad is set yet, create a default canvas with the name ""c1"". ; Definition at line 184 of file TObject.cxx. ◆ Browse(). void TObject::Browse ; (; TBrowser * ; b). virtual . Browse object. May be overridden for another default action. ; Reimplemented in TASImage, TRecorder, TEfficiency, TGraph2D, TChain, TTree, TDirectory, TFolder, TMacro, TRemoteObject, TROOT, TStyle, TSystemDirectory, TSystemFile, TTask, TCollection, TPair, TBrowserObject, TBaseClass, TClass, TGeoManager, TGeoNode, TGeoVolume, TGeoOverlap, TGeoTrack, TCanvas, TPad, TAxis3D, TGeometry, TNode, TRootIconList, THbookBranch, THbookFile, THbookKey, TF1, TGraph, TH1, THnBase, ROOT::Internal::THnBaseBrowsable, THStack, TMultiDimFit, TMultiGraph, TPrincipal, TDirectoryFile, TKey, TKeyMapFile, TMapFile, TSPlot, T",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:21596,Integrability,rout,routine,21596,"Task, TCollection, TPair, TBrowserObject, TBaseClass, TClass, TGeoManager, TGeoNode, TGeoVolume, TGeoOverlap, TGeoTrack, TCanvas, TPad, TAxis3D, TGeometry, TNode, TRootIconList, THbookBranch, THbookFile, THbookKey, TF1, TGraph, TH1, THnBase, ROOT::Internal::THnBaseBrowsable, THStack, TMultiDimFit, TMultiGraph, TPrincipal, TDirectoryFile, TKey, TKeyMapFile, TMapFile, TSPlot, TDatabasePDG, TGenerator, TParticleClassPDG, TApplicationRemote, TProof, TProofChain, RooPlot, TBranch, TVirtualBranchBrowsable, TCollectionPropertyBrowsable, TBranchClones, TBranchElement, TBranchObject, TBranchSTL, TLeaf, TNtuple, TNtupleD, TTreePerfStats, ROOT::Experimental::XRooFit::xRooNode, and TQueryResult.; Definition at line 198 of file TObject.cxx. ◆ CheckedHash(). ULong_t TObject::CheckedHash ; (; ). inline . Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ; The intent is for this routine to be called instead of directly calling the function Hash during ""insert"" operations. See TObject::HasInconsistenTObjectHash();; (*) The setup is consistent when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 324 of file TObject.h. ◆ Class(). static TClass * TObject::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TObject::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TObject::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 243 of file TObject.h. ◆ ClassName(). const char * TObject::ClassName ; (; ); const. virtual . Returns name of class to which the object belongs. ; Definition at line 207 of file TObject.cxx. ◆ Clear(). virtual void TObject::Clear ; (; Option_t * ; = """"). ",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:33276,Integrability,message,message,33276,"X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style; X#define X(type, name); angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; styleOption_t Option_t styleDefinition TGWin32VirtualXProxy.cxx:46; TObject::fUniqueIDUInt_t fUniqueIDobject unique identifierDefinition TObject.h:44; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; lineTLine * lineDefinition entrylistblock_figure1.C:235. Reimplemented in TSystemFile, TCollection, TClass, TGFrame, and TGPack.; Definition at line 348 of file TObject.cxx. ◆ Error(). void TObject::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue error message. ; Use ""location"" to specify the method where the error occurred. Accepts standard printf formatting arguments. ; Reimplemented in TFitResult.; Definition at line 987 of file TObject.cxx. ◆ Execute() [1/2]. void TObject::Execute ; (; const char * ; method, . const char * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with the given parameter string, e.g. ; ""3.14,1,\""text\"""". ; Reimplemented in TMethodCall, TCling, TInterpreter, ROOT::R::TRInterface, and TContextMenu.; Definition at line 359 of file TObject.cxx. ◆ Execute() [2/2]. void TObject::Execute ; (; TMethod * ; method, . TObjArray * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with parameters stored in the TObjArray. ; The TObjArray should contain an argv vector like: argv[0] ... argv[n] = the list of TObjString parameters; TObjStringCollectable string class.Definition TObjString.h:28; nconst Int_t nDefinition legend1.C:16. Reimplemented in TClin",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:35605,Integrability,message,message,35605,"react to graphics events. ; Reimplemented in TParallelCoord, TParallelCoordRange, TParallelCoordVar, TGeoManager, TGeoNode, TGeoShape, TGeoVolume, TGeoOverlap, TGeoTrack, TASImage, TASPaletteEditor::LimitLine, TButton, TCanvas, TGroupButton, TPad, TSliderBox, TBox, TCrown, TCurlyArc, TCurlyLine, TDiamond, TEllipse, TFrame, TGraphPolargram, TLine, TLink, TMarker, TPave, TPolyLine, TText, TWbox, TGraphEdge, TGraphNode, TAxis3D, TMarker3DBox, TNode, TPolyLine3D, TPolyMarker3D, TView3D, TGL5DDataSet, TGLEventHandler, TGLHistPainter, TGLParametricEquation, TGLTH3Composition, TGLViewer, TAxis, TEfficiency, TF1, TF2, TF3, TGraph, TGraph2D, TH1, TPolyMarker, TScatter, TSpline, THistPainter, TPaletteAxis, TGenerator, TParticle, TPrimary, TFileDrawMap, TTreePerfStats, TSpider, TView, TVirtualHistPainter, TPie, and TGLScenePad.; Definition at line 393 of file TObject.cxx. ◆ Fatal(). void TObject::Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue fatal error message. ; Use ""location"" to specify the method where the fatal error occurred. Accepts standard printf formatting arguments. ; Definition at line 1015 of file TObject.cxx. ◆ FindObject() [1/2]. TObject * TObject::FindObject ; (; const char * ; name); const. virtual . Must be redefined in derived classes. ; This function is typically used with TCollections, but can also be used to find an object by name inside this object. ; Reimplemented in TListOfEnums, TMap, TDirectory, TFolder, TROOT, TListOfTypes, TListOfTypes, TBtree, TCollection, THashList, THashTable, TList, TObjArray, TListOfDataMembers, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, TListOfFunctionTemplates, TViewPubDataMembers, TViewPubFunctions, TPad, TGeometry, THbookFile, TGraph, TGraph2D, TH1, RooAbsCollection, and RooLinkedList.; Definition at line 403 of file TObject.cxx. ◆ FindObject() [2/2]. TObject * TObject::FindObject ; (; const TObject * ; obj); const. vir",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:42241,Integrability,rout,routine,42241,"ine 483 of file TObject.cxx. ◆ GetUniqueID(). UInt_t TObject::GetUniqueID ; (; ); const. virtual . Return the unique object id. ; Definition at line 457 of file TObject.cxx. ◆ HandleTimer(). Bool_t TObject::HandleTimer ; (; TTimer * ; timer). virtual . Execute action in response of a timer timing out. ; This method must be overridden if an object has to react to timers. ; Reimplemented in TGWindow, TGuiBldDragManager, TSessionViewer, TGLEventHandler, TGCommandPlugin, TGDNDManager, TGFileContainer, TGPopupMenu, TGScrollBar, TGShutter, TGTextEdit, TGTextEditor, TGTextEntry, TGTextView, TGToolTip, TGHtml, TVirtualPacketizer, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, TProofPlayerLite, and TTreeViewer.; Definition at line 493 of file TObject.cxx. ◆ Hash(). ULong_t TObject::Hash ; (; ); const. virtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:515; TROOT::RecursiveRemovevoid RecursiveRemove(TObj",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:43173,Integrability,message,message,43173,"(; ); const. virtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:515; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented in TEnvRec, TNamed, TObjString, TParameter< AParamType >, TParameter< Long64_t >, TCollection, TPair, TASImagePlugin, TASPluginGS, TPad, TImagePlugin, TPave, TGObject, TGPicture, TIconBoxThumb, TClassDocInfo, THtml::TFileSysEntry, TStatistic, TDrawFeedback, TStatsFeedback, and RooLinkedList.; Definition at line 515 of file TObject.cxx. ◆ HasInconsistentHash(). Bool_t TObject::HasInconsistentHash ; (; ); const. inline . Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ; missing call to RecursiveRemove in destructor).; Note: Since the consistency is only tested for during inserts, this routine will return true for object th",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:44130,Integrability,rout,routine,44130,",...) constIssue error message.Definition TObject.cxx:987; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:515; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented in TEnvRec, TNamed, TObjString, TParameter< AParamType >, TParameter< Long64_t >, TCollection, TPair, TASImagePlugin, TASPluginGS, TPad, TImagePlugin, TPave, TGObject, TGPicture, TIconBoxThumb, TClassDocInfo, THtml::TFileSysEntry, TStatistic, TDrawFeedback, TStatsFeedback, and RooLinkedList.; Definition at line 515 of file TObject.cxx. ◆ HasInconsistentHash(). Bool_t TObject::HasInconsistentHash ; (; ); const. inline . Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ; missing call to RecursiveRemove in destructor).; Note: Since the consistency is only tested for during inserts, this routine will return true for object that have never been inserted whether or not they have a consistent setup. This has no negative side-effect as searching for the object with the right or wrong Hash will always yield a not-found answer (Since anyway no hash can be guaranteed unique, there is always a check) ; Definition at line 358 of file TObject.h. ◆ Info(). void TObject::Info ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue info message. ; Use ""location"" to specify the method where the warning occurred. Accepts standard printf formatting arguments. ; Definition at line 961 of file TObject.cxx. ◆ InheritsFrom() [1/2]. Bool_t TObject::InheritsFrom ; (; const char * ; classname); const. virtual . Returns kTRUE if object inherits from class ""classname"". ; Reimplemented in TClass.; Definition at line 525 of file TObject.cxx. ◆ InheritsFrom() [2/2]. Bool_t TObject::InheritsFrom ; (; const TClass * ; cl); const. virtual . Returns kTRUE if object inherits from TClass c",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:44608,Integrability,message,message,44608,"TPad, TImagePlugin, TPave, TGObject, TGPicture, TIconBoxThumb, TClassDocInfo, THtml::TFileSysEntry, TStatistic, TDrawFeedback, TStatsFeedback, and RooLinkedList.; Definition at line 515 of file TObject.cxx. ◆ HasInconsistentHash(). Bool_t TObject::HasInconsistentHash ; (; ); const. inline . Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ; missing call to RecursiveRemove in destructor).; Note: Since the consistency is only tested for during inserts, this routine will return true for object that have never been inserted whether or not they have a consistent setup. This has no negative side-effect as searching for the object with the right or wrong Hash will always yield a not-found answer (Since anyway no hash can be guaranteed unique, there is always a check) ; Definition at line 358 of file TObject.h. ◆ Info(). void TObject::Info ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue info message. ; Use ""location"" to specify the method where the warning occurred. Accepts standard printf formatting arguments. ; Definition at line 961 of file TObject.cxx. ◆ InheritsFrom() [1/2]. Bool_t TObject::InheritsFrom ; (; const char * ; classname); const. virtual . Returns kTRUE if object inherits from class ""classname"". ; Reimplemented in TClass.; Definition at line 525 of file TObject.cxx. ◆ InheritsFrom() [2/2]. Bool_t TObject::InheritsFrom ; (; const TClass * ; cl); const. virtual . Returns kTRUE if object inherits from TClass cl. ; Reimplemented in TClass.; Definition at line 533 of file TObject.cxx. ◆ Inspect(). void TObject::Inspect ; (; ); const. virtual . Dump contents of this object in a graphics canvas. ; Same action as Dump but in a graphical form. In addition pointers to other objects can be followed.; The following picture is the Inspect of a histogram object: . Reimplemented in TSystemFile, TInspectorObject, TGFrame, and ROOT::Experimental::XRooFit::xRooNode.; Defi",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:116082,Integrability,message,message,116082,"lar, TTree, TTreeCache, TTreeCacheUnzip, TTreeSQL, TVirtualIndex, TVirtualTreePlayer, ROOT::Experimental::TTreeReaderFast, ROOT::Internal::TBranchProxyClassDescriptor, ROOT::Internal::TBranchProxyDescriptor, TChainIndex, TFileDrawMap, ROOT::Internal::TFriendProxyDescriptor, TSelectorDraw, TSelectorEntries, TTreeDrawArgsParser, TTreeFormula, TTreeFormulaManager, TTreeIndex, TTreePerfStats, TTreePlayer, TTreeReader, TParallelCoord, TParallelCoordRange, TParallelCoordSelect, TParallelCoordVar, TSpider, TTreeViewer, TTVRecord, TTVSession, iterplugin, h1analysis, h1analysisTreeReader, PyROOT::RegulatorCleanup, and ROOT::Internal::TCheckHashRecursiveRemoveConsistency.; Definition at line 888 of file TObject.cxx. ◆ StreamerNVirtual(). void TObject::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 243 of file TObject.h. ◆ SysError(). void TObject::SysError ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue system error message. ; Use ""location"" to specify the method where the system error occurred. Accepts standard printf formatting arguments. ; Definition at line 1001 of file TObject.cxx. ◆ TestBit(). R__ALWAYS_INLINE Bool_t TObject::TestBit ; (; UInt_t ; f); const. inline . Definition at line 199 of file TObject.h. ◆ TestBits(). Int_t TObject::TestBits ; (; UInt_t ; f); const. inline . Definition at line 200 of file TObject.h. ◆ UseCurrentStyle(). void TObject::UseCurrentStyle ; (; ). virtual . Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ; Reimplemented in TCanvas, TPad, TFrame, TPaveStats, TPaveText, TAxis3D, TGraph, TH1, and TTree.; Definition at line 801 of file TObject.cxx. ◆ Warning(). void TObject::Warning ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue warning message. ; Use ""location"" to specify the method where the warning occurred. Accepts stand",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:116987,Integrability,message,message,116987,"; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue system error message. ; Use ""location"" to specify the method where the system error occurred. Accepts standard printf formatting arguments. ; Definition at line 1001 of file TObject.cxx. ◆ TestBit(). R__ALWAYS_INLINE Bool_t TObject::TestBit ; (; UInt_t ; f); const. inline . Definition at line 199 of file TObject.h. ◆ TestBits(). Int_t TObject::TestBits ; (; UInt_t ; f); const. inline . Definition at line 200 of file TObject.h. ◆ UseCurrentStyle(). void TObject::UseCurrentStyle ; (; ). virtual . Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ; Reimplemented in TCanvas, TPad, TFrame, TPaveStats, TPaveText, TAxis3D, TGraph, TH1, and TTree.; Definition at line 801 of file TObject.cxx. ◆ Warning(). void TObject::Warning ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue warning message. ; Use ""location"" to specify the method where the warning occurred. Accepts standard printf formatting arguments. ; Definition at line 973 of file TObject.cxx. ◆ Write() [1/2]. Int_t TObject::Write ; (; const char * ; name = nullptr, . Int_t ; option = 0, . Int_t ; bufsize = 0 . ). virtual . Write this object to the current directory. ; For more see the const version of this method. ; Reimplemented in TSQLFile, TXMLFile, TDirectory, TBuffer, TFile, TParallelMergingFile, ROOT::TBufferMergerFile, TDirectoryFile, TCollection, TMap, and TTree.; Definition at line 880 of file TObject.cxx. ◆ Write() [2/2]. Int_t TObject::Write ; (; const char * ; name = nullptr, . Int_t ; option = 0, . Int_t ; bufsize = 0 . ); const. virtual . Write this object to the current directory. ; The data structure corresponding to this object is serialized. The corresponding buffer is written to the current directory with an associated key with name ""name"".; Writing an object to a file involves the follo",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:686,Modifiability,inherit,inherits,686,". ROOT: TObject Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Types |; Protected Member Functions |; Static Private Member Functions |; Private Attributes |; Static Private Attributes |; Friends |; List of all members ; TObject Class ReferenceCore ROOT classes » Base ROOT classes. ; Mother of all ROOT objects. ; The TObject class provides default behaviour and protocol for all objects in the ROOT system. It provides protocol for object I/O, error handling, sorting, inspection, printing, drawing, etc. Every object which inherits from TObject can be stored in the ROOT collection classes.; TObject's bits can be used as flags, bits 0 - 13 and 24-31 are reserved as global bits while bits 14 - 23 can be used in different class hierarchies (watch out for overlaps). ; Definition at line 41 of file TObject.h. Public Types; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; vi",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:2985,Modifiability,inherit,inheritance,2985,"pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in de",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:5196,Modifiability,inherit,inherits,5196,"ed by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a b",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:5313,Modifiability,inherit,inherits,5313,"ame of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not pro",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:19037,Modifiability,variab,variable,19037,"dStatusBits. enum TObject::EDeprecatedStatusBits. EnumeratorkObjInCanvas for backward compatibility only, use kMustCleanup . Definition at line 75 of file TObject.h. ◆ EStatusBits. enum TObject::EStatusBits. EnumeratorkCanDelete if object in a list can be deleted . kMustCleanup if object destructor must call RecursiveRemove() . kIsReferenced if object is referenced by a TRef or TRefArray . kHasUUID if object has a TUUID (its fUniqueID=UUIDNumber) . kCannotPick if object in a pad cannot be picked . kNoContextMenu if object does not want context menu . kInvalidObject if object ctor succeeded but object should not be used . Definition at line 61 of file TObject.h. Constructor & Destructor Documentation. ◆ TObject() [1/2]. TObject::TObject ; (; ). inline . TObject constructor. ; It sets the two data words of TObject to their initial values. The unique ID is set to 0 and the status word is set depending if the object is created on the stack or allocated on the heap. Depending on the ROOT environment variable ""Root.ObjStat"" (see TEnv) the object is added to the global TObjectTable for bookkeeping. ; Definition at line 254 of file TObject.h. ◆ TObject() [2/2]. TObject::TObject ; (; const TObject & ; object). inline . TObject copy ctor. ; Definition at line 272 of file TObject.h. ◆ ~TObject(). TObject::~TObject ; (; ). virtual . TObject destructor. ; Removes object from all canvases and object browsers if observer bit is on and remove from the global object table. ; Definition at line 158 of file TObject.cxx. Member Function Documentation. ◆ AbstractMethod(). void TObject::AbstractMethod ; (; const char * ; method); const. Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; Definition at line 1029 of file TObject.cxx. ◆ AddToTObjectTable(). void TObject::AddToTObjectTable ; (; TObject * ; op). staticprivate . Private helper function which will dispatch to TObjectTable::AddObj. ; Included here to avoid circular dependency between",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:31065,Modifiability,inherit,inheritance,31065,"emanSol, TGeoNode, TGeoPhysicalNode, TGeoPolygon, TGeoShape, TGeoVolume, TGeoOverlap, TGeoPainter, TGeoTrack, TGeoVGShape, TASImage, TButton, TCanvas, TColorWheel, TPad, TArrow, TBox, TDiamond, TEllipse, TFrame, TLegend, TMarker, TPave, TPaveLabel, TPavesText, TPaveText, TPolyLine, TWbox, TGraphStruct, TEveGeoNode, TEveGeoTopNode, TGeometry, THelix, TNode, TNodeDiv, TPolyLine3D, TPolyMarker3D, TStructViewer, TStructViewerGUI, TF1, TF2, TF3, TH1, TPolyMarker, TSpline, TFile, TMatrixTBase< Element >, TMatrixTBase< AReal >, TMatrixTBase< Double_t >, TVectorT< Element >, TVectorT< Double_t >, TMultiLayerPerceptron, TGenerator, RooAbsData, RooTreeDataStore, TTreePerfStats, TParallelCoordVar, TGItemContext, TVirtualPad, TPie, TGraph2D, TGraphPolar, TGraphPolargram, TParallelCoord, TParallelCoordRange, TSpider, RooPlot, and RooStats::SamplingDistPlot.; Definition at line 274 of file TObject.cxx. ◆ DrawClass(). void TObject::DrawClass ; (; ); const. virtual . Draw class inheritance tree of the class to which this object belongs. ; If a class B inherits from a class A, description of B is drawn on the right side of description of A. Member functions overridden by B are shown in class A with a blue line crossing-out the corresponding member function. The following picture is the class inheritance tree of class TPaveLabel:. Reimplemented in TSystemDirectory, TSystemFile, and TGFrame.; Definition at line 289 of file TObject.cxx. ◆ DrawClone(). TObject * TObject::DrawClone ; (; Option_t * ; option = """"); const. virtual . Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ; If pad was not selected - gPad will be used. ; Reimplemented in TSystemDirectory, TSystemFile, TGFrame, TAxis, and TCanvas.; Definition at line 299 of file TObject.cxx. ◆ Dump(). void TObject::Dump ; (; ); const. virtual . Dump contents of object on stdout. ; Using the information in the object dictionary (class TClass) each data member is interpreted. If a data member is a",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:31140,Modifiability,inherit,inherits,31140,"eoPainter, TGeoTrack, TGeoVGShape, TASImage, TButton, TCanvas, TColorWheel, TPad, TArrow, TBox, TDiamond, TEllipse, TFrame, TLegend, TMarker, TPave, TPaveLabel, TPavesText, TPaveText, TPolyLine, TWbox, TGraphStruct, TEveGeoNode, TEveGeoTopNode, TGeometry, THelix, TNode, TNodeDiv, TPolyLine3D, TPolyMarker3D, TStructViewer, TStructViewerGUI, TF1, TF2, TF3, TH1, TPolyMarker, TSpline, TFile, TMatrixTBase< Element >, TMatrixTBase< AReal >, TMatrixTBase< Double_t >, TVectorT< Element >, TVectorT< Double_t >, TMultiLayerPerceptron, TGenerator, RooAbsData, RooTreeDataStore, TTreePerfStats, TParallelCoordVar, TGItemContext, TVirtualPad, TPie, TGraph2D, TGraphPolar, TGraphPolargram, TParallelCoord, TParallelCoordRange, TSpider, RooPlot, and RooStats::SamplingDistPlot.; Definition at line 274 of file TObject.cxx. ◆ DrawClass(). void TObject::DrawClass ; (; ); const. virtual . Draw class inheritance tree of the class to which this object belongs. ; If a class B inherits from a class A, description of B is drawn on the right side of description of A. Member functions overridden by B are shown in class A with a blue line crossing-out the corresponding member function. The following picture is the class inheritance tree of class TPaveLabel:. Reimplemented in TSystemDirectory, TSystemFile, and TGFrame.; Definition at line 289 of file TObject.cxx. ◆ DrawClone(). TObject * TObject::DrawClone ; (; Option_t * ; option = """"); const. virtual . Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ; If pad was not selected - gPad will be used. ; Reimplemented in TSystemDirectory, TSystemFile, TGFrame, TAxis, and TCanvas.; Definition at line 299 of file TObject.cxx. ◆ Dump(). void TObject::Dump ; (; ); const. virtual . Dump contents of object on stdout. ; Using the information in the object dictionary (class TClass) each data member is interpreted. If a data member is a pointer, the pointer value is printed; The following output is the Dump of a TArrow obj",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:31384,Modifiability,inherit,inheritance,31384,"truct, TEveGeoNode, TEveGeoTopNode, TGeometry, THelix, TNode, TNodeDiv, TPolyLine3D, TPolyMarker3D, TStructViewer, TStructViewerGUI, TF1, TF2, TF3, TH1, TPolyMarker, TSpline, TFile, TMatrixTBase< Element >, TMatrixTBase< AReal >, TMatrixTBase< Double_t >, TVectorT< Element >, TVectorT< Double_t >, TMultiLayerPerceptron, TGenerator, RooAbsData, RooTreeDataStore, TTreePerfStats, TParallelCoordVar, TGItemContext, TVirtualPad, TPie, TGraph2D, TGraphPolar, TGraphPolargram, TParallelCoord, TParallelCoordRange, TSpider, RooPlot, and RooStats::SamplingDistPlot.; Definition at line 274 of file TObject.cxx. ◆ DrawClass(). void TObject::DrawClass ; (; ); const. virtual . Draw class inheritance tree of the class to which this object belongs. ; If a class B inherits from a class A, description of B is drawn on the right side of description of A. Member functions overridden by B are shown in class A with a blue line crossing-out the corresponding member function. The following picture is the class inheritance tree of class TPaveLabel:. Reimplemented in TSystemDirectory, TSystemFile, and TGFrame.; Definition at line 289 of file TObject.cxx. ◆ DrawClone(). TObject * TObject::DrawClone ; (; Option_t * ; option = """"); const. virtual . Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ; If pad was not selected - gPad will be used. ; Reimplemented in TSystemDirectory, TSystemFile, TGFrame, TAxis, and TCanvas.; Definition at line 299 of file TObject.cxx. ◆ Dump(). void TObject::Dump ; (; ); const. virtual . Dump contents of object on stdout. ; Using the information in the object dictionary (class TClass) each data member is interpreted. If a data member is a pointer, the pointer value is printed; The following output is the Dump of a TArrow object: fAngle 0 Arrow opening angle (degrees); fArrowSize 0.2 Arrow Size; fOption.*fData; fX1 0.1 X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object un",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:44902,Modifiability,inherit,inherits,44902,"true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ; missing call to RecursiveRemove in destructor).; Note: Since the consistency is only tested for during inserts, this routine will return true for object that have never been inserted whether or not they have a consistent setup. This has no negative side-effect as searching for the object with the right or wrong Hash will always yield a not-found answer (Since anyway no hash can be guaranteed unique, there is always a check) ; Definition at line 358 of file TObject.h. ◆ Info(). void TObject::Info ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue info message. ; Use ""location"" to specify the method where the warning occurred. Accepts standard printf formatting arguments. ; Definition at line 961 of file TObject.cxx. ◆ InheritsFrom() [1/2]. Bool_t TObject::InheritsFrom ; (; const char * ; classname); const. virtual . Returns kTRUE if object inherits from class ""classname"". ; Reimplemented in TClass.; Definition at line 525 of file TObject.cxx. ◆ InheritsFrom() [2/2]. Bool_t TObject::InheritsFrom ; (; const TClass * ; cl); const. virtual . Returns kTRUE if object inherits from TClass cl. ; Reimplemented in TClass.; Definition at line 533 of file TObject.cxx. ◆ Inspect(). void TObject::Inspect ; (; ); const. virtual . Dump contents of this object in a graphics canvas. ; Same action as Dump but in a graphical form. In addition pointers to other objects can be followed.; The following picture is the Inspect of a histogram object: . Reimplemented in TSystemFile, TInspectorObject, TGFrame, and ROOT::Experimental::XRooFit::xRooNode.; Definition at line 546 of file TObject.cxx. ◆ InvertBit(). void TObject::InvertBit ; (; UInt_t ; f). inline . Definition at line 201 of file TObject.h. ◆ IsA(). virtual TClass * TObject::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented in PyROOT::RegulatorCleanu",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:45128,Modifiability,inherit,inherits,45128,"is routine will return true for object that have never been inserted whether or not they have a consistent setup. This has no negative side-effect as searching for the object with the right or wrong Hash will always yield a not-found answer (Since anyway no hash can be guaranteed unique, there is always a check) ; Definition at line 358 of file TObject.h. ◆ Info(). void TObject::Info ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue info message. ; Use ""location"" to specify the method where the warning occurred. Accepts standard printf formatting arguments. ; Definition at line 961 of file TObject.cxx. ◆ InheritsFrom() [1/2]. Bool_t TObject::InheritsFrom ; (; const char * ; classname); const. virtual . Returns kTRUE if object inherits from class ""classname"". ; Reimplemented in TClass.; Definition at line 525 of file TObject.cxx. ◆ InheritsFrom() [2/2]. Bool_t TObject::InheritsFrom ; (; const TClass * ; cl); const. virtual . Returns kTRUE if object inherits from TClass cl. ; Reimplemented in TClass.; Definition at line 533 of file TObject.cxx. ◆ Inspect(). void TObject::Inspect ; (; ); const. virtual . Dump contents of this object in a graphics canvas. ; Same action as Dump but in a graphical form. In addition pointers to other objects can be followed.; The following picture is the Inspect of a histogram object: . Reimplemented in TSystemFile, TInspectorObject, TGFrame, and ROOT::Experimental::XRooFit::xRooNode.; Definition at line 546 of file TObject.cxx. ◆ InvertBit(). void TObject::InvertBit ; (; UInt_t ; f). inline . Definition at line 201 of file TObject.h. ◆ IsA(). virtual TClass * TObject::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented in PyROOT::RegulatorCleanup, ROOT::R::TRDataFrame, ROOT::R::TRFunctionExport, ROOT::R::TRFunctionImport, ROOT::R::TRInterface, ROOT::R::TRObject, TVirtualMapFile, TDavixFile, TDavixSystem, TMonaLisaValue, TMonaLisaText, TMonaLisaWriter, TXNetFile, ",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:74636,Performance,load,load,74636,"t, TVirtualPad, TTask, TNode, and TGeometry.; Definition at line 574 of file TObject.cxx. ◆ MakeZombie(). void TObject::MakeZombie ; (; ). inlineprotected . Definition at line 53 of file TObject.h. ◆ MayNotUse(). void TObject::MayNotUse ; (; const char * ; method); const. Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ; Definition at line 1040 of file TObject.cxx. ◆ Notify(). Bool_t TObject::Notify ; (; ). virtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented in TSelEvent, TXSocketHandler, TProofMgrInterruptHandler, TXProofServSigPipeHandler, TXProofServTerminationHandler, TXProofServSegViolationHandler, TXProofServInputHandler, TXSlaveInterruptHandler, TXSocketPingHandler, TMessageHandler, TNotifyLink< Type >, TNotifyLink< RNoCleanupNotifierHelper >, TNotifyLink< ROOT::Detail::TBranchProxy >, TNotifyLink< TTreeReader >, TFileHandler, TSignalHandler, TStdExceptionHandler, TProcessEventTimer, TTimer, TIdleTimer, TSingleShotCleaner, TCollection, TRefTable, TBrowserTimer, TInterruptHandler, TTermInputHandler, TThreadTimer, TGLRedrawTimer, TViewTimer, TGContainerKeyboardTimer, TGContainerScrollTimer, TGInputHandler, TViewUpdateTimer, TPopupDelayTimer, TRepeatTimer, TSBRepeatTimer, TGTextEditHist, TInsCharCom, TDelCharCom, TBreakLineCom, TInsTextCom, TDelTextCom, TBlinkTimer, TTipDelayTimer, TGuiBldDragMa",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:74674,Performance,load,load,74674,"t, TVirtualPad, TTask, TNode, and TGeometry.; Definition at line 574 of file TObject.cxx. ◆ MakeZombie(). void TObject::MakeZombie ; (; ). inlineprotected . Definition at line 53 of file TObject.h. ◆ MayNotUse(). void TObject::MayNotUse ; (; const char * ; method); const. Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ; Definition at line 1040 of file TObject.cxx. ◆ Notify(). Bool_t TObject::Notify ; (; ). virtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented in TSelEvent, TXSocketHandler, TProofMgrInterruptHandler, TXProofServSigPipeHandler, TXProofServTerminationHandler, TXProofServSegViolationHandler, TXProofServInputHandler, TXSlaveInterruptHandler, TXSocketPingHandler, TMessageHandler, TNotifyLink< Type >, TNotifyLink< RNoCleanupNotifierHelper >, TNotifyLink< ROOT::Detail::TBranchProxy >, TNotifyLink< TTreeReader >, TFileHandler, TSignalHandler, TStdExceptionHandler, TProcessEventTimer, TTimer, TIdleTimer, TSingleShotCleaner, TCollection, TRefTable, TBrowserTimer, TInterruptHandler, TTermInputHandler, TThreadTimer, TGLRedrawTimer, TViewTimer, TGContainerKeyboardTimer, TGContainerScrollTimer, TGInputHandler, TViewUpdateTimer, TPopupDelayTimer, TRepeatTimer, TSBRepeatTimer, TGTextEditHist, TInsCharCom, TDelCharCom, TBreakLineCom, TInsTextCom, TDelTextCom, TBlinkTimer, TTipDelayTimer, TGuiBldDragMa",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:19994,Safety,avoid,avoid,19994,"nding on the ROOT environment variable ""Root.ObjStat"" (see TEnv) the object is added to the global TObjectTable for bookkeeping. ; Definition at line 254 of file TObject.h. ◆ TObject() [2/2]. TObject::TObject ; (; const TObject & ; object). inline . TObject copy ctor. ; Definition at line 272 of file TObject.h. ◆ ~TObject(). TObject::~TObject ; (; ). virtual . TObject destructor. ; Removes object from all canvases and object browsers if observer bit is on and remove from the global object table. ; Definition at line 158 of file TObject.cxx. Member Function Documentation. ◆ AbstractMethod(). void TObject::AbstractMethod ; (; const char * ; method); const. Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ; Definition at line 1029 of file TObject.cxx. ◆ AddToTObjectTable(). void TObject::AddToTObjectTable ; (; TObject * ; op). staticprivate . Private helper function which will dispatch to TObjectTable::AddObj. ; Included here to avoid circular dependency between header files. ; Definition at line 175 of file TObject.cxx. ◆ AppendPad(). void TObject::AppendPad ; (; Option_t * ; option = """"). virtual . Append graphics object to current pad. ; In case no current pad is set yet, create a default canvas with the name ""c1"". ; Definition at line 184 of file TObject.cxx. ◆ Browse(). void TObject::Browse ; (; TBrowser * ; b). virtual . Browse object. May be overridden for another default action. ; Reimplemented in TASImage, TRecorder, TEfficiency, TGraph2D, TChain, TTree, TDirectory, TFolder, TMacro, TRemoteObject, TROOT, TStyle, TSystemDirectory, TSystemFile, TTask, TCollection, TPair, TBrowserObject, TBaseClass, TClass, TGeoManager, TGeoNode, TGeoVolume, TGeoOverlap, TGeoTrack, TCanvas, TPad, TAxis3D, TGeometry, TNode, TRootIconList, THbookBranch, THbookFile, THbookKey, TF1, TGraph, TH1, THnBase, ROOT::Internal::THnBaseBrowsable, THStack, TMultiDimFit, TMultiGraph, TPrincipal, TDirectoryFile, TKey, TKeyMapFile, TMapFile, TSPlot, T",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:21904,Safety,safe,safe,21904,"ph, TPrincipal, TDirectoryFile, TKey, TKeyMapFile, TMapFile, TSPlot, TDatabasePDG, TGenerator, TParticleClassPDG, TApplicationRemote, TProof, TProofChain, RooPlot, TBranch, TVirtualBranchBrowsable, TCollectionPropertyBrowsable, TBranchClones, TBranchElement, TBranchObject, TBranchSTL, TLeaf, TNtuple, TNtupleD, TTreePerfStats, ROOT::Experimental::XRooFit::xRooNode, and TQueryResult.; Definition at line 198 of file TObject.cxx. ◆ CheckedHash(). ULong_t TObject::CheckedHash ; (; ). inline . Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ; The intent is for this routine to be called instead of directly calling the function Hash during ""insert"" operations. See TObject::HasInconsistenTObjectHash();; (*) The setup is consistent when all classes in the class hierarchy that overload TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor. i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation. ; Definition at line 324 of file TObject.h. ◆ Class(). static TClass * TObject::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TObject::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TObject::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 243 of file TObject.h. ◆ ClassName(). const char * TObject::ClassName ; (; ); const. virtual . Returns name of class to which the object belongs. ; Definition at line 207 of file TObject.cxx. ◆ Clear(). virtual void TObject::Clear ; (; Option_t * ; = """"). inlinevirtual . Reimplemented in TMVA::ResultsClassification, TMVA::ResultsMulticlass, TMVA::ResultsRegression, TMVA::ResultsClassification, TMVA::ResultsMulticlass, TMVA::ResultsRegression, TMrbSubevent_Caen, TNotifyLinkBase, TRefTable, ROOT::TSchemaRule, TGTextEdit, TGTextView, TGView, TGHtml, TStreamerInf",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:119085,Safety,safe,safer,119085,"t.; The TBuffer object is filled via the class::Streamer function.; If the file is compressed (default) a second buffer is created to hold the compressed buffer.; Reservation of the corresponding space in the file by looking in the TFree list of free blocks of the file.; The buffer is written to the file. Bufsize can be given to force a given buffer size to write this object. By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far.; If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by GetName().; The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete Using the kOverwrite option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the kWriteDelete option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile– the space is simply freed up to be overwritten; in the case of a TTree, it is more complicated. If one opens a TTree, appends some entries, then writes it out, the behaviour is effectively the same. If, however, one creates a new TTree and writes it out in this way, only the metadata is replaced, effectively making the old data invisible without deleting it. TTree::Delete() can be used to mark all disk space occupied by a TTree as free before overwriting its metadata this way. The kSingleKey option is only used by TCollection::Write() to write a container with a single key instead of each object in the container with its own key.; An object is read from the file into memory via TKey::Read() or via TObject::Read().; The function returns the total number of bytes written to the file. It returns 0 if the object cannot be written. ; Reimplemented in TSQLFile, TXMLFile, TDirectory, TBuffer, TF",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:4827,Security,hash,hash,4827," Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other obje",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:42197,Security,hash,hash,42197,"LVEntry, TGTextEntry, TRootIconList, TAxis, TKey, TMapFile, TParticle, TPrimary, TPackMgr, Axis2, TParallelCoordSelect, and TVirtualPad.; Definition at line 483 of file TObject.cxx. ◆ GetUniqueID(). UInt_t TObject::GetUniqueID ; (; ); const. virtual . Return the unique object id. ; Definition at line 457 of file TObject.cxx. ◆ HandleTimer(). Bool_t TObject::HandleTimer ; (; TTimer * ; timer). virtual . Execute action in response of a timer timing out. ; This method must be overridden if an object has to react to timers. ; Reimplemented in TGWindow, TGuiBldDragManager, TSessionViewer, TGLEventHandler, TGCommandPlugin, TGDNDManager, TGFileContainer, TGPopupMenu, TGScrollBar, TGShutter, TGTextEdit, TGTextEditor, TGTextEntry, TGTextView, TGToolTip, TGHtml, TVirtualPacketizer, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, TProofPlayerLite, and TTreeViewer.; Definition at line 493 of file TObject.cxx. ◆ Hash(). ULong_t TObject::Hash ; (; ); const. virtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:43257,Security,hash,hash,43257,"outine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:515; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented in TEnvRec, TNamed, TObjString, TParameter< AParamType >, TParameter< Long64_t >, TCollection, TPair, TASImagePlugin, TASPluginGS, TPad, TImagePlugin, TPave, TGObject, TGPicture, TIconBoxThumb, TClassDocInfo, THtml::TFileSysEntry, TStatistic, TDrawFeedback, TStatsFeedback, and RooLinkedList.; Definition at line 515 of file TObject.cxx. ◆ HasInconsistentHash(). Bool_t TObject::HasInconsistentHash ; (; ); const. inline . Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ; missing call to RecursiveRemove in destructor).; Note: Since the consistency is only tested for during inserts, this routine will return true for object that have never been inserted whether or not they have a consistent setup. T",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:44385,Security,hash,hash,44385,"t *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented in TEnvRec, TNamed, TObjString, TParameter< AParamType >, TParameter< Long64_t >, TCollection, TPair, TASImagePlugin, TASPluginGS, TPad, TImagePlugin, TPave, TGObject, TGPicture, TIconBoxThumb, TClassDocInfo, THtml::TFileSysEntry, TStatistic, TDrawFeedback, TStatsFeedback, and RooLinkedList.; Definition at line 515 of file TObject.cxx. ◆ HasInconsistentHash(). Bool_t TObject::HasInconsistentHash ; (; ); const. inline . Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ; missing call to RecursiveRemove in destructor).; Note: Since the consistency is only tested for during inserts, this routine will return true for object that have never been inserted whether or not they have a consistent setup. This has no negative side-effect as searching for the object with the right or wrong Hash will always yield a not-found answer (Since anyway no hash can be guaranteed unique, there is always a check) ; Definition at line 358 of file TObject.h. ◆ Info(). void TObject::Info ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue info message. ; Use ""location"" to specify the method where the warning occurred. Accepts standard printf formatting arguments. ; Definition at line 961 of file TObject.cxx. ◆ InheritsFrom() [1/2]. Bool_t TObject::InheritsFrom ; (; const char * ; classname); const. virtual . Returns kTRUE if object inherits from class ""classname"". ; Reimplemented in TClass.; Definition at line 525 of file TObject.cxx. ◆ InheritsFrom() [2/2]. Bool_t TObject::InheritsFrom ; (; const TClass * ; cl); const. virtual . Returns kTRUE if object inherits from TClass cl. ; Reimplemented in TClass.; Definition at line 533 of file TObject.cxx. ◆ Inspect(). void TObject::Inspect ; (; ); const. virtual . Dump contents of this object in a graphics canvas. ; Same action as Dump but",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:42772,Testability,log,logarithmic,42772," method must be overridden if an object has to react to timers. ; Reimplemented in TGWindow, TGuiBldDragManager, TSessionViewer, TGLEventHandler, TGCommandPlugin, TGDNDManager, TGFileContainer, TGPopupMenu, TGScrollBar, TGShutter, TGTextEdit, TGTextEditor, TGTextEntry, TGTextView, TGToolTip, TGHtml, TVirtualPacketizer, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, TProofPlayerLite, and TTreeViewer.; Definition at line 493 of file TObject.cxx. ◆ Hash(). ULong_t TObject::Hash ; (; ); const. virtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:515; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented in TEnvRec, TNamed, TObjString, TParameter< AParamType >, TParameter< Long64_t >, TCollection, TPair, TASImagePlugin, TASPluginGS, TPad, TImagePlugin, TPave, TGObject, TGPicture, TIconBoxThumb, ",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:44098,Testability,test,tested,44098,",...) constIssue error message.Definition TObject.cxx:987; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:515; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented in TEnvRec, TNamed, TObjString, TParameter< AParamType >, TParameter< Long64_t >, TCollection, TPair, TASImagePlugin, TASPluginGS, TPad, TImagePlugin, TPave, TGObject, TGPicture, TIconBoxThumb, TClassDocInfo, THtml::TFileSysEntry, TStatistic, TDrawFeedback, TStatsFeedback, and RooLinkedList.; Definition at line 515 of file TObject.cxx. ◆ HasInconsistentHash(). Bool_t TObject::HasInconsistentHash ; (; ); const. inline . Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ; missing call to RecursiveRemove in destructor).; Note: Since the consistency is only tested for during inserts, this routine will return true for object that have never been inserted whether or not they have a consistent setup. This has no negative side-effect as searching for the object with the right or wrong Hash will always yield a not-found answer (Since anyway no hash can be guaranteed unique, there is always a check) ; Definition at line 358 of file TObject.h. ◆ Info(). void TObject::Info ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue info message. ; Use ""location"" to specify the method where the warning occurred. Accepts standard printf formatting arguments. ; Definition at line 961 of file TObject.cxx. ◆ InheritsFrom() [1/2]. Bool_t TObject::InheritsFrom ; (; const char * ; classname); const. virtual . Returns kTRUE if object inherits from class ""classname"". ; Reimplemented in TClass.; Definition at line 525 of file TObject.cxx. ◆ InheritsFrom() [2/2]. Bool_t TObject::InheritsFrom ; (; const TClass * ; cl); const. virtual . Returns kTRUE if object inherits from TClass c",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTObject.html:119209,Usability,simpl,simply,119209,"d buffer is created to hold the compressed buffer.; Reservation of the corresponding space in the file by looking in the TFree list of free blocks of the file.; The buffer is written to the file. Bufsize can be given to force a given buffer size to write this object. By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far.; If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by GetName().; The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete Using the kOverwrite option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the kWriteDelete option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile– the space is simply freed up to be overwritten; in the case of a TTree, it is more complicated. If one opens a TTree, appends some entries, then writes it out, the behaviour is effectively the same. If, however, one creates a new TTree and writes it out in this way, only the metadata is replaced, effectively making the old data invisible without deleting it. TTree::Delete() can be used to mark all disk space occupied by a TTree as free before overwriting its metadata this way. The kSingleKey option is only used by TCollection::Write() to write a container with a single key instead of each object in the container with its own key.; An object is read from the file into memory via TKey::Read() or via TObject::Read().; The function returns the total number of bytes written to the file. It returns 0 if the object cannot be written. ; Reimplemented in TSQLFile, TXMLFile, TDirectory, TBuffer, TFile, TParallelMergingFile, TDirectoryFile, TCollection, TMap, and TTree.; Definition at line 858 of file TObjec",MatchSource.WIKI,doc/v632/classTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTObject.html
https://root.cern/doc/v632/classTROOT.html:10508,Availability,error,error,10508," a class that is known to ROOT, e.g. ;  ; TClass * IsA () const override;  ; Bool_t IsBatch () const;  ; Bool_t IsEscaped () const;  ; Bool_t IsExecutingMacro () const;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsInterrupted () const;  ; Bool_t IsLineProcessing () const;  ; Bool_t IsProofServ () const;  ; Bool_t IsRootFile (const char *filename) const;  Return true if the file is local and is (likely) to be a ROOT file. ;  ; Bool_t IsWebDisplay () const;  ; Bool_t IsWebDisplayBatch () const;  ; Int_t LoadClass (const char *classname, const char *libname, Bool_t check=kFALSE);  Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored). ;  ; TClass * LoadClass (const char *name, Bool_t silent=kFALSE) const;  Helper function used by TClass::GetClass(). ;  ; Int_t LoadMacro (const char *filename, Int_t *error=nullptr, Bool_t check=kFALSE);  Load a macro in the interpreter's memory. ;  ; void ls (Option_t *option="""") const override;  To list all objects of the application. ;  ; Longptr_t Macro (const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE);  Execute a macro in the interpreter. ;  ; TCanvas * MakeDefCanvas () const;  Return a default canvas. ;  ; void Message (Int_t id, const TObject *obj);  Process message id called by obj. ;  ; Bool_t MustClean () const;  ; Longptr_t ProcessLine (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Longptr_t ProcessLineFast (const char *line, Int_t *error=nullptr);  Process interpreter command directly via CINT interpreter. ;  ; Longptr_t ProcessLineSync (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Bool_t ReadingObject () const;  Deprecated (will be removed in next release). ;  ; void RecursiveRemove (TObject *obj) override;  ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:10731,Availability,error,error,10731,"in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsInterrupted () const;  ; Bool_t IsLineProcessing () const;  ; Bool_t IsProofServ () const;  ; Bool_t IsRootFile (const char *filename) const;  Return true if the file is local and is (likely) to be a ROOT file. ;  ; Bool_t IsWebDisplay () const;  ; Bool_t IsWebDisplayBatch () const;  ; Int_t LoadClass (const char *classname, const char *libname, Bool_t check=kFALSE);  Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored). ;  ; TClass * LoadClass (const char *name, Bool_t silent=kFALSE) const;  Helper function used by TClass::GetClass(). ;  ; Int_t LoadMacro (const char *filename, Int_t *error=nullptr, Bool_t check=kFALSE);  Load a macro in the interpreter's memory. ;  ; void ls (Option_t *option="""") const override;  To list all objects of the application. ;  ; Longptr_t Macro (const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE);  Execute a macro in the interpreter. ;  ; TCanvas * MakeDefCanvas () const;  Return a default canvas. ;  ; void Message (Int_t id, const TObject *obj);  Process message id called by obj. ;  ; Bool_t MustClean () const;  ; Longptr_t ProcessLine (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Longptr_t ProcessLineFast (const char *line, Int_t *error=nullptr);  Process interpreter command directly via CINT interpreter. ;  ; Longptr_t ProcessLineSync (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Bool_t ReadingObject () const;  Deprecated (will be removed in next release). ;  ; void RecursiveRemove (TObject *obj) override;  Recursively remove this object from the list of Cleanups. ;  ; void RefreshBrowsers ();  Refresh all browsers. ;  ; TObject * Remove (TObject *) override;  Remove an object from the in-memory list. ;  ; void RemoveClass (",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:11041,Availability,error,error,11041,"o be a ROOT file. ;  ; Bool_t IsWebDisplay () const;  ; Bool_t IsWebDisplayBatch () const;  ; Int_t LoadClass (const char *classname, const char *libname, Bool_t check=kFALSE);  Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored). ;  ; TClass * LoadClass (const char *name, Bool_t silent=kFALSE) const;  Helper function used by TClass::GetClass(). ;  ; Int_t LoadMacro (const char *filename, Int_t *error=nullptr, Bool_t check=kFALSE);  Load a macro in the interpreter's memory. ;  ; void ls (Option_t *option="""") const override;  To list all objects of the application. ;  ; Longptr_t Macro (const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE);  Execute a macro in the interpreter. ;  ; TCanvas * MakeDefCanvas () const;  Return a default canvas. ;  ; void Message (Int_t id, const TObject *obj);  Process message id called by obj. ;  ; Bool_t MustClean () const;  ; Longptr_t ProcessLine (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Longptr_t ProcessLineFast (const char *line, Int_t *error=nullptr);  Process interpreter command directly via CINT interpreter. ;  ; Longptr_t ProcessLineSync (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Bool_t ReadingObject () const;  Deprecated (will be removed in next release). ;  ; void RecursiveRemove (TObject *obj) override;  Recursively remove this object from the list of Cleanups. ;  ; void RefreshBrowsers ();  Refresh all browsers. ;  ; TObject * Remove (TObject *) override;  Remove an object from the in-memory list. ;  ; void RemoveClass (TClass *);  Remove a class from the list and map of classes. ;  ; void Reset (Option_t *option="""");  Delete all global interpreter objects created since the last call to Reset. ;  ; void ResetClassSaved ();  Reset the ClassSaved status of all classes. ;  ; void SaveContext ();  Save the current",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:11176,Availability,error,error,11176,"ibname, Bool_t check=kFALSE);  Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored). ;  ; TClass * LoadClass (const char *name, Bool_t silent=kFALSE) const;  Helper function used by TClass::GetClass(). ;  ; Int_t LoadMacro (const char *filename, Int_t *error=nullptr, Bool_t check=kFALSE);  Load a macro in the interpreter's memory. ;  ; void ls (Option_t *option="""") const override;  To list all objects of the application. ;  ; Longptr_t Macro (const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE);  Execute a macro in the interpreter. ;  ; TCanvas * MakeDefCanvas () const;  Return a default canvas. ;  ; void Message (Int_t id, const TObject *obj);  Process message id called by obj. ;  ; Bool_t MustClean () const;  ; Longptr_t ProcessLine (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Longptr_t ProcessLineFast (const char *line, Int_t *error=nullptr);  Process interpreter command directly via CINT interpreter. ;  ; Longptr_t ProcessLineSync (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Bool_t ReadingObject () const;  Deprecated (will be removed in next release). ;  ; void RecursiveRemove (TObject *obj) override;  Recursively remove this object from the list of Cleanups. ;  ; void RefreshBrowsers ();  Refresh all browsers. ;  ; TObject * Remove (TObject *) override;  Remove an object from the in-memory list. ;  ; void RemoveClass (TClass *);  Remove a class from the list and map of classes. ;  ; void Reset (Option_t *option="""");  Delete all global interpreter objects created since the last call to Reset. ;  ; void ResetClassSaved ();  Reset the ClassSaved status of all classes. ;  ; void SaveContext ();  Save the current interpreter context. ;  ; void SetApplication (TApplication *app);  ; void SetBatch (Bool_t batch=kTRUE);  Set batch mode for ROOT If the argument",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:11309,Availability,error,error,11309,"lassname is ignored). ;  ; TClass * LoadClass (const char *name, Bool_t silent=kFALSE) const;  Helper function used by TClass::GetClass(). ;  ; Int_t LoadMacro (const char *filename, Int_t *error=nullptr, Bool_t check=kFALSE);  Load a macro in the interpreter's memory. ;  ; void ls (Option_t *option="""") const override;  To list all objects of the application. ;  ; Longptr_t Macro (const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE);  Execute a macro in the interpreter. ;  ; TCanvas * MakeDefCanvas () const;  Return a default canvas. ;  ; void Message (Int_t id, const TObject *obj);  Process message id called by obj. ;  ; Bool_t MustClean () const;  ; Longptr_t ProcessLine (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Longptr_t ProcessLineFast (const char *line, Int_t *error=nullptr);  Process interpreter command directly via CINT interpreter. ;  ; Longptr_t ProcessLineSync (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Bool_t ReadingObject () const;  Deprecated (will be removed in next release). ;  ; void RecursiveRemove (TObject *obj) override;  Recursively remove this object from the list of Cleanups. ;  ; void RefreshBrowsers ();  Refresh all browsers. ;  ; TObject * Remove (TObject *) override;  Remove an object from the in-memory list. ;  ; void RemoveClass (TClass *);  Remove a class from the list and map of classes. ;  ; void Reset (Option_t *option="""");  Delete all global interpreter objects created since the last call to Reset. ;  ; void ResetClassSaved ();  Reset the ClassSaved status of all classes. ;  ; void SaveContext ();  Save the current interpreter context. ;  ; void SetApplication (TApplication *app);  ; void SetBatch (Bool_t batch=kTRUE);  Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graphics. ;  ; void SetCutClassName (const char *name=""TCutG"");  Set the defa",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:22200,Availability,error,error,22200," *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:22289,Availability,error,error,22289,"ave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out.",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:22444,Availability,error,error,22444,"hether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ; ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:22741,Availability,error,error,22741,"putes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns k",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:26276,Availability,error,error,26276," operator= (const TObject &rhs);  TObject assignment operator. ;  ; virtual void Pop ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  . Static Public Member Functions; static const std::vector< std::string > & AddExtraInterpreterArgs (const std::vector< std::string > &args);  Provide command line arguments to the interpreter construction. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Int_t ConvertVersionCode2Int (Int_t code);  Convert version code to an integer, i.e. 331527 -> 51507. ;  ; static Int_t ConvertVersionInt2Code (Int_t v);  Convert version as an integer to version code as used in RVersion.h. ;  ; static const char * DeclFileName ();  ; st",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:30261,Availability,down,down,30261," in the installation. ;  ; static Int_t IncreaseDirLevel ();  Increase the indentation level for ls(). ;  ; static void IndentLevel ();  Functions used by ls() to indent an object hierarchy. ;  ; static void Initialize ();  Initialize ROOT explicitly. ;  ; static Bool_t Initialized ();  Return kTRUE if the TROOT object has been initialized. ;  ; static void RegisterModule (const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false);  Called by static dictionary initialization to register clang modules for headers. ;  ; static Int_t RootVersionCode ();  Return ROOT version code as defined in RVersion.h. ;  ; static void SetDirLevel (Int_t level=0);  Return Indentation level for ls(). ;  ; static void SetMacroPath (const char *newpath);  Set or extend the macro search path. ;  ; static void ShutDown ();  Shut down ROOT. ;  ;  Static Public Member Functions inherited from TDirectory; static void AddDirectory (Bool_t add=kTRUE);  Sets the flag controlling the automatic add objects like histograms, TGraph2D, etc in memory. ;  ; static Bool_t AddDirectoryStatus ();  Static function: see TDirectory::AddDirectory for more comments. ;  ; static Bool_t Cd (const char *path);  Change current directory to ""path"". ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static std::atomic< TDirectory * > & CurrentDirectory ();  Return the current directory for the current thread. ;  ; static const char * DeclFileName ();  ; static void DecodeNameCycle (const char *namecycle, char *name, Short_t &cycle, const size_t namesize=0);  Decode a namecycle ""aap;2"" into name ""aap"" and cycle ""2"". ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:66708,Availability,error,error,66708,"har * ; filename); const. Return true if the file is local and is (likely) to be a ROOT file. ; Definition at line 2230 of file TROOT.cxx. ◆ IsWebDisplay(). Bool_t TROOT::IsWebDisplay ; (; ); const. inline . Definition at line 287 of file TROOT.h. ◆ IsWebDisplayBatch(). Bool_t TROOT::IsWebDisplayBatch ; (; ); const. inline . Definition at line 288 of file TROOT.h. ◆ LoadClass() [1/2]. Int_t TROOT::LoadClass ; (; const char * ; classname, . const char * ; libname, . Bool_t ; check = kFALSE . ). Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored). ; If not it will load library ""libname"". If the library couldn't be found with original libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again. If DynamicPathName still couldn't find the library, return -1. If check is true it will only check if libname exists and is readable. Returns 0 on successful loading, -1 in case libname does not exist or in case of error and -2 in case of version mismatch. ; Definition at line 2183 of file TROOT.cxx. ◆ LoadClass() [2/2]. TClass * TROOT::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent = kFALSE . ); const. Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 2167 of file TROOT.cxx. ◆ LoadMacro(). Int_t TROOT::LoadMacro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; check = kFALSE . ). Load a macro in the interpreter's memory. ; Equivalent to the command line command "".L filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:67408,Availability,error,error,67408,"if the name was not prefixed with lib, try to prefix with ""lib"" and search again. If DynamicPathName still couldn't find the library, return -1. If check is true it will only check if libname exists and is readable. Returns 0 on successful loading, -1 in case libname does not exist or in case of error and -2 in case of version mismatch. ; Definition at line 2183 of file TROOT.cxx. ◆ LoadClass() [2/2]. TClass * TROOT::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent = kFALSE . ); const. Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 2167 of file TROOT.cxx. ◆ LoadMacro(). Int_t TROOT::LoadMacro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; check = kFALSE . ). Load a macro in the interpreter's memory. ; Equivalent to the command line command "".L filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]]. The possible error codes are defined by TInterpreter::EErrorCode. If check is true it will only check if filename exists and is readable. Returns 0 on successful loading and -1 in case filename does not exist or in case of error. ; Definition at line 2268 of file TROOT.cxx. ◆ ls(). void TROOT::ls ; (; Option_t * ; option = """"); const. overridevirtual . To list all objects of the application. ; Loop on all objects created in the ROOT linked lists. Objects may be files and windows or any other object directly attached to the ROOT linked list. ; Reimplemented from TDirectory.; Definition at line 2250 of file TROOT.cxx. ◆ Macro(). Longptr_t TROOT::Macro ; (; const char * ; filename, . Int_t * ; error = nullptr, .",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:67707,Availability,error,error,67707,"se of version mismatch. ; Definition at line 2183 of file TROOT.cxx. ◆ LoadClass() [2/2]. TClass * TROOT::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent = kFALSE . ); const. Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 2167 of file TROOT.cxx. ◆ LoadMacro(). Int_t TROOT::LoadMacro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; check = kFALSE . ). Load a macro in the interpreter's memory. ; Equivalent to the command line command "".L filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]]. The possible error codes are defined by TInterpreter::EErrorCode. If check is true it will only check if filename exists and is readable. Returns 0 on successful loading and -1 in case filename does not exist or in case of error. ; Definition at line 2268 of file TROOT.cxx. ◆ ls(). void TROOT::ls ; (; Option_t * ; option = """"); const. overridevirtual . To list all objects of the application. ; Loop on all objects created in the ROOT linked lists. Objects may be files and windows or any other object directly attached to the ROOT linked list. ; Reimplemented from TDirectory.; Definition at line 2250 of file TROOT.cxx. ◆ Macro(). Longptr_t TROOT::Macro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; padUpdate = kTRUE . ). Execute a macro in the interpreter. ; Equivalent to the command line command "".x filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]][(args)]. The possible error codes are defined by T",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:67917,Availability,error,error,67917,". Bool_t ; silent = kFALSE . ); const. Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 2167 of file TROOT.cxx. ◆ LoadMacro(). Int_t TROOT::LoadMacro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; check = kFALSE . ). Load a macro in the interpreter's memory. ; Equivalent to the command line command "".L filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]]. The possible error codes are defined by TInterpreter::EErrorCode. If check is true it will only check if filename exists and is readable. Returns 0 on successful loading and -1 in case filename does not exist or in case of error. ; Definition at line 2268 of file TROOT.cxx. ◆ ls(). void TROOT::ls ; (; Option_t * ; option = """"); const. overridevirtual . To list all objects of the application. ; Loop on all objects created in the ROOT linked lists. Objects may be files and windows or any other object directly attached to the ROOT linked list. ; Reimplemented from TDirectory.; Definition at line 2250 of file TROOT.cxx. ◆ Macro(). Longptr_t TROOT::Macro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; padUpdate = kTRUE . ). Execute a macro in the interpreter. ; Equivalent to the command line command "".x filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]][(args)]. The possible error codes are defined by TInterpreter::EErrorCode. If padUpdate is true (default) update the current pad. Returns the macro return value. ; Definition at line 2316 of file TROOT",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:68394,Availability,error,error,68394," Int_t * ; error = nullptr, . Bool_t ; check = kFALSE . ). Load a macro in the interpreter's memory. ; Equivalent to the command line command "".L filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]]. The possible error codes are defined by TInterpreter::EErrorCode. If check is true it will only check if filename exists and is readable. Returns 0 on successful loading and -1 in case filename does not exist or in case of error. ; Definition at line 2268 of file TROOT.cxx. ◆ ls(). void TROOT::ls ; (; Option_t * ; option = """"); const. overridevirtual . To list all objects of the application. ; Loop on all objects created in the ROOT linked lists. Objects may be files and windows or any other object directly attached to the ROOT linked list. ; Reimplemented from TDirectory.; Definition at line 2250 of file TROOT.cxx. ◆ Macro(). Longptr_t TROOT::Macro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; padUpdate = kTRUE . ). Execute a macro in the interpreter. ; Equivalent to the command line command "".x filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]][(args)]. The possible error codes are defined by TInterpreter::EErrorCode. If padUpdate is true (default) update the current pad. Returns the macro return value. ; Definition at line 2316 of file TROOT.cxx. ◆ MakeDefCanvas(). TCanvas * TROOT::MakeDefCanvas ; (; ); const. Return a default canvas. ; Definition at line 1554 of file TROOT.cxx. ◆ Message(). void TROOT::Message ; (; Int_t ; id, . const TObject * ; obj . ). Process message id called by obj. ; Definition at line 2350 of file TROOT.cxx. ◆ MustClean(). Bool_t TROOT::MustClean ; (; ); const. inline . Definition at line 296 of file TROOT.h. ◆ operator new() [1/2]. void * TROOT::operator new ; (; size_t ; l). inlineprotected . Definition at line 178 of file T",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:68698,Availability,error,error,68698,"s are defined by TInterpreter::EErrorCode. If check is true it will only check if filename exists and is readable. Returns 0 on successful loading and -1 in case filename does not exist or in case of error. ; Definition at line 2268 of file TROOT.cxx. ◆ ls(). void TROOT::ls ; (; Option_t * ; option = """"); const. overridevirtual . To list all objects of the application. ; Loop on all objects created in the ROOT linked lists. Objects may be files and windows or any other object directly attached to the ROOT linked list. ; Reimplemented from TDirectory.; Definition at line 2250 of file TROOT.cxx. ◆ Macro(). Longptr_t TROOT::Macro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; padUpdate = kTRUE . ). Execute a macro in the interpreter. ; Equivalent to the command line command "".x filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]][(args)]. The possible error codes are defined by TInterpreter::EErrorCode. If padUpdate is true (default) update the current pad. Returns the macro return value. ; Definition at line 2316 of file TROOT.cxx. ◆ MakeDefCanvas(). TCanvas * TROOT::MakeDefCanvas ; (; ); const. Return a default canvas. ; Definition at line 1554 of file TROOT.cxx. ◆ Message(). void TROOT::Message ; (; Int_t ; id, . const TObject * ; obj . ). Process message id called by obj. ; Definition at line 2350 of file TROOT.cxx. ◆ MustClean(). Bool_t TROOT::MustClean ; (; ); const. inline . Definition at line 296 of file TROOT.h. ◆ operator new() [1/2]. void * TROOT::operator new ; (; size_t ; l). inlineprotected . Definition at line 178 of file TROOT.h. ◆ operator new() [2/2]. void * TROOT::operator new ; (; size_t ; l, . void * ; ptr . ). inlineprotected . Definition at line 179 of file TROOT.h. ◆ operator=(). TROOT & TROOT::operator= ; (; const TROOT & ; ). privatedelete . ◆ ProcessLine(). Longptr_t TROOT::ProcessLine ; (; const char * ; line, . Int_t * ; e",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:69716,Availability,error,error,69716,"ed by TInterpreter::EErrorCode. If padUpdate is true (default) update the current pad. Returns the macro return value. ; Definition at line 2316 of file TROOT.cxx. ◆ MakeDefCanvas(). TCanvas * TROOT::MakeDefCanvas ; (; ); const. Return a default canvas. ; Definition at line 1554 of file TROOT.cxx. ◆ Message(). void TROOT::Message ; (; Int_t ; id, . const TObject * ; obj . ). Process message id called by obj. ; Definition at line 2350 of file TROOT.cxx. ◆ MustClean(). Bool_t TROOT::MustClean ; (; ); const. inline . Definition at line 296 of file TROOT.h. ◆ operator new() [1/2]. void * TROOT::operator new ; (; size_t ; l). inlineprotected . Definition at line 178 of file TROOT.h. ◆ operator new() [2/2]. void * TROOT::operator new ; (; size_t ; l, . void * ; ptr . ). inlineprotected . Definition at line 179 of file TROOT.h. ◆ operator=(). TROOT & TROOT::operator= ; (; const TROOT & ; ). privatedelete . ◆ ProcessLine(). Longptr_t TROOT::ProcessLine ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplication::ProcessLine(). ; On Win32 the line will be processed asynchronously by sending it to the CINT interpreter thread. For explicit synchronous processing use ProcessLineSync(). On non-Win32 platforms there is no difference between ProcessLine() and ProcessLineSync(). The possible error codes are defined by TInterpreter::EErrorCode. In particular, error will equal to TInterpreter::kProcessing until the CINT interpreted thread has finished executing the line. Returns the result of the command, cast to a Longptr_t. ; Definition at line 2370 of file TROOT.cxx. ◆ ProcessLineFast(). Longptr_t TROOT::ProcessLineFast ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command directly via CINT interpreter. ; Only executable statements are allowed (no variable declarations), In all other cases use TROOT::ProcessLine(). The possible error codes are defined by TInterpreter::EErrorCode. ; Definition at line 2407",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:70060,Availability,error,error,70060,"ject * ; obj . ). Process message id called by obj. ; Definition at line 2350 of file TROOT.cxx. ◆ MustClean(). Bool_t TROOT::MustClean ; (; ); const. inline . Definition at line 296 of file TROOT.h. ◆ operator new() [1/2]. void * TROOT::operator new ; (; size_t ; l). inlineprotected . Definition at line 178 of file TROOT.h. ◆ operator new() [2/2]. void * TROOT::operator new ; (; size_t ; l, . void * ; ptr . ). inlineprotected . Definition at line 179 of file TROOT.h. ◆ operator=(). TROOT & TROOT::operator= ; (; const TROOT & ; ). privatedelete . ◆ ProcessLine(). Longptr_t TROOT::ProcessLine ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplication::ProcessLine(). ; On Win32 the line will be processed asynchronously by sending it to the CINT interpreter thread. For explicit synchronous processing use ProcessLineSync(). On non-Win32 platforms there is no difference between ProcessLine() and ProcessLineSync(). The possible error codes are defined by TInterpreter::EErrorCode. In particular, error will equal to TInterpreter::kProcessing until the CINT interpreted thread has finished executing the line. Returns the result of the command, cast to a Longptr_t. ; Definition at line 2370 of file TROOT.cxx. ◆ ProcessLineFast(). Longptr_t TROOT::ProcessLineFast ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command directly via CINT interpreter. ; Only executable statements are allowed (no variable declarations), In all other cases use TROOT::ProcessLine(). The possible error codes are defined by TInterpreter::EErrorCode. ; Definition at line 2407 of file TROOT.cxx. ◆ ProcessLineSync(). Longptr_t TROOT::ProcessLineSync ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplication::ProcessLine(). ; On Win32 the line will be processed synchronously (i.e. it will only return when the CINT interpreter thread has finished executing the line). On non-Win32 platform",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:70128,Availability,error,error,70128,"◆ MustClean(). Bool_t TROOT::MustClean ; (; ); const. inline . Definition at line 296 of file TROOT.h. ◆ operator new() [1/2]. void * TROOT::operator new ; (; size_t ; l). inlineprotected . Definition at line 178 of file TROOT.h. ◆ operator new() [2/2]. void * TROOT::operator new ; (; size_t ; l, . void * ; ptr . ). inlineprotected . Definition at line 179 of file TROOT.h. ◆ operator=(). TROOT & TROOT::operator= ; (; const TROOT & ; ). privatedelete . ◆ ProcessLine(). Longptr_t TROOT::ProcessLine ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplication::ProcessLine(). ; On Win32 the line will be processed asynchronously by sending it to the CINT interpreter thread. For explicit synchronous processing use ProcessLineSync(). On non-Win32 platforms there is no difference between ProcessLine() and ProcessLineSync(). The possible error codes are defined by TInterpreter::EErrorCode. In particular, error will equal to TInterpreter::kProcessing until the CINT interpreted thread has finished executing the line. Returns the result of the command, cast to a Longptr_t. ; Definition at line 2370 of file TROOT.cxx. ◆ ProcessLineFast(). Longptr_t TROOT::ProcessLineFast ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command directly via CINT interpreter. ; Only executable statements are allowed (no variable declarations), In all other cases use TROOT::ProcessLine(). The possible error codes are defined by TInterpreter::EErrorCode. ; Definition at line 2407 of file TROOT.cxx. ◆ ProcessLineSync(). Longptr_t TROOT::ProcessLineSync ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplication::ProcessLine(). ; On Win32 the line will be processed synchronously (i.e. it will only return when the CINT interpreter thread has finished executing the line). On non-Win32 platforms there is no difference between ProcessLine() and ProcessLineSync(). The possible error codes ar",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:70434,Availability,error,error,70434,"TROOT::operator new ; (; size_t ; l, . void * ; ptr . ). inlineprotected . Definition at line 179 of file TROOT.h. ◆ operator=(). TROOT & TROOT::operator= ; (; const TROOT & ; ). privatedelete . ◆ ProcessLine(). Longptr_t TROOT::ProcessLine ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplication::ProcessLine(). ; On Win32 the line will be processed asynchronously by sending it to the CINT interpreter thread. For explicit synchronous processing use ProcessLineSync(). On non-Win32 platforms there is no difference between ProcessLine() and ProcessLineSync(). The possible error codes are defined by TInterpreter::EErrorCode. In particular, error will equal to TInterpreter::kProcessing until the CINT interpreted thread has finished executing the line. Returns the result of the command, cast to a Longptr_t. ; Definition at line 2370 of file TROOT.cxx. ◆ ProcessLineFast(). Longptr_t TROOT::ProcessLineFast ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command directly via CINT interpreter. ; Only executable statements are allowed (no variable declarations), In all other cases use TROOT::ProcessLine(). The possible error codes are defined by TInterpreter::EErrorCode. ; Definition at line 2407 of file TROOT.cxx. ◆ ProcessLineSync(). Longptr_t TROOT::ProcessLineSync ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplication::ProcessLine(). ; On Win32 the line will be processed synchronously (i.e. it will only return when the CINT interpreter thread has finished executing the line). On non-Win32 platforms there is no difference between ProcessLine() and ProcessLineSync(). The possible error codes are defined by TInterpreter::EErrorCode. Returns the result of the command, cast to a Longptr_t. ; Definition at line 2390 of file TROOT.cxx. ◆ ReadGitInfo(). void TROOT::ReadGitInfo ; (; ). protected . Read Git commit SHA1 and branch name. ; Read Git commit info",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:70641,Availability,error,error,70641,"ROOT::ProcessLine ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplication::ProcessLine(). ; On Win32 the line will be processed asynchronously by sending it to the CINT interpreter thread. For explicit synchronous processing use ProcessLineSync(). On non-Win32 platforms there is no difference between ProcessLine() and ProcessLineSync(). The possible error codes are defined by TInterpreter::EErrorCode. In particular, error will equal to TInterpreter::kProcessing until the CINT interpreted thread has finished executing the line. Returns the result of the command, cast to a Longptr_t. ; Definition at line 2370 of file TROOT.cxx. ◆ ProcessLineFast(). Longptr_t TROOT::ProcessLineFast ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command directly via CINT interpreter. ; Only executable statements are allowed (no variable declarations), In all other cases use TROOT::ProcessLine(). The possible error codes are defined by TInterpreter::EErrorCode. ; Definition at line 2407 of file TROOT.cxx. ◆ ProcessLineSync(). Longptr_t TROOT::ProcessLineSync ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplication::ProcessLine(). ; On Win32 the line will be processed synchronously (i.e. it will only return when the CINT interpreter thread has finished executing the line). On non-Win32 platforms there is no difference between ProcessLine() and ProcessLineSync(). The possible error codes are defined by TInterpreter::EErrorCode. Returns the result of the command, cast to a Longptr_t. ; Definition at line 2390 of file TROOT.cxx. ◆ ReadGitInfo(). void TROOT::ReadGitInfo ; (; ). protected . Read Git commit SHA1 and branch name. ; Read Git commit information and branch name from the etc/gitinfo.txt file. ; Definition at line 2429 of file TROOT.cxx. ◆ ReadingObject(). Bool_t TROOT::ReadingObject ; (; ); const. Deprecated (will be removed in next release). ; Definition at",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:70831,Availability,error,error,70831,"d asynchronously by sending it to the CINT interpreter thread. For explicit synchronous processing use ProcessLineSync(). On non-Win32 platforms there is no difference between ProcessLine() and ProcessLineSync(). The possible error codes are defined by TInterpreter::EErrorCode. In particular, error will equal to TInterpreter::kProcessing until the CINT interpreted thread has finished executing the line. Returns the result of the command, cast to a Longptr_t. ; Definition at line 2370 of file TROOT.cxx. ◆ ProcessLineFast(). Longptr_t TROOT::ProcessLineFast ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command directly via CINT interpreter. ; Only executable statements are allowed (no variable declarations), In all other cases use TROOT::ProcessLine(). The possible error codes are defined by TInterpreter::EErrorCode. ; Definition at line 2407 of file TROOT.cxx. ◆ ProcessLineSync(). Longptr_t TROOT::ProcessLineSync ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplication::ProcessLine(). ; On Win32 the line will be processed synchronously (i.e. it will only return when the CINT interpreter thread has finished executing the line). On non-Win32 platforms there is no difference between ProcessLine() and ProcessLineSync(). The possible error codes are defined by TInterpreter::EErrorCode. Returns the result of the command, cast to a Longptr_t. ; Definition at line 2390 of file TROOT.cxx. ◆ ReadGitInfo(). void TROOT::ReadGitInfo ; (; ). protected . Read Git commit SHA1 and branch name. ; Read Git commit information and branch name from the etc/gitinfo.txt file. ; Definition at line 2429 of file TROOT.cxx. ◆ ReadingObject(). Bool_t TROOT::ReadingObject ; (; ); const. Deprecated (will be removed in next release). ; Definition at line 2460 of file TROOT.cxx. ◆ RecursiveRemove(). void TROOT::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Recursively remove this object from the list of Cleanu",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:71162,Availability,error,error,71162,"he CINT interpreted thread has finished executing the line. Returns the result of the command, cast to a Longptr_t. ; Definition at line 2370 of file TROOT.cxx. ◆ ProcessLineFast(). Longptr_t TROOT::ProcessLineFast ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command directly via CINT interpreter. ; Only executable statements are allowed (no variable declarations), In all other cases use TROOT::ProcessLine(). The possible error codes are defined by TInterpreter::EErrorCode. ; Definition at line 2407 of file TROOT.cxx. ◆ ProcessLineSync(). Longptr_t TROOT::ProcessLineSync ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplication::ProcessLine(). ; On Win32 the line will be processed synchronously (i.e. it will only return when the CINT interpreter thread has finished executing the line). On non-Win32 platforms there is no difference between ProcessLine() and ProcessLineSync(). The possible error codes are defined by TInterpreter::EErrorCode. Returns the result of the command, cast to a Longptr_t. ; Definition at line 2390 of file TROOT.cxx. ◆ ReadGitInfo(). void TROOT::ReadGitInfo ; (; ). protected . Read Git commit SHA1 and branch name. ; Read Git commit information and branch name from the etc/gitinfo.txt file. ; Definition at line 2429 of file TROOT.cxx. ◆ ReadingObject(). Bool_t TROOT::ReadingObject ; (; ); const. Deprecated (will be removed in next release). ; Definition at line 2460 of file TROOT.cxx. ◆ RecursiveRemove(). void TROOT::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Recursively remove this object from the list of Cleanups. ; Typically RecursiveRemove is implemented by classes that can contain mulitple references to a same object or shared ownership of the object with others. ; Reimplemented from TDirectory.; Definition at line 2498 of file TROOT.cxx. ◆ RefreshBrowsers(). void TROOT::RefreshBrowsers ; (; ). Refresh all browsers. ; Call this method when some com",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:75162,Availability,avail,available,75162,"set from within an interpreted function will lead to the unloading of the dictionary and source file, including the one defining the function being executed. ; Definition at line 2651 of file TROOT.cxx. ◆ ResetClassSaved(). void TROOT::ResetClassSaved ; (; ). Reset the ClassSaved status of all classes. ; Definition at line 1096 of file TROOT.cxx. ◆ RootVersionCode(). Int_t TROOT::RootVersionCode ; (; ). static . Return ROOT version code as defined in RVersion.h. ; Definition at line 2941 of file TROOT.cxx. ◆ SaveContext(). void TROOT::SaveContext ; (; ). Save the current interpreter context. ; Definition at line 2671 of file TROOT.cxx. ◆ SetApplication(). void TROOT::SetApplication ; (; TApplication * ; app). inline . Definition at line 317 of file TROOT.h. ◆ SetBatch(). void TROOT::SetBatch ; (; Bool_t ; batch = kTRUE). Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graphics. ; If web graphics runs in server mode, the web widgets are still available via URL ; Definition at line 2803 of file TROOT.cxx. ◆ SetCutClassName(). void TROOT::SetCutClassName ; (; const char * ; name = ""TCutG""). Set the default graphical cut class name for the graphics editor By default the graphics editor creates an instance of a class TCutG. ; This function may be called to specify a different class that MUST derive from TCutG ; Definition at line 2683 of file TROOT.cxx. ◆ SetDefCanvasName(). void TROOT::SetDefCanvasName ; (; const char * ; name = ""c1""). inline . Definition at line 321 of file TROOT.h. ◆ SetDirLevel(). void TROOT::SetDirLevel ; (; Int_t ; level = 0). static . Return Indentation level for ls(). ; Definition at line 2914 of file TROOT.cxx. ◆ SetEditHistograms(). void TROOT::SetEditHistograms ; (; Bool_t ; flag = kTRUE). inline . Definition at line 322 of file TROOT.h. ◆ SetEditorMode(). void TROOT::SetEditorMode ; (; const char * ; mode = """"). Set editor mode. ; Definition at line 2704 of file TROOT.cxx. ◆ SetEscape(). void TR",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:78690,Availability,avail,available,78690,"OT::SetSelectedPrimitive ; (; const TObject * ; obj). inline . Definition at line 332 of file TROOT.h. ◆ SetStyle(). void TROOT::SetStyle ; (; const char * ; stylename = ""Default""). Change current style to style with name stylename. ; Definition at line 2730 of file TROOT.cxx. ◆ SetWebDisplay(). void TROOT::SetWebDisplay ; (; const char * ; webdisplay = """"). Specify where web graphics shall be rendered. ; The input parameter webdisplay defines where web graphics is rendered. webdisplay parameter may contain:. ""firefox"": select Mozilla Firefox browser for interactive web display; ""chrome"": select Google Chrome browser for interactive web display; ""edge"": select Microsoft Edge browser for interactive web display; ""native"": select one of the natively-supported web browsers firefox/chrome/edge for interactive web display; ""qt5"": uses QWebEngine from Qt5, no real http server started (requires qt5web component build for ROOT); ""qt6"": uses QWebEngine from Qt6, no real http server started (requires qt6web component build for ROOT); ""cef"": uses Chromium Embeded Framework, no real http server started (requires cefweb component build for ROOT); ""local"": select on of available local (without http server) engines like qt5/qt6/cef; ""default"": system default web browser, invoked with xdg-open on Linux, start on Mac or open on Windows; ""on"": try ""local"", then ""native"", then ""default"" option; ""off"": turns off the web display and comes back to normal graphics in interactive mode.; ""server:port"": turns the web display into server mode with specified port. Web widgets will not be displayed, only text message with window URL will be printed on standard output . Definition at line 2831 of file TROOT.cxx. ◆ ShutDown(). void TROOT::ShutDown ; (; ). static . Shut down ROOT. ; Definition at line 3136 of file TROOT.cxx. ◆ Streamer(). void TROOT::Streamer ; (; TBuffer & ; R__b). overridevirtual . TDirectory Streamer. ; Reimplemented from TDirectory. ◆ StreamerNVirtual(). void TROOT::StreamerNV",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:79285,Availability,down,down,79285," browsers firefox/chrome/edge for interactive web display; ""qt5"": uses QWebEngine from Qt5, no real http server started (requires qt5web component build for ROOT); ""qt6"": uses QWebEngine from Qt6, no real http server started (requires qt6web component build for ROOT); ""cef"": uses Chromium Embeded Framework, no real http server started (requires cefweb component build for ROOT); ""local"": select on of available local (without http server) engines like qt5/qt6/cef; ""default"": system default web browser, invoked with xdg-open on Linux, start on Mac or open on Windows; ""on"": try ""local"", then ""native"", then ""default"" option; ""off"": turns off the web display and comes back to normal graphics in interactive mode.; ""server:port"": turns the web display into server mode with specified port. Web widgets will not be displayed, only text message with window URL will be printed on standard output . Definition at line 2831 of file TROOT.cxx. ◆ ShutDown(). void TROOT::ShutDown ; (; ). static . Shut down ROOT. ; Definition at line 3136 of file TROOT.cxx. ◆ Streamer(). void TROOT::Streamer ; (; TBuffer & ; R__b). overridevirtual . TDirectory Streamer. ; Reimplemented from TDirectory. ◆ StreamerNVirtual(). void TROOT::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 372 of file TROOT.h. ◆ Time(). void TROOT::Time ; (; Int_t ; casetime = 1). inline . Definition at line 335 of file TROOT.h. ◆ Timer(). Int_t TROOT::Timer ; (; ); const. inline . Definition at line 336 of file TROOT.h. Friends And Related Symbol Documentation. ◆ ::ROOT::Internal::TROOTAllocator. friend class ::ROOT::Internal::TROOTAllocator. friend . Definition at line 181 of file TROOT.h. ◆ ROOT::Internal::GetROOT2. TROOT * ROOT::Internal::GetROOT2 ; (; ). friend . ◆ TCling. friend class TCling. friend . Definition at line 96 of file TROOT.h. Member Data Documentation. ◆ fApplication. std::atomic<TApplication*> TROOT::fApplication. protected . Pointer to current application. ; De",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:11460,Deployability,release,release,11460,"n used by TClass::GetClass(). ;  ; Int_t LoadMacro (const char *filename, Int_t *error=nullptr, Bool_t check=kFALSE);  Load a macro in the interpreter's memory. ;  ; void ls (Option_t *option="""") const override;  To list all objects of the application. ;  ; Longptr_t Macro (const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE);  Execute a macro in the interpreter. ;  ; TCanvas * MakeDefCanvas () const;  Return a default canvas. ;  ; void Message (Int_t id, const TObject *obj);  Process message id called by obj. ;  ; Bool_t MustClean () const;  ; Longptr_t ProcessLine (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Longptr_t ProcessLineFast (const char *line, Int_t *error=nullptr);  Process interpreter command directly via CINT interpreter. ;  ; Longptr_t ProcessLineSync (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Bool_t ReadingObject () const;  Deprecated (will be removed in next release). ;  ; void RecursiveRemove (TObject *obj) override;  Recursively remove this object from the list of Cleanups. ;  ; void RefreshBrowsers ();  Refresh all browsers. ;  ; TObject * Remove (TObject *) override;  Remove an object from the in-memory list. ;  ; void RemoveClass (TClass *);  Remove a class from the list and map of classes. ;  ; void Reset (Option_t *option="""");  Delete all global interpreter objects created since the last call to Reset. ;  ; void ResetClassSaved ();  Reset the ClassSaved status of all classes. ;  ; void SaveContext ();  Save the current interpreter context. ;  ; void SetApplication (TApplication *app);  ; void SetBatch (Bool_t batch=kTRUE);  Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graphics. ;  ; void SetCutClassName (const char *name=""TCutG"");  Set the default graphical cut class name for the graphics editor By default the graphics editor creates an instance of a ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:27421,Deployability,install,installation,27421,"ual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  . Static Public Member Functions; static const std::vector< std::string > & AddExtraInterpreterArgs (const std::vector< std::string > &args);  Provide command line arguments to the interpreter construction. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Int_t ConvertVersionCode2Int (Int_t code);  Convert version code to an integer, i.e. 331527 -> 51507. ;  ; static Int_t ConvertVersionInt2Code (Int_t v);  Convert version as an integer to version code as used in RVersion.h. ;  ; static const char * DeclFileName ();  ; static Int_t DecreaseDirLevel ();  Decrease the indentation level for ls(). ;  ; static const TString & GetBinDir ();  Get the binary directory in the installation. Static utility function. ;  ; static const TString & GetDataDir ();  Get the data directory in the installation. Static utility function. ;  ; static Int_t GetDirLevel ();  return directory level ;  ; static const TString & GetDocDir ();  Get the documentation directory in the installation. Static utility function. ;  ; static const TString & GetEtcDir ();  Get the sysconfig directory in the installation. Static utility function. ;  ; static const char **& GetExtraInterpreterArgs ();  INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ;  ; static const TString & GetIconPath ();  Get the icon path in the installation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TStrin",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:27534,Deployability,install,installation,27534,"s::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  . Static Public Member Functions; static const std::vector< std::string > & AddExtraInterpreterArgs (const std::vector< std::string > &args);  Provide command line arguments to the interpreter construction. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Int_t ConvertVersionCode2Int (Int_t code);  Convert version code to an integer, i.e. 331527 -> 51507. ;  ; static Int_t ConvertVersionInt2Code (Int_t v);  Convert version as an integer to version code as used in RVersion.h. ;  ; static const char * DeclFileName ();  ; static Int_t DecreaseDirLevel ();  Decrease the indentation level for ls(). ;  ; static const TString & GetBinDir ();  Get the binary directory in the installation. Static utility function. ;  ; static const TString & GetDataDir ();  Get the data directory in the installation. Static utility function. ;  ; static Int_t GetDirLevel ();  return directory level ;  ; static const TString & GetDocDir ();  Get the documentation directory in the installation. Static utility function. ;  ; static const TString & GetEtcDir ();  Get the sysconfig directory in the installation. Static utility function. ;  ; static const char **& GetExtraInterpreterArgs ();  INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ;  ; static const TString & GetIconPath ();  Get the icon path in the installation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:27713,Deployability,install,installation,27713,"rning message. ;  . Static Public Member Functions; static const std::vector< std::string > & AddExtraInterpreterArgs (const std::vector< std::string > &args);  Provide command line arguments to the interpreter construction. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Int_t ConvertVersionCode2Int (Int_t code);  Convert version code to an integer, i.e. 331527 -> 51507. ;  ; static Int_t ConvertVersionInt2Code (Int_t v);  Convert version as an integer to version code as used in RVersion.h. ;  ; static const char * DeclFileName ();  ; static Int_t DecreaseDirLevel ();  Decrease the indentation level for ls(). ;  ; static const TString & GetBinDir ();  Get the binary directory in the installation. Static utility function. ;  ; static const TString & GetDataDir ();  Get the data directory in the installation. Static utility function. ;  ; static Int_t GetDirLevel ();  return directory level ;  ; static const TString & GetDocDir ();  Get the documentation directory in the installation. Static utility function. ;  ; static const TString & GetEtcDir ();  Get the sysconfig directory in the installation. Static utility function. ;  ; static const char **& GetExtraInterpreterArgs ();  INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ;  ; static const TString & GetIconPath ();  Get the icon path in the installation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char * GetMacroPath ();  Get macro search path. Static utility function. ;  ; static const TString & GetRootSys ();  Get the rootsys directory in the ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:27830,Deployability,install,installation,27830,"g > &args);  Provide command line arguments to the interpreter construction. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Int_t ConvertVersionCode2Int (Int_t code);  Convert version code to an integer, i.e. 331527 -> 51507. ;  ; static Int_t ConvertVersionInt2Code (Int_t v);  Convert version as an integer to version code as used in RVersion.h. ;  ; static const char * DeclFileName ();  ; static Int_t DecreaseDirLevel ();  Decrease the indentation level for ls(). ;  ; static const TString & GetBinDir ();  Get the binary directory in the installation. Static utility function. ;  ; static const TString & GetDataDir ();  Get the data directory in the installation. Static utility function. ;  ; static Int_t GetDirLevel ();  return directory level ;  ; static const TString & GetDocDir ();  Get the documentation directory in the installation. Static utility function. ;  ; static const TString & GetEtcDir ();  Get the sysconfig directory in the installation. Static utility function. ;  ; static const char **& GetExtraInterpreterArgs ();  INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ;  ; static const TString & GetIconPath ();  Get the icon path in the installation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char * GetMacroPath ();  Get macro search path. Static utility function. ;  ; static const TString & GetRootSys ();  Get the rootsys directory in the installation. Static utility function. ;  ; static const TString & GetSharedLibDir ();  Get the shared libraries directory in the installation. Stat",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:28093,Deployability,install,installation,28093,"e to an integer, i.e. 331527 -> 51507. ;  ; static Int_t ConvertVersionInt2Code (Int_t v);  Convert version as an integer to version code as used in RVersion.h. ;  ; static const char * DeclFileName ();  ; static Int_t DecreaseDirLevel ();  Decrease the indentation level for ls(). ;  ; static const TString & GetBinDir ();  Get the binary directory in the installation. Static utility function. ;  ; static const TString & GetDataDir ();  Get the data directory in the installation. Static utility function. ;  ; static Int_t GetDirLevel ();  return directory level ;  ; static const TString & GetDocDir ();  Get the documentation directory in the installation. Static utility function. ;  ; static const TString & GetEtcDir ();  Get the sysconfig directory in the installation. Static utility function. ;  ; static const char **& GetExtraInterpreterArgs ();  INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ;  ; static const TString & GetIconPath ();  Get the icon path in the installation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char * GetMacroPath ();  Get macro search path. Static utility function. ;  ; static const TString & GetRootSys ();  Get the rootsys directory in the installation. Static utility function. ;  ; static const TString & GetSharedLibDir ();  Get the shared libraries directory in the installation. Static utility function. ;  ; static const TString & GetSourceDir ();  Get the source directory in the installation. Static utility function. ;  ; static const TString & GetTTFFontDir ();  Get the fonts directory in the installation. Static utility function. ;  ; static ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:28212,Deployability,install,installation,28212,integer to version code as used in RVersion.h. ;  ; static const char * DeclFileName ();  ; static Int_t DecreaseDirLevel ();  Decrease the indentation level for ls(). ;  ; static const TString & GetBinDir ();  Get the binary directory in the installation. Static utility function. ;  ; static const TString & GetDataDir ();  Get the data directory in the installation. Static utility function. ;  ; static Int_t GetDirLevel ();  return directory level ;  ; static const TString & GetDocDir ();  Get the documentation directory in the installation. Static utility function. ;  ; static const TString & GetEtcDir ();  Get the sysconfig directory in the installation. Static utility function. ;  ; static const char **& GetExtraInterpreterArgs ();  INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ;  ; static const TString & GetIconPath ();  Get the icon path in the installation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char * GetMacroPath ();  Get macro search path. Static utility function. ;  ; static const TString & GetRootSys ();  Get the rootsys directory in the installation. Static utility function. ;  ; static const TString & GetSharedLibDir ();  Get the shared libraries directory in the installation. Static utility function. ;  ; static const TString & GetSourceDir ();  Get the source directory in the installation. Static utility function. ;  ; static const TString & GetTTFFontDir ();  Get the fonts directory in the installation. Static utility function. ;  ; static const TString & GetTutorialDir ();  Get the tutorials directory in the installation. Static utility function. ;  ;,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:28327,Deployability,install,installation,28327,evel ();  Decrease the indentation level for ls(). ;  ; static const TString & GetBinDir ();  Get the binary directory in the installation. Static utility function. ;  ; static const TString & GetDataDir ();  Get the data directory in the installation. Static utility function. ;  ; static Int_t GetDirLevel ();  return directory level ;  ; static const TString & GetDocDir ();  Get the documentation directory in the installation. Static utility function. ;  ; static const TString & GetEtcDir ();  Get the sysconfig directory in the installation. Static utility function. ;  ; static const char **& GetExtraInterpreterArgs ();  INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ;  ; static const TString & GetIconPath ();  Get the icon path in the installation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char * GetMacroPath ();  Get macro search path. Static utility function. ;  ; static const TString & GetRootSys ();  Get the rootsys directory in the installation. Static utility function. ;  ; static const TString & GetSharedLibDir ();  Get the shared libraries directory in the installation. Static utility function. ;  ; static const TString & GetSourceDir ();  Get the source directory in the installation. Static utility function. ;  ; static const TString & GetTTFFontDir ();  Get the fonts directory in the installation. Static utility function. ;  ; static const TString & GetTutorialDir ();  Get the tutorials directory in the installation. Static utility function. ;  ; static const char * GetTutorialsDir ();  Get the tutorials directory in the installation. ;  ; static Int_t Increase,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:28442,Deployability,install,installation,28442,ory in the installation. Static utility function. ;  ; static const TString & GetDataDir ();  Get the data directory in the installation. Static utility function. ;  ; static Int_t GetDirLevel ();  return directory level ;  ; static const TString & GetDocDir ();  Get the documentation directory in the installation. Static utility function. ;  ; static const TString & GetEtcDir ();  Get the sysconfig directory in the installation. Static utility function. ;  ; static const char **& GetExtraInterpreterArgs ();  INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ;  ; static const TString & GetIconPath ();  Get the icon path in the installation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char * GetMacroPath ();  Get macro search path. Static utility function. ;  ; static const TString & GetRootSys ();  Get the rootsys directory in the installation. Static utility function. ;  ; static const TString & GetSharedLibDir ();  Get the shared libraries directory in the installation. Static utility function. ;  ; static const TString & GetSourceDir ();  Get the source directory in the installation. Static utility function. ;  ; static const TString & GetTTFFontDir ();  Get the fonts directory in the installation. Static utility function. ;  ; static const TString & GetTutorialDir ();  Get the tutorials directory in the installation. Static utility function. ;  ; static const char * GetTutorialsDir ();  Get the tutorials directory in the installation. ;  ; static Int_t IncreaseDirLevel ();  Increase the indentation level for ls(). ;  ; static void IndentLevel ();  Functions used by ls() to ,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:28649,Deployability,install,installation,28649,irectory level ;  ; static const TString & GetDocDir ();  Get the documentation directory in the installation. Static utility function. ;  ; static const TString & GetEtcDir ();  Get the sysconfig directory in the installation. Static utility function. ;  ; static const char **& GetExtraInterpreterArgs ();  INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ;  ; static const TString & GetIconPath ();  Get the icon path in the installation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char * GetMacroPath ();  Get macro search path. Static utility function. ;  ; static const TString & GetRootSys ();  Get the rootsys directory in the installation. Static utility function. ;  ; static const TString & GetSharedLibDir ();  Get the shared libraries directory in the installation. Static utility function. ;  ; static const TString & GetSourceDir ();  Get the source directory in the installation. Static utility function. ;  ; static const TString & GetTTFFontDir ();  Get the fonts directory in the installation. Static utility function. ;  ; static const TString & GetTutorialDir ();  Get the tutorials directory in the installation. Static utility function. ;  ; static const char * GetTutorialsDir ();  Get the tutorials directory in the installation. ;  ; static Int_t IncreaseDirLevel ();  Increase the indentation level for ls(). ;  ; static void IndentLevel ();  Functions used by ls() to indent an object hierarchy. ;  ; static void Initialize ();  Initialize ROOT explicitly. ;  ; static Bool_t Initialized ();  Return kTRUE if the TROOT object has been initialized. ;  ; static void RegisterMo,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:28779,Deployability,install,installation,28779,"ty function. ;  ; static const TString & GetEtcDir ();  Get the sysconfig directory in the installation. Static utility function. ;  ; static const char **& GetExtraInterpreterArgs ();  INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ;  ; static const TString & GetIconPath ();  Get the icon path in the installation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char * GetMacroPath ();  Get macro search path. Static utility function. ;  ; static const TString & GetRootSys ();  Get the rootsys directory in the installation. Static utility function. ;  ; static const TString & GetSharedLibDir ();  Get the shared libraries directory in the installation. Static utility function. ;  ; static const TString & GetSourceDir ();  Get the source directory in the installation. Static utility function. ;  ; static const TString & GetTTFFontDir ();  Get the fonts directory in the installation. Static utility function. ;  ; static const TString & GetTutorialDir ();  Get the tutorials directory in the installation. Static utility function. ;  ; static const char * GetTutorialsDir ();  Get the tutorials directory in the installation. ;  ; static Int_t IncreaseDirLevel ();  Increase the indentation level for ls(). ;  ; static void IndentLevel ();  Functions used by ls() to indent an object hierarchy. ;  ; static void Initialize ();  Initialize ROOT explicitly. ;  ; static Bool_t Initialized ();  Return kTRUE if the TROOT object has been initialized. ;  ; static void RegisterModule (const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDecl",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:28896,Deployability,install,installation,28896,"tion. ;  ; static const char **& GetExtraInterpreterArgs ();  INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ;  ; static const TString & GetIconPath ();  Get the icon path in the installation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char * GetMacroPath ();  Get macro search path. Static utility function. ;  ; static const TString & GetRootSys ();  Get the rootsys directory in the installation. Static utility function. ;  ; static const TString & GetSharedLibDir ();  Get the shared libraries directory in the installation. Static utility function. ;  ; static const TString & GetSourceDir ();  Get the source directory in the installation. Static utility function. ;  ; static const TString & GetTTFFontDir ();  Get the fonts directory in the installation. Static utility function. ;  ; static const TString & GetTutorialDir ();  Get the tutorials directory in the installation. Static utility function. ;  ; static const char * GetTutorialsDir ();  Get the tutorials directory in the installation. ;  ; static Int_t IncreaseDirLevel ();  Increase the indentation level for ls(). ;  ; static void IndentLevel ();  Functions used by ls() to indent an object hierarchy. ;  ; static void Initialize ();  Initialize ROOT explicitly. ;  ; static Bool_t Initialized ();  Return kTRUE if the TROOT object has been initialized. ;  ; static void RegisterModule (const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCx",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:29013,Deployability,install,installation,29013,"ter arguments through a C-interface layer. ;  ; static const TString & GetIconPath ();  Get the icon path in the installation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char * GetMacroPath ();  Get macro search path. Static utility function. ;  ; static const TString & GetRootSys ();  Get the rootsys directory in the installation. Static utility function. ;  ; static const TString & GetSharedLibDir ();  Get the shared libraries directory in the installation. Static utility function. ;  ; static const TString & GetSourceDir ();  Get the source directory in the installation. Static utility function. ;  ; static const TString & GetTTFFontDir ();  Get the fonts directory in the installation. Static utility function. ;  ; static const TString & GetTutorialDir ();  Get the tutorials directory in the installation. Static utility function. ;  ; static const char * GetTutorialsDir ();  Get the tutorials directory in the installation. ;  ; static Int_t IncreaseDirLevel ();  Increase the indentation level for ls(). ;  ; static void IndentLevel ();  Functions used by ls() to indent an object hierarchy. ;  ; static void Initialize ();  Initialize ROOT explicitly. ;  ; static Bool_t Initialized ();  Return kTRUE if the TROOT object has been initialized. ;  ; static void RegisterModule (const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false);  Called by static dictionary initialization to register clang modules for headers. ;  ; static Int_t ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:29135,Deployability,install,installation,29135,"lation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char * GetMacroPath ();  Get macro search path. Static utility function. ;  ; static const TString & GetRootSys ();  Get the rootsys directory in the installation. Static utility function. ;  ; static const TString & GetSharedLibDir ();  Get the shared libraries directory in the installation. Static utility function. ;  ; static const TString & GetSourceDir ();  Get the source directory in the installation. Static utility function. ;  ; static const TString & GetTTFFontDir ();  Get the fonts directory in the installation. Static utility function. ;  ; static const TString & GetTutorialDir ();  Get the tutorials directory in the installation. Static utility function. ;  ; static const char * GetTutorialsDir ();  Get the tutorials directory in the installation. ;  ; static Int_t IncreaseDirLevel ();  Increase the indentation level for ls(). ;  ; static void IndentLevel ();  Functions used by ls() to indent an object hierarchy. ;  ; static void Initialize ();  Initialize ROOT explicitly. ;  ; static Bool_t Initialized ();  Return kTRUE if the TROOT object has been initialized. ;  ; static void RegisterModule (const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false);  Called by static dictionary initialization to register clang modules for headers. ;  ; static Int_t RootVersionCode ();  Return ROOT version code as defined in RVersion.h. ;  ; static void SetDirLevel (Int_t level=0);  R",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:29255,Deployability,install,installation,29255,"tion. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char * GetMacroPath ();  Get macro search path. Static utility function. ;  ; static const TString & GetRootSys ();  Get the rootsys directory in the installation. Static utility function. ;  ; static const TString & GetSharedLibDir ();  Get the shared libraries directory in the installation. Static utility function. ;  ; static const TString & GetSourceDir ();  Get the source directory in the installation. Static utility function. ;  ; static const TString & GetTTFFontDir ();  Get the fonts directory in the installation. Static utility function. ;  ; static const TString & GetTutorialDir ();  Get the tutorials directory in the installation. Static utility function. ;  ; static const char * GetTutorialsDir ();  Get the tutorials directory in the installation. ;  ; static Int_t IncreaseDirLevel ();  Increase the indentation level for ls(). ;  ; static void IndentLevel ();  Functions used by ls() to indent an object hierarchy. ;  ; static void Initialize ();  Initialize ROOT explicitly. ;  ; static Bool_t Initialized ();  Return kTRUE if the TROOT object has been initialized. ;  ; static void RegisterModule (const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false);  Called by static dictionary initialization to register clang modules for headers. ;  ; static Int_t RootVersionCode ();  Return ROOT version code as defined in RVersion.h. ;  ; static void SetDirLevel (Int_t level=0);  Return Indentation level for ls(). ;  ; static void SetMacroPath (const char *newpath);  Set or extend the macro search pa",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:48241,Deployability,install,installation,48241,"t geometry; List of matrices in current geometry; List of Nodes in current geometry; Current Directory in memory; Current Directory on file . Definition at line 1367 of file TROOT.cxx. ◆ FindSTLClass(). TClass * TROOT::FindSTLClass ; (; const char * ; name, . Bool_t ; load, . Bool_t ; silent = kFALSE . ); const. return a TClass object corresponding to 'name' assuming it is an STL container. ; In particular we looking for possible alternative name (default template parameter, typedefs template arguments, typedefed name). ; Definition at line 1484 of file TROOT.cxx. ◆ ForceStyle(). void TROOT::ForceStyle ; (; Bool_t ; force = kTRUE). inline . Definition at line 206 of file TROOT.h. ◆ FromPopUp(). Bool_t TROOT::FromPopUp ; (; ); const. inline . Definition at line 207 of file TROOT.h. ◆ GetApplication(). TApplication * TROOT::GetApplication ; (; ); const. inline . Definition at line 209 of file TROOT.h. ◆ GetBinDir(). const TString & TROOT::GetBinDir ; (; ). static . Get the binary directory in the installation. Static utility function. ; Definition at line 2989 of file TROOT.cxx. ◆ GetBuiltDate(). Int_t TROOT::GetBuiltDate ; (; ); const. inline . Definition at line 221 of file TROOT.h. ◆ GetBuiltTime(). Int_t TROOT::GetBuiltTime ; (; ); const. inline . Definition at line 222 of file TROOT.h. ◆ GetClass() [1/2]. TClass * TROOT::GetClass ; (; const char * ; name, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ); const. Return pointer to class with name. Obsolete, use TClass::GetClass directly. ; Definition at line 1518 of file TROOT.cxx. ◆ GetClass() [2/2]. TClass * TROOT::GetClass ; (; const std::type_info & ; typeinfo, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ); const. Return pointer to class from its name. ; Obsolete, use TClass::GetClass directly See TClass::GetClass ; Definition at line 1528 of file TROOT.cxx. ◆ GetClipboard(). TSeqCollection * TROOT::GetClipboard ; (; ); const. inline . Definition at line 254 of file TROOT.h. ◆ GetColor(). TColo",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:49832,Deployability,install,installation,49832," * TROOT::GetClass ; (; const std::type_info & ; typeinfo, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ); const. Return pointer to class from its name. ; Obsolete, use TClass::GetClass directly See TClass::GetClass ; Definition at line 1528 of file TROOT.cxx. ◆ GetClipboard(). TSeqCollection * TROOT::GetClipboard ; (; ); const. inline . Definition at line 254 of file TROOT.h. ◆ GetColor(). TColor * TROOT::GetColor ; (; Int_t ; color); const. Return address of color with index color. ; Definition at line 1536 of file TROOT.cxx. ◆ GetConfigFeatures(). const char * TROOT::GetConfigFeatures ; (; ); const. inline . Definition at line 215 of file TROOT.h. ◆ GetConfigOptions(). const char * TROOT::GetConfigOptions ; (; ); const. inline . Definition at line 214 of file TROOT.h. ◆ GetCutClassName(). const char * TROOT::GetCutClassName ; (; ); const. inline . Definition at line 216 of file TROOT.h. ◆ GetDataDir(). const TString & TROOT::GetDataDir ; (; ). static . Get the data directory in the installation. Static utility function. ; Definition at line 3062 of file TROOT.cxx. ◆ GetDefCanvasName(). const char * TROOT::GetDefCanvasName ; (; ); const. inline . Definition at line 217 of file TROOT.h. ◆ GetDirLevel(). Int_t TROOT::GetDirLevel ; (; ). static . return directory level ; Definition at line 2754 of file TROOT.cxx. ◆ GetDocDir(). const TString & TROOT::GetDocDir ; (; ). static . Get the documentation directory in the installation. Static utility function. ; Definition at line 3078 of file TROOT.cxx. ◆ GetEditHistograms(). Bool_t TROOT::GetEditHistograms ; (; ); const. inline . Definition at line 218 of file TROOT.h. ◆ GetEditorMode(). Int_t TROOT::GetEditorMode ; (; ); const. inline . Definition at line 219 of file TROOT.h. ◆ GetEtcDir(). const TString & TROOT::GetEtcDir ; (; ). static . Get the sysconfig directory in the installation. Static utility function. ; Definition at line 3052 of file TROOT.cxx. ◆ GetExtraInterpreterArgs(). const char **& TROOT::GetEx",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:50270,Deployability,install,installation,50270,Int_t ; color); const. Return address of color with index color. ; Definition at line 1536 of file TROOT.cxx. ◆ GetConfigFeatures(). const char * TROOT::GetConfigFeatures ; (; ); const. inline . Definition at line 215 of file TROOT.h. ◆ GetConfigOptions(). const char * TROOT::GetConfigOptions ; (; ); const. inline . Definition at line 214 of file TROOT.h. ◆ GetCutClassName(). const char * TROOT::GetCutClassName ; (; ); const. inline . Definition at line 216 of file TROOT.h. ◆ GetDataDir(). const TString & TROOT::GetDataDir ; (; ). static . Get the data directory in the installation. Static utility function. ; Definition at line 3062 of file TROOT.cxx. ◆ GetDefCanvasName(). const char * TROOT::GetDefCanvasName ; (; ); const. inline . Definition at line 217 of file TROOT.h. ◆ GetDirLevel(). Int_t TROOT::GetDirLevel ; (; ). static . return directory level ; Definition at line 2754 of file TROOT.cxx. ◆ GetDocDir(). const TString & TROOT::GetDocDir ; (; ). static . Get the documentation directory in the installation. Static utility function. ; Definition at line 3078 of file TROOT.cxx. ◆ GetEditHistograms(). Bool_t TROOT::GetEditHistograms ; (; ); const. inline . Definition at line 218 of file TROOT.h. ◆ GetEditorMode(). Int_t TROOT::GetEditorMode ; (; ); const. inline . Definition at line 219 of file TROOT.h. ◆ GetEtcDir(). const TString & TROOT::GetEtcDir ; (; ). static . Get the sysconfig directory in the installation. Static utility function. ; Definition at line 3052 of file TROOT.cxx. ◆ GetExtraInterpreterArgs(). const char **& TROOT::GetExtraInterpreterArgs ; (; ). static . INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ; Definition at line 2962 of file TROOT.cxx. ◆ GetFile() [1/2]. TFile * TROOT::GetFile ; (; ); const. inlineoverridevirtual . Reimplemented from TDirectory.; Definition at line 260 of file TROOT.h. ◆ GetFile() [2/2]. TFile * TROOT::GetFile ; (; const char * ; name); const. Return pointer to file wit,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:50683,Deployability,install,installation,50683,; (; ); const. inline . Definition at line 216 of file TROOT.h. ◆ GetDataDir(). const TString & TROOT::GetDataDir ; (; ). static . Get the data directory in the installation. Static utility function. ; Definition at line 3062 of file TROOT.cxx. ◆ GetDefCanvasName(). const char * TROOT::GetDefCanvasName ; (; ); const. inline . Definition at line 217 of file TROOT.h. ◆ GetDirLevel(). Int_t TROOT::GetDirLevel ; (; ). static . return directory level ; Definition at line 2754 of file TROOT.cxx. ◆ GetDocDir(). const TString & TROOT::GetDocDir ; (; ). static . Get the documentation directory in the installation. Static utility function. ; Definition at line 3078 of file TROOT.cxx. ◆ GetEditHistograms(). Bool_t TROOT::GetEditHistograms ; (; ); const. inline . Definition at line 218 of file TROOT.h. ◆ GetEditorMode(). Int_t TROOT::GetEditorMode ; (; ); const. inline . Definition at line 219 of file TROOT.h. ◆ GetEtcDir(). const TString & TROOT::GetEtcDir ; (; ). static . Get the sysconfig directory in the installation. Static utility function. ; Definition at line 3052 of file TROOT.cxx. ◆ GetExtraInterpreterArgs(). const char **& TROOT::GetExtraInterpreterArgs ; (; ). static . INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ; Definition at line 2962 of file TROOT.cxx. ◆ GetFile() [1/2]. TFile * TROOT::GetFile ; (; ); const. inlineoverridevirtual . Reimplemented from TDirectory.; Definition at line 260 of file TROOT.h. ◆ GetFile() [2/2]. TFile * TROOT::GetFile ; (; const char * ; name); const. Return pointer to file with name. ; Definition at line 1570 of file TROOT.cxx. ◆ GetForceStyle(). Bool_t TROOT::GetForceStyle ; (; ); const. inline . Definition at line 220 of file TROOT.h. ◆ GetFunction(). TObject * TROOT::GetFunction ; (; const char * ; name); const. Return pointer to function with name. ; Definition at line 1587 of file TROOT.cxx. ◆ GetFunctionTemplate(). TFunctionTemplate * TROOT::GetFunctionTemplate ; (; const char ,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:54032,Deployability,install,installation,54032,"st name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necessary, the list of global function. ; Definition at line 1663 of file TROOT.cxx. ◆ GetGlobalFunctionWithPrototype(). TFunction * TROOT::GetGlobalFunctionWithPrototype ; (; const char * ; function, . const char * ; proto = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If proto != 0 it will also resolve overloading. If load is true force reading of all currently defined global functions from CINT (more expensive). The proto string must be of the form: ""int, char*, float"". ; Definition at line 1718 of file TROOT.cxx. ◆ GetIconPath(). const TString & TROOT::GetIconPath ; (; ). static . Get the icon path in the installation. Static utility function. ; Definition at line 3168 of file TROOT.cxx. ◆ GetIncludeDir(). const TString & TROOT::GetIncludeDir ; (; ). static . Get the include directory in the installation. Static utility function. ; Definition at line 3042 of file TROOT.cxx. ◆ GetInterpreter(). TInterpreter * TROOT::GetInterpreter ; (; ); const. inline . Definition at line 210 of file TROOT.h. ◆ GetLibDir(). const TString & TROOT::GetLibDir ; (; ). static . Get the library directory in the installation. Static utility function. ; Definition at line 3010 of file TROOT.cxx. ◆ GetListOfBrowsables(). TList * TROOT::GetListOfBrowsables ; (; ); const. inline . Definition at line 258 of file TROOT.h. ◆ GetListOfBrowsers(). TSeqCollection * TROOT::GetListOfBrowsers ; (; ); const. inline . Definition at line 245 of file TROOT.h. ◆ GetListOfCanvases(). TSeqCollection * TROOT::GetListOfCanvases ; (; ); const. inline . Definition at line 240 of file TROOT.h. ◆ GetListOfClasses(). TCollection *",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:54222,Deployability,install,installation,54222,"at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necessary, the list of global function. ; Definition at line 1663 of file TROOT.cxx. ◆ GetGlobalFunctionWithPrototype(). TFunction * TROOT::GetGlobalFunctionWithPrototype ; (; const char * ; function, . const char * ; proto = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If proto != 0 it will also resolve overloading. If load is true force reading of all currently defined global functions from CINT (more expensive). The proto string must be of the form: ""int, char*, float"". ; Definition at line 1718 of file TROOT.cxx. ◆ GetIconPath(). const TString & TROOT::GetIconPath ; (; ). static . Get the icon path in the installation. Static utility function. ; Definition at line 3168 of file TROOT.cxx. ◆ GetIncludeDir(). const TString & TROOT::GetIncludeDir ; (; ). static . Get the include directory in the installation. Static utility function. ; Definition at line 3042 of file TROOT.cxx. ◆ GetInterpreter(). TInterpreter * TROOT::GetInterpreter ; (; ); const. inline . Definition at line 210 of file TROOT.h. ◆ GetLibDir(). const TString & TROOT::GetLibDir ; (; ). static . Get the library directory in the installation. Static utility function. ; Definition at line 3010 of file TROOT.cxx. ◆ GetListOfBrowsables(). TList * TROOT::GetListOfBrowsables ; (; ); const. inline . Definition at line 258 of file TROOT.h. ◆ GetListOfBrowsers(). TSeqCollection * TROOT::GetListOfBrowsers ; (; ); const. inline . Definition at line 245 of file TROOT.h. ◆ GetListOfCanvases(). TSeqCollection * TROOT::GetListOfCanvases ; (; ); const. inline . Definition at line 240 of file TROOT.h. ◆ GetListOfClasses(). TCollection * TROOT::GetListOfClasses ; (; ); const. inline . Definition at line 231 of file TROOT.h. ◆ GetListOfClassGenerators(). TCollection * TROOT::GetListOfClassGenerators ; (; ); const. inline",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:54525,Deployability,install,installation,54525,"::GetGlobalFunctionWithPrototype ; (; const char * ; function, . const char * ; proto = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If proto != 0 it will also resolve overloading. If load is true force reading of all currently defined global functions from CINT (more expensive). The proto string must be of the form: ""int, char*, float"". ; Definition at line 1718 of file TROOT.cxx. ◆ GetIconPath(). const TString & TROOT::GetIconPath ; (; ). static . Get the icon path in the installation. Static utility function. ; Definition at line 3168 of file TROOT.cxx. ◆ GetIncludeDir(). const TString & TROOT::GetIncludeDir ; (; ). static . Get the include directory in the installation. Static utility function. ; Definition at line 3042 of file TROOT.cxx. ◆ GetInterpreter(). TInterpreter * TROOT::GetInterpreter ; (; ); const. inline . Definition at line 210 of file TROOT.h. ◆ GetLibDir(). const TString & TROOT::GetLibDir ; (; ). static . Get the library directory in the installation. Static utility function. ; Definition at line 3010 of file TROOT.cxx. ◆ GetListOfBrowsables(). TList * TROOT::GetListOfBrowsables ; (; ); const. inline . Definition at line 258 of file TROOT.h. ◆ GetListOfBrowsers(). TSeqCollection * TROOT::GetListOfBrowsers ; (; ); const. inline . Definition at line 245 of file TROOT.h. ◆ GetListOfCanvases(). TSeqCollection * TROOT::GetListOfCanvases ; (; ); const. inline . Definition at line 240 of file TROOT.h. ◆ GetListOfClasses(). TCollection * TROOT::GetListOfClasses ; (; ); const. inline . Definition at line 231 of file TROOT.h. ◆ GetListOfClassGenerators(). TCollection * TROOT::GetListOfClassGenerators ; (; ); const. inline . Definition at line 251 of file TROOT.h. ◆ GetListOfCleanups(). TSeqCollection * TROOT::GetListOfCleanups ; (; ); const. inline . Definition at line 248 of file TROOT.h. ◆ GetListOfClosedObjects(). TSeqCollection * TROOT::GetListOfClosedObjects ; (; ); const. inline . Definition at line 236 of file T",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:56878,Deployability,update,update,56878,"inition at line 1754 of file TROOT.cxx. ◆ GetListOfFiles(). TSeqCollection * TROOT::GetListOfFiles ; (; ); const. inline . Definition at line 237 of file TROOT.h. ◆ GetListOfFunctionOverloads(). TCollection * TROOT::GetListOfFunctionOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 1672 of file TROOT.cxx. ◆ GetListOfFunctions(). TCollection * TROOT::GetListOfFunctions ; (; ); const. inline . Definition at line 242 of file TROOT.h. ◆ GetListOfFunctionTemplates(). TCollection * TROOT::GetListOfFunctionTemplates ; (; ). Definition at line 1771 of file TROOT.cxx. ◆ GetListOfGeometries(). TSeqCollection * TROOT::GetListOfGeometries ; (; ); const. inline . Definition at line 244 of file TROOT.h. ◆ GetListOfGlobalFunctions(). TCollection * TROOT::GetListOfGlobalFunctions ; (; Bool_t ; load = kFALSE). Return list containing the TFunctions currently defined. ; Since functions are created and deleted during execution of the program, we need to update the list of functions every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1826 of file TROOT.cxx. ◆ GetListOfGlobals(). TCollection * TROOT::GetListOfGlobals ; (; Bool_t ; load = kFALSE). Return list containing the TGlobals currently defined. ; Since globals are created and deleted during execution of the program, we need to update the list of globals every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1788 of file TROOT.cxx. ◆ GetListOfMappedFiles(). TSeqCollection * TROOT::GetListOfMappedFiles ; (; ); const. inline . Definition at line 238 of file TROOT.h. ◆ GetListOfMessageHandlers(). TSeqCollection * TROOT::GetListOfMessageHandlers ; (; ); const. inline . Definition at line 250 of file TROOT.",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:57350,Deployability,update,update,57350," line 242 of file TROOT.h. ◆ GetListOfFunctionTemplates(). TCollection * TROOT::GetListOfFunctionTemplates ; (; ). Definition at line 1771 of file TROOT.cxx. ◆ GetListOfGeometries(). TSeqCollection * TROOT::GetListOfGeometries ; (; ); const. inline . Definition at line 244 of file TROOT.h. ◆ GetListOfGlobalFunctions(). TCollection * TROOT::GetListOfGlobalFunctions ; (; Bool_t ; load = kFALSE). Return list containing the TFunctions currently defined. ; Since functions are created and deleted during execution of the program, we need to update the list of functions every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1826 of file TROOT.cxx. ◆ GetListOfGlobals(). TCollection * TROOT::GetListOfGlobals ; (; Bool_t ; load = kFALSE). Return list containing the TGlobals currently defined. ; Since globals are created and deleted during execution of the program, we need to update the list of globals every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1788 of file TROOT.cxx. ◆ GetListOfMappedFiles(). TSeqCollection * TROOT::GetListOfMappedFiles ; (; ); const. inline . Definition at line 238 of file TROOT.h. ◆ GetListOfMessageHandlers(). TSeqCollection * TROOT::GetListOfMessageHandlers ; (; ); const. inline . Definition at line 250 of file TROOT.h. ◆ GetListOfProofs(). TSeqCollection * TROOT::GetListOfProofs ; (; ); const. inline . Definition at line 253 of file TROOT.h. ◆ GetListOfSecContexts(). TSeqCollection * TROOT::GetListOfSecContexts ; (; ); const. inline . Definition at line 252 of file TROOT.h. ◆ GetListOfSockets(). TSeqCollection * TROOT::GetListOfSockets ; (; ); const. inline . Definition at line 239 of file TROOT.h. ◆ GetListOfSpecials(). TSeqCollection * TROOT::GetListOfSpecials ; (; ); const. in",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:59523,Deployability,install,installation,59523,"TROOT.h. ◆ GetListOfStyles(). TSeqCollection * TROOT::GetListOfStyles ; (; ); const. inline . Definition at line 241 of file TROOT.h. ◆ GetListOfTasks(). TSeqCollection * TROOT::GetListOfTasks ; (; ); const. inline . Definition at line 247 of file TROOT.h. ◆ GetListOfTypes(). TCollection * TROOT::GetListOfTypes ; (; Bool_t ; load = kFALSE). Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ; The list is populated on demand. Calling gROOT->GetListOfTypes()->FindObject(nameoftype);; will return the TDataType corresponding to 'nameoftype'. If the TDataType is not already in the list itself and the type does exist, a new TDataType will be created and added to the list.; Calling gROOT->GetListOfTypes()->ls(); // or Print(); list only the typedefs that have been previously accessed through the list (plus the builtins types). ; Definition at line 1865 of file TROOT.cxx. ◆ GetMacroDir(). const TString & TROOT::GetMacroDir ; (; ). static . Get the macro directory in the installation. Static utility function. ; Definition at line 3094 of file TROOT.cxx. ◆ GetMacroPath(). const char * TROOT::GetMacroPath ; (; ). static . Get macro search path. Static utility function. ; Definition at line 2762 of file TROOT.cxx. ◆ GetNclasses(). Int_t TROOT::GetNclasses ; (; ); const. Get number of classes. ; Definition at line 1876 of file TROOT.cxx. ◆ GetNtypes(). Int_t TROOT::GetNtypes ; (; ); const. Get number of types. ; Definition at line 1884 of file TROOT.cxx. ◆ GetPluginManager(). TPluginManager * TROOT::GetPluginManager ; (; ); const. inline . Definition at line 208 of file TROOT.h. ◆ GetRootFolder(). TFolder * TROOT::GetRootFolder ; (; ); const. inline . Definition at line 274 of file TROOT.h. ◆ GetRootSys(). const TString & TROOT::GetRootSys ; (; ). static . Get the rootsys directory in the installation. Static utility function. ; Definition at line 2979 of file TROOT.cxx. ◆ GetSelectedPad(). TVirtualPad * TROOT::GetSelectedPad ; (; ); const. inline",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:60353,Deployability,install,installation,60353,the list (plus the builtins types). ; Definition at line 1865 of file TROOT.cxx. ◆ GetMacroDir(). const TString & TROOT::GetMacroDir ; (; ). static . Get the macro directory in the installation. Static utility function. ; Definition at line 3094 of file TROOT.cxx. ◆ GetMacroPath(). const char * TROOT::GetMacroPath ; (; ). static . Get macro search path. Static utility function. ; Definition at line 2762 of file TROOT.cxx. ◆ GetNclasses(). Int_t TROOT::GetNclasses ; (; ); const. Get number of classes. ; Definition at line 1876 of file TROOT.cxx. ◆ GetNtypes(). Int_t TROOT::GetNtypes ; (; ); const. Get number of types. ; Definition at line 1884 of file TROOT.cxx. ◆ GetPluginManager(). TPluginManager * TROOT::GetPluginManager ; (; ); const. inline . Definition at line 208 of file TROOT.h. ◆ GetRootFolder(). TFolder * TROOT::GetRootFolder ; (; ); const. inline . Definition at line 274 of file TROOT.h. ◆ GetRootSys(). const TString & TROOT::GetRootSys ; (; ). static . Get the rootsys directory in the installation. Static utility function. ; Definition at line 2979 of file TROOT.cxx. ◆ GetSelectedPad(). TVirtualPad * TROOT::GetSelectedPad ; (; ); const. inline . Definition at line 271 of file TROOT.h. ◆ GetSelectedPrimitive(). const TObject * TROOT::GetSelectedPrimitive ; (; ); const. inline . Definition at line 270 of file TROOT.h. ◆ GetSharedLibDir(). const TString & TROOT::GetSharedLibDir ; (; ). static . Get the shared libraries directory in the installation. Static utility function. ; Definition at line 3031 of file TROOT.cxx. ◆ GetSourceDir(). const TString & TROOT::GetSourceDir ; (; ). static . Get the source directory in the installation. Static utility function. ; Definition at line 3147 of file TROOT.cxx. ◆ GetStyle(). TStyle * TROOT::GetStyle ; (; const char * ; name); const. Return pointer to style with name. ; Definition at line 1579 of file TROOT.cxx. ◆ GetTTFFontDir(). const TString & TROOT::GetTTFFontDir ; (; ). static . Get the fonts directory in the insta,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:60810,Deployability,install,installation,60810,T::GetNclasses ; (; ); const. Get number of classes. ; Definition at line 1876 of file TROOT.cxx. ◆ GetNtypes(). Int_t TROOT::GetNtypes ; (; ); const. Get number of types. ; Definition at line 1884 of file TROOT.cxx. ◆ GetPluginManager(). TPluginManager * TROOT::GetPluginManager ; (; ); const. inline . Definition at line 208 of file TROOT.h. ◆ GetRootFolder(). TFolder * TROOT::GetRootFolder ; (; ); const. inline . Definition at line 274 of file TROOT.h. ◆ GetRootSys(). const TString & TROOT::GetRootSys ; (; ). static . Get the rootsys directory in the installation. Static utility function. ; Definition at line 2979 of file TROOT.cxx. ◆ GetSelectedPad(). TVirtualPad * TROOT::GetSelectedPad ; (; ); const. inline . Definition at line 271 of file TROOT.h. ◆ GetSelectedPrimitive(). const TObject * TROOT::GetSelectedPrimitive ; (; ); const. inline . Definition at line 270 of file TROOT.h. ◆ GetSharedLibDir(). const TString & TROOT::GetSharedLibDir ; (; ). static . Get the shared libraries directory in the installation. Static utility function. ; Definition at line 3031 of file TROOT.cxx. ◆ GetSourceDir(). const TString & TROOT::GetSourceDir ; (; ). static . Get the source directory in the installation. Static utility function. ; Definition at line 3147 of file TROOT.cxx. ◆ GetStyle(). TStyle * TROOT::GetStyle ; (; const char * ; name); const. Return pointer to style with name. ; Definition at line 1579 of file TROOT.cxx. ◆ GetTTFFontDir(). const TString & TROOT::GetTTFFontDir ; (; ). static . Get the fonts directory in the installation. Static utility function. ; Definition at line 3189 of file TROOT.cxx. ◆ GetTutorialDir(). const TString & TROOT::GetTutorialDir ; (; ). static . Get the tutorials directory in the installation. Static utility function. ; Definition at line 3115 of file TROOT.cxx. ◆ GetTutorialsDir(). const char * TROOT::GetTutorialsDir ; (; ). static . Get the tutorials directory in the installation. ; Static utility function. Backward compatibility functi,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:60997,Deployability,install,installation,60997," 1884 of file TROOT.cxx. ◆ GetPluginManager(). TPluginManager * TROOT::GetPluginManager ; (; ); const. inline . Definition at line 208 of file TROOT.h. ◆ GetRootFolder(). TFolder * TROOT::GetRootFolder ; (; ); const. inline . Definition at line 274 of file TROOT.h. ◆ GetRootSys(). const TString & TROOT::GetRootSys ; (; ). static . Get the rootsys directory in the installation. Static utility function. ; Definition at line 2979 of file TROOT.cxx. ◆ GetSelectedPad(). TVirtualPad * TROOT::GetSelectedPad ; (; ); const. inline . Definition at line 271 of file TROOT.h. ◆ GetSelectedPrimitive(). const TObject * TROOT::GetSelectedPrimitive ; (; ); const. inline . Definition at line 270 of file TROOT.h. ◆ GetSharedLibDir(). const TString & TROOT::GetSharedLibDir ; (; ). static . Get the shared libraries directory in the installation. Static utility function. ; Definition at line 3031 of file TROOT.cxx. ◆ GetSourceDir(). const TString & TROOT::GetSourceDir ; (; ). static . Get the source directory in the installation. Static utility function. ; Definition at line 3147 of file TROOT.cxx. ◆ GetStyle(). TStyle * TROOT::GetStyle ; (; const char * ; name); const. Return pointer to style with name. ; Definition at line 1579 of file TROOT.cxx. ◆ GetTTFFontDir(). const TString & TROOT::GetTTFFontDir ; (; ). static . Get the fonts directory in the installation. Static utility function. ; Definition at line 3189 of file TROOT.cxx. ◆ GetTutorialDir(). const TString & TROOT::GetTutorialDir ; (; ). static . Get the tutorials directory in the installation. Static utility function. ; Definition at line 3115 of file TROOT.cxx. ◆ GetTutorialsDir(). const char * TROOT::GetTutorialsDir ; (; ). static . Get the tutorials directory in the installation. ; Static utility function. Backward compatibility function - do not use for new code ; Definition at line 3211 of file TROOT.cxx. ◆ GetType(). TDataType * TROOT::GetType ; (; const char * ; name, . Bool_t ; load = kFALSE . ); const. Return pointer ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:61338,Deployability,install,installation,61338,"rootsys directory in the installation. Static utility function. ; Definition at line 2979 of file TROOT.cxx. ◆ GetSelectedPad(). TVirtualPad * TROOT::GetSelectedPad ; (; ); const. inline . Definition at line 271 of file TROOT.h. ◆ GetSelectedPrimitive(). const TObject * TROOT::GetSelectedPrimitive ; (; ); const. inline . Definition at line 270 of file TROOT.h. ◆ GetSharedLibDir(). const TString & TROOT::GetSharedLibDir ; (; ). static . Get the shared libraries directory in the installation. Static utility function. ; Definition at line 3031 of file TROOT.cxx. ◆ GetSourceDir(). const TString & TROOT::GetSourceDir ; (; ). static . Get the source directory in the installation. Static utility function. ; Definition at line 3147 of file TROOT.cxx. ◆ GetStyle(). TStyle * TROOT::GetStyle ; (; const char * ; name); const. Return pointer to style with name. ; Definition at line 1579 of file TROOT.cxx. ◆ GetTTFFontDir(). const TString & TROOT::GetTTFFontDir ; (; ). static . Get the fonts directory in the installation. Static utility function. ; Definition at line 3189 of file TROOT.cxx. ◆ GetTutorialDir(). const TString & TROOT::GetTutorialDir ; (; ). static . Get the tutorials directory in the installation. Static utility function. ; Definition at line 3115 of file TROOT.cxx. ◆ GetTutorialsDir(). const char * TROOT::GetTutorialsDir ; (; ). static . Get the tutorials directory in the installation. ; Static utility function. Backward compatibility function - do not use for new code ; Definition at line 3211 of file TROOT.cxx. ◆ GetType(). TDataType * TROOT::GetType ; (; const char * ; name, . Bool_t ; load = kFALSE . ); const. Return pointer to type with name. ; Definition at line 1562 of file TROOT.cxx. ◆ GetUUIDs(). TProcessUUID * TROOT::GetUUIDs ; (; ); const. inline . Definition at line 275 of file TROOT.h. ◆ GetVersion(). const char * TROOT::GetVersion ; (; ); const. inline . Definition at line 230 of file TROOT.h. ◆ GetVersionCode(). Int_t TROOT::GetVersionCode ; (; ); co",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:61532,Deployability,install,installation,61532,"inition at line 271 of file TROOT.h. ◆ GetSelectedPrimitive(). const TObject * TROOT::GetSelectedPrimitive ; (; ); const. inline . Definition at line 270 of file TROOT.h. ◆ GetSharedLibDir(). const TString & TROOT::GetSharedLibDir ; (; ). static . Get the shared libraries directory in the installation. Static utility function. ; Definition at line 3031 of file TROOT.cxx. ◆ GetSourceDir(). const TString & TROOT::GetSourceDir ; (; ). static . Get the source directory in the installation. Static utility function. ; Definition at line 3147 of file TROOT.cxx. ◆ GetStyle(). TStyle * TROOT::GetStyle ; (; const char * ; name); const. Return pointer to style with name. ; Definition at line 1579 of file TROOT.cxx. ◆ GetTTFFontDir(). const TString & TROOT::GetTTFFontDir ; (; ). static . Get the fonts directory in the installation. Static utility function. ; Definition at line 3189 of file TROOT.cxx. ◆ GetTutorialDir(). const TString & TROOT::GetTutorialDir ; (; ). static . Get the tutorials directory in the installation. Static utility function. ; Definition at line 3115 of file TROOT.cxx. ◆ GetTutorialsDir(). const char * TROOT::GetTutorialsDir ; (; ). static . Get the tutorials directory in the installation. ; Static utility function. Backward compatibility function - do not use for new code ; Definition at line 3211 of file TROOT.cxx. ◆ GetType(). TDataType * TROOT::GetType ; (; const char * ; name, . Bool_t ; load = kFALSE . ); const. Return pointer to type with name. ; Definition at line 1562 of file TROOT.cxx. ◆ GetUUIDs(). TProcessUUID * TROOT::GetUUIDs ; (; ); const. inline . Definition at line 275 of file TROOT.h. ◆ GetVersion(). const char * TROOT::GetVersion ; (; ); const. inline . Definition at line 230 of file TROOT.h. ◆ GetVersionCode(). Int_t TROOT::GetVersionCode ; (; ); const. inline . Definition at line 229 of file TROOT.h. ◆ GetVersionDate(). Int_t TROOT::GetVersionDate ; (; ); const. inline . Definition at line 226 of file TROOT.h. ◆ GetVersionInt(). Int_t T",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:61725,Deployability,install,installation,61725,"onst TString & TROOT::GetSharedLibDir ; (; ). static . Get the shared libraries directory in the installation. Static utility function. ; Definition at line 3031 of file TROOT.cxx. ◆ GetSourceDir(). const TString & TROOT::GetSourceDir ; (; ). static . Get the source directory in the installation. Static utility function. ; Definition at line 3147 of file TROOT.cxx. ◆ GetStyle(). TStyle * TROOT::GetStyle ; (; const char * ; name); const. Return pointer to style with name. ; Definition at line 1579 of file TROOT.cxx. ◆ GetTTFFontDir(). const TString & TROOT::GetTTFFontDir ; (; ). static . Get the fonts directory in the installation. Static utility function. ; Definition at line 3189 of file TROOT.cxx. ◆ GetTutorialDir(). const TString & TROOT::GetTutorialDir ; (; ). static . Get the tutorials directory in the installation. Static utility function. ; Definition at line 3115 of file TROOT.cxx. ◆ GetTutorialsDir(). const char * TROOT::GetTutorialsDir ; (; ). static . Get the tutorials directory in the installation. ; Static utility function. Backward compatibility function - do not use for new code ; Definition at line 3211 of file TROOT.cxx. ◆ GetType(). TDataType * TROOT::GetType ; (; const char * ; name, . Bool_t ; load = kFALSE . ); const. Return pointer to type with name. ; Definition at line 1562 of file TROOT.cxx. ◆ GetUUIDs(). TProcessUUID * TROOT::GetUUIDs ; (; ); const. inline . Definition at line 275 of file TROOT.h. ◆ GetVersion(). const char * TROOT::GetVersion ; (; ); const. inline . Definition at line 230 of file TROOT.h. ◆ GetVersionCode(). Int_t TROOT::GetVersionCode ; (; ); const. inline . Definition at line 229 of file TROOT.h. ◆ GetVersionDate(). Int_t TROOT::GetVersionDate ; (; ); const. inline . Definition at line 226 of file TROOT.h. ◆ GetVersionInt(). Int_t TROOT::GetVersionInt ; (; ); const. inline . Definition at line 228 of file TROOT.h. ◆ GetVersionTime(). Int_t TROOT::GetVersionTime ; (; ); const. inline . Definition at line 227 of file TROOT.",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:68782,Deployability,update,update,68782,"it will only check if filename exists and is readable. Returns 0 on successful loading and -1 in case filename does not exist or in case of error. ; Definition at line 2268 of file TROOT.cxx. ◆ ls(). void TROOT::ls ; (; Option_t * ; option = """"); const. overridevirtual . To list all objects of the application. ; Loop on all objects created in the ROOT linked lists. Objects may be files and windows or any other object directly attached to the ROOT linked list. ; Reimplemented from TDirectory.; Definition at line 2250 of file TROOT.cxx. ◆ Macro(). Longptr_t TROOT::Macro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; padUpdate = kTRUE . ). Execute a macro in the interpreter. ; Equivalent to the command line command "".x filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]][(args)]. The possible error codes are defined by TInterpreter::EErrorCode. If padUpdate is true (default) update the current pad. Returns the macro return value. ; Definition at line 2316 of file TROOT.cxx. ◆ MakeDefCanvas(). TCanvas * TROOT::MakeDefCanvas ; (; ); const. Return a default canvas. ; Definition at line 1554 of file TROOT.cxx. ◆ Message(). void TROOT::Message ; (; Int_t ; id, . const TObject * ; obj . ). Process message id called by obj. ; Definition at line 2350 of file TROOT.cxx. ◆ MustClean(). Bool_t TROOT::MustClean ; (; ); const. inline . Definition at line 296 of file TROOT.h. ◆ operator new() [1/2]. void * TROOT::operator new ; (; size_t ; l). inlineprotected . Definition at line 178 of file TROOT.h. ◆ operator new() [2/2]. void * TROOT::operator new ; (; size_t ; l, . void * ; ptr . ). inlineprotected . Definition at line 179 of file TROOT.h. ◆ operator=(). TROOT & TROOT::operator= ; (; const TROOT & ; ). privatedelete . ◆ ProcessLine(). Longptr_t TROOT::ProcessLine ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplicat",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:71635,Deployability,release,release,71635,"ine(). The possible error codes are defined by TInterpreter::EErrorCode. ; Definition at line 2407 of file TROOT.cxx. ◆ ProcessLineSync(). Longptr_t TROOT::ProcessLineSync ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplication::ProcessLine(). ; On Win32 the line will be processed synchronously (i.e. it will only return when the CINT interpreter thread has finished executing the line). On non-Win32 platforms there is no difference between ProcessLine() and ProcessLineSync(). The possible error codes are defined by TInterpreter::EErrorCode. Returns the result of the command, cast to a Longptr_t. ; Definition at line 2390 of file TROOT.cxx. ◆ ReadGitInfo(). void TROOT::ReadGitInfo ; (; ). protected . Read Git commit SHA1 and branch name. ; Read Git commit information and branch name from the etc/gitinfo.txt file. ; Definition at line 2429 of file TROOT.cxx. ◆ ReadingObject(). Bool_t TROOT::ReadingObject ; (; ); const. Deprecated (will be removed in next release). ; Definition at line 2460 of file TROOT.cxx. ◆ RecursiveRemove(). void TROOT::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Recursively remove this object from the list of Cleanups. ; Typically RecursiveRemove is implemented by classes that can contain mulitple references to a same object or shared ownership of the object with others. ; Reimplemented from TDirectory.; Definition at line 2498 of file TROOT.cxx. ◆ RefreshBrowsers(). void TROOT::RefreshBrowsers ; (; ). Refresh all browsers. ; Call this method when some command line command or script has changed the browser contents. Not needed for objects that have the kMustCleanup bit set. Most useful to update browsers that show the file system or other objects external to the running ROOT session. ; Definition at line 2512 of file TROOT.cxx. ◆ RegisterModule(). void TROOT::RegisterModule ; (; const char * ; modulename, . const char ** ; headers, . const char ** ; includePaths, . const char * ; payload",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:72317,Deployability,update,update,72317,"; (; ). protected . Read Git commit SHA1 and branch name. ; Read Git commit information and branch name from the etc/gitinfo.txt file. ; Definition at line 2429 of file TROOT.cxx. ◆ ReadingObject(). Bool_t TROOT::ReadingObject ; (; ); const. Deprecated (will be removed in next release). ; Definition at line 2460 of file TROOT.cxx. ◆ RecursiveRemove(). void TROOT::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Recursively remove this object from the list of Cleanups. ; Typically RecursiveRemove is implemented by classes that can contain mulitple references to a same object or shared ownership of the object with others. ; Reimplemented from TDirectory.; Definition at line 2498 of file TROOT.cxx. ◆ RefreshBrowsers(). void TROOT::RefreshBrowsers ; (; ). Refresh all browsers. ; Call this method when some command line command or script has changed the browser contents. Not needed for objects that have the kMustCleanup bit set. Most useful to update browsers that show the file system or other objects external to the running ROOT session. ; Definition at line 2512 of file TROOT.cxx. ◆ RegisterModule(). void TROOT::RegisterModule ; (; const char * ; modulename, . const char ** ; headers, . const char ** ; includePaths, . const char * ; payloadCode, . const char * ; fwdDeclCode, . void(*)() ; triggerFunc, . const FwdDeclArgsToKeepCollection_t & ; fwdDeclsArgToSkip, . const char ** ; classesHeaders, . bool ; hasCxxModule = false . ). static . Called by static dictionary initialization to register clang modules for headers. ; Calls TCling::RegisterModule() unless gCling is NULL, i.e. during startup, where the information is buffered in the static GetModuleHeaderInfoBuffer(). ; Definition at line 2535 of file TROOT.cxx. ◆ Remove(). TObject * TROOT::Remove ; (; TObject * ; obj). overridevirtual . Remove an object from the in-memory list. ; Since TROOT is global resource, this is lock protected. ; Reimplemented from TDirectory.; Definition at line 2618 of file TROOT.cxx.",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:10932,Integrability,message,message,10932,"sProofServ () const;  ; Bool_t IsRootFile (const char *filename) const;  Return true if the file is local and is (likely) to be a ROOT file. ;  ; Bool_t IsWebDisplay () const;  ; Bool_t IsWebDisplayBatch () const;  ; Int_t LoadClass (const char *classname, const char *libname, Bool_t check=kFALSE);  Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored). ;  ; TClass * LoadClass (const char *name, Bool_t silent=kFALSE) const;  Helper function used by TClass::GetClass(). ;  ; Int_t LoadMacro (const char *filename, Int_t *error=nullptr, Bool_t check=kFALSE);  Load a macro in the interpreter's memory. ;  ; void ls (Option_t *option="""") const override;  To list all objects of the application. ;  ; Longptr_t Macro (const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE);  Execute a macro in the interpreter. ;  ; TCanvas * MakeDefCanvas () const;  Return a default canvas. ;  ; void Message (Int_t id, const TObject *obj);  Process message id called by obj. ;  ; Bool_t MustClean () const;  ; Longptr_t ProcessLine (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Longptr_t ProcessLineFast (const char *line, Int_t *error=nullptr);  Process interpreter command directly via CINT interpreter. ;  ; Longptr_t ProcessLineSync (const char *line, Int_t *error=nullptr);  Process interpreter command via TApplication::ProcessLine(). ;  ; Bool_t ReadingObject () const;  Deprecated (will be removed in next release). ;  ; void RecursiveRemove (TObject *obj) override;  Recursively remove this object from the list of Cleanups. ;  ; void RefreshBrowsers ();  Refresh all browsers. ;  ; TObject * Remove (TObject *) override;  Remove an object from the in-memory list. ;  ; void RemoveClass (TClass *);  Remove a class from the list and map of classes. ;  ; void Reset (Option_t *option="""");  Delete all global interpreter objects created since the last call to Re",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:22206,Integrability,message,message,22206," *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:22747,Integrability,message,message,22747,"putes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns k",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:23537,Integrability,message,message,23537,". ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ;  ; virtual Bool_t Notify ();  This method must be o",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:26282,Integrability,message,message,26282," operator= (const TObject &rhs);  TObject assignment operator. ;  ; virtual void Pop ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  . Static Public Member Functions; static const std::vector< std::string > & AddExtraInterpreterArgs (const std::vector< std::string > &args);  Provide command line arguments to the interpreter construction. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Int_t ConvertVersionCode2Int (Int_t code);  Convert version code to an integer, i.e. 331527 -> 51507. ;  ; static Int_t ConvertVersionInt2Code (Int_t v);  Convert version as an integer to version code as used in RVersion.h. ;  ; static const char * DeclFileName ();  ; st",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:26655,Integrability,message,message,26655," Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  . Static Public Member Functions; static const std::vector< std::string > & AddExtraInterpreterArgs (const std::vector< std::string > &args);  Provide command line arguments to the interpreter construction. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Int_t ConvertVersionCode2Int (Int_t code);  Convert version code to an integer, i.e. 331527 -> 51507. ;  ; static Int_t ConvertVersionInt2Code (Int_t v);  Convert version as an integer to version code as used in RVersion.h. ;  ; static const char * DeclFileName ();  ; static Int_t DecreaseDirLevel ();  Decrease the indentation level for ls(). ;  ; static const TString & GetBinDir ();  Get the binary directory in the installation. Static utility function. ;  ; static const TString & GetDataDir ();  Get the data directory in the installation. Static utility function. ;  ; static Int_t GetDirLevel ();  return directory level ;  ; static cons",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:27965,Integrability,inject,inject,27965," static constexpr Version_t Class_Version ();  ; static Int_t ConvertVersionCode2Int (Int_t code);  Convert version code to an integer, i.e. 331527 -> 51507. ;  ; static Int_t ConvertVersionInt2Code (Int_t v);  Convert version as an integer to version code as used in RVersion.h. ;  ; static const char * DeclFileName ();  ; static Int_t DecreaseDirLevel ();  Decrease the indentation level for ls(). ;  ; static const TString & GetBinDir ();  Get the binary directory in the installation. Static utility function. ;  ; static const TString & GetDataDir ();  Get the data directory in the installation. Static utility function. ;  ; static Int_t GetDirLevel ();  return directory level ;  ; static const TString & GetDocDir ();  Get the documentation directory in the installation. Static utility function. ;  ; static const TString & GetEtcDir ();  Get the sysconfig directory in the installation. Static utility function. ;  ; static const char **& GetExtraInterpreterArgs ();  INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ;  ; static const TString & GetIconPath ();  Get the icon path in the installation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char * GetMacroPath ();  Get macro search path. Static utility function. ;  ; static const TString & GetRootSys ();  Get the rootsys directory in the installation. Static utility function. ;  ; static const TString & GetSharedLibDir ();  Get the shared libraries directory in the installation. Static utility function. ;  ; static const TString & GetSourceDir ();  Get the source directory in the installation. Static utility function. ;  ; stati",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:28006,Integrability,interface,interface,28006," static constexpr Version_t Class_Version ();  ; static Int_t ConvertVersionCode2Int (Int_t code);  Convert version code to an integer, i.e. 331527 -> 51507. ;  ; static Int_t ConvertVersionInt2Code (Int_t v);  Convert version as an integer to version code as used in RVersion.h. ;  ; static const char * DeclFileName ();  ; static Int_t DecreaseDirLevel ();  Decrease the indentation level for ls(). ;  ; static const TString & GetBinDir ();  Get the binary directory in the installation. Static utility function. ;  ; static const TString & GetDataDir ();  Get the data directory in the installation. Static utility function. ;  ; static Int_t GetDirLevel ();  return directory level ;  ; static const TString & GetDocDir ();  Get the documentation directory in the installation. Static utility function. ;  ; static const TString & GetEtcDir ();  Get the sysconfig directory in the installation. Static utility function. ;  ; static const char **& GetExtraInterpreterArgs ();  INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ;  ; static const TString & GetIconPath ();  Get the icon path in the installation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char * GetMacroPath ();  Get macro search path. Static utility function. ;  ; static const TString & GetRootSys ();  Get the rootsys directory in the installation. Static utility function. ;  ; static const TString & GetSharedLibDir ();  Get the shared libraries directory in the installation. Static utility function. ;  ; static const TString & GetSourceDir ();  Get the source directory in the installation. Static utility function. ;  ; stati",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:32313,Integrability,rout,routine,32313,"Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; typedef std::atomic< TListOfEnums * > AListOfEnums_t;  ;  Protected Types inherited from TDirectory; using SharedGDirectory_t = std::shared_ptr< std::atomic< TDirectory * > >;  Pointer to a list of TContext object pointing to this TDirectory. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions;  TROOT ();  Only used by Dictionary. ;  ; TListOfFunctions * GetGlobalFunctions ();  Internal routine returning, and creating if necessary, the list of global function. ;  ; void InitInterpreter ();  Initialize interpreter (cling) ;  ; void InitSystem ();  Operating System interface. ;  ; void InitThreads ();  Initialize threads library. ;  ; void * operator new (size_t l);  ; void * operator new (size_t l, void *ptr);  ; void ReadGitInfo ();  Read Git commit SHA1 and branch name. ;  ;  Protected Member Functions inherited from TDirectory;  TDirectory (const TDirectory &directory)=delete;  ; void BuildDirectory (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; Bool_t cd1 (const char *path);  flag to add histograms, graphs,etc to the directory ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.). ;  ; void FillFullPath (TString &buf) const;  Recursive method to fill full path for directory. ;  ; void operator= (const TDirectory &)=delete;  ; void RegisterContext (TContext *ctxt);  Register a TContext pointing to thi",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:32493,Integrability,interface,interface,32493,"atic constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; typedef std::atomic< TListOfEnums * > AListOfEnums_t;  ;  Protected Types inherited from TDirectory; using SharedGDirectory_t = std::shared_ptr< std::atomic< TDirectory * > >;  Pointer to a list of TContext object pointing to this TDirectory. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions;  TROOT ();  Only used by Dictionary. ;  ; TListOfFunctions * GetGlobalFunctions ();  Internal routine returning, and creating if necessary, the list of global function. ;  ; void InitInterpreter ();  Initialize interpreter (cling) ;  ; void InitSystem ();  Operating System interface. ;  ; void InitThreads ();  Initialize threads library. ;  ; void * operator new (size_t l);  ; void * operator new (size_t l, void *ptr);  ; void ReadGitInfo ();  Read Git commit SHA1 and branch name. ;  ;  Protected Member Functions inherited from TDirectory;  TDirectory (const TDirectory &directory)=delete;  ; void BuildDirectory (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; Bool_t cd1 (const char *path);  flag to add histograms, graphs,etc to the directory ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.). ;  ; void FillFullPath (TString &buf) const;  Recursive method to fill full path for directory. ;  ; void operator= (const TDirectory &)=delete;  ; void RegisterContext (TContext *ctxt);  Register a TContext pointing to this TDirectory object. ;  ; void RegisterGDirectory (SharedGDirectory_t &ptr);  Register a std::atomic<TDirectory*> that will ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:36318,Integrability,message,message,36318,fFiles;  List of files. ;  ; Bool_t fForceStyle;  Force setting of current style when reading objects. ;  ; Bool_t fFromPopUp;  True if command executed from a popup menu. ;  ; TListOfFunctionTemplates * fFuncTemplate;  List of global function templates. ;  ; TCollection * fFunctions;  List of analytic functions. ;  ; TSeqCollection * fGeometries;  List of geometries. ;  ; TString fGitBranch;  Git branch. ;  ; TString fGitCommit;  Git commit SHA1 of built. ;  ; TString fGitDate;  Date and time when make was run. ;  ; TListOfFunctions * fGlobalFunctions;  List of global functions. ;  ; TListOfDataMembers * fGlobals;  List of global variables. ;  ; TInterpreter * fInterpreter;  Command interpreter. ;  ; Bool_t fInterrupt;  True if macro should be interrupted. ;  ; Bool_t fIsWebDisplay;  True if session uses web widgets. ;  ; Bool_t fIsWebDisplayBatch;  True if web widgets are not displayed. ;  ; TSeqCollection * fMappedFiles;  List of memory mapped files. ;  ; TSeqCollection * fMessageHandlers;  List of message handlers. ;  ; Bool_t fMustClean;  True if object destructor scans canvases. ;  ; TPluginManager * fPluginManager;  Keeps track of plugin library handlers. ;  ; const TObject * fPrimitive;  Currently selected primitive. ;  ; TSeqCollection * fProofs;  List of proof sessions. ;  ; TFolder * fRootFolder;  top level folder //root ;  ; TSeqCollection * fSecContexts;  List of security contexts (TSecContext) ;  ; TVirtualPad * fSelectPad;  Currently selected pad. ;  ; TSeqCollection * fSockets;  List of network sockets. ;  ; TSeqCollection * fSpecials;  List of special objects. ;  ; TSeqCollection * fStreamerInfo;  List of active StreamerInfo classes. ;  ; TSeqCollection * fStyles;  List of styles. ;  ; TSeqCollection * fTasks;  List of tasks. ;  ; Int_t fTimer;  Timer flag. ;  ; TCollection * fTypes;  List of data types definition. ;  ; TProcessUUID * fUUIDs;  Pointer to TProcessID managing TUUIDs. ;  ; TString fVersion;  ROOT version (from CMZ VERSQQ) ex 0.05/01. ; ,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:38354,Integrability,synchroniz,synchronize,38354,"e as used in RVersion.h. ;  ; Int_t fVersionDate;  Date of ROOT version (ex 951226) ;  ; Int_t fVersionInt;  ROOT version in integer format (501) ;  ; Int_t fVersionTime;  Time of ROOT version (ex 1152) ;  ; TString fWebDisplay;  If not empty it defines where web graphics should be rendered (cef, qt5, browser...) ;  ;  Protected Attributes inherited from TDirectory; TContext * fContext {nullptr};  Buffer for GetPath() function. ;  ; std::atomic< size_t > fContextPeg {0};  thread local gDirectory pointing to this object. ;  ; std::vector< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions;  TROOT (const TROOT &)=delete;  ; TROOT & operator= (const TROOT &)=delete;  . Private Attributes; Int_t fLineIsProcessing;  To synchronize multi-threads. ;  . Static Private Attributes; static Int_t fgDirLevel = 0;  Indentation level for ls() ;  ; static Bool_t fgRootInit = kFALSE;  Singleton initialization flag. ;  . Friends; class ::ROOT::Internal::TROOTAllocator;  ; TROOT * ROOT::Internal::GetROOT2 ();  ; class TCling;  . Additional Inherited Members;  Static Protected Member Functions inherited from TDirectory; static Bool_t Cd1 (const char *path);  Change current directory to ""path"". ;  ; static SharedGDirectory_t & GetSharedLocalCurrentDirectory ();  Return the (address of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TROOT.h>. Inheritance diagram for TROOT:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:40975,Integrability,depend,dependencies,40975," . const char * ; title, . VoidFuncPtr_t * ; initfunc = nullptr . ). Initialize the ROOT system. ; The creation of the TROOT object initializes the ROOT system. It must be the first ROOT related action that is performed by a program. The TROOT object must be created on the stack (can not be called via new since ""operator new"" is protected). The TROOT object is either created as a global object (outside the main() program), or it is one of the first objects created in main(). Make sure that the TROOT object stays in scope for as long as ROOT related actions are performed. TROOT is a so called singleton so only one instance of it can be created. The single TROOT object can always be accessed via the global pointer gROOT. The name and title arguments can be used to identify the running application. The initfunc argument can contain an array of function pointers (last element must be 0). These functions are executed at the end of the constructor. This way one can easily extend the ROOT system without adding permanent dependencies (e.g. the graphics system is initialized via such a function). ; Definition at line 639 of file TROOT.cxx. ◆ ~TROOT(). TROOT::~TROOT ; (; ). virtual . Clean up and free resources used by ROOT (files, network sockets, shared memory segments, etc.). ; Definition at line 867 of file TROOT.cxx. Member Function Documentation. ◆ AddClass(). void TROOT::AddClass ; (; TClass * ; cl). Add a class to the list and map of classes. ; This routine is deprecated, use TClass::AddClass directly. ; Definition at line 1025 of file TROOT.cxx. ◆ AddClassGenerator(). void TROOT::AddClassGenerator ; (; TClassGenerator * ; generator). Add a class generator. ; This generator will be called by TClass::GetClass in case its does not find a loaded rootcint dictionary to request the creation of a TClass object. ; Definition at line 1035 of file TROOT.cxx. ◆ AddExtraInterpreterArgs(). const std::vector< std::string > & TROOT::AddExtraInterpreterArgs ; (; const std::vector< st",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:41418,Integrability,rout,routine,41418," the TROOT object stays in scope for as long as ROOT related actions are performed. TROOT is a so called singleton so only one instance of it can be created. The single TROOT object can always be accessed via the global pointer gROOT. The name and title arguments can be used to identify the running application. The initfunc argument can contain an array of function pointers (last element must be 0). These functions are executed at the end of the constructor. This way one can easily extend the ROOT system without adding permanent dependencies (e.g. the graphics system is initialized via such a function). ; Definition at line 639 of file TROOT.cxx. ◆ ~TROOT(). TROOT::~TROOT ; (; ). virtual . Clean up and free resources used by ROOT (files, network sockets, shared memory segments, etc.). ; Definition at line 867 of file TROOT.cxx. Member Function Documentation. ◆ AddClass(). void TROOT::AddClass ; (; TClass * ; cl). Add a class to the list and map of classes. ; This routine is deprecated, use TClass::AddClass directly. ; Definition at line 1025 of file TROOT.cxx. ◆ AddClassGenerator(). void TROOT::AddClassGenerator ; (; TClassGenerator * ; generator). Add a class generator. ; This generator will be called by TClass::GetClass in case its does not find a loaded rootcint dictionary to request the creation of a TClass object. ; Definition at line 1035 of file TROOT.cxx. ◆ AddExtraInterpreterArgs(). const std::vector< std::string > & TROOT::AddExtraInterpreterArgs ; (; const std::vector< std::string > & ; args). static . Provide command line arguments to the interpreter construction. ; These arguments are added to the existing flags (e.g. -DNDEBUG). They are evaluated once per process, at the time where TROOT (and thus TInterpreter) is constructed. Returns the new flags. ; Definition at line 2952 of file TROOT.cxx. ◆ Append(). void TROOT::Append ; (; TObject * ; obj, . Bool_t ; replace = kFALSE . ). overridevirtual . Append object to this directory. ; If replace is true: rem",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:50899,Integrability,inject,inject,50899,OOT.cxx. ◆ GetDefCanvasName(). const char * TROOT::GetDefCanvasName ; (; ); const. inline . Definition at line 217 of file TROOT.h. ◆ GetDirLevel(). Int_t TROOT::GetDirLevel ; (; ). static . return directory level ; Definition at line 2754 of file TROOT.cxx. ◆ GetDocDir(). const TString & TROOT::GetDocDir ; (; ). static . Get the documentation directory in the installation. Static utility function. ; Definition at line 3078 of file TROOT.cxx. ◆ GetEditHistograms(). Bool_t TROOT::GetEditHistograms ; (; ); const. inline . Definition at line 218 of file TROOT.h. ◆ GetEditorMode(). Int_t TROOT::GetEditorMode ; (; ); const. inline . Definition at line 219 of file TROOT.h. ◆ GetEtcDir(). const TString & TROOT::GetEtcDir ; (; ). static . Get the sysconfig directory in the installation. Static utility function. ; Definition at line 3052 of file TROOT.cxx. ◆ GetExtraInterpreterArgs(). const char **& TROOT::GetExtraInterpreterArgs ; (; ). static . INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ; Definition at line 2962 of file TROOT.cxx. ◆ GetFile() [1/2]. TFile * TROOT::GetFile ; (; ); const. inlineoverridevirtual . Reimplemented from TDirectory.; Definition at line 260 of file TROOT.h. ◆ GetFile() [2/2]. TFile * TROOT::GetFile ; (; const char * ; name); const. Return pointer to file with name. ; Definition at line 1570 of file TROOT.cxx. ◆ GetForceStyle(). Bool_t TROOT::GetForceStyle ; (; ); const. inline . Definition at line 220 of file TROOT.h. ◆ GetFunction(). TObject * TROOT::GetFunction ; (; const char * ; name); const. Return pointer to function with name. ; Definition at line 1587 of file TROOT.cxx. ◆ GetFunctionTemplate(). TFunctionTemplate * TROOT::GetFunctionTemplate ; (; const char * ; name). Definition at line 1618 of file TROOT.cxx. ◆ GetGeometry(). TObject * TROOT::GetGeometry ; (; const char * ; name); const. Return pointer to Geometry with name. ; Definition at line 1747 of file TROOT.cxx. ◆ GetGitBranch(). ,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:50940,Integrability,interface,interface,50940,OOT.cxx. ◆ GetDefCanvasName(). const char * TROOT::GetDefCanvasName ; (; ); const. inline . Definition at line 217 of file TROOT.h. ◆ GetDirLevel(). Int_t TROOT::GetDirLevel ; (; ). static . return directory level ; Definition at line 2754 of file TROOT.cxx. ◆ GetDocDir(). const TString & TROOT::GetDocDir ; (; ). static . Get the documentation directory in the installation. Static utility function. ; Definition at line 3078 of file TROOT.cxx. ◆ GetEditHistograms(). Bool_t TROOT::GetEditHistograms ; (; ); const. inline . Definition at line 218 of file TROOT.h. ◆ GetEditorMode(). Int_t TROOT::GetEditorMode ; (; ); const. inline . Definition at line 219 of file TROOT.h. ◆ GetEtcDir(). const TString & TROOT::GetEtcDir ; (; ). static . Get the sysconfig directory in the installation. Static utility function. ; Definition at line 3052 of file TROOT.cxx. ◆ GetExtraInterpreterArgs(). const char **& TROOT::GetExtraInterpreterArgs ; (; ). static . INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ; Definition at line 2962 of file TROOT.cxx. ◆ GetFile() [1/2]. TFile * TROOT::GetFile ; (; ); const. inlineoverridevirtual . Reimplemented from TDirectory.; Definition at line 260 of file TROOT.h. ◆ GetFile() [2/2]. TFile * TROOT::GetFile ; (; const char * ; name); const. Return pointer to file with name. ; Definition at line 1570 of file TROOT.cxx. ◆ GetForceStyle(). Bool_t TROOT::GetForceStyle ; (; ); const. inline . Definition at line 220 of file TROOT.h. ◆ GetFunction(). TObject * TROOT::GetFunction ; (; const char * ; name); const. Return pointer to function with name. ; Definition at line 1587 of file TROOT.cxx. ◆ GetFunctionTemplate(). TFunctionTemplate * TROOT::GetFunctionTemplate ; (; const char * ; name). Definition at line 1618 of file TROOT.cxx. ◆ GetGeometry(). TObject * TROOT::GetGeometry ; (; const char * ; name); const. Return pointer to Geometry with name. ; Definition at line 1747 of file TROOT.cxx. ◆ GetGitBranch(). ,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:53341,Integrability,rout,routine,53341,"er to global variable by name. ; If load is true force reading of all currently defined globals from CINT (more expensive). ; Definition at line 1631 of file TROOT.cxx. ◆ GetGlobal() [2/2]. TGlobal * TROOT::GetGlobal ; (; const TObject * ; obj, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable with address addr. ; Definition at line 1639 of file TROOT.cxx. ◆ GetGlobalFunction(). TFunction * TROOT::GetGlobalFunction ; (; const char * ; function, . const char * ; params = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If params != 0 it will also resolve overloading other it returns the first name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necessary, the list of global function. ; Definition at line 1663 of file TROOT.cxx. ◆ GetGlobalFunctionWithPrototype(). TFunction * TROOT::GetGlobalFunctionWithPrototype ; (; const char * ; function, . const char * ; proto = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If proto != 0 it will also resolve overloading. If load is true force reading of all currently defined global functions from CINT (more expensive). The proto string must be of the form: ""int, char*, float"". ; Definition at line 1718 of file TROOT.cxx. ◆ GetIconPath(). const TString & TROOT::GetIconPath ; (; ). static . Get the icon path in the installation. Static utility function. ; Definition at line 3168 of file TROOT.cxx. ◆ GetIncludeDir(). const TString & TROOT::GetIncludeDir ; (; ). static . Get the include directory in the installation. Static utility function. ; Definition at line 3042 of file TROOT.cxx. ◆ GetInterpreter(). TInterpreter * TROOT::GetInterpreter ; (; ); co",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:64278,Integrability,interface,interface,64278," versus TLorentzVector. ; Definition at line 1928 of file TROOT.cxx. ◆ IncreaseDirLevel(). Int_t TROOT::IncreaseDirLevel ; (; ). static . Increase the indentation level for ls(). ; Definition at line 2883 of file TROOT.cxx. ◆ IndentLevel(). void TROOT::IndentLevel ; (; ). static . Functions used by ls() to indent an object hierarchy. ; Definition at line 2891 of file TROOT.cxx. ◆ Initialize(). void TROOT::Initialize ; (; ). static . Initialize ROOT explicitly. ; Definition at line 2899 of file TROOT.cxx. ◆ Initialized(). Bool_t TROOT::Initialized ; (; ). static . Return kTRUE if the TROOT object has been initialized. ; Definition at line 2906 of file TROOT.cxx. ◆ InitInterpreter(). void TROOT::InitInterpreter ; (; ). protected . Initialize interpreter (cling) ; Initialize the interpreter.; Should be called only after main(), to make sure LLVM/Clang is fully initialized. ; Definition at line 2064 of file TROOT.cxx. ◆ InitSystem(). void TROOT::InitSystem ; (; ). protected . Operating System interface. ; Initialize operating system interface. ; Definition at line 1978 of file TROOT.cxx. ◆ InitThreads(). void TROOT::InitThreads ; (; ). protected . Initialize threads library. ; Load and initialize thread library. ; Definition at line 2053 of file TROOT.cxx. ◆ IsA(). TClass * TROOT::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TDirectory.; Definition at line 372 of file TROOT.h. ◆ IsBatch(). Bool_t TROOT::IsBatch ; (; ); const. inline . Definition at line 279 of file TROOT.h. ◆ IsEscaped(). Bool_t TROOT::IsEscaped ; (; ); const. inline . Definition at line 283 of file TROOT.h. ◆ IsExecutingMacro(). Bool_t TROOT::IsExecutingMacro ; (; ); const. inline . Definition at line 280 of file TROOT.h. ◆ IsFolder(). Bool_t TROOT::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TDirectory.; Definition at l",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:64319,Integrability,interface,interface,64319,"on at line 1928 of file TROOT.cxx. ◆ IncreaseDirLevel(). Int_t TROOT::IncreaseDirLevel ; (; ). static . Increase the indentation level for ls(). ; Definition at line 2883 of file TROOT.cxx. ◆ IndentLevel(). void TROOT::IndentLevel ; (; ). static . Functions used by ls() to indent an object hierarchy. ; Definition at line 2891 of file TROOT.cxx. ◆ Initialize(). void TROOT::Initialize ; (; ). static . Initialize ROOT explicitly. ; Definition at line 2899 of file TROOT.cxx. ◆ Initialized(). Bool_t TROOT::Initialized ; (; ). static . Return kTRUE if the TROOT object has been initialized. ; Definition at line 2906 of file TROOT.cxx. ◆ InitInterpreter(). void TROOT::InitInterpreter ; (; ). protected . Initialize interpreter (cling) ; Initialize the interpreter.; Should be called only after main(), to make sure LLVM/Clang is fully initialized. ; Definition at line 2064 of file TROOT.cxx. ◆ InitSystem(). void TROOT::InitSystem ; (; ). protected . Operating System interface. ; Initialize operating system interface. ; Definition at line 1978 of file TROOT.cxx. ◆ InitThreads(). void TROOT::InitThreads ; (; ). protected . Initialize threads library. ; Load and initialize thread library. ; Definition at line 2053 of file TROOT.cxx. ◆ IsA(). TClass * TROOT::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TDirectory.; Definition at line 372 of file TROOT.h. ◆ IsBatch(). Bool_t TROOT::IsBatch ; (; ); const. inline . Definition at line 279 of file TROOT.h. ◆ IsEscaped(). Bool_t TROOT::IsEscaped ; (; ); const. inline . Definition at line 283 of file TROOT.h. ◆ IsExecutingMacro(). Bool_t TROOT::IsExecutingMacro ; (; ); const. inline . Definition at line 280 of file TROOT.h. ◆ IsFolder(). Bool_t TROOT::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TDirectory.; Definition at line 281 of file TROOT.h. ◆ IsInterr",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:69105,Integrability,message,message,69105,"eated in the ROOT linked lists. Objects may be files and windows or any other object directly attached to the ROOT linked list. ; Reimplemented from TDirectory.; Definition at line 2250 of file TROOT.cxx. ◆ Macro(). Longptr_t TROOT::Macro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; padUpdate = kTRUE . ). Execute a macro in the interpreter. ; Equivalent to the command line command "".x filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]][(args)]. The possible error codes are defined by TInterpreter::EErrorCode. If padUpdate is true (default) update the current pad. Returns the macro return value. ; Definition at line 2316 of file TROOT.cxx. ◆ MakeDefCanvas(). TCanvas * TROOT::MakeDefCanvas ; (; ); const. Return a default canvas. ; Definition at line 1554 of file TROOT.cxx. ◆ Message(). void TROOT::Message ; (; Int_t ; id, . const TObject * ; obj . ). Process message id called by obj. ; Definition at line 2350 of file TROOT.cxx. ◆ MustClean(). Bool_t TROOT::MustClean ; (; ); const. inline . Definition at line 296 of file TROOT.h. ◆ operator new() [1/2]. void * TROOT::operator new ; (; size_t ; l). inlineprotected . Definition at line 178 of file TROOT.h. ◆ operator new() [2/2]. void * TROOT::operator new ; (; size_t ; l, . void * ; ptr . ). inlineprotected . Definition at line 179 of file TROOT.h. ◆ operator=(). TROOT & TROOT::operator= ; (; const TROOT & ; ). privatedelete . ◆ ProcessLine(). Longptr_t TROOT::ProcessLine ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplication::ProcessLine(). ; On Win32 the line will be processed asynchronously by sending it to the CINT interpreter thread. For explicit synchronous processing use ProcessLineSync(). On non-Win32 platforms there is no difference between ProcessLine() and ProcessLineSync(). The possible error codes are defined by TInterpreter::EErrorCode. ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:73479,Integrability,rout,routine,73479,"le ; (; const char * ; modulename, . const char ** ; headers, . const char ** ; includePaths, . const char * ; payloadCode, . const char * ; fwdDeclCode, . void(*)() ; triggerFunc, . const FwdDeclArgsToKeepCollection_t & ; fwdDeclsArgToSkip, . const char ** ; classesHeaders, . bool ; hasCxxModule = false . ). static . Called by static dictionary initialization to register clang modules for headers. ; Calls TCling::RegisterModule() unless gCling is NULL, i.e. during startup, where the information is buffered in the static GetModuleHeaderInfoBuffer(). ; Definition at line 2535 of file TROOT.cxx. ◆ Remove(). TObject * TROOT::Remove ; (; TObject * ; obj). overridevirtual . Remove an object from the in-memory list. ; Since TROOT is global resource, this is lock protected. ; Reimplemented from TDirectory.; Definition at line 2618 of file TROOT.cxx. ◆ RemoveClass(). void TROOT::RemoveClass ; (; TClass * ; oldcl). Remove a class from the list and map of classes. ; This routine is deprecated, use TClass::RemoveClass directly. ; Definition at line 2628 of file TROOT.cxx. ◆ Reset(). void TROOT::Reset ; (; Option_t * ; option = """"). Delete all global interpreter objects created since the last call to Reset. ; If option=""a"" is set reset to startup context (i.e. unload also all loaded files, classes, structs, typedefs, etc.).; This function is typically used at the beginning (or end) of an unnamed macro to clean the environment.; IMPORTANT WARNING: Do not use this call from within any function (neither compiled nor interpreted. This should only be used from a unnamed macro (which starts with a { (curly braces) ). For example, using TROOT::Reset from within an interpreted function will lead to the unloading of the dictionary and source file, including the one defining the function being executed. ; Definition at line 2651 of file TROOT.cxx. ◆ ResetClassSaved(). void TROOT::ResetClassSaved ; (; ). Reset the ClassSaved status of all classes. ; Definition at line 1096 of file TROOT.c",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:79124,Integrability,message,message,79124,"e browser for interactive web display; ""edge"": select Microsoft Edge browser for interactive web display; ""native"": select one of the natively-supported web browsers firefox/chrome/edge for interactive web display; ""qt5"": uses QWebEngine from Qt5, no real http server started (requires qt5web component build for ROOT); ""qt6"": uses QWebEngine from Qt6, no real http server started (requires qt6web component build for ROOT); ""cef"": uses Chromium Embeded Framework, no real http server started (requires cefweb component build for ROOT); ""local"": select on of available local (without http server) engines like qt5/qt6/cef; ""default"": system default web browser, invoked with xdg-open on Linux, start on Mac or open on Windows; ""on"": try ""local"", then ""native"", then ""default"" option; ""off"": turns off the web display and comes back to normal graphics in interactive mode.; ""server:port"": turns the web display into server mode with specified port. Web widgets will not be displayed, only text message with window URL will be printed on standard output . Definition at line 2831 of file TROOT.cxx. ◆ ShutDown(). void TROOT::ShutDown ; (; ). static . Shut down ROOT. ; Definition at line 3136 of file TROOT.cxx. ◆ Streamer(). void TROOT::Streamer ; (; TBuffer & ; R__b). overridevirtual . TDirectory Streamer. ; Reimplemented from TDirectory. ◆ StreamerNVirtual(). void TROOT::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 372 of file TROOT.h. ◆ Time(). void TROOT::Time ; (; Int_t ; casetime = 1). inline . Definition at line 335 of file TROOT.h. ◆ Timer(). Int_t TROOT::Timer ; (; ); const. inline . Definition at line 336 of file TROOT.h. Friends And Related Symbol Documentation. ◆ ::ROOT::Internal::TROOTAllocator. friend class ::ROOT::Internal::TROOTAllocator. friend . Definition at line 181 of file TROOT.h. ◆ ROOT::Internal::GetROOT2. TROOT * ROOT::Internal::GetROOT2 ; (; ). friend . ◆ TCling. friend class TCling. friend . Definition at line 96 ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:85521,Integrability,synchroniz,synchronize,85521,Functions* TROOT::fGlobalFunctions. protected . List of global functions. ; Definition at line 144 of file TROOT.h. ◆ fGlobals. TListOfDataMembers* TROOT::fGlobals. protected . List of global variables. ; Definition at line 143 of file TROOT.h. ◆ fgRootInit. Bool_t TROOT::fgRootInit = kFALSE. staticprivate . Singleton initialization flag. ; Definition at line 103 of file TROOT.h. ◆ fInterpreter. TInterpreter* TROOT::fInterpreter. protected . Command interpreter. ; Definition at line 125 of file TROOT.h. ◆ fInterrupt. Bool_t TROOT::fInterrupt. protected . True if macro should be interrupted. ; Definition at line 134 of file TROOT.h. ◆ fIsWebDisplay. Bool_t TROOT::fIsWebDisplay. protected . True if session uses web widgets. ; Definition at line 128 of file TROOT.h. ◆ fIsWebDisplayBatch. Bool_t TROOT::fIsWebDisplayBatch. protected . True if web widgets are not displayed. ; Definition at line 129 of file TROOT.h. ◆ fLineIsProcessing. Int_t TROOT::fLineIsProcessing. private . To synchronize multi-threads. ; Definition at line 100 of file TROOT.h. ◆ fMappedFiles. TSeqCollection* TROOT::fMappedFiles. protected . List of memory mapped files. ; Definition at line 147 of file TROOT.h. ◆ fMessageHandlers. TSeqCollection* TROOT::fMessageHandlers. protected . List of message handlers. ; Definition at line 158 of file TROOT.h. ◆ fMustClean. Bool_t TROOT::fMustClean. protected . True if object destructor scans canvases. ; Definition at line 132 of file TROOT.h. ◆ fPluginManager. TPluginManager* TROOT::fPluginManager. protected . Keeps track of plugin library handlers. ; Definition at line 169 of file TROOT.h. ◆ fPrimitive. const TObject* TROOT::fPrimitive. protected . Currently selected primitive. ; Definition at line 138 of file TROOT.h. ◆ fProofs. TSeqCollection* TROOT::fProofs. protected . List of proof sessions. ; Definition at line 162 of file TROOT.h. ◆ fRootFolder. TFolder* TROOT::fRootFolder. protected . top level folder //root ; Definition at line 167 of file TROOT.h. ◆ f,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:85807,Integrability,message,message,85807,Init = kFALSE. staticprivate . Singleton initialization flag. ; Definition at line 103 of file TROOT.h. ◆ fInterpreter. TInterpreter* TROOT::fInterpreter. protected . Command interpreter. ; Definition at line 125 of file TROOT.h. ◆ fInterrupt. Bool_t TROOT::fInterrupt. protected . True if macro should be interrupted. ; Definition at line 134 of file TROOT.h. ◆ fIsWebDisplay. Bool_t TROOT::fIsWebDisplay. protected . True if session uses web widgets. ; Definition at line 128 of file TROOT.h. ◆ fIsWebDisplayBatch. Bool_t TROOT::fIsWebDisplayBatch. protected . True if web widgets are not displayed. ; Definition at line 129 of file TROOT.h. ◆ fLineIsProcessing. Int_t TROOT::fLineIsProcessing. private . To synchronize multi-threads. ; Definition at line 100 of file TROOT.h. ◆ fMappedFiles. TSeqCollection* TROOT::fMappedFiles. protected . List of memory mapped files. ; Definition at line 147 of file TROOT.h. ◆ fMessageHandlers. TSeqCollection* TROOT::fMessageHandlers. protected . List of message handlers. ; Definition at line 158 of file TROOT.h. ◆ fMustClean. Bool_t TROOT::fMustClean. protected . True if object destructor scans canvases. ; Definition at line 132 of file TROOT.h. ◆ fPluginManager. TPluginManager* TROOT::fPluginManager. protected . Keeps track of plugin library handlers. ; Definition at line 169 of file TROOT.h. ◆ fPrimitive. const TObject* TROOT::fPrimitive. protected . Currently selected primitive. ; Definition at line 138 of file TROOT.h. ◆ fProofs. TSeqCollection* TROOT::fProofs. protected . List of proof sessions. ; Definition at line 162 of file TROOT.h. ◆ fRootFolder. TFolder* TROOT::fRootFolder. protected . top level folder //root ; Definition at line 167 of file TROOT.h. ◆ fSecContexts. TSeqCollection* TROOT::fSecContexts. protected . List of security contexts (TSecContext) ; Definition at line 161 of file TROOT.h. ◆ fSelectPad. TVirtualPad* TROOT::fSelectPad. protected . Currently selected pad. ; Definition at line 139 of file TROOT.h. ◆ fSockets.,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:2257,Modifiability,inherit,inherited,2257,"rs; gROOT->GetListOfCleanups; gROOT->GetListOfMessageHandlers; gROOT#define gROOTDefinition TROOT.h:406; exampleDefinition example.py:1; The TROOT class provides also many useful services:; Get pointer to an object in any of the lists above; Time utilities TROOT::Time. The ROOT object must be created as a static object. An example of a main program creating an interactive version is shown below:. Example of a main program; #include ""TRint.h""; ; int main(int argc, char **argv); {; TRint *theApp = new TRint(""ROOT example"", &argc, argv);; ; // Init Intrinsics, build all windows, and enter event loop; theApp->Run();; ; return(0);; }; mainint main()Definition Prototype.cxx:12; TRint.h; TRintDefinition TRint.h:31; TRint::Runvoid Run(Bool_t retrn=kFALSE) overrideMain application eventloop.Definition TRint.cxx:384. Definition at line 94 of file TROOT.h. Public Types; typedef std::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_t;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TROOT (const char *name, const char *title, VoidFuncPtr_t *initfunc=nullptr);  Initialize the ROOT system. ;  ; virtual ~TROOT ();  Clean up and free resources used by ROOT (files, network sockets, shared memory segments, etc.). ;  ; void AddClass (TClass *cl);  Add a class to the list and map of classes. ;  ; void AddClassGenerator (TClassGenerator *gen);  Add a class gener",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:6412,Modifiability,variab,variable,6412,"er to class from its name. ;  ; TSeqCollection * GetClipboard () const;  ; TColor * GetColor (Int_t color) const;  Return address of color with index color. ;  ; const char * GetConfigFeatures () const;  ; const char * GetConfigOptions () const;  ; const char * GetCutClassName () const;  ; const char * GetDefCanvasName () const;  ; Bool_t GetEditHistograms () const;  ; Int_t GetEditorMode () const;  ; TFile * GetFile () const override;  ; TFile * GetFile (const char *name) const;  Return pointer to file with name. ;  ; Bool_t GetForceStyle () const;  ; TObject * GetFunction (const char *name) const;  Return pointer to function with name. ;  ; TFunctionTemplate * GetFunctionTemplate (const char *name);  ; TObject * GetGeometry (const char *name) const;  Return pointer to Geometry with name. ;  ; const char * GetGitBranch () const;  ; const char * GetGitCommit () const;  ; const char * GetGitDate ();  Return date/time make was run. ;  ; TGlobal * GetGlobal (const char *name, Bool_t load=kFALSE) const;  Return pointer to global variable by name. ;  ; TGlobal * GetGlobal (const TObject *obj, Bool_t load=kFALSE) const;  Return pointer to global variable with address addr. ;  ; TFunction * GetGlobalFunction (const char *name, const char *params=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TFunction * GetGlobalFunctionWithPrototype (const char *name, const char *proto=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TInterpreter * GetInterpreter () const;  ; TList * GetListOfBrowsables () const;  ; TSeqCollection * GetListOfBrowsers () const;  ; TSeqCollection * GetListOfCanvases () const;  ; TCollection * GetListOfClasses () const;  ; TCollection * GetListOfClassGenerators () const;  ; TSeqCollection * GetListOfCleanups () const;  ; TSeqCollection * GetListOfClosedObjects () const;  ; TSeqCollection * GetListOfColors () const;  ; TSeqCollection * GetListOfDataSets () const;  ; TCollection * GetListOfEnums (Boo",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:6529,Modifiability,variab,variable,6529," address of color with index color. ;  ; const char * GetConfigFeatures () const;  ; const char * GetConfigOptions () const;  ; const char * GetCutClassName () const;  ; const char * GetDefCanvasName () const;  ; Bool_t GetEditHistograms () const;  ; Int_t GetEditorMode () const;  ; TFile * GetFile () const override;  ; TFile * GetFile (const char *name) const;  Return pointer to file with name. ;  ; Bool_t GetForceStyle () const;  ; TObject * GetFunction (const char *name) const;  Return pointer to function with name. ;  ; TFunctionTemplate * GetFunctionTemplate (const char *name);  ; TObject * GetGeometry (const char *name) const;  Return pointer to Geometry with name. ;  ; const char * GetGitBranch () const;  ; const char * GetGitCommit () const;  ; const char * GetGitDate ();  Return date/time make was run. ;  ; TGlobal * GetGlobal (const char *name, Bool_t load=kFALSE) const;  Return pointer to global variable by name. ;  ; TGlobal * GetGlobal (const TObject *obj, Bool_t load=kFALSE) const;  Return pointer to global variable with address addr. ;  ; TFunction * GetGlobalFunction (const char *name, const char *params=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TFunction * GetGlobalFunctionWithPrototype (const char *name, const char *proto=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TInterpreter * GetInterpreter () const;  ; TList * GetListOfBrowsables () const;  ; TSeqCollection * GetListOfBrowsers () const;  ; TSeqCollection * GetListOfCanvases () const;  ; TCollection * GetListOfClasses () const;  ; TCollection * GetListOfClassGenerators () const;  ; TSeqCollection * GetListOfCleanups () const;  ; TSeqCollection * GetListOfClosedObjects () const;  ; TSeqCollection * GetListOfColors () const;  ; TSeqCollection * GetListOfDataSets () const;  ; TCollection * GetListOfEnums (Bool_t load=kFALSE);  ; TSeqCollection * GetListOfFiles () const;  ; TCollection * GetListOfFunctionOverloads (const char *n",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:13445,Modifiability,inherit,inherited,13445,"eates an instance of a class TCutG. ;  ; void SetDefCanvasName (const char *name=""c1"");  ; void SetEditHistograms (Bool_t flag=kTRUE);  ; void SetEditorMode (const char *mode="""");  Set editor mode. ;  ; void SetEscape (Bool_t flag=kTRUE);  ; void SetExecutingMacro (Bool_t flag=kTRUE);  ; void SetFromPopUp (Bool_t flag=kTRUE);  ; void SetInterrupt (Bool_t flag=kTRUE);  ; void SetLineHasBeenProcessed ();  ; void SetLineIsProcessing ();  ; void SetMustClean (Bool_t flag=kTRUE);  ; void SetReadingObject (Bool_t flag=kTRUE);  ; void SetSelectedPad (TVirtualPad *pad);  ; void SetSelectedPrimitive (const TObject *obj);  ; void SetStyle (const char *stylename=""Default"");  Change current style to style with name stylename. ;  ; void SetWebDisplay (const char *webdisplay="""");  Specify where web graphics shall be rendered. ;  ; void Streamer (TBuffer &) override;  TDirectory Streamer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Time (Int_t casetime=1);  ; Int_t Timer () const;  ;  Public Member Functions inherited from TDirectory;  TDirectory ();  Directory default constructor. ;  ;  TDirectory (const char *name, const char *title, Option_t *option="""", TDirectory *motherDir=nullptr);  Create a new Directory. ;  ; virtual ~TDirectory ();  Destructor. ;  ; virtual void Add (TObject *obj, Bool_t replace=kFALSE);  ; virtual Int_t AppendKey (TKey *);  ; virtual void Build (TFile *motherFile=nullptr, TDirectory *motherDir=nullptr);  ; virtual Bool_t cd ();  Change current directory to ""this"" directory. ;  ; virtual Bool_t cd (const char *path);  Change current directory to ""this"" directory or to the directory described by the path if given one. ;  ; void Clear (Option_t *option="""") override;  Delete all objects from a Directory list. ;  ; virtual TObject * CloneObject (const TObject *obj, Bool_t autoadd=kTRUE);  Clone an object. ;  ; virtual void Close (Option_t *option="""");  Delete all objects from memory and directory structure itself. ;  ; void Copy",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:19609,Modifiability,inherit,inherited,19609,"t=0) override;  Write this object to the current directory. ;  ; virtual void WriteDirHeader ();  ; virtual void WriteKeys ();  ; template<typename T > ; std::enable_if_t<!std::is_base_of< TObject, T >::value, Int_t > WriteObject (const T *obj, const char *name, Option_t *option="""", Int_t bufsize=0);  Write an object with proper type checking. ;  ; template<typename T > ; std::enable_if_t< std::is_base_of< TObject, T >::value, Int_t > WriteObject (const T *obj, const char *name, Option_t *option="""", Int_t bufsize=0);  Write an object with proper type checking. ;  ; virtual Int_t WriteObjectAny (const void *, const char *, const char *, Option_t *="""", Int_t=0);  ; virtual Int_t WriteObjectAny (const void *, const TClass *, const char *, Option_t *="""", Int_t=0);  ; virtual Int_t WriteTObject (const TObject *obj, const char *name=nullptr, Option_t *="""", Int_t=0);  Write an object with proper type checking. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:20998,Modifiability,inherit,inherited,20998,"e="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:21836,Modifiability,inherit,inheritance,21836,"SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics sys",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:23635,Modifiability,inherit,inherits,23635," action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ;  ; virtual Bool_t Notify ();  This method must be overridden to handle object notification (the base implementation is no-op).",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:23752,Modifiability,inherit,inherits,23752,"const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ;  ; virtual Bool_t Notify ();  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; void Obsolete (const char *method, const char *asOfVers, const char *removedFromVers) const;  Use this method ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:30195,Modifiability,extend,extend,30195," static const char * GetTutorialsDir ();  Get the tutorials directory in the installation. ;  ; static Int_t IncreaseDirLevel ();  Increase the indentation level for ls(). ;  ; static void IndentLevel ();  Functions used by ls() to indent an object hierarchy. ;  ; static void Initialize ();  Initialize ROOT explicitly. ;  ; static Bool_t Initialized ();  Return kTRUE if the TROOT object has been initialized. ;  ; static void RegisterModule (const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false);  Called by static dictionary initialization to register clang modules for headers. ;  ; static Int_t RootVersionCode ();  Return ROOT version code as defined in RVersion.h. ;  ; static void SetDirLevel (Int_t level=0);  Return Indentation level for ls(). ;  ; static void SetMacroPath (const char *newpath);  Set or extend the macro search path. ;  ; static void ShutDown ();  Shut down ROOT. ;  ;  Static Public Member Functions inherited from TDirectory; static void AddDirectory (Bool_t add=kTRUE);  Sets the flag controlling the automatic add objects like histograms, TGraph2D, etc in memory. ;  ; static Bool_t AddDirectoryStatus ();  Static function: see TDirectory::AddDirectory for more comments. ;  ; static Bool_t Cd (const char *path);  Change current directory to ""path"". ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static std::atomic< TDirectory * > & CurrentDirectory ();  Return the current directory for the current thread. ;  ; static const char * DeclFileName ();  ; static void DecodeNameCycle (const char *namecycle, char *name, Short_t &cycle, const size_t namesize=0);  Decode a namecycle ""aap;2"" into name ""aap"" and cycle ""2"". ;  ;  Static Public Member Functions inherited from TNamed; static TClass ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:30309,Modifiability,inherit,inherited,30309,"Level ();  Functions used by ls() to indent an object hierarchy. ;  ; static void Initialize ();  Initialize ROOT explicitly. ;  ; static Bool_t Initialized ();  Return kTRUE if the TROOT object has been initialized. ;  ; static void RegisterModule (const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false);  Called by static dictionary initialization to register clang modules for headers. ;  ; static Int_t RootVersionCode ();  Return ROOT version code as defined in RVersion.h. ;  ; static void SetDirLevel (Int_t level=0);  Return Indentation level for ls(). ;  ; static void SetMacroPath (const char *newpath);  Set or extend the macro search path. ;  ; static void ShutDown ();  Shut down ROOT. ;  ;  Static Public Member Functions inherited from TDirectory; static void AddDirectory (Bool_t add=kTRUE);  Sets the flag controlling the automatic add objects like histograms, TGraph2D, etc in memory. ;  ; static Bool_t AddDirectoryStatus ();  Static function: see TDirectory::AddDirectory for more comments. ;  ; static Bool_t Cd (const char *path);  Change current directory to ""path"". ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static std::atomic< TDirectory * > & CurrentDirectory ();  Return the current directory for the current thread. ;  ; static const char * DeclFileName ();  ; static void DecodeNameCycle (const char *namecycle, char *name, Short_t &cycle, const size_t namesize=0);  Decode a namecycle ""aap;2"" into name ""aap"" and cycle ""2"". ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObjec",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:31142,Modifiability,inherit,inherited,31142,"AddDirectory (Bool_t add=kTRUE);  Sets the flag controlling the automatic add objects like histograms, TGraph2D, etc in memory. ;  ; static Bool_t AddDirectoryStatus ();  Static function: see TDirectory::AddDirectory for more comments. ;  ; static Bool_t Cd (const char *path);  Change current directory to ""path"". ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static std::atomic< TDirectory * > & CurrentDirectory ();  Return the current directory for the current thread. ;  ; static const char * DeclFileName ();  ; static void DecodeNameCycle (const char *namecycle, char *name, Short_t &cycle, const size_t namesize=0);  Decode a namecycle ""aap;2"" into name ""aap"" and cycle ""2"". ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; typedef std::atomic< TListOfEnums * > AListOfEnums_t;  ;  Protected Types inherited from TDirectory; using SharedGDirectory_t = std::shared_ptr< std::atomic< TDirectory * > >;  Pointer to a list of TContext object pointing to this TDirectory. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions;  TROOT ();  Only used by Dictionary. ;  ; TListOfFunctions * GetGlobalFunctions ();  Internal routine returning, and creating if n",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:31352,Modifiability,inherit,inherited,31352,"AddDirectory (Bool_t add=kTRUE);  Sets the flag controlling the automatic add objects like histograms, TGraph2D, etc in memory. ;  ; static Bool_t AddDirectoryStatus ();  Static function: see TDirectory::AddDirectory for more comments. ;  ; static Bool_t Cd (const char *path);  Change current directory to ""path"". ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static std::atomic< TDirectory * > & CurrentDirectory ();  Return the current directory for the current thread. ;  ; static const char * DeclFileName ();  ; static void DecodeNameCycle (const char *namecycle, char *name, Short_t &cycle, const size_t namesize=0);  Decode a namecycle ""aap;2"" into name ""aap"" and cycle ""2"". ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; typedef std::atomic< TListOfEnums * > AListOfEnums_t;  ;  Protected Types inherited from TDirectory; using SharedGDirectory_t = std::shared_ptr< std::atomic< TDirectory * > >;  Pointer to a list of TContext object pointing to this TDirectory. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions;  TROOT ();  Only used by Dictionary. ;  ; TListOfFunctions * GetGlobalFunctions ();  Internal routine returning, and creating if n",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:31929,Modifiability,inherit,inherited,31929," (const char *namecycle, char *name, Short_t &cycle, const size_t namesize=0);  Decode a namecycle ""aap;2"" into name ""aap"" and cycle ""2"". ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; typedef std::atomic< TListOfEnums * > AListOfEnums_t;  ;  Protected Types inherited from TDirectory; using SharedGDirectory_t = std::shared_ptr< std::atomic< TDirectory * > >;  Pointer to a list of TContext object pointing to this TDirectory. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions;  TROOT ();  Only used by Dictionary. ;  ; TListOfFunctions * GetGlobalFunctions ();  Internal routine returning, and creating if necessary, the list of global function. ;  ; void InitInterpreter ();  Initialize interpreter (cling) ;  ; void InitSystem ();  Operating System interface. ;  ; void InitThreads ();  Initialize threads library. ;  ; void * operator new (size_t l);  ; void * operator new (size_t l, void *ptr);  ; void ReadGitInfo ();  Read Git commit SHA1 and branch name. ;  ;  Protected Member Functions inherited from TDirectory;  TDirectory (const TDirectory &directory)=delete;  ; void BuildDirectory (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; Bool_t cd1 (const char *path);  flag to add h",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:32120,Modifiability,inherit,inherited,32120,"nherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; typedef std::atomic< TListOfEnums * > AListOfEnums_t;  ;  Protected Types inherited from TDirectory; using SharedGDirectory_t = std::shared_ptr< std::atomic< TDirectory * > >;  Pointer to a list of TContext object pointing to this TDirectory. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions;  TROOT ();  Only used by Dictionary. ;  ; TListOfFunctions * GetGlobalFunctions ();  Internal routine returning, and creating if necessary, the list of global function. ;  ; void InitInterpreter ();  Initialize interpreter (cling) ;  ; void InitSystem ();  Operating System interface. ;  ; void InitThreads ();  Initialize threads library. ;  ; void * operator new (size_t l);  ; void * operator new (size_t l, void *ptr);  ; void ReadGitInfo ();  Read Git commit SHA1 and branch name. ;  ;  Protected Member Functions inherited from TDirectory;  TDirectory (const TDirectory &directory)=delete;  ; void BuildDirectory (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; Bool_t cd1 (const char *path);  flag to add histograms, graphs,etc to the directory ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.). ;  ; void FillFullPath (TString &buf) const;  ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:32738,Modifiability,inherit,inherited,32738,"s in the TObjectTable. ;  . Protected Types; typedef std::atomic< TListOfEnums * > AListOfEnums_t;  ;  Protected Types inherited from TDirectory; using SharedGDirectory_t = std::shared_ptr< std::atomic< TDirectory * > >;  Pointer to a list of TContext object pointing to this TDirectory. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions;  TROOT ();  Only used by Dictionary. ;  ; TListOfFunctions * GetGlobalFunctions ();  Internal routine returning, and creating if necessary, the list of global function. ;  ; void InitInterpreter ();  Initialize interpreter (cling) ;  ; void InitSystem ();  Operating System interface. ;  ; void InitThreads ();  Initialize threads library. ;  ; void * operator new (size_t l);  ; void * operator new (size_t l, void *ptr);  ; void ReadGitInfo ();  Read Git commit SHA1 and branch name. ;  ;  Protected Member Functions inherited from TDirectory;  TDirectory (const TDirectory &directory)=delete;  ; void BuildDirectory (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; Bool_t cd1 (const char *path);  flag to add histograms, graphs,etc to the directory ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.). ;  ; void FillFullPath (TString &buf) const;  Recursive method to fill full path for directory. ;  ; void operator= (const TDirectory &)=delete;  ; void RegisterContext (TContext *ctxt);  Register a TContext pointing to this TDirectory object. ;  ; void RegisterGDirectory (SharedGDirectory_t &ptr);  Register a std::atomic<TDirectory*> that will soon be pointing to this TDirectory object. ;  ; void UnregisterContext (TContext *ctxt);  UnRegister a TContext pointing to this TDirectory object. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:33627,Modifiability,inherit,inherited,33627," and branch name. ;  ;  Protected Member Functions inherited from TDirectory;  TDirectory (const TDirectory &directory)=delete;  ; void BuildDirectory (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; Bool_t cd1 (const char *path);  flag to add histograms, graphs,etc to the directory ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.). ;  ; void FillFullPath (TString &buf) const;  Recursive method to fill full path for directory. ;  ; void operator= (const TDirectory &)=delete;  ; void RegisterContext (TContext *ctxt);  Register a TContext pointing to this TDirectory object. ;  ; void RegisterGDirectory (SharedGDirectory_t &ptr);  Register a std::atomic<TDirectory*> that will soon be pointing to this TDirectory object. ;  ; void UnregisterContext (TContext *ctxt);  UnRegister a TContext pointing to this TDirectory object. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::atomic< TApplication * > fApplication;  Pointer to current application. ;  ; Bool_t fBatch;  True if session without graphics. ;  ; TList * fBrowsables;  List of browsables. ;  ; TSeqCollection * fBrowsers;  List of browsers. ;  ; Int_t fBuiltDate;  Date of ROOT built. ;  ; Int_t fBuiltTime;  Time of ROOT built. ;  ; TSeqCollection * fCanvases;  List of canvases. ;  ; TCollection * fClasses;  List of classes definition. ;  ; TCollection * fClassGenerators;  List of user defined class generators;. ;  ; TSeqCollection * fCleanups;  List of recursiveRemove collections. ;  ; TSeqCollection * fClipboard;  List of clipboard objects. ;  ; TSeqCollection * fClosedObjects;  List of closed objects from the list of files and sockets, so we can delete them if neededCl. ;  ; TSeqCollection * fColors;  List of colors. ;  ; TString fConfigFeatures;  ROO",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:34691,Modifiability,config,configure,34691,"onst char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::atomic< TApplication * > fApplication;  Pointer to current application. ;  ; Bool_t fBatch;  True if session without graphics. ;  ; TList * fBrowsables;  List of browsables. ;  ; TSeqCollection * fBrowsers;  List of browsers. ;  ; Int_t fBuiltDate;  Date of ROOT built. ;  ; Int_t fBuiltTime;  Time of ROOT built. ;  ; TSeqCollection * fCanvases;  List of canvases. ;  ; TCollection * fClasses;  List of classes definition. ;  ; TCollection * fClassGenerators;  List of user defined class generators;. ;  ; TSeqCollection * fCleanups;  List of recursiveRemove collections. ;  ; TSeqCollection * fClipboard;  List of clipboard objects. ;  ; TSeqCollection * fClosedObjects;  List of closed objects from the list of files and sockets, so we can delete them if neededCl. ;  ; TSeqCollection * fColors;  List of colors. ;  ; TString fConfigFeatures;  ROOT ./configure detected build features. ;  ; TString fConfigOptions;  ROOT ./configure set build options. ;  ; TString fCutClassName;  Name of default CutG class in graphics editor. ;  ; TSeqCollection * fDataSets;  List of data sets (TDSet or TChain) ;  ; TString fDefCanvasName;  Name of default canvas. ;  ; Bool_t fEditHistograms;  True if histograms can be edited with the mouse. ;  ; Int_t fEditorMode;  Current Editor mode. ;  ; AListOfEnums_t fEnums;  List of enum types. ;  ; Bool_t fEscape;  True if ESC has been pressed. ;  ; Bool_t fExecutingMacro;  True while executing a TMacro. ;  ; TSeqCollection * fFiles;  List of files. ;  ; Bool_t fForceStyle;  Force setting of current style when reading objects. ;  ; Bool_t fFromPopUp;  True if command executed from a popup menu. ;  ; TListOfFunctionTemplates * fFuncTemplate;  List of global function templates. ;  ; TCollection * fFunctions;  List of analytic functions. ;  ; TSeqCollection * fGeometries;  List of geometries. ;  ; TString fGitBranch;  Git branch",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:34763,Modifiability,config,configure,34763,"ted). ;  ; void MakeZombie ();  . Protected Attributes; std::atomic< TApplication * > fApplication;  Pointer to current application. ;  ; Bool_t fBatch;  True if session without graphics. ;  ; TList * fBrowsables;  List of browsables. ;  ; TSeqCollection * fBrowsers;  List of browsers. ;  ; Int_t fBuiltDate;  Date of ROOT built. ;  ; Int_t fBuiltTime;  Time of ROOT built. ;  ; TSeqCollection * fCanvases;  List of canvases. ;  ; TCollection * fClasses;  List of classes definition. ;  ; TCollection * fClassGenerators;  List of user defined class generators;. ;  ; TSeqCollection * fCleanups;  List of recursiveRemove collections. ;  ; TSeqCollection * fClipboard;  List of clipboard objects. ;  ; TSeqCollection * fClosedObjects;  List of closed objects from the list of files and sockets, so we can delete them if neededCl. ;  ; TSeqCollection * fColors;  List of colors. ;  ; TString fConfigFeatures;  ROOT ./configure detected build features. ;  ; TString fConfigOptions;  ROOT ./configure set build options. ;  ; TString fCutClassName;  Name of default CutG class in graphics editor. ;  ; TSeqCollection * fDataSets;  List of data sets (TDSet or TChain) ;  ; TString fDefCanvasName;  Name of default canvas. ;  ; Bool_t fEditHistograms;  True if histograms can be edited with the mouse. ;  ; Int_t fEditorMode;  Current Editor mode. ;  ; AListOfEnums_t fEnums;  List of enum types. ;  ; Bool_t fEscape;  True if ESC has been pressed. ;  ; Bool_t fExecutingMacro;  True while executing a TMacro. ;  ; TSeqCollection * fFiles;  List of files. ;  ; Bool_t fForceStyle;  Force setting of current style when reading objects. ;  ; Bool_t fFromPopUp;  True if command executed from a popup menu. ;  ; TListOfFunctionTemplates * fFuncTemplate;  List of global function templates. ;  ; TCollection * fFunctions;  List of analytic functions. ;  ; TSeqCollection * fGeometries;  List of geometries. ;  ; TString fGitBranch;  Git branch. ;  ; TString fGitCommit;  Git commit SHA1 of built. ;  ; TString fG",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:35940,Modifiability,variab,variables,35940,s (TDSet or TChain) ;  ; TString fDefCanvasName;  Name of default canvas. ;  ; Bool_t fEditHistograms;  True if histograms can be edited with the mouse. ;  ; Int_t fEditorMode;  Current Editor mode. ;  ; AListOfEnums_t fEnums;  List of enum types. ;  ; Bool_t fEscape;  True if ESC has been pressed. ;  ; Bool_t fExecutingMacro;  True while executing a TMacro. ;  ; TSeqCollection * fFiles;  List of files. ;  ; Bool_t fForceStyle;  Force setting of current style when reading objects. ;  ; Bool_t fFromPopUp;  True if command executed from a popup menu. ;  ; TListOfFunctionTemplates * fFuncTemplate;  List of global function templates. ;  ; TCollection * fFunctions;  List of analytic functions. ;  ; TSeqCollection * fGeometries;  List of geometries. ;  ; TString fGitBranch;  Git branch. ;  ; TString fGitCommit;  Git commit SHA1 of built. ;  ; TString fGitDate;  Date and time when make was run. ;  ; TListOfFunctions * fGlobalFunctions;  List of global functions. ;  ; TListOfDataMembers * fGlobals;  List of global variables. ;  ; TInterpreter * fInterpreter;  Command interpreter. ;  ; Bool_t fInterrupt;  True if macro should be interrupted. ;  ; Bool_t fIsWebDisplay;  True if session uses web widgets. ;  ; Bool_t fIsWebDisplayBatch;  True if web widgets are not displayed. ;  ; TSeqCollection * fMappedFiles;  List of memory mapped files. ;  ; TSeqCollection * fMessageHandlers;  List of message handlers. ;  ; Bool_t fMustClean;  True if object destructor scans canvases. ;  ; TPluginManager * fPluginManager;  Keeps track of plugin library handlers. ;  ; const TObject * fPrimitive;  Currently selected primitive. ;  ; TSeqCollection * fProofs;  List of proof sessions. ;  ; TFolder * fRootFolder;  top level folder //root ;  ; TSeqCollection * fSecContexts;  List of security contexts (TSecContext) ;  ; TVirtualPad * fSelectPad;  Currently selected pad. ;  ; TSeqCollection * fSockets;  List of network sockets. ;  ; TSeqCollection * fSpecials;  List of special objects. ;  ; TSeqColle,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:36457,Modifiability,plugin,plugin,36457,and executed from a popup menu. ;  ; TListOfFunctionTemplates * fFuncTemplate;  List of global function templates. ;  ; TCollection * fFunctions;  List of analytic functions. ;  ; TSeqCollection * fGeometries;  List of geometries. ;  ; TString fGitBranch;  Git branch. ;  ; TString fGitCommit;  Git commit SHA1 of built. ;  ; TString fGitDate;  Date and time when make was run. ;  ; TListOfFunctions * fGlobalFunctions;  List of global functions. ;  ; TListOfDataMembers * fGlobals;  List of global variables. ;  ; TInterpreter * fInterpreter;  Command interpreter. ;  ; Bool_t fInterrupt;  True if macro should be interrupted. ;  ; Bool_t fIsWebDisplay;  True if session uses web widgets. ;  ; Bool_t fIsWebDisplayBatch;  True if web widgets are not displayed. ;  ; TSeqCollection * fMappedFiles;  List of memory mapped files. ;  ; TSeqCollection * fMessageHandlers;  List of message handlers. ;  ; Bool_t fMustClean;  True if object destructor scans canvases. ;  ; TPluginManager * fPluginManager;  Keeps track of plugin library handlers. ;  ; const TObject * fPrimitive;  Currently selected primitive. ;  ; TSeqCollection * fProofs;  List of proof sessions. ;  ; TFolder * fRootFolder;  top level folder //root ;  ; TSeqCollection * fSecContexts;  List of security contexts (TSecContext) ;  ; TVirtualPad * fSelectPad;  Currently selected pad. ;  ; TSeqCollection * fSockets;  List of network sockets. ;  ; TSeqCollection * fSpecials;  List of special objects. ;  ; TSeqCollection * fStreamerInfo;  List of active StreamerInfo classes. ;  ; TSeqCollection * fStyles;  List of styles. ;  ; TSeqCollection * fTasks;  List of tasks. ;  ; Int_t fTimer;  Timer flag. ;  ; TCollection * fTypes;  List of data types definition. ;  ; TProcessUUID * fUUIDs;  Pointer to TProcessID managing TUUIDs. ;  ; TString fVersion;  ROOT version (from CMZ VERSQQ) ex 0.05/01. ;  ; Int_t fVersionCode;  ROOT version code as used in RVersion.h. ;  ; Int_t fVersionDate;  Date of ROOT version (ex 951226) ;  ; Int_t fVers,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:37684,Modifiability,inherit,inherited,37684,"xts (TSecContext) ;  ; TVirtualPad * fSelectPad;  Currently selected pad. ;  ; TSeqCollection * fSockets;  List of network sockets. ;  ; TSeqCollection * fSpecials;  List of special objects. ;  ; TSeqCollection * fStreamerInfo;  List of active StreamerInfo classes. ;  ; TSeqCollection * fStyles;  List of styles. ;  ; TSeqCollection * fTasks;  List of tasks. ;  ; Int_t fTimer;  Timer flag. ;  ; TCollection * fTypes;  List of data types definition. ;  ; TProcessUUID * fUUIDs;  Pointer to TProcessID managing TUUIDs. ;  ; TString fVersion;  ROOT version (from CMZ VERSQQ) ex 0.05/01. ;  ; Int_t fVersionCode;  ROOT version code as used in RVersion.h. ;  ; Int_t fVersionDate;  Date of ROOT version (ex 951226) ;  ; Int_t fVersionInt;  ROOT version in integer format (501) ;  ; Int_t fVersionTime;  Time of ROOT version (ex 1152) ;  ; TString fWebDisplay;  If not empty it defines where web graphics should be rendered (cef, qt5, browser...) ;  ;  Protected Attributes inherited from TDirectory; TContext * fContext {nullptr};  Buffer for GetPath() function. ;  ; std::atomic< size_t > fContextPeg {0};  thread local gDirectory pointing to this object. ;  ; std::vector< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions;  TROOT (const TROOT &)=delete;  ; TROOT & operator= (const TROOT &)=delete;  . Private Attributes; Int_t fLineIsProcessing;  To synchronize multi-threads. ;  . Static Private Attributes; static Int_t fgDirLevel = 0;  Indentation level for ls() ;  ; static Bool_t fgRootInit = kFALSE;  Singleton initialization flag. ;  . Friends; class ::ROOT::Internal::TROOTAllocator;  ; TROOT * ROOT::Internal::GetROOT2 ();  ; class TCling;  . Additional Inherited Members;  Static Protected Member Fun",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:38140,Modifiability,inherit,inherited,38140,"types definition. ;  ; TProcessUUID * fUUIDs;  Pointer to TProcessID managing TUUIDs. ;  ; TString fVersion;  ROOT version (from CMZ VERSQQ) ex 0.05/01. ;  ; Int_t fVersionCode;  ROOT version code as used in RVersion.h. ;  ; Int_t fVersionDate;  Date of ROOT version (ex 951226) ;  ; Int_t fVersionInt;  ROOT version in integer format (501) ;  ; Int_t fVersionTime;  Time of ROOT version (ex 1152) ;  ; TString fWebDisplay;  If not empty it defines where web graphics should be rendered (cef, qt5, browser...) ;  ;  Protected Attributes inherited from TDirectory; TContext * fContext {nullptr};  Buffer for GetPath() function. ;  ; std::atomic< size_t > fContextPeg {0};  thread local gDirectory pointing to this object. ;  ; std::vector< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions;  TROOT (const TROOT &)=delete;  ; TROOT & operator= (const TROOT &)=delete;  . Private Attributes; Int_t fLineIsProcessing;  To synchronize multi-threads. ;  . Static Private Attributes; static Int_t fgDirLevel = 0;  Indentation level for ls() ;  ; static Bool_t fgRootInit = kFALSE;  Singleton initialization flag. ;  . Friends; class ::ROOT::Internal::TROOTAllocator;  ; TROOT * ROOT::Internal::GetROOT2 ();  ; class TCling;  . Additional Inherited Members;  Static Protected Member Functions inherited from TDirectory; static Bool_t Cd1 (const char *path);  Change current directory to ""path"". ;  ; static SharedGDirectory_t & GetSharedLocalCurrentDirectory ();  Return the (address of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't sup",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:38721,Modifiability,inherit,inherited,38721,"r};  Buffer for GetPath() function. ;  ; std::atomic< size_t > fContextPeg {0};  thread local gDirectory pointing to this object. ;  ; std::vector< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions;  TROOT (const TROOT &)=delete;  ; TROOT & operator= (const TROOT &)=delete;  . Private Attributes; Int_t fLineIsProcessing;  To synchronize multi-threads. ;  . Static Private Attributes; static Int_t fgDirLevel = 0;  Indentation level for ls() ;  ; static Bool_t fgRootInit = kFALSE;  Singleton initialization flag. ;  . Friends; class ::ROOT::Internal::TROOTAllocator;  ; TROOT * ROOT::Internal::GetROOT2 ();  ; class TCling;  . Additional Inherited Members;  Static Protected Member Functions inherited from TDirectory; static Bool_t Cd1 (const char *path);  Change current directory to ""path"". ;  ; static SharedGDirectory_t & GetSharedLocalCurrentDirectory ();  Return the (address of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TROOT.h>. Inheritance diagram for TROOT:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ AListOfEnums_t. typedef std::atomic<TListOfEnums*> TROOT::AListOfEnums_t. protected . Definition at line 109 of file TROOT.h. ◆ FwdDeclArgsToKeepCollection_t. typedef std::vector<std::pair<std::string, int> > TROOT::FwdDeclArgsToKeepCollection_t. Definition at line 187 of file TROOT.h. Constructor & Destructor Documentation. ◆ TROOT() [1/3]. TROOT::TROOT ; (; const TROOT & ; ).",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:39066,Modifiability,inherit,inherited,39066,"TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions;  TROOT (const TROOT &)=delete;  ; TROOT & operator= (const TROOT &)=delete;  . Private Attributes; Int_t fLineIsProcessing;  To synchronize multi-threads. ;  . Static Private Attributes; static Int_t fgDirLevel = 0;  Indentation level for ls() ;  ; static Bool_t fgRootInit = kFALSE;  Singleton initialization flag. ;  . Friends; class ::ROOT::Internal::TROOTAllocator;  ; TROOT * ROOT::Internal::GetROOT2 ();  ; class TCling;  . Additional Inherited Members;  Static Protected Member Functions inherited from TDirectory; static Bool_t Cd1 (const char *path);  Change current directory to ""path"". ;  ; static SharedGDirectory_t & GetSharedLocalCurrentDirectory ();  Return the (address of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TROOT.h>. Inheritance diagram for TROOT:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ AListOfEnums_t. typedef std::atomic<TListOfEnums*> TROOT::AListOfEnums_t. protected . Definition at line 109 of file TROOT.h. ◆ FwdDeclArgsToKeepCollection_t. typedef std::vector<std::pair<std::string, int> > TROOT::FwdDeclArgsToKeepCollection_t. Definition at line 187 of file TROOT.h. Constructor & Destructor Documentation. ◆ TROOT() [1/3]. TROOT::TROOT ; (; const TROOT & ; ). privatedelete . ◆ TROOT() [2/3]. TROOT::TROOT ; (; ). protected . Only used by Dictionary. ; Default ctor. ; Definition at line 605 of file TROOT.cxx. ◆ TROOT() [3/3]. TROOT::TROOT ; (; const char * ; name, . const char * ; title, . VoidFuncPtr_t * ; initfunc = nullptr . ). Initialize the ROOT system. ; The creation of the TROOT object initializes the ROOT sys",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:40927,Modifiability,extend,extend,40927," . const char * ; title, . VoidFuncPtr_t * ; initfunc = nullptr . ). Initialize the ROOT system. ; The creation of the TROOT object initializes the ROOT system. It must be the first ROOT related action that is performed by a program. The TROOT object must be created on the stack (can not be called via new since ""operator new"" is protected). The TROOT object is either created as a global object (outside the main() program), or it is one of the first objects created in main(). Make sure that the TROOT object stays in scope for as long as ROOT related actions are performed. TROOT is a so called singleton so only one instance of it can be created. The single TROOT object can always be accessed via the global pointer gROOT. The name and title arguments can be used to identify the running application. The initfunc argument can contain an array of function pointers (last element must be 0). These functions are executed at the end of the constructor. This way one can easily extend the ROOT system without adding permanent dependencies (e.g. the graphics system is initialized via such a function). ; Definition at line 639 of file TROOT.cxx. ◆ ~TROOT(). TROOT::~TROOT ; (; ). virtual . Clean up and free resources used by ROOT (files, network sockets, shared memory segments, etc.). ; Definition at line 867 of file TROOT.cxx. Member Function Documentation. ◆ AddClass(). void TROOT::AddClass ; (; TClass * ; cl). Add a class to the list and map of classes. ; This routine is deprecated, use TClass::AddClass directly. ; Definition at line 1025 of file TROOT.cxx. ◆ AddClassGenerator(). void TROOT::AddClassGenerator ; (; TClassGenerator * ; generator). Add a class generator. ; This generator will be called by TClass::GetClass in case its does not find a loaded rootcint dictionary to request the creation of a TClass object. ; Definition at line 1035 of file TROOT.cxx. ◆ AddExtraInterpreterArgs(). const std::vector< std::string > & TROOT::AddExtraInterpreterArgs ; (; const std::vector< st",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:52386,Modifiability,variab,variable,52386,"Definition at line 220 of file TROOT.h. ◆ GetFunction(). TObject * TROOT::GetFunction ; (; const char * ; name); const. Return pointer to function with name. ; Definition at line 1587 of file TROOT.cxx. ◆ GetFunctionTemplate(). TFunctionTemplate * TROOT::GetFunctionTemplate ; (; const char * ; name). Definition at line 1618 of file TROOT.cxx. ◆ GetGeometry(). TObject * TROOT::GetGeometry ; (; const char * ; name); const. Return pointer to Geometry with name. ; Definition at line 1747 of file TROOT.cxx. ◆ GetGitBranch(). const char * TROOT::GetGitBranch ; (; ); const. inline . Definition at line 224 of file TROOT.h. ◆ GetGitCommit(). const char * TROOT::GetGitCommit ; (; ); const. inline . Definition at line 223 of file TROOT.h. ◆ GetGitDate(). const char * TROOT::GetGitDate ; (; ). Return date/time make was run. ; Definition at line 2474 of file TROOT.cxx. ◆ GetGlobal() [1/2]. TGlobal * TROOT::GetGlobal ; (; const char * ; name, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable by name. ; If load is true force reading of all currently defined globals from CINT (more expensive). ; Definition at line 1631 of file TROOT.cxx. ◆ GetGlobal() [2/2]. TGlobal * TROOT::GetGlobal ; (; const TObject * ; obj, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable with address addr. ; Definition at line 1639 of file TROOT.cxx. ◆ GetGlobalFunction(). TFunction * TROOT::GetGlobalFunction ; (; const char * ; function, . const char * ; params = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If params != 0 it will also resolve overloading other it returns the first name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necess",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:52680,Modifiability,variab,variable,52680,"). Definition at line 1618 of file TROOT.cxx. ◆ GetGeometry(). TObject * TROOT::GetGeometry ; (; const char * ; name); const. Return pointer to Geometry with name. ; Definition at line 1747 of file TROOT.cxx. ◆ GetGitBranch(). const char * TROOT::GetGitBranch ; (; ); const. inline . Definition at line 224 of file TROOT.h. ◆ GetGitCommit(). const char * TROOT::GetGitCommit ; (; ); const. inline . Definition at line 223 of file TROOT.h. ◆ GetGitDate(). const char * TROOT::GetGitDate ; (; ). Return date/time make was run. ; Definition at line 2474 of file TROOT.cxx. ◆ GetGlobal() [1/2]. TGlobal * TROOT::GetGlobal ; (; const char * ; name, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable by name. ; If load is true force reading of all currently defined globals from CINT (more expensive). ; Definition at line 1631 of file TROOT.cxx. ◆ GetGlobal() [2/2]. TGlobal * TROOT::GetGlobal ; (; const TObject * ; obj, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable with address addr. ; Definition at line 1639 of file TROOT.cxx. ◆ GetGlobalFunction(). TFunction * TROOT::GetGlobalFunction ; (; const char * ; function, . const char * ; params = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If params != 0 it will also resolve overloading other it returns the first name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necessary, the list of global function. ; Definition at line 1663 of file TROOT.cxx. ◆ GetGlobalFunctionWithPrototype(). TFunction * TROOT::GetGlobalFunctionWithPrototype ; (; const char * ; function, . const char * ; proto = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by nam",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:70559,Modifiability,variab,variable,70559,"OT & TROOT::operator= ; (; const TROOT & ; ). privatedelete . ◆ ProcessLine(). Longptr_t TROOT::ProcessLine ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplication::ProcessLine(). ; On Win32 the line will be processed asynchronously by sending it to the CINT interpreter thread. For explicit synchronous processing use ProcessLineSync(). On non-Win32 platforms there is no difference between ProcessLine() and ProcessLineSync(). The possible error codes are defined by TInterpreter::EErrorCode. In particular, error will equal to TInterpreter::kProcessing until the CINT interpreted thread has finished executing the line. Returns the result of the command, cast to a Longptr_t. ; Definition at line 2370 of file TROOT.cxx. ◆ ProcessLineFast(). Longptr_t TROOT::ProcessLineFast ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command directly via CINT interpreter. ; Only executable statements are allowed (no variable declarations), In all other cases use TROOT::ProcessLine(). The possible error codes are defined by TInterpreter::EErrorCode. ; Definition at line 2407 of file TROOT.cxx. ◆ ProcessLineSync(). Longptr_t TROOT::ProcessLineSync ; (; const char * ; line, . Int_t * ; error = nullptr . ). Process interpreter command via TApplication::ProcessLine(). ; On Win32 the line will be processed synchronously (i.e. it will only return when the CINT interpreter thread has finished executing the line). On non-Win32 platforms there is no difference between ProcessLine() and ProcessLineSync(). The possible error codes are defined by TInterpreter::EErrorCode. Returns the result of the command, cast to a Longptr_t. ; Definition at line 2390 of file TROOT.cxx. ◆ ReadGitInfo(). void TROOT::ReadGitInfo ; (; ). protected . Read Git commit SHA1 and branch name. ; Read Git commit information and branch name from the etc/gitinfo.txt file. ; Definition at line 2429 of file TROOT.cxx. ◆ ReadingObject(). Bool_t TROOT::",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:76949,Modifiability,extend,extend,76949,"finition at line 322 of file TROOT.h. ◆ SetEditorMode(). void TROOT::SetEditorMode ; (; const char * ; mode = """"). Set editor mode. ; Definition at line 2704 of file TROOT.cxx. ◆ SetEscape(). void TROOT::SetEscape ; (; Bool_t ; flag = kTRUE). inline . Definition at line 327 of file TROOT.h. ◆ SetExecutingMacro(). void TROOT::SetExecutingMacro ; (; Bool_t ; flag = kTRUE). inline . Definition at line 324 of file TROOT.h. ◆ SetFromPopUp(). void TROOT::SetFromPopUp ; (; Bool_t ; flag = kTRUE). inline . Definition at line 325 of file TROOT.h. ◆ SetInterrupt(). void TROOT::SetInterrupt ; (; Bool_t ; flag = kTRUE). inline . Definition at line 326 of file TROOT.h. ◆ SetLineHasBeenProcessed(). void TROOT::SetLineHasBeenProcessed ; (; ). inline . Definition at line 329 of file TROOT.h. ◆ SetLineIsProcessing(). void TROOT::SetLineIsProcessing ; (; ). inline . Definition at line 328 of file TROOT.h. ◆ SetMacroPath(). void TROOT::SetMacroPath ; (; const char * ; newpath). static . Set or extend the macro search path. ; Static utility function. If newpath=0 or """" reset to value specified in the rootrc file. ; Definition at line 2788 of file TROOT.cxx. ◆ SetMustClean(). void TROOT::SetMustClean ; (; Bool_t ; flag = kTRUE). inline . Definition at line 331 of file TROOT.h. ◆ SetReadingObject(). void TROOT::SetReadingObject ; (; Bool_t ; flag = kTRUE). Definition at line 2465 of file TROOT.cxx. ◆ SetSelectedPad(). void TROOT::SetSelectedPad ; (; TVirtualPad * ; pad). inline . Definition at line 333 of file TROOT.h. ◆ SetSelectedPrimitive(). void TROOT::SetSelectedPrimitive ; (; const TObject * ; obj). inline . Definition at line 332 of file TROOT.h. ◆ SetStyle(). void TROOT::SetStyle ; (; const char * ; stylename = ""Default""). Change current style to style with name stylename. ; Definition at line 2730 of file TROOT.cxx. ◆ SetWebDisplay(). void TROOT::SetWebDisplay ; (; const char * ; webdisplay = """"). Specify where web graphics shall be rendered. ; The input parameter webdisplay defi",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:81957,Modifiability,config,configure,81957,"canvases. ; Definition at line 149 of file TROOT.h. ◆ fClasses. TCollection* TROOT::fClasses. protected . List of classes definition. ; Definition at line 140 of file TROOT.h. ◆ fClassGenerators. TCollection* TROOT::fClassGenerators. protected . List of user defined class generators;. ; Definition at line 160 of file TROOT.h. ◆ fCleanups. TSeqCollection* TROOT::fCleanups. protected . List of recursiveRemove collections. ; Definition at line 157 of file TROOT.h. ◆ fClipboard. TSeqCollection* TROOT::fClipboard. protected . List of clipboard objects. ; Definition at line 163 of file TROOT.h. ◆ fClosedObjects. TSeqCollection* TROOT::fClosedObjects. protected . List of closed objects from the list of files and sockets, so we can delete them if neededCl. ; Definition at line 145 of file TROOT.h. ◆ fColors. TSeqCollection* TROOT::fColors. protected . List of colors. ; Definition at line 153 of file TROOT.h. ◆ fConfigFeatures. TString TROOT::fConfigFeatures. protected . ROOT ./configure detected build features. ; Definition at line 112 of file TROOT.h. ◆ fConfigOptions. TString TROOT::fConfigOptions. protected . ROOT ./configure set build options. ; Definition at line 111 of file TROOT.h. ◆ fCutClassName. TString TROOT::fCutClassName. protected . Name of default CutG class in graphics editor. ; Definition at line 170 of file TROOT.h. ◆ fDataSets. TSeqCollection* TROOT::fDataSets. protected . List of data sets (TDSet or TChain) ; Definition at line 164 of file TROOT.h. ◆ fDefCanvasName. TString TROOT::fDefCanvasName. protected . Name of default canvas. ; Definition at line 171 of file TROOT.h. ◆ fEditHistograms. Bool_t TROOT::fEditHistograms. protected . True if histograms can be edited with the mouse. ; Definition at line 130 of file TROOT.h. ◆ fEditorMode. Int_t TROOT::fEditorMode. protected . Current Editor mode. ; Definition at line 137 of file TROOT.h. ◆ fEnums. AListOfEnums_t TROOT::fEnums. protected . List of enum types. ; Definition at line 165 of file TROOT.h. ◆ fEsc",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:82102,Modifiability,config,configure,82102,"tion at line 140 of file TROOT.h. ◆ fClassGenerators. TCollection* TROOT::fClassGenerators. protected . List of user defined class generators;. ; Definition at line 160 of file TROOT.h. ◆ fCleanups. TSeqCollection* TROOT::fCleanups. protected . List of recursiveRemove collections. ; Definition at line 157 of file TROOT.h. ◆ fClipboard. TSeqCollection* TROOT::fClipboard. protected . List of clipboard objects. ; Definition at line 163 of file TROOT.h. ◆ fClosedObjects. TSeqCollection* TROOT::fClosedObjects. protected . List of closed objects from the list of files and sockets, so we can delete them if neededCl. ; Definition at line 145 of file TROOT.h. ◆ fColors. TSeqCollection* TROOT::fColors. protected . List of colors. ; Definition at line 153 of file TROOT.h. ◆ fConfigFeatures. TString TROOT::fConfigFeatures. protected . ROOT ./configure detected build features. ; Definition at line 112 of file TROOT.h. ◆ fConfigOptions. TString TROOT::fConfigOptions. protected . ROOT ./configure set build options. ; Definition at line 111 of file TROOT.h. ◆ fCutClassName. TString TROOT::fCutClassName. protected . Name of default CutG class in graphics editor. ; Definition at line 170 of file TROOT.h. ◆ fDataSets. TSeqCollection* TROOT::fDataSets. protected . List of data sets (TDSet or TChain) ; Definition at line 164 of file TROOT.h. ◆ fDefCanvasName. TString TROOT::fDefCanvasName. protected . Name of default canvas. ; Definition at line 171 of file TROOT.h. ◆ fEditHistograms. Bool_t TROOT::fEditHistograms. protected . True if histograms can be edited with the mouse. ; Definition at line 130 of file TROOT.h. ◆ fEditorMode. Int_t TROOT::fEditorMode. protected . Current Editor mode. ; Definition at line 137 of file TROOT.h. ◆ fEnums. AListOfEnums_t TROOT::fEnums. protected . List of enum types. ; Definition at line 165 of file TROOT.h. ◆ fEscape. Bool_t TROOT::fEscape. protected . True if ESC has been pressed. ; Definition at line 135 of file TROOT.h. ◆ fExecutingMacro. Bool_t TROO",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:84724,Modifiability,variab,variables,84724,mplates. ; Definition at line 142 of file TROOT.h. ◆ fFunctions. TCollection* TROOT::fFunctions. protected . List of analytic functions. ; Definition at line 151 of file TROOT.h. ◆ fgDirLevel. Int_t TROOT::fgDirLevel = 0. staticprivate . Indentation level for ls() ; Definition at line 102 of file TROOT.h. ◆ fGeometries. TSeqCollection* TROOT::fGeometries. protected . List of geometries. ; Definition at line 154 of file TROOT.h. ◆ fGitBranch. TString TROOT::fGitBranch. protected . Git branch. ; Definition at line 121 of file TROOT.h. ◆ fGitCommit. TString TROOT::fGitCommit. protected . Git commit SHA1 of built. ; Definition at line 120 of file TROOT.h. ◆ fGitDate. TString TROOT::fGitDate. protected . Date and time when make was run. ; Definition at line 122 of file TROOT.h. ◆ fGlobalFunctions. TListOfFunctions* TROOT::fGlobalFunctions. protected . List of global functions. ; Definition at line 144 of file TROOT.h. ◆ fGlobals. TListOfDataMembers* TROOT::fGlobals. protected . List of global variables. ; Definition at line 143 of file TROOT.h. ◆ fgRootInit. Bool_t TROOT::fgRootInit = kFALSE. staticprivate . Singleton initialization flag. ; Definition at line 103 of file TROOT.h. ◆ fInterpreter. TInterpreter* TROOT::fInterpreter. protected . Command interpreter. ; Definition at line 125 of file TROOT.h. ◆ fInterrupt. Bool_t TROOT::fInterrupt. protected . True if macro should be interrupted. ; Definition at line 134 of file TROOT.h. ◆ fIsWebDisplay. Bool_t TROOT::fIsWebDisplay. protected . True if session uses web widgets. ; Definition at line 128 of file TROOT.h. ◆ fIsWebDisplayBatch. Bool_t TROOT::fIsWebDisplayBatch. protected . True if web widgets are not displayed. ; Definition at line 129 of file TROOT.h. ◆ fLineIsProcessing. Int_t TROOT::fLineIsProcessing. private . To synchronize multi-threads. ; Definition at line 100 of file TROOT.h. ◆ fMappedFiles. TSeqCollection* TROOT::fMappedFiles. protected . List of memory mapped files. ; Definition at line 147 of file TROO,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:86087,Modifiability,plugin,plugin,86087,. True if macro should be interrupted. ; Definition at line 134 of file TROOT.h. ◆ fIsWebDisplay. Bool_t TROOT::fIsWebDisplay. protected . True if session uses web widgets. ; Definition at line 128 of file TROOT.h. ◆ fIsWebDisplayBatch. Bool_t TROOT::fIsWebDisplayBatch. protected . True if web widgets are not displayed. ; Definition at line 129 of file TROOT.h. ◆ fLineIsProcessing. Int_t TROOT::fLineIsProcessing. private . To synchronize multi-threads. ; Definition at line 100 of file TROOT.h. ◆ fMappedFiles. TSeqCollection* TROOT::fMappedFiles. protected . List of memory mapped files. ; Definition at line 147 of file TROOT.h. ◆ fMessageHandlers. TSeqCollection* TROOT::fMessageHandlers. protected . List of message handlers. ; Definition at line 158 of file TROOT.h. ◆ fMustClean. Bool_t TROOT::fMustClean. protected . True if object destructor scans canvases. ; Definition at line 132 of file TROOT.h. ◆ fPluginManager. TPluginManager* TROOT::fPluginManager. protected . Keeps track of plugin library handlers. ; Definition at line 169 of file TROOT.h. ◆ fPrimitive. const TObject* TROOT::fPrimitive. protected . Currently selected primitive. ; Definition at line 138 of file TROOT.h. ◆ fProofs. TSeqCollection* TROOT::fProofs. protected . List of proof sessions. ; Definition at line 162 of file TROOT.h. ◆ fRootFolder. TFolder* TROOT::fRootFolder. protected . top level folder //root ; Definition at line 167 of file TROOT.h. ◆ fSecContexts. TSeqCollection* TROOT::fSecContexts. protected . List of security contexts (TSecContext) ; Definition at line 161 of file TROOT.h. ◆ fSelectPad. TVirtualPad* TROOT::fSelectPad. protected . Currently selected pad. ; Definition at line 139 of file TROOT.h. ◆ fSockets. TSeqCollection* TROOT::fSockets. protected . List of network sockets. ; Definition at line 148 of file TROOT.h. ◆ fSpecials. TSeqCollection* TROOT::fSpecials. protected . List of special objects. ; Definition at line 156 of file TROOT.h. ◆ fStreamerInfo. TSeqCollection* TROOT::f,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:4793,Performance,load,load,4793,"lar those that must be executed before the library start being unloaded. ;  ; TObject * FindObject (const char *name) const override;  Returns address of a ROOT object if it exists. ;  ; TObject * FindObject (const TObject *obj) const override;  Find an object in one Root folder. ;  ; TObject * FindObjectAny (const char *name) const override;  Return a pointer to the first object with name starting at //root. ;  ; TObject * FindObjectAnyFile (const char *name) const override;  Scan the memory lists of all files for an object with name. ;  ; const char * FindObjectClassName (const char *name) const;  Returns class name of a ROOT object including CINT globals. ;  ; const char * FindObjectPathName (const TObject *obj) const;  Return path name of obj somewhere in the //root/... path. ;  ; TObject * FindSpecialObject (const char *name, void *&where);  Returns address and folder of a ROOT object if it exists. ;  ; TClass * FindSTLClass (const char *name, Bool_t load, Bool_t silent=kFALSE) const;  return a TClass object corresponding to 'name' assuming it is an STL container. ;  ; void ForceStyle (Bool_t force=kTRUE);  ; Bool_t FromPopUp () const;  ; TApplication * GetApplication () const;  ; Int_t GetBuiltDate () const;  ; Int_t GetBuiltTime () const;  ; TClass * GetClass (const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) const;  Return pointer to class with name. Obsolete, use TClass::GetClass directly. ;  ; TClass * GetClass (const std::type_info &typeinfo, Bool_t load=kTRUE, Bool_t silent=kFALSE) const;  Return pointer to class from its name. ;  ; TSeqCollection * GetClipboard () const;  ; TColor * GetColor (Int_t color) const;  Return address of color with index color. ;  ; const char * GetConfigFeatures () const;  ; const char * GetConfigOptions () const;  ; const char * GetCutClassName () const;  ; const char * GetDefCanvasName () const;  ; Bool_t GetEditHistograms () const;  ; Int_t GetEditorMode () const;  ; TFile * GetFile () const override;  ; TFile * Ge",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:5136,Performance,load,load,5136,"erride;  Find an object in one Root folder. ;  ; TObject * FindObjectAny (const char *name) const override;  Return a pointer to the first object with name starting at //root. ;  ; TObject * FindObjectAnyFile (const char *name) const override;  Scan the memory lists of all files for an object with name. ;  ; const char * FindObjectClassName (const char *name) const;  Returns class name of a ROOT object including CINT globals. ;  ; const char * FindObjectPathName (const TObject *obj) const;  Return path name of obj somewhere in the //root/... path. ;  ; TObject * FindSpecialObject (const char *name, void *&where);  Returns address and folder of a ROOT object if it exists. ;  ; TClass * FindSTLClass (const char *name, Bool_t load, Bool_t silent=kFALSE) const;  return a TClass object corresponding to 'name' assuming it is an STL container. ;  ; void ForceStyle (Bool_t force=kTRUE);  ; Bool_t FromPopUp () const;  ; TApplication * GetApplication () const;  ; Int_t GetBuiltDate () const;  ; Int_t GetBuiltTime () const;  ; TClass * GetClass (const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) const;  Return pointer to class with name. Obsolete, use TClass::GetClass directly. ;  ; TClass * GetClass (const std::type_info &typeinfo, Bool_t load=kTRUE, Bool_t silent=kFALSE) const;  Return pointer to class from its name. ;  ; TSeqCollection * GetClipboard () const;  ; TColor * GetColor (Int_t color) const;  Return address of color with index color. ;  ; const char * GetConfigFeatures () const;  ; const char * GetConfigOptions () const;  ; const char * GetCutClassName () const;  ; const char * GetDefCanvasName () const;  ; Bool_t GetEditHistograms () const;  ; Int_t GetEditorMode () const;  ; TFile * GetFile () const override;  ; TFile * GetFile (const char *name) const;  Return pointer to file with name. ;  ; Bool_t GetForceStyle () const;  ; TObject * GetFunction (const char *name) const;  Return pointer to function with name. ;  ; TFunctionTemplate * GetFunctionTemplat",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:5317,Performance,load,load,5317,"s of all files for an object with name. ;  ; const char * FindObjectClassName (const char *name) const;  Returns class name of a ROOT object including CINT globals. ;  ; const char * FindObjectPathName (const TObject *obj) const;  Return path name of obj somewhere in the //root/... path. ;  ; TObject * FindSpecialObject (const char *name, void *&where);  Returns address and folder of a ROOT object if it exists. ;  ; TClass * FindSTLClass (const char *name, Bool_t load, Bool_t silent=kFALSE) const;  return a TClass object corresponding to 'name' assuming it is an STL container. ;  ; void ForceStyle (Bool_t force=kTRUE);  ; Bool_t FromPopUp () const;  ; TApplication * GetApplication () const;  ; Int_t GetBuiltDate () const;  ; Int_t GetBuiltTime () const;  ; TClass * GetClass (const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) const;  Return pointer to class with name. Obsolete, use TClass::GetClass directly. ;  ; TClass * GetClass (const std::type_info &typeinfo, Bool_t load=kTRUE, Bool_t silent=kFALSE) const;  Return pointer to class from its name. ;  ; TSeqCollection * GetClipboard () const;  ; TColor * GetColor (Int_t color) const;  Return address of color with index color. ;  ; const char * GetConfigFeatures () const;  ; const char * GetConfigOptions () const;  ; const char * GetCutClassName () const;  ; const char * GetDefCanvasName () const;  ; Bool_t GetEditHistograms () const;  ; Int_t GetEditorMode () const;  ; TFile * GetFile () const override;  ; TFile * GetFile (const char *name) const;  Return pointer to file with name. ;  ; Bool_t GetForceStyle () const;  ; TObject * GetFunction (const char *name) const;  Return pointer to function with name. ;  ; TFunctionTemplate * GetFunctionTemplate (const char *name);  ; TObject * GetGeometry (const char *name) const;  Return pointer to Geometry with name. ;  ; const char * GetGitBranch () const;  ; const char * GetGitCommit () const;  ; const char * GetGitDate ();  Return date/time make was run. ;  ; TGlob",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:6366,Performance,load,load,6366,"er to class from its name. ;  ; TSeqCollection * GetClipboard () const;  ; TColor * GetColor (Int_t color) const;  Return address of color with index color. ;  ; const char * GetConfigFeatures () const;  ; const char * GetConfigOptions () const;  ; const char * GetCutClassName () const;  ; const char * GetDefCanvasName () const;  ; Bool_t GetEditHistograms () const;  ; Int_t GetEditorMode () const;  ; TFile * GetFile () const override;  ; TFile * GetFile (const char *name) const;  Return pointer to file with name. ;  ; Bool_t GetForceStyle () const;  ; TObject * GetFunction (const char *name) const;  Return pointer to function with name. ;  ; TFunctionTemplate * GetFunctionTemplate (const char *name);  ; TObject * GetGeometry (const char *name) const;  Return pointer to Geometry with name. ;  ; const char * GetGitBranch () const;  ; const char * GetGitCommit () const;  ; const char * GetGitDate ();  Return date/time make was run. ;  ; TGlobal * GetGlobal (const char *name, Bool_t load=kFALSE) const;  Return pointer to global variable by name. ;  ; TGlobal * GetGlobal (const TObject *obj, Bool_t load=kFALSE) const;  Return pointer to global variable with address addr. ;  ; TFunction * GetGlobalFunction (const char *name, const char *params=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TFunction * GetGlobalFunctionWithPrototype (const char *name, const char *proto=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TInterpreter * GetInterpreter () const;  ; TList * GetListOfBrowsables () const;  ; TSeqCollection * GetListOfBrowsers () const;  ; TSeqCollection * GetListOfCanvases () const;  ; TCollection * GetListOfClasses () const;  ; TCollection * GetListOfClassGenerators () const;  ; TSeqCollection * GetListOfCleanups () const;  ; TSeqCollection * GetListOfClosedObjects () const;  ; TSeqCollection * GetListOfColors () const;  ; TSeqCollection * GetListOfDataSets () const;  ; TCollection * GetListOfEnums (Boo",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:6483,Performance,load,load,6483," address of color with index color. ;  ; const char * GetConfigFeatures () const;  ; const char * GetConfigOptions () const;  ; const char * GetCutClassName () const;  ; const char * GetDefCanvasName () const;  ; Bool_t GetEditHistograms () const;  ; Int_t GetEditorMode () const;  ; TFile * GetFile () const override;  ; TFile * GetFile (const char *name) const;  Return pointer to file with name. ;  ; Bool_t GetForceStyle () const;  ; TObject * GetFunction (const char *name) const;  Return pointer to function with name. ;  ; TFunctionTemplate * GetFunctionTemplate (const char *name);  ; TObject * GetGeometry (const char *name) const;  Return pointer to Geometry with name. ;  ; const char * GetGitBranch () const;  ; const char * GetGitCommit () const;  ; const char * GetGitDate ();  Return date/time make was run. ;  ; TGlobal * GetGlobal (const char *name, Bool_t load=kFALSE) const;  Return pointer to global variable by name. ;  ; TGlobal * GetGlobal (const TObject *obj, Bool_t load=kFALSE) const;  Return pointer to global variable with address addr. ;  ; TFunction * GetGlobalFunction (const char *name, const char *params=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TFunction * GetGlobalFunctionWithPrototype (const char *name, const char *proto=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TInterpreter * GetInterpreter () const;  ; TList * GetListOfBrowsables () const;  ; TSeqCollection * GetListOfBrowsers () const;  ; TSeqCollection * GetListOfCanvases () const;  ; TCollection * GetListOfClasses () const;  ; TCollection * GetListOfClassGenerators () const;  ; TSeqCollection * GetListOfCleanups () const;  ; TSeqCollection * GetListOfClosedObjects () const;  ; TSeqCollection * GetListOfColors () const;  ; TSeqCollection * GetListOfDataSets () const;  ; TCollection * GetListOfEnums (Bool_t load=kFALSE);  ; TSeqCollection * GetListOfFiles () const;  ; TCollection * GetListOfFunctionOverloads (const char *n",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:6646,Performance,load,load,6646,"r * GetCutClassName () const;  ; const char * GetDefCanvasName () const;  ; Bool_t GetEditHistograms () const;  ; Int_t GetEditorMode () const;  ; TFile * GetFile () const override;  ; TFile * GetFile (const char *name) const;  Return pointer to file with name. ;  ; Bool_t GetForceStyle () const;  ; TObject * GetFunction (const char *name) const;  Return pointer to function with name. ;  ; TFunctionTemplate * GetFunctionTemplate (const char *name);  ; TObject * GetGeometry (const char *name) const;  Return pointer to Geometry with name. ;  ; const char * GetGitBranch () const;  ; const char * GetGitCommit () const;  ; const char * GetGitDate ();  Return date/time make was run. ;  ; TGlobal * GetGlobal (const char *name, Bool_t load=kFALSE) const;  Return pointer to global variable by name. ;  ; TGlobal * GetGlobal (const TObject *obj, Bool_t load=kFALSE) const;  Return pointer to global variable with address addr. ;  ; TFunction * GetGlobalFunction (const char *name, const char *params=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TFunction * GetGlobalFunctionWithPrototype (const char *name, const char *proto=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TInterpreter * GetInterpreter () const;  ; TList * GetListOfBrowsables () const;  ; TSeqCollection * GetListOfBrowsers () const;  ; TSeqCollection * GetListOfCanvases () const;  ; TCollection * GetListOfClasses () const;  ; TCollection * GetListOfClassGenerators () const;  ; TSeqCollection * GetListOfCleanups () const;  ; TSeqCollection * GetListOfClosedObjects () const;  ; TSeqCollection * GetListOfColors () const;  ; TSeqCollection * GetListOfDataSets () const;  ; TCollection * GetListOfEnums (Bool_t load=kFALSE);  ; TSeqCollection * GetListOfFiles () const;  ; TCollection * GetListOfFunctionOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TCollection * GetListOfFunctions () const;  ; TCollection * GetListOfF",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:6805,Performance,load,load,6805,"* GetFile () const override;  ; TFile * GetFile (const char *name) const;  Return pointer to file with name. ;  ; Bool_t GetForceStyle () const;  ; TObject * GetFunction (const char *name) const;  Return pointer to function with name. ;  ; TFunctionTemplate * GetFunctionTemplate (const char *name);  ; TObject * GetGeometry (const char *name) const;  Return pointer to Geometry with name. ;  ; const char * GetGitBranch () const;  ; const char * GetGitCommit () const;  ; const char * GetGitDate ();  Return date/time make was run. ;  ; TGlobal * GetGlobal (const char *name, Bool_t load=kFALSE) const;  Return pointer to global variable by name. ;  ; TGlobal * GetGlobal (const TObject *obj, Bool_t load=kFALSE) const;  Return pointer to global variable with address addr. ;  ; TFunction * GetGlobalFunction (const char *name, const char *params=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TFunction * GetGlobalFunctionWithPrototype (const char *name, const char *proto=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TInterpreter * GetInterpreter () const;  ; TList * GetListOfBrowsables () const;  ; TSeqCollection * GetListOfBrowsers () const;  ; TSeqCollection * GetListOfCanvases () const;  ; TCollection * GetListOfClasses () const;  ; TCollection * GetListOfClassGenerators () const;  ; TSeqCollection * GetListOfCleanups () const;  ; TSeqCollection * GetListOfClosedObjects () const;  ; TSeqCollection * GetListOfColors () const;  ; TSeqCollection * GetListOfDataSets () const;  ; TCollection * GetListOfEnums (Bool_t load=kFALSE);  ; TSeqCollection * GetListOfFiles () const;  ; TCollection * GetListOfFunctionOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TCollection * GetListOfFunctions () const;  ; TCollection * GetListOfFunctionTemplates ();  ; TSeqCollection * GetListOfGeometries () const;  ; TCollection * GetListOfGlobalFunctions (Bool_t load=kFALSE);  Return list conta",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:7376,Performance,load,load,7376,"nst;  ; const char * GetGitCommit () const;  ; const char * GetGitDate ();  Return date/time make was run. ;  ; TGlobal * GetGlobal (const char *name, Bool_t load=kFALSE) const;  Return pointer to global variable by name. ;  ; TGlobal * GetGlobal (const TObject *obj, Bool_t load=kFALSE) const;  Return pointer to global variable with address addr. ;  ; TFunction * GetGlobalFunction (const char *name, const char *params=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TFunction * GetGlobalFunctionWithPrototype (const char *name, const char *proto=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TInterpreter * GetInterpreter () const;  ; TList * GetListOfBrowsables () const;  ; TSeqCollection * GetListOfBrowsers () const;  ; TSeqCollection * GetListOfCanvases () const;  ; TCollection * GetListOfClasses () const;  ; TCollection * GetListOfClassGenerators () const;  ; TSeqCollection * GetListOfCleanups () const;  ; TSeqCollection * GetListOfClosedObjects () const;  ; TSeqCollection * GetListOfColors () const;  ; TSeqCollection * GetListOfDataSets () const;  ; TCollection * GetListOfEnums (Bool_t load=kFALSE);  ; TSeqCollection * GetListOfFiles () const;  ; TCollection * GetListOfFunctionOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TCollection * GetListOfFunctions () const;  ; TCollection * GetListOfFunctionTemplates ();  ; TSeqCollection * GetListOfGeometries () const;  ; TCollection * GetListOfGlobalFunctions (Bool_t load=kFALSE);  Return list containing the TFunctions currently defined. ;  ; TCollection * GetListOfGlobals (Bool_t load=kFALSE);  Return list containing the TGlobals currently defined. ;  ; TSeqCollection * GetListOfMappedFiles () const;  ; TSeqCollection * GetListOfMessageHandlers () const;  ; TSeqCollection * GetListOfProofs () const;  ; TSeqCollection * GetListOfSecContexts () const;  ; TSeqCollection * GetListOfSockets () const;  ; TSeqCollection *",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:7751,Performance,load,load,7751,"nction by name. ;  ; TFunction * GetGlobalFunctionWithPrototype (const char *name, const char *proto=nullptr, Bool_t load=kFALSE);  Return pointer to global function by name. ;  ; TInterpreter * GetInterpreter () const;  ; TList * GetListOfBrowsables () const;  ; TSeqCollection * GetListOfBrowsers () const;  ; TSeqCollection * GetListOfCanvases () const;  ; TCollection * GetListOfClasses () const;  ; TCollection * GetListOfClassGenerators () const;  ; TSeqCollection * GetListOfCleanups () const;  ; TSeqCollection * GetListOfClosedObjects () const;  ; TSeqCollection * GetListOfColors () const;  ; TSeqCollection * GetListOfDataSets () const;  ; TCollection * GetListOfEnums (Bool_t load=kFALSE);  ; TSeqCollection * GetListOfFiles () const;  ; TCollection * GetListOfFunctionOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TCollection * GetListOfFunctions () const;  ; TCollection * GetListOfFunctionTemplates ();  ; TSeqCollection * GetListOfGeometries () const;  ; TCollection * GetListOfGlobalFunctions (Bool_t load=kFALSE);  Return list containing the TFunctions currently defined. ;  ; TCollection * GetListOfGlobals (Bool_t load=kFALSE);  Return list containing the TGlobals currently defined. ;  ; TSeqCollection * GetListOfMappedFiles () const;  ; TSeqCollection * GetListOfMessageHandlers () const;  ; TSeqCollection * GetListOfProofs () const;  ; TSeqCollection * GetListOfSecContexts () const;  ; TSeqCollection * GetListOfSockets () const;  ; TSeqCollection * GetListOfSpecials () const;  ; TSeqCollection * GetListOfStreamerInfo () const;  ; TSeqCollection * GetListOfStyles () const;  ; TSeqCollection * GetListOfTasks () const;  ; TCollection * GetListOfTypes (Bool_t load=kFALSE);  Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ;  ; Int_t GetNclasses () const;  Get number of classes. ;  ; Int_t GetNtypes () const;  Get number of types. ;  ; TPluginManager * GetPluginManager () const;  ; TFolder",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:7867,Performance,load,load,7867,"r * GetInterpreter () const;  ; TList * GetListOfBrowsables () const;  ; TSeqCollection * GetListOfBrowsers () const;  ; TSeqCollection * GetListOfCanvases () const;  ; TCollection * GetListOfClasses () const;  ; TCollection * GetListOfClassGenerators () const;  ; TSeqCollection * GetListOfCleanups () const;  ; TSeqCollection * GetListOfClosedObjects () const;  ; TSeqCollection * GetListOfColors () const;  ; TSeqCollection * GetListOfDataSets () const;  ; TCollection * GetListOfEnums (Bool_t load=kFALSE);  ; TSeqCollection * GetListOfFiles () const;  ; TCollection * GetListOfFunctionOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TCollection * GetListOfFunctions () const;  ; TCollection * GetListOfFunctionTemplates ();  ; TSeqCollection * GetListOfGeometries () const;  ; TCollection * GetListOfGlobalFunctions (Bool_t load=kFALSE);  Return list containing the TFunctions currently defined. ;  ; TCollection * GetListOfGlobals (Bool_t load=kFALSE);  Return list containing the TGlobals currently defined. ;  ; TSeqCollection * GetListOfMappedFiles () const;  ; TSeqCollection * GetListOfMessageHandlers () const;  ; TSeqCollection * GetListOfProofs () const;  ; TSeqCollection * GetListOfSecContexts () const;  ; TSeqCollection * GetListOfSockets () const;  ; TSeqCollection * GetListOfSpecials () const;  ; TSeqCollection * GetListOfStreamerInfo () const;  ; TSeqCollection * GetListOfStyles () const;  ; TSeqCollection * GetListOfTasks () const;  ; TCollection * GetListOfTypes (Bool_t load=kFALSE);  Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ;  ; Int_t GetNclasses () const;  Get number of classes. ;  ; Int_t GetNtypes () const;  Get number of types. ;  ; TPluginManager * GetPluginManager () const;  ; TFolder * GetRootFolder () const;  ; TVirtualPad * GetSelectedPad () const;  ; const TObject * GetSelectedPrimitive () const;  ; TStyle * GetStyle (const char *name) const;  Return pointer to style ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:8420,Performance,load,load,8420,"ects () const;  ; TSeqCollection * GetListOfColors () const;  ; TSeqCollection * GetListOfDataSets () const;  ; TCollection * GetListOfEnums (Bool_t load=kFALSE);  ; TSeqCollection * GetListOfFiles () const;  ; TCollection * GetListOfFunctionOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TCollection * GetListOfFunctions () const;  ; TCollection * GetListOfFunctionTemplates ();  ; TSeqCollection * GetListOfGeometries () const;  ; TCollection * GetListOfGlobalFunctions (Bool_t load=kFALSE);  Return list containing the TFunctions currently defined. ;  ; TCollection * GetListOfGlobals (Bool_t load=kFALSE);  Return list containing the TGlobals currently defined. ;  ; TSeqCollection * GetListOfMappedFiles () const;  ; TSeqCollection * GetListOfMessageHandlers () const;  ; TSeqCollection * GetListOfProofs () const;  ; TSeqCollection * GetListOfSecContexts () const;  ; TSeqCollection * GetListOfSockets () const;  ; TSeqCollection * GetListOfSpecials () const;  ; TSeqCollection * GetListOfStreamerInfo () const;  ; TSeqCollection * GetListOfStyles () const;  ; TSeqCollection * GetListOfTasks () const;  ; TCollection * GetListOfTypes (Bool_t load=kFALSE);  Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ;  ; Int_t GetNclasses () const;  Get number of classes. ;  ; Int_t GetNtypes () const;  Get number of types. ;  ; TPluginManager * GetPluginManager () const;  ; TFolder * GetRootFolder () const;  ; TVirtualPad * GetSelectedPad () const;  ; const TObject * GetSelectedPrimitive () const;  ; TStyle * GetStyle (const char *name) const;  Return pointer to style with name. ;  ; TDataType * GetType (const char *name, Bool_t load=kFALSE) const;  Return pointer to type with name. ;  ; TProcessUUID * GetUUIDs () const;  ; const char * GetVersion () const;  ; Int_t GetVersionCode () const;  ; Int_t GetVersionDate () const;  ; Int_t GetVersionInt () const;  ; Int_t GetVersionTime () const;  ; const TString & G",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:8941,Performance,load,load,8941,"TSeqCollection * GetListOfMappedFiles () const;  ; TSeqCollection * GetListOfMessageHandlers () const;  ; TSeqCollection * GetListOfProofs () const;  ; TSeqCollection * GetListOfSecContexts () const;  ; TSeqCollection * GetListOfSockets () const;  ; TSeqCollection * GetListOfSpecials () const;  ; TSeqCollection * GetListOfStreamerInfo () const;  ; TSeqCollection * GetListOfStyles () const;  ; TSeqCollection * GetListOfTasks () const;  ; TCollection * GetListOfTypes (Bool_t load=kFALSE);  Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ;  ; Int_t GetNclasses () const;  Get number of classes. ;  ; Int_t GetNtypes () const;  Get number of types. ;  ; TPluginManager * GetPluginManager () const;  ; TFolder * GetRootFolder () const;  ; TVirtualPad * GetSelectedPad () const;  ; const TObject * GetSelectedPrimitive () const;  ; TStyle * GetStyle (const char *name) const;  Return pointer to style with name. ;  ; TDataType * GetType (const char *name, Bool_t load=kFALSE) const;  Return pointer to type with name. ;  ; TProcessUUID * GetUUIDs () const;  ; const char * GetVersion () const;  ; Int_t GetVersionCode () const;  ; Int_t GetVersionDate () const;  ; Int_t GetVersionInt () const;  ; Int_t GetVersionTime () const;  ; const TString & GetWebDisplay () const;  ; void Idle (UInt_t idleTimeInSec, const char *command=nullptr);  Execute command when system has been idle for idleTimeInSec seconds. ;  ; Int_t IgnoreInclude (const char *fname, const char *expandedfname);  Return 1 if the name of the given include file corresponds to a class that is known to ROOT, e.g. ;  ; TClass * IsA () const override;  ; Bool_t IsBatch () const;  ; Bool_t IsEscaped () const;  ; Bool_t IsExecutingMacro () const;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsInterrupted () const;  ; Bool_t IsLineProcessing () const;  ; Bool_t IsProofServ () const;  ; Bool",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:16091,Performance,perform,performed,16091,"rn pointer to object identified by namecycle. ;  ; template<class T > ; T * Get (const char *namecycle);  See documentation of TDirectoryFile::Get(const char *namecycle) ;  ; virtual Int_t GetBufferSize () const;  ; virtual TDirectory * GetDirectory (const char *namecycle, Bool_t printError=false, const char *funcname=""GetDirectory"");  Find a directory using apath. ;  ; virtual TKey * GetKey (const char *, Short_t=9999) const;  ; virtual TList * GetList () const;  ; virtual TList * GetListOfKeys () const;  ; TObject * GetMother () const;  ; TDirectory * GetMotherDir () const;  ; virtual Int_t GetNbytesKeys () const;  ; virtual Int_t GetNkeys () const;  ; template<class T > ; void GetObject (const char *namecycle, T *&ptr);  Get an object with proper type checking. ;  ; virtual void * GetObjectChecked (const char *namecycle, const char *classname);  See documentation of TDirectory::GetObjectCheck(const char *namecycle, const TClass *cl) ;  ; virtual void * GetObjectChecked (const char *namecycle, const TClass *cl);  Return pointer to object identified by namecycle if and only if the actual object is a type suitable to be stored as a pointer to a ""expectedClass"" If expectedClass is null, no check is performed. ;  ; virtual void * GetObjectUnchecked (const char *namecycle);  Return pointer to object identified by namecycle. ;  ; virtual const char * GetPath () const;  Returns the full path of the directory. ;  ; virtual const char * GetPathStatic () const;  Returns the full path of the directory. ;  ; virtual Long64_t GetSeekDir () const;  ; virtual Long64_t GetSeekKeys () const;  ; virtual Long64_t GetSeekParent () const;  ; TUUID GetUUID () const;  ; Bool_t IsBuilt () const;  ; virtual Bool_t IsModified () const;  ; virtual Bool_t IsWritable () const;  ; virtual TDirectory * mkdir (const char *name, const char *title="""", Bool_t returnExistingDirectory=kFALSE);  Create a sub-directory ""a"" or a hierarchy of sub-directories ""a/b/c/..."". ;  ; virtual TFile * OpenFile (con",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:38366,Performance,multi-thread,multi-threads,38366,"e as used in RVersion.h. ;  ; Int_t fVersionDate;  Date of ROOT version (ex 951226) ;  ; Int_t fVersionInt;  ROOT version in integer format (501) ;  ; Int_t fVersionTime;  Time of ROOT version (ex 1152) ;  ; TString fWebDisplay;  If not empty it defines where web graphics should be rendered (cef, qt5, browser...) ;  ;  Protected Attributes inherited from TDirectory; TContext * fContext {nullptr};  Buffer for GetPath() function. ;  ; std::atomic< size_t > fContextPeg {0};  thread local gDirectory pointing to this object. ;  ; std::vector< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions;  TROOT (const TROOT &)=delete;  ; TROOT & operator= (const TROOT &)=delete;  . Private Attributes; Int_t fLineIsProcessing;  To synchronize multi-threads. ;  . Static Private Attributes; static Int_t fgDirLevel = 0;  Indentation level for ls() ;  ; static Bool_t fgRootInit = kFALSE;  Singleton initialization flag. ;  . Friends; class ::ROOT::Internal::TROOTAllocator;  ; TROOT * ROOT::Internal::GetROOT2 ();  ; class TCling;  . Additional Inherited Members;  Static Protected Member Functions inherited from TDirectory; static Bool_t Cd1 (const char *path);  Change current directory to ""path"". ;  ; static SharedGDirectory_t & GetSharedLocalCurrentDirectory ();  Return the (address of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TROOT.h>. Inheritance diagram for TROOT:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:40156,Performance,perform,performed,40156,"'t support = ATOMIC_FLAG_INIT;. ;  . #include <TROOT.h>. Inheritance diagram for TROOT:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ AListOfEnums_t. typedef std::atomic<TListOfEnums*> TROOT::AListOfEnums_t. protected . Definition at line 109 of file TROOT.h. ◆ FwdDeclArgsToKeepCollection_t. typedef std::vector<std::pair<std::string, int> > TROOT::FwdDeclArgsToKeepCollection_t. Definition at line 187 of file TROOT.h. Constructor & Destructor Documentation. ◆ TROOT() [1/3]. TROOT::TROOT ; (; const TROOT & ; ). privatedelete . ◆ TROOT() [2/3]. TROOT::TROOT ; (; ). protected . Only used by Dictionary. ; Default ctor. ; Definition at line 605 of file TROOT.cxx. ◆ TROOT() [3/3]. TROOT::TROOT ; (; const char * ; name, . const char * ; title, . VoidFuncPtr_t * ; initfunc = nullptr . ). Initialize the ROOT system. ; The creation of the TROOT object initializes the ROOT system. It must be the first ROOT related action that is performed by a program. The TROOT object must be created on the stack (can not be called via new since ""operator new"" is protected). The TROOT object is either created as a global object (outside the main() program), or it is one of the first objects created in main(). Make sure that the TROOT object stays in scope for as long as ROOT related actions are performed. TROOT is a so called singleton so only one instance of it can be created. The single TROOT object can always be accessed via the global pointer gROOT. The name and title arguments can be used to identify the running application. The initfunc argument can contain an array of function pointers (last element must be 0). These functions are executed at the end of the constructor. This way one can easily extend the ROOT system without adding permanent dependencies (e.g. the graphics system is initialized via such a function). ; Definition at line 639 of file TROOT.cxx. ◆ ~TROOT(). TROOT::~TROOT ; (; ). virtual . Clea",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:40513,Performance,perform,performed,40513,"e TROOT.h. ◆ FwdDeclArgsToKeepCollection_t. typedef std::vector<std::pair<std::string, int> > TROOT::FwdDeclArgsToKeepCollection_t. Definition at line 187 of file TROOT.h. Constructor & Destructor Documentation. ◆ TROOT() [1/3]. TROOT::TROOT ; (; const TROOT & ; ). privatedelete . ◆ TROOT() [2/3]. TROOT::TROOT ; (; ). protected . Only used by Dictionary. ; Default ctor. ; Definition at line 605 of file TROOT.cxx. ◆ TROOT() [3/3]. TROOT::TROOT ; (; const char * ; name, . const char * ; title, . VoidFuncPtr_t * ; initfunc = nullptr . ). Initialize the ROOT system. ; The creation of the TROOT object initializes the ROOT system. It must be the first ROOT related action that is performed by a program. The TROOT object must be created on the stack (can not be called via new since ""operator new"" is protected). The TROOT object is either created as a global object (outside the main() program), or it is one of the first objects created in main(). Make sure that the TROOT object stays in scope for as long as ROOT related actions are performed. TROOT is a so called singleton so only one instance of it can be created. The single TROOT object can always be accessed via the global pointer gROOT. The name and title arguments can be used to identify the running application. The initfunc argument can contain an array of function pointers (last element must be 0). These functions are executed at the end of the constructor. This way one can easily extend the ROOT system without adding permanent dependencies (e.g. the graphics system is initialized via such a function). ; Definition at line 639 of file TROOT.cxx. ◆ ~TROOT(). TROOT::~TROOT ; (; ). virtual . Clean up and free resources used by ROOT (files, network sockets, shared memory segments, etc.). ; Definition at line 867 of file TROOT.cxx. Member Function Documentation. ◆ AddClass(). void TROOT::AddClass ; (; TClass * ; cl). Add a class to the list and map of classes. ; This routine is deprecated, use TClass::AddClass directly. ; ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:41710,Performance,load,loaded,41710,"can be used to identify the running application. The initfunc argument can contain an array of function pointers (last element must be 0). These functions are executed at the end of the constructor. This way one can easily extend the ROOT system without adding permanent dependencies (e.g. the graphics system is initialized via such a function). ; Definition at line 639 of file TROOT.cxx. ◆ ~TROOT(). TROOT::~TROOT ; (; ). virtual . Clean up and free resources used by ROOT (files, network sockets, shared memory segments, etc.). ; Definition at line 867 of file TROOT.cxx. Member Function Documentation. ◆ AddClass(). void TROOT::AddClass ; (; TClass * ; cl). Add a class to the list and map of classes. ; This routine is deprecated, use TClass::AddClass directly. ; Definition at line 1025 of file TROOT.cxx. ◆ AddClassGenerator(). void TROOT::AddClassGenerator ; (; TClassGenerator * ; generator). Add a class generator. ; This generator will be called by TClass::GetClass in case its does not find a loaded rootcint dictionary to request the creation of a TClass object. ; Definition at line 1035 of file TROOT.cxx. ◆ AddExtraInterpreterArgs(). const std::vector< std::string > & TROOT::AddExtraInterpreterArgs ; (; const std::vector< std::string > & ; args). static . Provide command line arguments to the interpreter construction. ; These arguments are added to the existing flags (e.g. -DNDEBUG). They are evaluated once per process, at the time where TROOT (and thus TInterpreter) is constructed. Returns the new flags. ; Definition at line 2952 of file TROOT.cxx. ◆ Append(). void TROOT::Append ; (; TObject * ; obj, . Bool_t ; replace = kFALSE . ). overridevirtual . Append object to this directory. ; If replace is true: remove any existing objects with the same same (if the name is not """") ; Reimplemented from TDirectory.; Definition at line 1047 of file TROOT.cxx. ◆ Browse(). void TROOT::Browse ; (; TBrowser * ; b). overridevirtual . Add browsable objects to TBrowser. ; Reimplement",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:47500,Performance,load,load,47500," The function returns the first occurence of the object in the list of folders. The returned string points to a static char array in TROOT. If this function is called in a loop or recursively, it is the user's responsibility to copy this string in their area. ; Definition at line 1473 of file TROOT.cxx. ◆ FindSpecialObject(). TObject * TROOT::FindSpecialObject ; (; const char * ; name, . void *& ; where . ). Returns address and folder of a ROOT object if it exists. ; This function looks in the following order in the ROOT lists:; List of files; List of memory mapped files; List of functions; List of geometries; List of canvases; List of styles; List of specials; List of materials in current geometry; List of shapes in current geometry; List of matrices in current geometry; List of Nodes in current geometry; Current Directory in memory; Current Directory on file . Definition at line 1367 of file TROOT.cxx. ◆ FindSTLClass(). TClass * TROOT::FindSTLClass ; (; const char * ; name, . Bool_t ; load, . Bool_t ; silent = kFALSE . ); const. return a TClass object corresponding to 'name' assuming it is an STL container. ; In particular we looking for possible alternative name (default template parameter, typedefs template arguments, typedefed name). ; Definition at line 1484 of file TROOT.cxx. ◆ ForceStyle(). void TROOT::ForceStyle ; (; Bool_t ; force = kTRUE). inline . Definition at line 206 of file TROOT.h. ◆ FromPopUp(). Bool_t TROOT::FromPopUp ; (; ); const. inline . Definition at line 207 of file TROOT.h. ◆ GetApplication(). TApplication * TROOT::GetApplication ; (; ); const. inline . Definition at line 209 of file TROOT.h. ◆ GetBinDir(). const TString & TROOT::GetBinDir ; (; ). static . Get the binary directory in the installation. Static utility function. ; Definition at line 2989 of file TROOT.cxx. ◆ GetBuiltDate(). Int_t TROOT::GetBuiltDate ; (; ); const. inline . Definition at line 221 of file TROOT.h. ◆ GetBuiltTime(). Int_t TROOT::GetBuiltTime ; (; ); const. inline ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:48623,Performance,load,load,48623,"; In particular we looking for possible alternative name (default template parameter, typedefs template arguments, typedefed name). ; Definition at line 1484 of file TROOT.cxx. ◆ ForceStyle(). void TROOT::ForceStyle ; (; Bool_t ; force = kTRUE). inline . Definition at line 206 of file TROOT.h. ◆ FromPopUp(). Bool_t TROOT::FromPopUp ; (; ); const. inline . Definition at line 207 of file TROOT.h. ◆ GetApplication(). TApplication * TROOT::GetApplication ; (; ); const. inline . Definition at line 209 of file TROOT.h. ◆ GetBinDir(). const TString & TROOT::GetBinDir ; (; ). static . Get the binary directory in the installation. Static utility function. ; Definition at line 2989 of file TROOT.cxx. ◆ GetBuiltDate(). Int_t TROOT::GetBuiltDate ; (; ); const. inline . Definition at line 221 of file TROOT.h. ◆ GetBuiltTime(). Int_t TROOT::GetBuiltTime ; (; ); const. inline . Definition at line 222 of file TROOT.h. ◆ GetClass() [1/2]. TClass * TROOT::GetClass ; (; const char * ; name, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ); const. Return pointer to class with name. Obsolete, use TClass::GetClass directly. ; Definition at line 1518 of file TROOT.cxx. ◆ GetClass() [2/2]. TClass * TROOT::GetClass ; (; const std::type_info & ; typeinfo, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ); const. Return pointer to class from its name. ; Obsolete, use TClass::GetClass directly See TClass::GetClass ; Definition at line 1528 of file TROOT.cxx. ◆ GetClipboard(). TSeqCollection * TROOT::GetClipboard ; (; ); const. inline . Definition at line 254 of file TROOT.h. ◆ GetColor(). TColor * TROOT::GetColor ; (; Int_t ; color); const. Return address of color with index color. ; Definition at line 1536 of file TROOT.cxx. ◆ GetConfigFeatures(). const char * TROOT::GetConfigFeatures ; (; ); const. inline . Definition at line 215 of file TROOT.h. ◆ GetConfigOptions(). const char * TROOT::GetConfigOptions ; (; ); const. inline . Definition at line 214 of file TROOT.h. ◆ GetCutClas",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:48893,Performance,load,load,48893,"ine 206 of file TROOT.h. ◆ FromPopUp(). Bool_t TROOT::FromPopUp ; (; ); const. inline . Definition at line 207 of file TROOT.h. ◆ GetApplication(). TApplication * TROOT::GetApplication ; (; ); const. inline . Definition at line 209 of file TROOT.h. ◆ GetBinDir(). const TString & TROOT::GetBinDir ; (; ). static . Get the binary directory in the installation. Static utility function. ; Definition at line 2989 of file TROOT.cxx. ◆ GetBuiltDate(). Int_t TROOT::GetBuiltDate ; (; ); const. inline . Definition at line 221 of file TROOT.h. ◆ GetBuiltTime(). Int_t TROOT::GetBuiltTime ; (; ); const. inline . Definition at line 222 of file TROOT.h. ◆ GetClass() [1/2]. TClass * TROOT::GetClass ; (; const char * ; name, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ); const. Return pointer to class with name. Obsolete, use TClass::GetClass directly. ; Definition at line 1518 of file TROOT.cxx. ◆ GetClass() [2/2]. TClass * TROOT::GetClass ; (; const std::type_info & ; typeinfo, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ); const. Return pointer to class from its name. ; Obsolete, use TClass::GetClass directly See TClass::GetClass ; Definition at line 1528 of file TROOT.cxx. ◆ GetClipboard(). TSeqCollection * TROOT::GetClipboard ; (; ); const. inline . Definition at line 254 of file TROOT.h. ◆ GetColor(). TColor * TROOT::GetColor ; (; Int_t ; color); const. Return address of color with index color. ; Definition at line 1536 of file TROOT.cxx. ◆ GetConfigFeatures(). const char * TROOT::GetConfigFeatures ; (; ); const. inline . Definition at line 215 of file TROOT.h. ◆ GetConfigOptions(). const char * TROOT::GetConfigOptions ; (; ); const. inline . Definition at line 214 of file TROOT.h. ◆ GetCutClassName(). const char * TROOT::GetCutClassName ; (; ); const. inline . Definition at line 216 of file TROOT.h. ◆ GetDataDir(). const TString & TROOT::GetDataDir ; (; ). static . Get the data directory in the installation. Static utility function. ; Definition at line 3062",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:52335,Performance,load,load,52335,"ROOT::GetForceStyle ; (; ); const. inline . Definition at line 220 of file TROOT.h. ◆ GetFunction(). TObject * TROOT::GetFunction ; (; const char * ; name); const. Return pointer to function with name. ; Definition at line 1587 of file TROOT.cxx. ◆ GetFunctionTemplate(). TFunctionTemplate * TROOT::GetFunctionTemplate ; (; const char * ; name). Definition at line 1618 of file TROOT.cxx. ◆ GetGeometry(). TObject * TROOT::GetGeometry ; (; const char * ; name); const. Return pointer to Geometry with name. ; Definition at line 1747 of file TROOT.cxx. ◆ GetGitBranch(). const char * TROOT::GetGitBranch ; (; ); const. inline . Definition at line 224 of file TROOT.h. ◆ GetGitCommit(). const char * TROOT::GetGitCommit ; (; ); const. inline . Definition at line 223 of file TROOT.h. ◆ GetGitDate(). const char * TROOT::GetGitDate ; (; ). Return date/time make was run. ; Definition at line 2474 of file TROOT.cxx. ◆ GetGlobal() [1/2]. TGlobal * TROOT::GetGlobal ; (; const char * ; name, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable by name. ; If load is true force reading of all currently defined globals from CINT (more expensive). ; Definition at line 1631 of file TROOT.cxx. ◆ GetGlobal() [2/2]. TGlobal * TROOT::GetGlobal ; (; const TObject * ; obj, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable with address addr. ; Definition at line 1639 of file TROOT.cxx. ◆ GetGlobalFunction(). TFunction * TROOT::GetGlobalFunction ; (; const char * ; function, . const char * ; params = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If params != 0 it will also resolve overloading other it returns the first name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Intern",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:52409,Performance,load,load,52409,"ROOT::GetFunction ; (; const char * ; name); const. Return pointer to function with name. ; Definition at line 1587 of file TROOT.cxx. ◆ GetFunctionTemplate(). TFunctionTemplate * TROOT::GetFunctionTemplate ; (; const char * ; name). Definition at line 1618 of file TROOT.cxx. ◆ GetGeometry(). TObject * TROOT::GetGeometry ; (; const char * ; name); const. Return pointer to Geometry with name. ; Definition at line 1747 of file TROOT.cxx. ◆ GetGitBranch(). const char * TROOT::GetGitBranch ; (; ); const. inline . Definition at line 224 of file TROOT.h. ◆ GetGitCommit(). const char * TROOT::GetGitCommit ; (; ); const. inline . Definition at line 223 of file TROOT.h. ◆ GetGitDate(). const char * TROOT::GetGitDate ; (; ). Return date/time make was run. ; Definition at line 2474 of file TROOT.cxx. ◆ GetGlobal() [1/2]. TGlobal * TROOT::GetGlobal ; (; const char * ; name, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable by name. ; If load is true force reading of all currently defined globals from CINT (more expensive). ; Definition at line 1631 of file TROOT.cxx. ◆ GetGlobal() [2/2]. TGlobal * TROOT::GetGlobal ; (; const TObject * ; obj, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable with address addr. ; Definition at line 1639 of file TROOT.cxx. ◆ GetGlobalFunction(). TFunction * TROOT::GetGlobalFunction ; (; const char * ; function, . const char * ; params = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If params != 0 it will also resolve overloading other it returns the first name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necessary, the list of global function. ; Definition at line 1663 of file ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:52629,Performance,load,load,52629,"OOT::GetFunctionTemplate ; (; const char * ; name). Definition at line 1618 of file TROOT.cxx. ◆ GetGeometry(). TObject * TROOT::GetGeometry ; (; const char * ; name); const. Return pointer to Geometry with name. ; Definition at line 1747 of file TROOT.cxx. ◆ GetGitBranch(). const char * TROOT::GetGitBranch ; (; ); const. inline . Definition at line 224 of file TROOT.h. ◆ GetGitCommit(). const char * TROOT::GetGitCommit ; (; ); const. inline . Definition at line 223 of file TROOT.h. ◆ GetGitDate(). const char * TROOT::GetGitDate ; (; ). Return date/time make was run. ; Definition at line 2474 of file TROOT.cxx. ◆ GetGlobal() [1/2]. TGlobal * TROOT::GetGlobal ; (; const char * ; name, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable by name. ; If load is true force reading of all currently defined globals from CINT (more expensive). ; Definition at line 1631 of file TROOT.cxx. ◆ GetGlobal() [2/2]. TGlobal * TROOT::GetGlobal ; (; const TObject * ; obj, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable with address addr. ; Definition at line 1639 of file TROOT.cxx. ◆ GetGlobalFunction(). TFunction * TROOT::GetGlobalFunction ; (; const char * ; function, . const char * ; params = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If params != 0 it will also resolve overloading other it returns the first name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necessary, the list of global function. ; Definition at line 1663 of file TROOT.cxx. ◆ GetGlobalFunctionWithPrototype(). TFunction * TROOT::GetGlobalFunctionWithPrototype ; (; const char * ; function, . const char * ; proto = nullptr, . Bool_t ; load = kFA",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:52889,Performance,load,load,52889,"GetGitBranch(). const char * TROOT::GetGitBranch ; (; ); const. inline . Definition at line 224 of file TROOT.h. ◆ GetGitCommit(). const char * TROOT::GetGitCommit ; (; ); const. inline . Definition at line 223 of file TROOT.h. ◆ GetGitDate(). const char * TROOT::GetGitDate ; (; ). Return date/time make was run. ; Definition at line 2474 of file TROOT.cxx. ◆ GetGlobal() [1/2]. TGlobal * TROOT::GetGlobal ; (; const char * ; name, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable by name. ; If load is true force reading of all currently defined globals from CINT (more expensive). ; Definition at line 1631 of file TROOT.cxx. ◆ GetGlobal() [2/2]. TGlobal * TROOT::GetGlobal ; (; const TObject * ; obj, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable with address addr. ; Definition at line 1639 of file TROOT.cxx. ◆ GetGlobalFunction(). TFunction * TROOT::GetGlobalFunction ; (; const char * ; function, . const char * ; params = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If params != 0 it will also resolve overloading other it returns the first name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necessary, the list of global function. ; Definition at line 1663 of file TROOT.cxx. ◆ GetGlobalFunctionWithPrototype(). TFunction * TROOT::GetGlobalFunctionWithPrototype ; (; const char * ; function, . const char * ; proto = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If proto != 0 it will also resolve overloading. If load is true force reading of all currently defined global functions from CINT (more expensive). The proto string must be of the form: ""int, char*, float"".",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:53059,Performance,load,load,53059," at line 223 of file TROOT.h. ◆ GetGitDate(). const char * TROOT::GetGitDate ; (; ). Return date/time make was run. ; Definition at line 2474 of file TROOT.cxx. ◆ GetGlobal() [1/2]. TGlobal * TROOT::GetGlobal ; (; const char * ; name, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable by name. ; If load is true force reading of all currently defined globals from CINT (more expensive). ; Definition at line 1631 of file TROOT.cxx. ◆ GetGlobal() [2/2]. TGlobal * TROOT::GetGlobal ; (; const TObject * ; obj, . Bool_t ; load = kFALSE . ); const. Return pointer to global variable with address addr. ; Definition at line 1639 of file TROOT.cxx. ◆ GetGlobalFunction(). TFunction * TROOT::GetGlobalFunction ; (; const char * ; function, . const char * ; params = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If params != 0 it will also resolve overloading other it returns the first name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necessary, the list of global function. ; Definition at line 1663 of file TROOT.cxx. ◆ GetGlobalFunctionWithPrototype(). TFunction * TROOT::GetGlobalFunctionWithPrototype ; (; const char * ; function, . const char * ; proto = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If proto != 0 it will also resolve overloading. If load is true force reading of all currently defined global functions from CINT (more expensive). The proto string must be of the form: ""int, char*, float"". ; Definition at line 1718 of file TROOT.cxx. ◆ GetIconPath(). const TString & TROOT::GetIconPath ; (; ). static . Get the icon path in the installation. Static utility function. ; Definition at li",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:53622,Performance,load,load,53622,"_t ; load = kFALSE . ); const. Return pointer to global variable with address addr. ; Definition at line 1639 of file TROOT.cxx. ◆ GetGlobalFunction(). TFunction * TROOT::GetGlobalFunction ; (; const char * ; function, . const char * ; params = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If params != 0 it will also resolve overloading other it returns the first name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necessary, the list of global function. ; Definition at line 1663 of file TROOT.cxx. ◆ GetGlobalFunctionWithPrototype(). TFunction * TROOT::GetGlobalFunctionWithPrototype ; (; const char * ; function, . const char * ; proto = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If proto != 0 it will also resolve overloading. If load is true force reading of all currently defined global functions from CINT (more expensive). The proto string must be of the form: ""int, char*, float"". ; Definition at line 1718 of file TROOT.cxx. ◆ GetIconPath(). const TString & TROOT::GetIconPath ; (; ). static . Get the icon path in the installation. Static utility function. ; Definition at line 3168 of file TROOT.cxx. ◆ GetIncludeDir(). const TString & TROOT::GetIncludeDir ; (; ). static . Get the include directory in the installation. Static utility function. ; Definition at line 3042 of file TROOT.cxx. ◆ GetInterpreter(). TInterpreter * TROOT::GetInterpreter ; (; ); const. inline . Definition at line 210 of file TROOT.h. ◆ GetLibDir(). const TString & TROOT::GetLibDir ; (; ). static . Get the library directory in the installation. Static utility function. ; Definition at line 3010 of file TROOT.cxx. ◆ GetListOfBrows",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:53737,Performance,load,load,53737,"on * TROOT::GetGlobalFunction ; (; const char * ; function, . const char * ; params = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If params != 0 it will also resolve overloading other it returns the first name match. If params == 0 and load is true force reading of all currently defined global functions from Cling. The param string must be of the form: ""3189,\""aap\"",1.3"". ; Definition at line 1685 of file TROOT.cxx. ◆ GetGlobalFunctions(). TListOfFunctions * TROOT::GetGlobalFunctions ; (; ). protected . Internal routine returning, and creating if necessary, the list of global function. ; Definition at line 1663 of file TROOT.cxx. ◆ GetGlobalFunctionWithPrototype(). TFunction * TROOT::GetGlobalFunctionWithPrototype ; (; const char * ; function, . const char * ; proto = nullptr, . Bool_t ; load = kFALSE . ). Return pointer to global function by name. ; If proto != 0 it will also resolve overloading. If load is true force reading of all currently defined global functions from CINT (more expensive). The proto string must be of the form: ""int, char*, float"". ; Definition at line 1718 of file TROOT.cxx. ◆ GetIconPath(). const TString & TROOT::GetIconPath ; (; ). static . Get the icon path in the installation. Static utility function. ; Definition at line 3168 of file TROOT.cxx. ◆ GetIncludeDir(). const TString & TROOT::GetIncludeDir ; (; ). static . Get the include directory in the installation. Static utility function. ; Definition at line 3042 of file TROOT.cxx. ◆ GetInterpreter(). TInterpreter * TROOT::GetInterpreter ; (; ); const. inline . Definition at line 210 of file TROOT.h. ◆ GetLibDir(). const TString & TROOT::GetLibDir ; (; ). static . Get the library directory in the installation. Static utility function. ; Definition at line 3010 of file TROOT.cxx. ◆ GetListOfBrowsables(). TList * TROOT::GetListOfBrowsables ; (; ); const. inline . Definition at line 258 of file TROOT.h. ◆ GetListOfBrowsers(). TSeqCollection * TROOT::Get",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:55847,Performance,load,load,55847,"ion at line 245 of file TROOT.h. ◆ GetListOfCanvases(). TSeqCollection * TROOT::GetListOfCanvases ; (; ); const. inline . Definition at line 240 of file TROOT.h. ◆ GetListOfClasses(). TCollection * TROOT::GetListOfClasses ; (; ); const. inline . Definition at line 231 of file TROOT.h. ◆ GetListOfClassGenerators(). TCollection * TROOT::GetListOfClassGenerators ; (; ); const. inline . Definition at line 251 of file TROOT.h. ◆ GetListOfCleanups(). TSeqCollection * TROOT::GetListOfCleanups ; (; ); const. inline . Definition at line 248 of file TROOT.h. ◆ GetListOfClosedObjects(). TSeqCollection * TROOT::GetListOfClosedObjects ; (; ); const. inline . Definition at line 236 of file TROOT.h. ◆ GetListOfColors(). TSeqCollection * TROOT::GetListOfColors ; (; ); const. inline . Definition at line 232 of file TROOT.h. ◆ GetListOfDataSets(). TSeqCollection * TROOT::GetListOfDataSets ; (; ); const. inline . Definition at line 255 of file TROOT.h. ◆ GetListOfEnums(). TCollection * TROOT::GetListOfEnums ; (; Bool_t ; load = kFALSE). Definition at line 1754 of file TROOT.cxx. ◆ GetListOfFiles(). TSeqCollection * TROOT::GetListOfFiles ; (; ); const. inline . Definition at line 237 of file TROOT.h. ◆ GetListOfFunctionOverloads(). TCollection * TROOT::GetListOfFunctionOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 1672 of file TROOT.cxx. ◆ GetListOfFunctions(). TCollection * TROOT::GetListOfFunctions ; (; ); const. inline . Definition at line 242 of file TROOT.h. ◆ GetListOfFunctionTemplates(). TCollection * TROOT::GetListOfFunctionTemplates ; (; ). Definition at line 1771 of file TROOT.cxx. ◆ GetListOfGeometries(). TSeqCollection * TROOT::GetListOfGeometries ; (; ); const. inline . Definition at line 244 of file TROOT.h. ◆ GetListOfGlobalFunctions(). TCollection * TROOT::GetListOfGlobalFunctions ; (; Bool_t ; load = kFALSE). Return list containing the TFunctions currently defined. ; Since functions are created and del",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:56719,Performance,load,load,56719,"etListOfDataSets ; (; ); const. inline . Definition at line 255 of file TROOT.h. ◆ GetListOfEnums(). TCollection * TROOT::GetListOfEnums ; (; Bool_t ; load = kFALSE). Definition at line 1754 of file TROOT.cxx. ◆ GetListOfFiles(). TSeqCollection * TROOT::GetListOfFiles ; (; ); const. inline . Definition at line 237 of file TROOT.h. ◆ GetListOfFunctionOverloads(). TCollection * TROOT::GetListOfFunctionOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 1672 of file TROOT.cxx. ◆ GetListOfFunctions(). TCollection * TROOT::GetListOfFunctions ; (; ); const. inline . Definition at line 242 of file TROOT.h. ◆ GetListOfFunctionTemplates(). TCollection * TROOT::GetListOfFunctionTemplates ; (; ). Definition at line 1771 of file TROOT.cxx. ◆ GetListOfGeometries(). TSeqCollection * TROOT::GetListOfGeometries ; (; ); const. inline . Definition at line 244 of file TROOT.h. ◆ GetListOfGlobalFunctions(). TCollection * TROOT::GetListOfGlobalFunctions ; (; Bool_t ; load = kFALSE). Return list containing the TFunctions currently defined. ; Since functions are created and deleted during execution of the program, we need to update the list of functions every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1826 of file TROOT.cxx. ◆ GetListOfGlobals(). TCollection * TROOT::GetListOfGlobals ; (; Bool_t ; load = kFALSE). Return list containing the TGlobals currently defined. ; Since globals are created and deleted during execution of the program, we need to update the list of globals every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1788 of file TROOT.cxx. ◆ GetListOfMappedFiles(). TSeqCollection * TROOT::GetListOfMappedFiles ; (; ); const. inline . Definition",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:57053,Performance,load,load,57053,"237 of file TROOT.h. ◆ GetListOfFunctionOverloads(). TCollection * TROOT::GetListOfFunctionOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 1672 of file TROOT.cxx. ◆ GetListOfFunctions(). TCollection * TROOT::GetListOfFunctions ; (; ); const. inline . Definition at line 242 of file TROOT.h. ◆ GetListOfFunctionTemplates(). TCollection * TROOT::GetListOfFunctionTemplates ; (; ). Definition at line 1771 of file TROOT.cxx. ◆ GetListOfGeometries(). TSeqCollection * TROOT::GetListOfGeometries ; (; ); const. inline . Definition at line 244 of file TROOT.h. ◆ GetListOfGlobalFunctions(). TCollection * TROOT::GetListOfGlobalFunctions ; (; Bool_t ; load = kFALSE). Return list containing the TFunctions currently defined. ; Since functions are created and deleted during execution of the program, we need to update the list of functions every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1826 of file TROOT.cxx. ◆ GetListOfGlobals(). TCollection * TROOT::GetListOfGlobals ; (; Bool_t ; load = kFALSE). Return list containing the TGlobals currently defined. ; Since globals are created and deleted during execution of the program, we need to update the list of globals every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1788 of file TROOT.cxx. ◆ GetListOfMappedFiles(). TSeqCollection * TROOT::GetListOfMappedFiles ; (; ); const. inline . Definition at line 238 of file TROOT.h. ◆ GetListOfMessageHandlers(). TSeqCollection * TROOT::GetListOfMessageHandlers ; (; ); const. inline . Definition at line 250 of file TROOT.h. ◆ GetListOfProofs(). TSeqCollection * TROOT::GetListOfProofs ; (; ); const. inline . Definition at line 253 of file TROOT.h. ◆ GetListOfSec",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:57195,Performance,load,load,57195,"s named ""name"". ; Definition at line 1672 of file TROOT.cxx. ◆ GetListOfFunctions(). TCollection * TROOT::GetListOfFunctions ; (; ); const. inline . Definition at line 242 of file TROOT.h. ◆ GetListOfFunctionTemplates(). TCollection * TROOT::GetListOfFunctionTemplates ; (; ). Definition at line 1771 of file TROOT.cxx. ◆ GetListOfGeometries(). TSeqCollection * TROOT::GetListOfGeometries ; (; ); const. inline . Definition at line 244 of file TROOT.h. ◆ GetListOfGlobalFunctions(). TCollection * TROOT::GetListOfGlobalFunctions ; (; Bool_t ; load = kFALSE). Return list containing the TFunctions currently defined. ; Since functions are created and deleted during execution of the program, we need to update the list of functions every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1826 of file TROOT.cxx. ◆ GetListOfGlobals(). TCollection * TROOT::GetListOfGlobals ; (; Bool_t ; load = kFALSE). Return list containing the TGlobals currently defined. ; Since globals are created and deleted during execution of the program, we need to update the list of globals every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1788 of file TROOT.cxx. ◆ GetListOfMappedFiles(). TSeqCollection * TROOT::GetListOfMappedFiles ; (; ); const. inline . Definition at line 238 of file TROOT.h. ◆ GetListOfMessageHandlers(). TSeqCollection * TROOT::GetListOfMessageHandlers ; (; ); const. inline . Definition at line 250 of file TROOT.h. ◆ GetListOfProofs(). TSeqCollection * TROOT::GetListOfProofs ; (; ); const. inline . Definition at line 253 of file TROOT.h. ◆ GetListOfSecContexts(). TSeqCollection * TROOT::GetListOfSecContexts ; (; ); const. inline . Definition at line 252 of file TROOT.h. ◆ GetListOfSockets(). TSeqCollection * TROOT::G",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:57523,Performance,load,load,57523,"f file TROOT.cxx. ◆ GetListOfGeometries(). TSeqCollection * TROOT::GetListOfGeometries ; (; ); const. inline . Definition at line 244 of file TROOT.h. ◆ GetListOfGlobalFunctions(). TCollection * TROOT::GetListOfGlobalFunctions ; (; Bool_t ; load = kFALSE). Return list containing the TFunctions currently defined. ; Since functions are created and deleted during execution of the program, we need to update the list of functions every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1826 of file TROOT.cxx. ◆ GetListOfGlobals(). TCollection * TROOT::GetListOfGlobals ; (; Bool_t ; load = kFALSE). Return list containing the TGlobals currently defined. ; Since globals are created and deleted during execution of the program, we need to update the list of globals every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1788 of file TROOT.cxx. ◆ GetListOfMappedFiles(). TSeqCollection * TROOT::GetListOfMappedFiles ; (; ); const. inline . Definition at line 238 of file TROOT.h. ◆ GetListOfMessageHandlers(). TSeqCollection * TROOT::GetListOfMessageHandlers ; (; ); const. inline . Definition at line 250 of file TROOT.h. ◆ GetListOfProofs(). TSeqCollection * TROOT::GetListOfProofs ; (; ); const. inline . Definition at line 253 of file TROOT.h. ◆ GetListOfSecContexts(). TSeqCollection * TROOT::GetListOfSecContexts ; (; ); const. inline . Definition at line 252 of file TROOT.h. ◆ GetListOfSockets(). TSeqCollection * TROOT::GetListOfSockets ; (; ); const. inline . Definition at line 239 of file TROOT.h. ◆ GetListOfSpecials(). TSeqCollection * TROOT::GetListOfSpecials ; (; ); const. inline . Definition at line 246 of file TROOT.h. ◆ GetListOfStreamerInfo(). TSeqCollection * TROOT::GetListOfStreamerInfo ; (; ); const. inlin",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:58840,Performance,load,load,58840,"line . Definition at line 250 of file TROOT.h. ◆ GetListOfProofs(). TSeqCollection * TROOT::GetListOfProofs ; (; ); const. inline . Definition at line 253 of file TROOT.h. ◆ GetListOfSecContexts(). TSeqCollection * TROOT::GetListOfSecContexts ; (; ); const. inline . Definition at line 252 of file TROOT.h. ◆ GetListOfSockets(). TSeqCollection * TROOT::GetListOfSockets ; (; ); const. inline . Definition at line 239 of file TROOT.h. ◆ GetListOfSpecials(). TSeqCollection * TROOT::GetListOfSpecials ; (; ); const. inline . Definition at line 246 of file TROOT.h. ◆ GetListOfStreamerInfo(). TSeqCollection * TROOT::GetListOfStreamerInfo ; (; ); const. inline . Definition at line 249 of file TROOT.h. ◆ GetListOfStyles(). TSeqCollection * TROOT::GetListOfStyles ; (; ); const. inline . Definition at line 241 of file TROOT.h. ◆ GetListOfTasks(). TSeqCollection * TROOT::GetListOfTasks ; (; ); const. inline . Definition at line 247 of file TROOT.h. ◆ GetListOfTypes(). TCollection * TROOT::GetListOfTypes ; (; Bool_t ; load = kFALSE). Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ; The list is populated on demand. Calling gROOT->GetListOfTypes()->FindObject(nameoftype);; will return the TDataType corresponding to 'nameoftype'. If the TDataType is not already in the list itself and the type does exist, a new TDataType will be created and added to the list.; Calling gROOT->GetListOfTypes()->ls(); // or Print(); list only the typedefs that have been previously accessed through the list (plus the builtins types). ; Definition at line 1865 of file TROOT.cxx. ◆ GetMacroDir(). const TString & TROOT::GetMacroDir ; (; ). static . Get the macro directory in the installation. Static utility function. ; Definition at line 3094 of file TROOT.cxx. ◆ GetMacroPath(). const char * TROOT::GetMacroPath ; (; ). static . Get macro search path. Static utility function. ; Definition at line 2762 of file TROOT.cxx. ◆ GetNclasses(). Int_t TROOT::GetNclasses ; (; ); cons",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:61946,Performance,load,load,61946,"; (; ). static . Get the source directory in the installation. Static utility function. ; Definition at line 3147 of file TROOT.cxx. ◆ GetStyle(). TStyle * TROOT::GetStyle ; (; const char * ; name); const. Return pointer to style with name. ; Definition at line 1579 of file TROOT.cxx. ◆ GetTTFFontDir(). const TString & TROOT::GetTTFFontDir ; (; ). static . Get the fonts directory in the installation. Static utility function. ; Definition at line 3189 of file TROOT.cxx. ◆ GetTutorialDir(). const TString & TROOT::GetTutorialDir ; (; ). static . Get the tutorials directory in the installation. Static utility function. ; Definition at line 3115 of file TROOT.cxx. ◆ GetTutorialsDir(). const char * TROOT::GetTutorialsDir ; (; ). static . Get the tutorials directory in the installation. ; Static utility function. Backward compatibility function - do not use for new code ; Definition at line 3211 of file TROOT.cxx. ◆ GetType(). TDataType * TROOT::GetType ; (; const char * ; name, . Bool_t ; load = kFALSE . ); const. Return pointer to type with name. ; Definition at line 1562 of file TROOT.cxx. ◆ GetUUIDs(). TProcessUUID * TROOT::GetUUIDs ; (; ); const. inline . Definition at line 275 of file TROOT.h. ◆ GetVersion(). const char * TROOT::GetVersion ; (; ); const. inline . Definition at line 230 of file TROOT.h. ◆ GetVersionCode(). Int_t TROOT::GetVersionCode ; (; ); const. inline . Definition at line 229 of file TROOT.h. ◆ GetVersionDate(). Int_t TROOT::GetVersionDate ; (; ); const. inline . Definition at line 226 of file TROOT.h. ◆ GetVersionInt(). Int_t TROOT::GetVersionInt ; (; ); const. inline . Definition at line 228 of file TROOT.h. ◆ GetVersionTime(). Int_t TROOT::GetVersionTime ; (; ); const. inline . Definition at line 227 of file TROOT.h. ◆ GetWebDisplay(). const TString & TROOT::GetWebDisplay ; (; ); const. inline . Definition at line 276 of file TROOT.h. ◆ Idle(). void TROOT::Idle ; (; UInt_t ; idleTimeInSec, . const char * ; command = nullptr . ). Execute command ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:66328,Performance,load,load,66328,"::IsInterrupted ; (; ); const. inline . Definition at line 282 of file TROOT.h. ◆ IsLineProcessing(). Bool_t TROOT::IsLineProcessing ; (; ); const. inline . Definition at line 284 of file TROOT.h. ◆ IsProofServ(). Bool_t TROOT::IsProofServ ; (; ); const. inline . Definition at line 285 of file TROOT.h. ◆ IsRootFile(). Bool_t TROOT::IsRootFile ; (; const char * ; filename); const. Return true if the file is local and is (likely) to be a ROOT file. ; Definition at line 2230 of file TROOT.cxx. ◆ IsWebDisplay(). Bool_t TROOT::IsWebDisplay ; (; ); const. inline . Definition at line 287 of file TROOT.h. ◆ IsWebDisplayBatch(). Bool_t TROOT::IsWebDisplayBatch ; (; ); const. inline . Definition at line 288 of file TROOT.h. ◆ LoadClass() [1/2]. Int_t TROOT::LoadClass ; (; const char * ; classname, . const char * ; libname, . Bool_t ; check = kFALSE . ). Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored). ; If not it will load library ""libname"". If the library couldn't be found with original libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again. If DynamicPathName still couldn't find the library, return -1. If check is true it will only check if libname exists and is readable. Returns 0 on successful loading, -1 in case libname does not exist or in case of error and -2 in case of version mismatch. ; Definition at line 2183 of file TROOT.cxx. ◆ LoadClass() [2/2]. TClass * TROOT::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent = kFALSE . ); const. Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 2167 of file TROOT.cxx. ◆ L",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:66651,Performance,load,loading,66651,"har * ; filename); const. Return true if the file is local and is (likely) to be a ROOT file. ; Definition at line 2230 of file TROOT.cxx. ◆ IsWebDisplay(). Bool_t TROOT::IsWebDisplay ; (; ); const. inline . Definition at line 287 of file TROOT.h. ◆ IsWebDisplayBatch(). Bool_t TROOT::IsWebDisplayBatch ; (; ); const. inline . Definition at line 288 of file TROOT.h. ◆ LoadClass() [1/2]. Int_t TROOT::LoadClass ; (; const char * ; classname, . const char * ; libname, . Bool_t ; check = kFALSE . ). Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored). ; If not it will load library ""libname"". If the library couldn't be found with original libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again. If DynamicPathName still couldn't find the library, return -1. If check is true it will only check if libname exists and is readable. Returns 0 on successful loading, -1 in case libname does not exist or in case of error and -2 in case of version mismatch. ; Definition at line 2183 of file TROOT.cxx. ◆ LoadClass() [2/2]. TClass * TROOT::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent = kFALSE . ); const. Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 2167 of file TROOT.cxx. ◆ LoadMacro(). Int_t TROOT::LoadMacro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; check = kFALSE . ). Load a macro in the interpreter's memory. ; Equivalent to the command line command "".L filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:66988,Performance,load,load,66988,"tion at line 288 of file TROOT.h. ◆ LoadClass() [1/2]. Int_t TROOT::LoadClass ; (; const char * ; classname, . const char * ; libname, . Bool_t ; check = kFALSE . ). Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore, so classname is ignored). ; If not it will load library ""libname"". If the library couldn't be found with original libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again. If DynamicPathName still couldn't find the library, return -1. If check is true it will only check if libname exists and is readable. Returns 0 on successful loading, -1 in case libname does not exist or in case of error and -2 in case of version mismatch. ; Definition at line 2183 of file TROOT.cxx. ◆ LoadClass() [2/2]. TClass * TROOT::LoadClass ; (; const char * ; requestedname, . Bool_t ; silent = kFALSE . ); const. Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 2167 of file TROOT.cxx. ◆ LoadMacro(). Int_t TROOT::LoadMacro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; check = kFALSE . ). Load a macro in the interpreter's memory. ; Equivalent to the command line command "".L filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]]. The possible error codes are defined by TInterpreter::EErrorCode. If check is true it will only check if filename exists and is readable. Returns 0 on successful loading and -1 in case filename does not exist or in case of error. ; Definition at line 2268 of file TROOT.cxx. ◆ ls(). void TROOT::ls ; (; Option_t * ; option = """"",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:67856,Performance,load,loading,67856,". Bool_t ; silent = kFALSE . ); const. Helper function used by TClass::GetClass(). ; This function attempts to load the dictionary for 'classname' either from the TClassTable or from the list of generator. If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members); The 'requestedname' is expected to be already normalized. ; Definition at line 2167 of file TROOT.cxx. ◆ LoadMacro(). Int_t TROOT::LoadMacro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; check = kFALSE . ). Load a macro in the interpreter's memory. ; Equivalent to the command line command "".L filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]]. The possible error codes are defined by TInterpreter::EErrorCode. If check is true it will only check if filename exists and is readable. Returns 0 on successful loading and -1 in case filename does not exist or in case of error. ; Definition at line 2268 of file TROOT.cxx. ◆ ls(). void TROOT::ls ; (; Option_t * ; option = """"); const. overridevirtual . To list all objects of the application. ; Loop on all objects created in the ROOT linked lists. Objects may be files and windows or any other object directly attached to the ROOT linked list. ; Reimplemented from TDirectory.; Definition at line 2250 of file TROOT.cxx. ◆ Macro(). Longptr_t TROOT::Macro ; (; const char * ; filename, . Int_t * ; error = nullptr, . Bool_t ; padUpdate = kTRUE . ). Execute a macro in the interpreter. ; Equivalent to the command line command "".x filename"". If the filename has ""+"" or ""++"" appended the macro will be compiled by ACLiC. The filename must have the format: [path/]macro.C[+|++[g|O]][(args)]. The possible error codes are defined by TInterpreter::EErrorCode. If padUpdate is true (default) update the current pad. Returns the macro return value. ; Definition at line 2316 of file TROOT",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:73788,Performance,load,loaded,73788," false . ). static . Called by static dictionary initialization to register clang modules for headers. ; Calls TCling::RegisterModule() unless gCling is NULL, i.e. during startup, where the information is buffered in the static GetModuleHeaderInfoBuffer(). ; Definition at line 2535 of file TROOT.cxx. ◆ Remove(). TObject * TROOT::Remove ; (; TObject * ; obj). overridevirtual . Remove an object from the in-memory list. ; Since TROOT is global resource, this is lock protected. ; Reimplemented from TDirectory.; Definition at line 2618 of file TROOT.cxx. ◆ RemoveClass(). void TROOT::RemoveClass ; (; TClass * ; oldcl). Remove a class from the list and map of classes. ; This routine is deprecated, use TClass::RemoveClass directly. ; Definition at line 2628 of file TROOT.cxx. ◆ Reset(). void TROOT::Reset ; (; Option_t * ; option = """"). Delete all global interpreter objects created since the last call to Reset. ; If option=""a"" is set reset to startup context (i.e. unload also all loaded files, classes, structs, typedefs, etc.).; This function is typically used at the beginning (or end) of an unnamed macro to clean the environment.; IMPORTANT WARNING: Do not use this call from within any function (neither compiled nor interpreted. This should only be used from a unnamed macro (which starts with a { (curly braces) ). For example, using TROOT::Reset from within an interpreted function will lead to the unloading of the dictionary and source file, including the one defining the function being executed. ; Definition at line 2651 of file TROOT.cxx. ◆ ResetClassSaved(). void TROOT::ResetClassSaved ; (; ). Reset the ClassSaved status of all classes. ; Definition at line 1096 of file TROOT.cxx. ◆ RootVersionCode(). Int_t TROOT::RootVersionCode ; (; ). static . Return ROOT version code as defined in RVersion.h. ; Definition at line 2941 of file TROOT.cxx. ◆ SaveContext(). void TROOT::SaveContext ; (; ). Save the current interpreter context. ; Definition at line 2671 of file TROOT.cxx. ◆",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:85533,Performance,multi-thread,multi-threads,85533,Functions* TROOT::fGlobalFunctions. protected . List of global functions. ; Definition at line 144 of file TROOT.h. ◆ fGlobals. TListOfDataMembers* TROOT::fGlobals. protected . List of global variables. ; Definition at line 143 of file TROOT.h. ◆ fgRootInit. Bool_t TROOT::fgRootInit = kFALSE. staticprivate . Singleton initialization flag. ; Definition at line 103 of file TROOT.h. ◆ fInterpreter. TInterpreter* TROOT::fInterpreter. protected . Command interpreter. ; Definition at line 125 of file TROOT.h. ◆ fInterrupt. Bool_t TROOT::fInterrupt. protected . True if macro should be interrupted. ; Definition at line 134 of file TROOT.h. ◆ fIsWebDisplay. Bool_t TROOT::fIsWebDisplay. protected . True if session uses web widgets. ; Definition at line 128 of file TROOT.h. ◆ fIsWebDisplayBatch. Bool_t TROOT::fIsWebDisplayBatch. protected . True if web widgets are not displayed. ; Definition at line 129 of file TROOT.h. ◆ fLineIsProcessing. Int_t TROOT::fLineIsProcessing. private . To synchronize multi-threads. ; Definition at line 100 of file TROOT.h. ◆ fMappedFiles. TSeqCollection* TROOT::fMappedFiles. protected . List of memory mapped files. ; Definition at line 147 of file TROOT.h. ◆ fMessageHandlers. TSeqCollection* TROOT::fMessageHandlers. protected . List of message handlers. ; Definition at line 158 of file TROOT.h. ◆ fMustClean. Bool_t TROOT::fMustClean. protected . True if object destructor scans canvases. ; Definition at line 132 of file TROOT.h. ◆ fPluginManager. TPluginManager* TROOT::fPluginManager. protected . Keeps track of plugin library handlers. ; Definition at line 169 of file TROOT.h. ◆ fPrimitive. const TObject* TROOT::fPrimitive. protected . Currently selected primitive. ; Definition at line 138 of file TROOT.h. ◆ fProofs. TSeqCollection* TROOT::fProofs. protected . List of proof sessions. ; Definition at line 162 of file TROOT.h. ◆ fRootFolder. TFolder* TROOT::fRootFolder. protected . top level folder //root ; Definition at line 167 of file TROOT.h. ◆ f,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:34701,Safety,detect,detected,34701,"onst char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::atomic< TApplication * > fApplication;  Pointer to current application. ;  ; Bool_t fBatch;  True if session without graphics. ;  ; TList * fBrowsables;  List of browsables. ;  ; TSeqCollection * fBrowsers;  List of browsers. ;  ; Int_t fBuiltDate;  Date of ROOT built. ;  ; Int_t fBuiltTime;  Time of ROOT built. ;  ; TSeqCollection * fCanvases;  List of canvases. ;  ; TCollection * fClasses;  List of classes definition. ;  ; TCollection * fClassGenerators;  List of user defined class generators;. ;  ; TSeqCollection * fCleanups;  List of recursiveRemove collections. ;  ; TSeqCollection * fClipboard;  List of clipboard objects. ;  ; TSeqCollection * fClosedObjects;  List of closed objects from the list of files and sockets, so we can delete them if neededCl. ;  ; TSeqCollection * fColors;  List of colors. ;  ; TString fConfigFeatures;  ROOT ./configure detected build features. ;  ; TString fConfigOptions;  ROOT ./configure set build options. ;  ; TString fCutClassName;  Name of default CutG class in graphics editor. ;  ; TSeqCollection * fDataSets;  List of data sets (TDSet or TChain) ;  ; TString fDefCanvasName;  Name of default canvas. ;  ; Bool_t fEditHistograms;  True if histograms can be edited with the mouse. ;  ; Int_t fEditorMode;  Current Editor mode. ;  ; AListOfEnums_t fEnums;  List of enum types. ;  ; Bool_t fEscape;  True if ESC has been pressed. ;  ; Bool_t fExecutingMacro;  True while executing a TMacro. ;  ; TSeqCollection * fFiles;  List of files. ;  ; Bool_t fForceStyle;  Force setting of current style when reading objects. ;  ; Bool_t fFromPopUp;  True if command executed from a popup menu. ;  ; TListOfFunctionTemplates * fFuncTemplate;  List of global function templates. ;  ; TCollection * fFunctions;  List of analytic functions. ;  ; TSeqCollection * fGeometries;  List of geometries. ;  ; TString fGitBranch;  Git branch",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:81967,Safety,detect,detected,81967,"canvases. ; Definition at line 149 of file TROOT.h. ◆ fClasses. TCollection* TROOT::fClasses. protected . List of classes definition. ; Definition at line 140 of file TROOT.h. ◆ fClassGenerators. TCollection* TROOT::fClassGenerators. protected . List of user defined class generators;. ; Definition at line 160 of file TROOT.h. ◆ fCleanups. TSeqCollection* TROOT::fCleanups. protected . List of recursiveRemove collections. ; Definition at line 157 of file TROOT.h. ◆ fClipboard. TSeqCollection* TROOT::fClipboard. protected . List of clipboard objects. ; Definition at line 163 of file TROOT.h. ◆ fClosedObjects. TSeqCollection* TROOT::fClosedObjects. protected . List of closed objects from the list of files and sockets, so we can delete them if neededCl. ; Definition at line 145 of file TROOT.h. ◆ fColors. TSeqCollection* TROOT::fColors. protected . List of colors. ; Definition at line 153 of file TROOT.h. ◆ fConfigFeatures. TString TROOT::fConfigFeatures. protected . ROOT ./configure detected build features. ; Definition at line 112 of file TROOT.h. ◆ fConfigOptions. TString TROOT::fConfigOptions. protected . ROOT ./configure set build options. ; Definition at line 111 of file TROOT.h. ◆ fCutClassName. TString TROOT::fCutClassName. protected . Name of default CutG class in graphics editor. ; Definition at line 170 of file TROOT.h. ◆ fDataSets. TSeqCollection* TROOT::fDataSets. protected . List of data sets (TDSet or TChain) ; Definition at line 164 of file TROOT.h. ◆ fDefCanvasName. TString TROOT::fDefCanvasName. protected . Name of default canvas. ; Definition at line 171 of file TROOT.h. ◆ fEditHistograms. Bool_t TROOT::fEditHistograms. protected . True if histograms can be edited with the mouse. ; Definition at line 130 of file TROOT.h. ◆ fEditorMode. Int_t TROOT::fEditorMode. protected . Current Editor mode. ; Definition at line 137 of file TROOT.h. ◆ fEnums. AListOfEnums_t TROOT::fEnums. protected . List of enum types. ; Definition at line 165 of file TROOT.h. ◆ fEsc",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:583,Security,access,accessible,583,". ROOT: TROOT Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Types |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; Private Attributes |; Static Private Attributes |; Friends |; List of all members ; TROOT Class ReferenceCore ROOT classes » Base ROOT classes. ; ROOT top level object description. ; The TROOT object is the entry point to the ROOT system. The single instance of TROOT is accessible via the global gROOT. Using the gROOT pointer one has access to basically every object created in a ROOT based program. The TROOT object is essentially a container of several lists pointing to the main ROOT objects.; The following lists are accessible from gROOT object:; gROOT->GetListOfClasses; gROOT->GetListOfColors; gROOT->GetListOfTypes; gROOT->GetListOfGlobals; gROOT->GetListOfGlobalFunctions; gROOT->GetListOfFiles; gROOT->GetListOfMappedFiles; gROOT->GetListOfSockets; gROOT->GetListOfSecContexts; gROOT->GetListOfCanvases; gROOT->GetListOfStyles; gROOT->GetListOfFunctions; gROOT->GetListOfSpecials (for example graphical cuts); gROOT->GetListOfGeometries; gROOT->GetListOfBrowsers; gROOT->GetListOfCleanups; gROOT->GetListOfMessageHandlers; gROOT#define gROOTDefinition TROOT.h:406; exampleDefinition example.py:1; The TROOT class provides also many useful services:; Get pointer to an object in any of the lists above; Time utilities TROOT::Time. The ROOT object must be created as a static object. An example of a main program creating an interactive version is shown below:. Example of a main program; #include ""TRint.h""; ; int main(int argc, char **argv); {; TRint *theApp = new TRint(""ROOT example"", &argc, argv);; ; // Init Intrinsics, build all windows, and enter event loop; theApp->Run();; ; return(0);; }; mainint main()Definition Prototype.cxx:12; TRint.h; TRintDefinition TRint.h:31;",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:648,Security,access,access,648,". ROOT: TROOT Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Types |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; Private Attributes |; Static Private Attributes |; Friends |; List of all members ; TROOT Class ReferenceCore ROOT classes » Base ROOT classes. ; ROOT top level object description. ; The TROOT object is the entry point to the ROOT system. The single instance of TROOT is accessible via the global gROOT. Using the gROOT pointer one has access to basically every object created in a ROOT based program. The TROOT object is essentially a container of several lists pointing to the main ROOT objects.; The following lists are accessible from gROOT object:; gROOT->GetListOfClasses; gROOT->GetListOfColors; gROOT->GetListOfTypes; gROOT->GetListOfGlobals; gROOT->GetListOfGlobalFunctions; gROOT->GetListOfFiles; gROOT->GetListOfMappedFiles; gROOT->GetListOfSockets; gROOT->GetListOfSecContexts; gROOT->GetListOfCanvases; gROOT->GetListOfStyles; gROOT->GetListOfFunctions; gROOT->GetListOfSpecials (for example graphical cuts); gROOT->GetListOfGeometries; gROOT->GetListOfBrowsers; gROOT->GetListOfCleanups; gROOT->GetListOfMessageHandlers; gROOT#define gROOTDefinition TROOT.h:406; exampleDefinition example.py:1; The TROOT class provides also many useful services:; Get pointer to an object in any of the lists above; Time utilities TROOT::Time. The ROOT object must be created as a static object. An example of a main program creating an interactive version is shown below:. Example of a main program; #include ""TRint.h""; ; int main(int argc, char **argv); {; TRint *theApp = new TRint(""ROOT example"", &argc, argv);; ; // Init Intrinsics, build all windows, and enter event loop; theApp->Run();; ; return(0);; }; mainint main()Definition Prototype.cxx:12; TRint.h; TRintDefinition TRint.h:31;",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:835,Security,access,accessible,835,"..; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Types |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; Private Attributes |; Static Private Attributes |; Friends |; List of all members ; TROOT Class ReferenceCore ROOT classes » Base ROOT classes. ; ROOT top level object description. ; The TROOT object is the entry point to the ROOT system. The single instance of TROOT is accessible via the global gROOT. Using the gROOT pointer one has access to basically every object created in a ROOT based program. The TROOT object is essentially a container of several lists pointing to the main ROOT objects.; The following lists are accessible from gROOT object:; gROOT->GetListOfClasses; gROOT->GetListOfColors; gROOT->GetListOfTypes; gROOT->GetListOfGlobals; gROOT->GetListOfGlobalFunctions; gROOT->GetListOfFiles; gROOT->GetListOfMappedFiles; gROOT->GetListOfSockets; gROOT->GetListOfSecContexts; gROOT->GetListOfCanvases; gROOT->GetListOfStyles; gROOT->GetListOfFunctions; gROOT->GetListOfSpecials (for example graphical cuts); gROOT->GetListOfGeometries; gROOT->GetListOfBrowsers; gROOT->GetListOfCleanups; gROOT->GetListOfMessageHandlers; gROOT#define gROOTDefinition TROOT.h:406; exampleDefinition example.py:1; The TROOT class provides also many useful services:; Get pointer to an object in any of the lists above; Time utilities TROOT::Time. The ROOT object must be created as a static object. An example of a main program creating an interactive version is shown below:. Example of a main program; #include ""TRint.h""; ; int main(int argc, char **argv); {; TRint *theApp = new TRint(""ROOT example"", &argc, argv);; ; // Init Intrinsics, build all windows, and enter event loop; theApp->Run();; ; return(0);; }; mainint main()Definition Prototype.cxx:12; TRint.h; TRintDefinition TRint.h:31; TRint::Runvoid Run(Bool_t retrn=kFALSE) overrideMain application eventloop.Definition TRint.cx",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:8464,Security,access,access,8464,"ects () const;  ; TSeqCollection * GetListOfColors () const;  ; TSeqCollection * GetListOfDataSets () const;  ; TCollection * GetListOfEnums (Bool_t load=kFALSE);  ; TSeqCollection * GetListOfFiles () const;  ; TCollection * GetListOfFunctionOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TCollection * GetListOfFunctions () const;  ; TCollection * GetListOfFunctionTemplates ();  ; TSeqCollection * GetListOfGeometries () const;  ; TCollection * GetListOfGlobalFunctions (Bool_t load=kFALSE);  Return list containing the TFunctions currently defined. ;  ; TCollection * GetListOfGlobals (Bool_t load=kFALSE);  Return list containing the TGlobals currently defined. ;  ; TSeqCollection * GetListOfMappedFiles () const;  ; TSeqCollection * GetListOfMessageHandlers () const;  ; TSeqCollection * GetListOfProofs () const;  ; TSeqCollection * GetListOfSecContexts () const;  ; TSeqCollection * GetListOfSockets () const;  ; TSeqCollection * GetListOfSpecials () const;  ; TSeqCollection * GetListOfStreamerInfo () const;  ; TSeqCollection * GetListOfStyles () const;  ; TSeqCollection * GetListOfTasks () const;  ; TCollection * GetListOfTypes (Bool_t load=kFALSE);  Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ;  ; Int_t GetNclasses () const;  Get number of classes. ;  ; Int_t GetNtypes () const;  Get number of types. ;  ; TPluginManager * GetPluginManager () const;  ; TFolder * GetRootFolder () const;  ; TVirtualPad * GetSelectedPad () const;  ; const TObject * GetSelectedPrimitive () const;  ; TStyle * GetStyle (const char *name) const;  Return pointer to style with name. ;  ; TDataType * GetType (const char *name, Bool_t load=kFALSE) const;  Return pointer to type with name. ;  ; TProcessUUID * GetUUIDs () const;  ; const char * GetVersion () const;  ; Int_t GetVersionCode () const;  ; Int_t GetVersionDate () const;  ; Int_t GetVersionInt () const;  ; Int_t GetVersionTime () const;  ; const TString & G",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:20477,Security,hash,hash,20477,"st TObject *obj, const char *name=nullptr, Option_t *="""", Int_t=0);  Write an object with proper type checking. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this clas",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:27965,Security,inject,inject,27965," static constexpr Version_t Class_Version ();  ; static Int_t ConvertVersionCode2Int (Int_t code);  Convert version code to an integer, i.e. 331527 -> 51507. ;  ; static Int_t ConvertVersionInt2Code (Int_t v);  Convert version as an integer to version code as used in RVersion.h. ;  ; static const char * DeclFileName ();  ; static Int_t DecreaseDirLevel ();  Decrease the indentation level for ls(). ;  ; static const TString & GetBinDir ();  Get the binary directory in the installation. Static utility function. ;  ; static const TString & GetDataDir ();  Get the data directory in the installation. Static utility function. ;  ; static Int_t GetDirLevel ();  return directory level ;  ; static const TString & GetDocDir ();  Get the documentation directory in the installation. Static utility function. ;  ; static const TString & GetEtcDir ();  Get the sysconfig directory in the installation. Static utility function. ;  ; static const char **& GetExtraInterpreterArgs ();  INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ;  ; static const TString & GetIconPath ();  Get the icon path in the installation. Static utility function. ;  ; static const TString & GetIncludeDir ();  Get the include directory in the installation. Static utility function. ;  ; static const TString & GetLibDir ();  Get the library directory in the installation. Static utility function. ;  ; static const TString & GetMacroDir ();  Get the macro directory in the installation. Static utility function. ;  ; static const char * GetMacroPath ();  Get macro search path. Static utility function. ;  ; static const TString & GetRootSys ();  Get the rootsys directory in the installation. Static utility function. ;  ; static const TString & GetSharedLibDir ();  Get the shared libraries directory in the installation. Static utility function. ;  ; static const TString & GetSourceDir ();  Get the source directory in the installation. Static utility function. ;  ; stati",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:36700,Security,secur,security,36700,"h;  Git branch. ;  ; TString fGitCommit;  Git commit SHA1 of built. ;  ; TString fGitDate;  Date and time when make was run. ;  ; TListOfFunctions * fGlobalFunctions;  List of global functions. ;  ; TListOfDataMembers * fGlobals;  List of global variables. ;  ; TInterpreter * fInterpreter;  Command interpreter. ;  ; Bool_t fInterrupt;  True if macro should be interrupted. ;  ; Bool_t fIsWebDisplay;  True if session uses web widgets. ;  ; Bool_t fIsWebDisplayBatch;  True if web widgets are not displayed. ;  ; TSeqCollection * fMappedFiles;  List of memory mapped files. ;  ; TSeqCollection * fMessageHandlers;  List of message handlers. ;  ; Bool_t fMustClean;  True if object destructor scans canvases. ;  ; TPluginManager * fPluginManager;  Keeps track of plugin library handlers. ;  ; const TObject * fPrimitive;  Currently selected primitive. ;  ; TSeqCollection * fProofs;  List of proof sessions. ;  ; TFolder * fRootFolder;  top level folder //root ;  ; TSeqCollection * fSecContexts;  List of security contexts (TSecContext) ;  ; TVirtualPad * fSelectPad;  Currently selected pad. ;  ; TSeqCollection * fSockets;  List of network sockets. ;  ; TSeqCollection * fSpecials;  List of special objects. ;  ; TSeqCollection * fStreamerInfo;  List of active StreamerInfo classes. ;  ; TSeqCollection * fStyles;  List of styles. ;  ; TSeqCollection * fTasks;  List of tasks. ;  ; Int_t fTimer;  Timer flag. ;  ; TCollection * fTypes;  List of data types definition. ;  ; TProcessUUID * fUUIDs;  Pointer to TProcessID managing TUUIDs. ;  ; TString fVersion;  ROOT version (from CMZ VERSQQ) ex 0.05/01. ;  ; Int_t fVersionCode;  ROOT version code as used in RVersion.h. ;  ; Int_t fVersionDate;  Date of ROOT version (ex 951226) ;  ; Int_t fVersionInt;  ROOT version in integer format (501) ;  ; Int_t fVersionTime;  Time of ROOT version (ex 1152) ;  ; TString fWebDisplay;  If not empty it defines where web graphics should be rendered (cef, qt5, browser...) ;  ;  Protected Attributes inherited ",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:40636,Security,access,accessed,40636,"e TROOT.h. Constructor & Destructor Documentation. ◆ TROOT() [1/3]. TROOT::TROOT ; (; const TROOT & ; ). privatedelete . ◆ TROOT() [2/3]. TROOT::TROOT ; (; ). protected . Only used by Dictionary. ; Default ctor. ; Definition at line 605 of file TROOT.cxx. ◆ TROOT() [3/3]. TROOT::TROOT ; (; const char * ; name, . const char * ; title, . VoidFuncPtr_t * ; initfunc = nullptr . ). Initialize the ROOT system. ; The creation of the TROOT object initializes the ROOT system. It must be the first ROOT related action that is performed by a program. The TROOT object must be created on the stack (can not be called via new since ""operator new"" is protected). The TROOT object is either created as a global object (outside the main() program), or it is one of the first objects created in main(). Make sure that the TROOT object stays in scope for as long as ROOT related actions are performed. TROOT is a so called singleton so only one instance of it can be created. The single TROOT object can always be accessed via the global pointer gROOT. The name and title arguments can be used to identify the running application. The initfunc argument can contain an array of function pointers (last element must be 0). These functions are executed at the end of the constructor. This way one can easily extend the ROOT system without adding permanent dependencies (e.g. the graphics system is initialized via such a function). ; Definition at line 639 of file TROOT.cxx. ◆ ~TROOT(). TROOT::~TROOT ; (; ). virtual . Clean up and free resources used by ROOT (files, network sockets, shared memory segments, etc.). ; Definition at line 867 of file TROOT.cxx. Member Function Documentation. ◆ AddClass(). void TROOT::AddClass ; (; TClass * ; cl). Add a class to the list and map of classes. ; This routine is deprecated, use TClass::AddClass directly. ; Definition at line 1025 of file TROOT.cxx. ◆ AddClassGenerator(). void TROOT::AddClassGenerator ; (; TClassGenerator * ; generator). Add a class generator. ; This",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:50899,Security,inject,inject,50899,OOT.cxx. ◆ GetDefCanvasName(). const char * TROOT::GetDefCanvasName ; (; ); const. inline . Definition at line 217 of file TROOT.h. ◆ GetDirLevel(). Int_t TROOT::GetDirLevel ; (; ). static . return directory level ; Definition at line 2754 of file TROOT.cxx. ◆ GetDocDir(). const TString & TROOT::GetDocDir ; (; ). static . Get the documentation directory in the installation. Static utility function. ; Definition at line 3078 of file TROOT.cxx. ◆ GetEditHistograms(). Bool_t TROOT::GetEditHistograms ; (; ); const. inline . Definition at line 218 of file TROOT.h. ◆ GetEditorMode(). Int_t TROOT::GetEditorMode ; (; ); const. inline . Definition at line 219 of file TROOT.h. ◆ GetEtcDir(). const TString & TROOT::GetEtcDir ; (; ). static . Get the sysconfig directory in the installation. Static utility function. ; Definition at line 3052 of file TROOT.cxx. ◆ GetExtraInterpreterArgs(). const char **& TROOT::GetExtraInterpreterArgs ; (; ). static . INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer. ; Definition at line 2962 of file TROOT.cxx. ◆ GetFile() [1/2]. TFile * TROOT::GetFile ; (; ); const. inlineoverridevirtual . Reimplemented from TDirectory.; Definition at line 260 of file TROOT.h. ◆ GetFile() [2/2]. TFile * TROOT::GetFile ; (; const char * ; name); const. Return pointer to file with name. ; Definition at line 1570 of file TROOT.cxx. ◆ GetForceStyle(). Bool_t TROOT::GetForceStyle ; (; ); const. inline . Definition at line 220 of file TROOT.h. ◆ GetFunction(). TObject * TROOT::GetFunction ; (; const char * ; name); const. Return pointer to function with name. ; Definition at line 1587 of file TROOT.cxx. ◆ GetFunctionTemplate(). TFunctionTemplate * TROOT::GetFunctionTemplate ; (; const char * ; name). Definition at line 1618 of file TROOT.cxx. ◆ GetGeometry(). TObject * TROOT::GetGeometry ; (; const char * ; name); const. Return pointer to Geometry with name. ; Definition at line 1747 of file TROOT.cxx. ◆ GetGitBranch(). ,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:58885,Security,access,access,58885,"lection * TROOT::GetListOfProofs ; (; ); const. inline . Definition at line 253 of file TROOT.h. ◆ GetListOfSecContexts(). TSeqCollection * TROOT::GetListOfSecContexts ; (; ); const. inline . Definition at line 252 of file TROOT.h. ◆ GetListOfSockets(). TSeqCollection * TROOT::GetListOfSockets ; (; ); const. inline . Definition at line 239 of file TROOT.h. ◆ GetListOfSpecials(). TSeqCollection * TROOT::GetListOfSpecials ; (; ); const. inline . Definition at line 246 of file TROOT.h. ◆ GetListOfStreamerInfo(). TSeqCollection * TROOT::GetListOfStreamerInfo ; (; ); const. inline . Definition at line 249 of file TROOT.h. ◆ GetListOfStyles(). TSeqCollection * TROOT::GetListOfStyles ; (; ); const. inline . Definition at line 241 of file TROOT.h. ◆ GetListOfTasks(). TSeqCollection * TROOT::GetListOfTasks ; (; ); const. inline . Definition at line 247 of file TROOT.h. ◆ GetListOfTypes(). TCollection * TROOT::GetListOfTypes ; (; Bool_t ; load = kFALSE). Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ; The list is populated on demand. Calling gROOT->GetListOfTypes()->FindObject(nameoftype);; will return the TDataType corresponding to 'nameoftype'. If the TDataType is not already in the list itself and the type does exist, a new TDataType will be created and added to the list.; Calling gROOT->GetListOfTypes()->ls(); // or Print(); list only the typedefs that have been previously accessed through the list (plus the builtins types). ; Definition at line 1865 of file TROOT.cxx. ◆ GetMacroDir(). const TString & TROOT::GetMacroDir ; (; ). static . Get the macro directory in the installation. Static utility function. ; Definition at line 3094 of file TROOT.cxx. ◆ GetMacroPath(). const char * TROOT::GetMacroPath ; (; ). static . Get macro search path. Static utility function. ; Definition at line 2762 of file TROOT.cxx. ◆ GetNclasses(). Int_t TROOT::GetNclasses ; (; ); const. Get number of classes. ; Definition at line 1876 of file TROOT.cxx. ◆ Ge",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:59325,Security,access,accessed,59325,"OOT::GetListOfSpecials ; (; ); const. inline . Definition at line 246 of file TROOT.h. ◆ GetListOfStreamerInfo(). TSeqCollection * TROOT::GetListOfStreamerInfo ; (; ); const. inline . Definition at line 249 of file TROOT.h. ◆ GetListOfStyles(). TSeqCollection * TROOT::GetListOfStyles ; (; ); const. inline . Definition at line 241 of file TROOT.h. ◆ GetListOfTasks(). TSeqCollection * TROOT::GetListOfTasks ; (; ); const. inline . Definition at line 247 of file TROOT.h. ◆ GetListOfTypes(). TCollection * TROOT::GetListOfTypes ; (; Bool_t ; load = kFALSE). Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ; The list is populated on demand. Calling gROOT->GetListOfTypes()->FindObject(nameoftype);; will return the TDataType corresponding to 'nameoftype'. If the TDataType is not already in the list itself and the type does exist, a new TDataType will be created and added to the list.; Calling gROOT->GetListOfTypes()->ls(); // or Print(); list only the typedefs that have been previously accessed through the list (plus the builtins types). ; Definition at line 1865 of file TROOT.cxx. ◆ GetMacroDir(). const TString & TROOT::GetMacroDir ; (; ). static . Get the macro directory in the installation. Static utility function. ; Definition at line 3094 of file TROOT.cxx. ◆ GetMacroPath(). const char * TROOT::GetMacroPath ; (; ). static . Get macro search path. Static utility function. ; Definition at line 2762 of file TROOT.cxx. ◆ GetNclasses(). Int_t TROOT::GetNclasses ; (; ); const. Get number of classes. ; Definition at line 1876 of file TROOT.cxx. ◆ GetNtypes(). Int_t TROOT::GetNtypes ; (; ); const. Get number of types. ; Definition at line 1884 of file TROOT.cxx. ◆ GetPluginManager(). TPluginManager * TROOT::GetPluginManager ; (; ); const. inline . Definition at line 208 of file TROOT.h. ◆ GetRootFolder(). TFolder * TROOT::GetRootFolder ; (; ); const. inline . Definition at line 274 of file TROOT.h. ◆ GetRootSys(). const TString & TROOT::GetRoot",MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTROOT.html:86602,Security,secur,security,86602,pedFiles. protected . List of memory mapped files. ; Definition at line 147 of file TROOT.h. ◆ fMessageHandlers. TSeqCollection* TROOT::fMessageHandlers. protected . List of message handlers. ; Definition at line 158 of file TROOT.h. ◆ fMustClean. Bool_t TROOT::fMustClean. protected . True if object destructor scans canvases. ; Definition at line 132 of file TROOT.h. ◆ fPluginManager. TPluginManager* TROOT::fPluginManager. protected . Keeps track of plugin library handlers. ; Definition at line 169 of file TROOT.h. ◆ fPrimitive. const TObject* TROOT::fPrimitive. protected . Currently selected primitive. ; Definition at line 138 of file TROOT.h. ◆ fProofs. TSeqCollection* TROOT::fProofs. protected . List of proof sessions. ; Definition at line 162 of file TROOT.h. ◆ fRootFolder. TFolder* TROOT::fRootFolder. protected . top level folder //root ; Definition at line 167 of file TROOT.h. ◆ fSecContexts. TSeqCollection* TROOT::fSecContexts. protected . List of security contexts (TSecContext) ; Definition at line 161 of file TROOT.h. ◆ fSelectPad. TVirtualPad* TROOT::fSelectPad. protected . Currently selected pad. ; Definition at line 139 of file TROOT.h. ◆ fSockets. TSeqCollection* TROOT::fSockets. protected . List of network sockets. ; Definition at line 148 of file TROOT.h. ◆ fSpecials. TSeqCollection* TROOT::fSpecials. protected . List of special objects. ; Definition at line 156 of file TROOT.h. ◆ fStreamerInfo. TSeqCollection* TROOT::fStreamerInfo. protected . List of active StreamerInfo classes. ; Definition at line 159 of file TROOT.h. ◆ fStyles. TSeqCollection* TROOT::fStyles. protected . List of styles. ; Definition at line 150 of file TROOT.h. ◆ fTasks. TSeqCollection* TROOT::fTasks. protected . List of tasks. ; Definition at line 152 of file TROOT.h. ◆ fTimer. Int_t TROOT::fTimer. protected . Timer flag. ; Definition at line 123 of file TROOT.h. ◆ fTypes. TCollection* TROOT::fTypes. protected . List of data types definition. ; Definition at line 141 of file TRO,MatchSource.WIKI,doc/v632/classTROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTROOT.html
https://root.cern/doc/v632/classTString.html:41897,Availability,error,error,41897,"); const. Returns true if all characters in string are octal digits (0-7). ; Returns false in case string length is 0 or string contains other characters. ; Definition at line 1924 of file TString.cxx. ◆ IsWhitespace(). Bool_t TString::IsWhitespace ; (; ); const. inline . Definition at line 415 of file TString.h. ◆ Itoa(). TString TString::Itoa ; (; Int_t ; value, . Int_t ; base . ). static . Converts an Int_t to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). Usage: the following statement produce the same output, namely ""1111"" std::cout << TString::Itoa(15,2) ;; std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; TString::Itoastatic TString Itoa(Int_t value, Int_t base)Converts an Int_t to a TString with respect to the base specified (2-36).Definition TString.cxx:2092; In case of error returns the ""!"" string. ; Definition at line 2092 of file TString.cxx. ◆ Last(). Ssiz_t TString::Last ; (; char ; c); const. Find last occurrence of a character c. ; Definition at line 931 of file TString.cxx. ◆ Length(). Ssiz_t TString::Length ; (; ); const. inline . Definition at line 417 of file TString.h. ◆ LLtoa(). TString TString::LLtoa ; (; Long64_t ; value, . Int_t ; base . ). static . Converts a Long64_t to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2144 of file TString.cxx. ◆ MaxSize(). static Ssiz_t TString::MaxSize ; (; ). inlinestaticprivate . Definition at line 261 of file TString.h. ◆ MaxWaste(). Ssiz_t TString::MaxWaste ; (; Ssiz_t ; mw = 15). static . Set maximum space that may be wasted in a string before doing a resize. ; Default is 15. ; Definition at line 1612 of file TStri",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:42508,Availability,error,error,42508,"tement produce the same output, namely ""1111"" std::cout << TString::Itoa(15,2) ;; std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; TString::Itoastatic TString Itoa(Int_t value, Int_t base)Converts an Int_t to a TString with respect to the base specified (2-36).Definition TString.cxx:2092; In case of error returns the ""!"" string. ; Definition at line 2092 of file TString.cxx. ◆ Last(). Ssiz_t TString::Last ; (; char ; c); const. Find last occurrence of a character c. ; Definition at line 931 of file TString.cxx. ◆ Length(). Ssiz_t TString::Length ; (; ); const. inline . Definition at line 417 of file TString.h. ◆ LLtoa(). TString TString::LLtoa ; (; Long64_t ; value, . Int_t ; base . ). static . Converts a Long64_t to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2144 of file TString.cxx. ◆ MaxSize(). static Ssiz_t TString::MaxSize ; (; ). inlinestaticprivate . Definition at line 261 of file TString.h. ◆ MaxWaste(). Ssiz_t TString::MaxWaste ; (; Ssiz_t ; mw = 15). static . Set maximum space that may be wasted in a string before doing a resize. ; Default is 15. ; Definition at line 1612 of file TString.cxx. ◆ MaybeRegexp(). Bool_t TString::MaybeRegexp ; (; ); const. Returns true if string contains one of the regexp characters ""^$.[]*+?"". ; Definition at line 952 of file TString.cxx. ◆ MaybeWildcard(). Bool_t TString::MaybeWildcard ; (; ); const. Returns true if string contains one of the wildcard characters ""[]*?"". ; Definition at line 964 of file TString.cxx. ◆ MD5(). TString TString::MD5 ; (; ); const. Return the MD5 digest for this string, in a string representation. ; Definition at line 940 of file TString.cxx. ◆ operator const char *(). TString::operator const char * ; (; ); const. inline . Definiti",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:56540,Availability,error,error,56540,"this way: TString myl = ""tok1 tok2|tok3"";; TString tok;; Ssiz_t from = 0;; while (myl.Tokenize(tok, from, ""[ |]"")) {; // Analyse tok; ...; }; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; int; more convenient of the other Tokenize method when saving the tokens is not needed. ; Definition at line 310 of file TRegexp.cxx. ◆ ToLower(). void TString::ToLower ; (; ). Change string to lower-case. ; Definition at line 1182 of file TString.cxx. ◆ ToUpper(). void TString::ToUpper ; (; ). Change string to upper case. ; Definition at line 1195 of file TString.cxx. ◆ UItoa(). TString TString::UItoa ; (; UInt_t ; value, . Int_t ; base . ). static . Converts a UInt_t (twice the range of an Int_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2119 of file TString.cxx. ◆ ULLtoa(). TString TString::ULLtoa ; (; ULong64_t ; value, . Int_t ; base . ). static . Converts a ULong64_t (twice the range of an Long64_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2171 of file TString.cxx. ◆ UnLink(). void TString::UnLink ; (; ); const. inlineprivate . Definition at line 263 of file TString.h. ◆ View(). std::string_view TString::View ; (; ); const. inline . Definition at line 452 of file TString.h. ◆ WriteString(). void TString::WriteString ; (; TBuffer & ; b, . const TString * ; a . ). static . Write TString object to buffer. ; Simplified version of TBuffer::WriteObject (does not keep track of multiple references to the same string). We need to have it here because TBuffer::ReadObject can only handle de",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:56948,Availability,error,error,56948," 310 of file TRegexp.cxx. ◆ ToLower(). void TString::ToLower ; (; ). Change string to lower-case. ; Definition at line 1182 of file TString.cxx. ◆ ToUpper(). void TString::ToUpper ; (; ). Change string to upper case. ; Definition at line 1195 of file TString.cxx. ◆ UItoa(). TString TString::UItoa ; (; UInt_t ; value, . Int_t ; base . ). static . Converts a UInt_t (twice the range of an Int_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2119 of file TString.cxx. ◆ ULLtoa(). TString TString::ULLtoa ; (; ULong64_t ; value, . Int_t ; base . ). static . Converts a ULong64_t (twice the range of an Long64_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2171 of file TString.cxx. ◆ UnLink(). void TString::UnLink ; (; ); const. inlineprivate . Definition at line 263 of file TString.h. ◆ View(). std::string_view TString::View ; (; ); const. inline . Definition at line 452 of file TString.h. ◆ WriteString(). void TString::WriteString ; (; TBuffer & ; b, . const TString * ; a . ). static . Write TString object to buffer. ; Simplified version of TBuffer::WriteObject (does not keep track of multiple references to the same string). We need to have it here because TBuffer::ReadObject can only handle descendant of TObject ; Definition at line 1428 of file TString.cxx. ◆ Zero(). void TString::Zero ; (; ). inlineprivate . Definition at line 264 of file TString.h. Friends And Related Symbol Documentation. ◆ operator+ [1/11]. TString operator+ ; (; char ; c, . const TString & ; s . ). friend . Add string to char. ; Definition at line 1557 of file TString.cxx. ◆ operator+ [2/11]. TString operator+ ; (; const",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:25399,Energy Efficiency,allocate,allocated,25399,"(; Ssiz_t ; nc). Return string capacity. ; If nc != current capacity Clone() the string in a string with the desired capacity. ; Definition at line 442 of file TString.cxx. ◆ Chop(). TString & TString::Chop ; (; ). inline . Definition at line 691 of file TString.h. ◆ Class(). static TClass * TString::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TString::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TString::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 473 of file TString.h. ◆ Clear(). void TString::Clear ; (; ). Clear string without changing its capacity. ; Definition at line 1235 of file TString.cxx. ◆ Clobber(). Ssiz_t TString::Clobber ; (; Ssiz_t ; nc). protected . Clear string and make sure it has a capacity of nc. ; WarningIf nc > MaxSize(), then Fatal() is raised, and only MaxSize() elements are allocated if Fatal does not abort ; ReturnsResulting allocated capacity (after clamping, if needed) ; Definition at line 1246 of file TString.cxx. ◆ Clone(). void TString::Clone ; (; Ssiz_t ; tot). private . Make self a distinct copy with capacity of at least tot, where tot cannot be smaller than the current length. ; Preserve previous contents. WarningIf tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated ; Definition at line 1279 of file TString.cxx. ◆ CompareTo() [1/2]. int TString::CompareTo ; (; const char * ; cs2, . ECaseCompare ; cmp = kExact . ); const. Compare a string to char *cs2. ; Returns returns zero if the two strings are identical, otherwise returns the difference between the first two differing bytes (treated as unsigned char values, so that ‘\200’ is greater than ‘\0’, for example). Zero-length strings are always identical. ; Definition at line 457 of file TString.cxx. ◆ CompareTo() [2/2]. int TString::CompareTo ; (; const TString & ; str, . ECaseCompare ; cmp = kExa",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:25452,Energy Efficiency,allocate,allocated,25452,"(; Ssiz_t ; nc). Return string capacity. ; If nc != current capacity Clone() the string in a string with the desired capacity. ; Definition at line 442 of file TString.cxx. ◆ Chop(). TString & TString::Chop ; (; ). inline . Definition at line 691 of file TString.h. ◆ Class(). static TClass * TString::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TString::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TString::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 473 of file TString.h. ◆ Clear(). void TString::Clear ; (; ). Clear string without changing its capacity. ; Definition at line 1235 of file TString.cxx. ◆ Clobber(). Ssiz_t TString::Clobber ; (; Ssiz_t ; nc). protected . Clear string and make sure it has a capacity of nc. ; WarningIf nc > MaxSize(), then Fatal() is raised, and only MaxSize() elements are allocated if Fatal does not abort ; ReturnsResulting allocated capacity (after clamping, if needed) ; Definition at line 1246 of file TString.cxx. ◆ Clone(). void TString::Clone ; (; Ssiz_t ; tot). private . Make self a distinct copy with capacity of at least tot, where tot cannot be smaller than the current length. ; Preserve previous contents. WarningIf tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated ; Definition at line 1279 of file TString.cxx. ◆ CompareTo() [1/2]. int TString::CompareTo ; (; const char * ; cs2, . ECaseCompare ; cmp = kExact . ); const. Compare a string to char *cs2. ; Returns returns zero if the two strings are identical, otherwise returns the difference between the first two differing bytes (treated as unsigned char values, so that ‘\200’ is greater than ‘\0’, for example). Zero-length strings are always identical. ; Definition at line 457 of file TString.cxx. ◆ CompareTo() [2/2]. int TString::CompareTo ; (; const TString & ; str, . ECaseCompare ; cmp = kExa",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:25829,Energy Efficiency,allocate,allocated,25829,"const char * TString::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TString::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 473 of file TString.h. ◆ Clear(). void TString::Clear ; (; ). Clear string without changing its capacity. ; Definition at line 1235 of file TString.cxx. ◆ Clobber(). Ssiz_t TString::Clobber ; (; Ssiz_t ; nc). protected . Clear string and make sure it has a capacity of nc. ; WarningIf nc > MaxSize(), then Fatal() is raised, and only MaxSize() elements are allocated if Fatal does not abort ; ReturnsResulting allocated capacity (after clamping, if needed) ; Definition at line 1246 of file TString.cxx. ◆ Clone(). void TString::Clone ; (; Ssiz_t ; tot). private . Make self a distinct copy with capacity of at least tot, where tot cannot be smaller than the current length. ; Preserve previous contents. WarningIf tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated ; Definition at line 1279 of file TString.cxx. ◆ CompareTo() [1/2]. int TString::CompareTo ; (; const char * ; cs2, . ECaseCompare ; cmp = kExact . ); const. Compare a string to char *cs2. ; Returns returns zero if the two strings are identical, otherwise returns the difference between the first two differing bytes (treated as unsigned char values, so that ‘\200’ is greater than ‘\0’, for example). Zero-length strings are always identical. ; Definition at line 457 of file TString.cxx. ◆ CompareTo() [2/2]. int TString::CompareTo ; (; const TString & ; str, . ECaseCompare ; cmp = kExact . ); const. Compare a string to another string. ; Returns returns zero if the two strings are identical, otherwise returns the difference between the first two differing bytes (treated as unsigned char values, so that ‘\200’ is greater than ‘\0’, for example). Zero-length strings are always identical. ; Definition at line 487 of file TString.cxx. ◆ Contains() [1/4]. Bool_t TString",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:37120,Energy Efficiency,allocate,allocated,37120,"; s, . Ssiz_t ; patlen, . Ssiz_t ; i, . ECaseCompare ; cmp . ); const. inline . Definition at line 657 of file TString.h. ◆ Index() [7/8]. Ssiz_t TString::Index ; (; TPRegexp & ; r, . Ssiz_t * ; extent, . Ssiz_t ; start = 0 . ); const. Find the first occurrence of the regexp in string and return the position. ; Extent is length of the matched string and start is the offset at which the matching should start. ; Definition at line 628 of file TPRegexp.cxx. ◆ Index() [8/8]. Ssiz_t TString::Index ; (; TPRegexp & ; r, . Ssiz_t ; start = 0 . ); const. Find the first occurrence of the regexp in string and return the position. ; Start is the offset at which the search should start. ; Definition at line 613 of file TPRegexp.cxx. ◆ Init(). char * TString::Init ; (; Ssiz_t ; capacity, . Ssiz_t ; nchar . ). private . Private member function returning an empty string representation of size capacity and containing nchar characters. ; WarningIf nchar > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated ; Definition at line 261 of file TString.cxx. ◆ InitChar(). void TString::InitChar ; (; char ; c). protected . Initialize a string with a single character. ; Definition at line 148 of file TString.cxx. ◆ InitialCapacity(). Ssiz_t TString::InitialCapacity ; (; Ssiz_t ; ic = 15). static . Set default initial capacity for all TStrings. Default is 15. ; Definition at line 1593 of file TString.cxx. ◆ Insert() [1/4]. TString & TString::Insert ; (; Ssiz_t ; pos, . const char * ; s . ). inline . Definition at line 661 of file TString.h. ◆ Insert() [2/4]. TString & TString::Insert ; (; Ssiz_t ; pos, . const char * ; s, . Ssiz_t ; extent . ). inline . Definition at line 664 of file TString.h. ◆ Insert() [3/4]. TString & TString::Insert ; (; Ssiz_t ; pos, . const TString & ; s . ). inline . Definition at line 667 of file TString.h. ◆ Insert() [4/4]. TString & TString::Insert ; (; Ssiz_t ; pos, . const TString & ; s, . Ssiz_t ; extent . ). inline . Definition at line 67",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:41416,Energy Efficiency,adapt,adapted,41416,"xpressed in the base specified (range=2-36), i.e. ; {0,1} for base 2, {0-9,a-f,A-F} for base 16, {0-9,a-z,A-Z} for base 36. Returns false in case string length is 0 or string contains other characters. ; Definition at line 1957 of file TString.cxx. ◆ IsLong(). Bool_t TString::IsLong ; (; ); const. inlineprivate . Definition at line 238 of file TString.h. ◆ IsNull(). Bool_t TString::IsNull ; (; ); const. inline . Definition at line 414 of file TString.h. ◆ IsOct(). Bool_t TString::IsOct ; (; ); const. Returns true if all characters in string are octal digits (0-7). ; Returns false in case string length is 0 or string contains other characters. ; Definition at line 1924 of file TString.cxx. ◆ IsWhitespace(). Bool_t TString::IsWhitespace ; (; ); const. inline . Definition at line 415 of file TString.h. ◆ Itoa(). TString TString::Itoa ; (; Int_t ; value, . Int_t ; base . ). static . Converts an Int_t to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). Usage: the following statement produce the same output, namely ""1111"" std::cout << TString::Itoa(15,2) ;; std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; TString::Itoastatic TString Itoa(Int_t value, Int_t base)Converts an Int_t to a TString with respect to the base specified (2-36).Definition TString.cxx:2092; In case of error returns the ""!"" string. ; Definition at line 2092 of file TString.cxx. ◆ Last(). Ssiz_t TString::Last ; (; char ; c); const. Find last occurrence of a character c. ; Definition at line 931 of file TString.cxx. ◆ Length(). Ssiz_t TString::Length ; (; ); const. inline . Definition at line 417 of file TString.h. ◆ LLtoa(). TString TString::LLtoa ; (; Long64_t ; value, . Int_t ; base . ). static . Converts a Long64_t to a TString with respect to the base specified (2-36). ; Thus it is an enhanced vers",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:42421,Energy Efficiency,adapt,adapted,42421,"intf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). Usage: the following statement produce the same output, namely ""1111"" std::cout << TString::Itoa(15,2) ;; std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; TString::Itoastatic TString Itoa(Int_t value, Int_t base)Converts an Int_t to a TString with respect to the base specified (2-36).Definition TString.cxx:2092; In case of error returns the ""!"" string. ; Definition at line 2092 of file TString.cxx. ◆ Last(). Ssiz_t TString::Last ; (; char ; c); const. Find last occurrence of a character c. ; Definition at line 931 of file TString.cxx. ◆ Length(). Ssiz_t TString::Length ; (; ); const. inline . Definition at line 417 of file TString.h. ◆ LLtoa(). TString TString::LLtoa ; (; Long64_t ; value, . Int_t ; base . ). static . Converts a Long64_t to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2144 of file TString.cxx. ◆ MaxSize(). static Ssiz_t TString::MaxSize ; (; ). inlinestaticprivate . Definition at line 261 of file TString.h. ◆ MaxWaste(). Ssiz_t TString::MaxWaste ; (; Ssiz_t ; mw = 15). static . Set maximum space that may be wasted in a string before doing a resize. ; Default is 15. ; Definition at line 1612 of file TString.cxx. ◆ MaybeRegexp(). Bool_t TString::MaybeRegexp ; (; ); const. Returns true if string contains one of the regexp characters ""^$.[]*+?"". ; Definition at line 952 of file TString.cxx. ◆ MaybeWildcard(). Bool_t TString::MaybeWildcard ; (; ); const. Returns true if string contains one of the wildcard characters ""[]*?"". ; Definition at line 964 of file TString.cxx. ◆ MD5(). TString TString::MD5 ; (; ); const. Return the MD5 digest for this string, in a string representation. ; Definition at line 940 of f",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:56453,Energy Efficiency,adapt,adapted,56453,"oken is found, kFALSE if not or if some inconsistency occurred. This method allows to loop over tokens in this way: TString myl = ""tok1 tok2|tok3"";; TString tok;; Ssiz_t from = 0;; while (myl.Tokenize(tok, from, ""[ |]"")) {; // Analyse tok; ...; }; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; int; more convenient of the other Tokenize method when saving the tokens is not needed. ; Definition at line 310 of file TRegexp.cxx. ◆ ToLower(). void TString::ToLower ; (; ). Change string to lower-case. ; Definition at line 1182 of file TString.cxx. ◆ ToUpper(). void TString::ToUpper ; (; ). Change string to upper case. ; Definition at line 1195 of file TString.cxx. ◆ UItoa(). TString TString::UItoa ; (; UInt_t ; value, . Int_t ; base . ). static . Converts a UInt_t (twice the range of an Int_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2119 of file TString.cxx. ◆ ULLtoa(). TString TString::ULLtoa ; (; ULong64_t ; value, . Int_t ; base . ). static . Converts a ULong64_t (twice the range of an Long64_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2171 of file TString.cxx. ◆ UnLink(). void TString::UnLink ; (; ); const. inlineprivate . Definition at line 263 of file TString.h. ◆ View(). std::string_view TString::View ; (; ); const. inline . Definition at line 452 of file TString.h. ◆ WriteString(). void TString::WriteString ; (; TBuffer & ; b, . const TString * ; a . ). static . Write TString object to buffer. ; Simplified version of TBuffer::WriteObject (does not keep track of mult",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:56861,Energy Efficiency,adapt,adapted,56861,"t; more convenient of the other Tokenize method when saving the tokens is not needed. ; Definition at line 310 of file TRegexp.cxx. ◆ ToLower(). void TString::ToLower ; (; ). Change string to lower-case. ; Definition at line 1182 of file TString.cxx. ◆ ToUpper(). void TString::ToUpper ; (; ). Change string to upper case. ; Definition at line 1195 of file TString.cxx. ◆ UItoa(). TString TString::UItoa ; (; UInt_t ; value, . Int_t ; base . ). static . Converts a UInt_t (twice the range of an Int_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2119 of file TString.cxx. ◆ ULLtoa(). TString TString::ULLtoa ; (; ULong64_t ; value, . Int_t ; base . ). static . Converts a ULong64_t (twice the range of an Long64_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2171 of file TString.cxx. ◆ UnLink(). void TString::UnLink ; (; ); const. inlineprivate . Definition at line 263 of file TString.h. ◆ View(). std::string_view TString::View ; (; ); const. inline . Definition at line 452 of file TString.h. ◆ WriteString(). void TString::WriteString ; (; TBuffer & ; b, . const TString * ; a . ). static . Write TString object to buffer. ; Simplified version of TBuffer::WriteObject (does not keep track of multiple references to the same string). We need to have it here because TBuffer::ReadObject can only handle descendant of TObject ; Definition at line 1428 of file TString.cxx. ◆ Zero(). void TString::Zero ; (; ). inlineprivate . Definition at line 264 of file TString.h. Friends And Related Symbol Documentation. ◆ operator+ [1/11]. TString operator+ ; (; char ; c, . const TString & ; s . ). friend . Add stri",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:33871,Integrability,depend,depending,33871,", . Bool_t ; chop = kTRUE . ). Read one line from the stream, including the \n, or until EOF. ; Remove the trailing [\r]\n if chop is true. Returns kTRUE if data was read. ; Definition at line 204 of file Stringio.cxx. ◆ GetShortPointer() [1/2]. char * TString::GetShortPointer ; (; ). inlineprivate . Definition at line 254 of file TString.h. ◆ GetShortPointer() [2/2]. const char * TString::GetShortPointer ; (; ); const. inlineprivate . Definition at line 255 of file TString.h. ◆ GetShortSize(). Ssiz_t TString::GetShortSize ; (; ); const. inlineprivate . Definition at line 244 of file TString.h. ◆ Hash() [1/2]. UInt_t TString::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). static . Calculates hash index from any char string. ; (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/ . Definition at line 850 of file TString.cxx. ◆ Hash() [2/2]. UInt_t TString::Hash ; (; ECaseCompare ; cmp = kExact); const. Return hash value. ; Definition at line 677 of file TString.cxx. ◆ HashCase(). UInt_t TString::HashCase ; (; ); const. private . Return a case-sensitive hash value (endian independent). ; Definition at line 633 of file TString.cxx. ◆ HashFoldCase(). UInt_t TString::HashFoldCase ; (; ); const. private . Return a case-insensitive hash value (endian independent). ; Definition at line 662 of file TString.cxx. ◆ Index() [1/8]. Ssiz_t TString::Index ; (; const char * ; pat, . Ssiz_t ; i = 0, . ECaseCompare ; cmp = kExact . ); const. inline . Definition at line 651 of file TString.h. ◆ Index() [2/8]. Ssiz_t TString::Index ; (; const char * ; pattern, . Ssiz_t ; plen, . Ssiz_t ; startIndex, . ECaseCompare ; cmp . ); const. Search for a string in the TString. ; Pl",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:41387,Modifiability,enhance,enhanced,41387,"xpressed in the base specified (range=2-36), i.e. ; {0,1} for base 2, {0-9,a-f,A-F} for base 16, {0-9,a-z,A-Z} for base 36. Returns false in case string length is 0 or string contains other characters. ; Definition at line 1957 of file TString.cxx. ◆ IsLong(). Bool_t TString::IsLong ; (; ); const. inlineprivate . Definition at line 238 of file TString.h. ◆ IsNull(). Bool_t TString::IsNull ; (; ); const. inline . Definition at line 414 of file TString.h. ◆ IsOct(). Bool_t TString::IsOct ; (; ); const. Returns true if all characters in string are octal digits (0-7). ; Returns false in case string length is 0 or string contains other characters. ; Definition at line 1924 of file TString.cxx. ◆ IsWhitespace(). Bool_t TString::IsWhitespace ; (; ); const. inline . Definition at line 415 of file TString.h. ◆ Itoa(). TString TString::Itoa ; (; Int_t ; value, . Int_t ; base . ). static . Converts an Int_t to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). Usage: the following statement produce the same output, namely ""1111"" std::cout << TString::Itoa(15,2) ;; std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; TString::Itoastatic TString Itoa(Int_t value, Int_t base)Converts an Int_t to a TString with respect to the base specified (2-36).Definition TString.cxx:2092; In case of error returns the ""!"" string. ; Definition at line 2092 of file TString.cxx. ◆ Last(). Ssiz_t TString::Last ; (; char ; c); const. Find last occurrence of a character c. ; Definition at line 931 of file TString.cxx. ◆ Length(). Ssiz_t TString::Length ; (; ); const. inline . Definition at line 417 of file TString.h. ◆ LLtoa(). TString TString::LLtoa ; (; Long64_t ; value, . Int_t ; base . ). static . Converts a Long64_t to a TString with respect to the base specified (2-36). ; Thus it is an enhanced vers",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:41416,Modifiability,adapt,adapted,41416,"xpressed in the base specified (range=2-36), i.e. ; {0,1} for base 2, {0-9,a-f,A-F} for base 16, {0-9,a-z,A-Z} for base 36. Returns false in case string length is 0 or string contains other characters. ; Definition at line 1957 of file TString.cxx. ◆ IsLong(). Bool_t TString::IsLong ; (; ); const. inlineprivate . Definition at line 238 of file TString.h. ◆ IsNull(). Bool_t TString::IsNull ; (; ); const. inline . Definition at line 414 of file TString.h. ◆ IsOct(). Bool_t TString::IsOct ; (; ); const. Returns true if all characters in string are octal digits (0-7). ; Returns false in case string length is 0 or string contains other characters. ; Definition at line 1924 of file TString.cxx. ◆ IsWhitespace(). Bool_t TString::IsWhitespace ; (; ); const. inline . Definition at line 415 of file TString.h. ◆ Itoa(). TString TString::Itoa ; (; Int_t ; value, . Int_t ; base . ). static . Converts an Int_t to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). Usage: the following statement produce the same output, namely ""1111"" std::cout << TString::Itoa(15,2) ;; std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; TString::Itoastatic TString Itoa(Int_t value, Int_t base)Converts an Int_t to a TString with respect to the base specified (2-36).Definition TString.cxx:2092; In case of error returns the ""!"" string. ; Definition at line 2092 of file TString.cxx. ◆ Last(). Ssiz_t TString::Last ; (; char ; c); const. Find last occurrence of a character c. ; Definition at line 931 of file TString.cxx. ◆ Length(). Ssiz_t TString::Length ; (; ); const. inline . Definition at line 417 of file TString.h. ◆ LLtoa(). TString TString::LLtoa ; (; Long64_t ; value, . Int_t ; base . ). static . Converts a Long64_t to a TString with respect to the base specified (2-36). ; Thus it is an enhanced vers",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:42392,Modifiability,enhance,enhanced,42392,"intf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). Usage: the following statement produce the same output, namely ""1111"" std::cout << TString::Itoa(15,2) ;; std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; TString::Itoastatic TString Itoa(Int_t value, Int_t base)Converts an Int_t to a TString with respect to the base specified (2-36).Definition TString.cxx:2092; In case of error returns the ""!"" string. ; Definition at line 2092 of file TString.cxx. ◆ Last(). Ssiz_t TString::Last ; (; char ; c); const. Find last occurrence of a character c. ; Definition at line 931 of file TString.cxx. ◆ Length(). Ssiz_t TString::Length ; (; ); const. inline . Definition at line 417 of file TString.h. ◆ LLtoa(). TString TString::LLtoa ; (; Long64_t ; value, . Int_t ; base . ). static . Converts a Long64_t to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2144 of file TString.cxx. ◆ MaxSize(). static Ssiz_t TString::MaxSize ; (; ). inlinestaticprivate . Definition at line 261 of file TString.h. ◆ MaxWaste(). Ssiz_t TString::MaxWaste ; (; Ssiz_t ; mw = 15). static . Set maximum space that may be wasted in a string before doing a resize. ; Default is 15. ; Definition at line 1612 of file TString.cxx. ◆ MaybeRegexp(). Bool_t TString::MaybeRegexp ; (; ); const. Returns true if string contains one of the regexp characters ""^$.[]*+?"". ; Definition at line 952 of file TString.cxx. ◆ MaybeWildcard(). Bool_t TString::MaybeWildcard ; (; ); const. Returns true if string contains one of the wildcard characters ""[]*?"". ; Definition at line 964 of file TString.cxx. ◆ MD5(). TString TString::MD5 ; (; ); const. Return the MD5 digest for this string, in a string representation. ; Definition at line 940 of f",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:42421,Modifiability,adapt,adapted,42421,"intf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). Usage: the following statement produce the same output, namely ""1111"" std::cout << TString::Itoa(15,2) ;; std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; TString::Itoastatic TString Itoa(Int_t value, Int_t base)Converts an Int_t to a TString with respect to the base specified (2-36).Definition TString.cxx:2092; In case of error returns the ""!"" string. ; Definition at line 2092 of file TString.cxx. ◆ Last(). Ssiz_t TString::Last ; (; char ; c); const. Find last occurrence of a character c. ; Definition at line 931 of file TString.cxx. ◆ Length(). Ssiz_t TString::Length ; (; ); const. inline . Definition at line 417 of file TString.h. ◆ LLtoa(). TString TString::LLtoa ; (; Long64_t ; value, . Int_t ; base . ). static . Converts a Long64_t to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2144 of file TString.cxx. ◆ MaxSize(). static Ssiz_t TString::MaxSize ; (; ). inlinestaticprivate . Definition at line 261 of file TString.h. ◆ MaxWaste(). Ssiz_t TString::MaxWaste ; (; Ssiz_t ; mw = 15). static . Set maximum space that may be wasted in a string before doing a resize. ; Default is 15. ; Definition at line 1612 of file TString.cxx. ◆ MaybeRegexp(). Bool_t TString::MaybeRegexp ; (; ); const. Returns true if string contains one of the regexp characters ""^$.[]*+?"". ; Definition at line 952 of file TString.cxx. ◆ MaybeWildcard(). Bool_t TString::MaybeWildcard ; (; ); const. Returns true if string contains one of the wildcard characters ""[]*?"". ; Definition at line 964 of file TString.cxx. ◆ MD5(). TString TString::MD5 ; (; ); const. Return the MD5 digest for this string, in a string representation. ; Definition at line 940 of f",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:56424,Modifiability,enhance,enhanced,56424,"oken is found, kFALSE if not or if some inconsistency occurred. This method allows to loop over tokens in this way: TString myl = ""tok1 tok2|tok3"";; TString tok;; Ssiz_t from = 0;; while (myl.Tokenize(tok, from, ""[ |]"")) {; // Analyse tok; ...; }; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; int; more convenient of the other Tokenize method when saving the tokens is not needed. ; Definition at line 310 of file TRegexp.cxx. ◆ ToLower(). void TString::ToLower ; (; ). Change string to lower-case. ; Definition at line 1182 of file TString.cxx. ◆ ToUpper(). void TString::ToUpper ; (; ). Change string to upper case. ; Definition at line 1195 of file TString.cxx. ◆ UItoa(). TString TString::UItoa ; (; UInt_t ; value, . Int_t ; base . ). static . Converts a UInt_t (twice the range of an Int_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2119 of file TString.cxx. ◆ ULLtoa(). TString TString::ULLtoa ; (; ULong64_t ; value, . Int_t ; base . ). static . Converts a ULong64_t (twice the range of an Long64_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2171 of file TString.cxx. ◆ UnLink(). void TString::UnLink ; (; ); const. inlineprivate . Definition at line 263 of file TString.h. ◆ View(). std::string_view TString::View ; (; ); const. inline . Definition at line 452 of file TString.h. ◆ WriteString(). void TString::WriteString ; (; TBuffer & ; b, . const TString * ; a . ). static . Write TString object to buffer. ; Simplified version of TBuffer::WriteObject (does not keep track of mult",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:56453,Modifiability,adapt,adapted,56453,"oken is found, kFALSE if not or if some inconsistency occurred. This method allows to loop over tokens in this way: TString myl = ""tok1 tok2|tok3"";; TString tok;; Ssiz_t from = 0;; while (myl.Tokenize(tok, from, ""[ |]"")) {; // Analyse tok; ...; }; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; int; more convenient of the other Tokenize method when saving the tokens is not needed. ; Definition at line 310 of file TRegexp.cxx. ◆ ToLower(). void TString::ToLower ; (; ). Change string to lower-case. ; Definition at line 1182 of file TString.cxx. ◆ ToUpper(). void TString::ToUpper ; (; ). Change string to upper case. ; Definition at line 1195 of file TString.cxx. ◆ UItoa(). TString TString::UItoa ; (; UInt_t ; value, . Int_t ; base . ). static . Converts a UInt_t (twice the range of an Int_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2119 of file TString.cxx. ◆ ULLtoa(). TString TString::ULLtoa ; (; ULong64_t ; value, . Int_t ; base . ). static . Converts a ULong64_t (twice the range of an Long64_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2171 of file TString.cxx. ◆ UnLink(). void TString::UnLink ; (; ); const. inlineprivate . Definition at line 263 of file TString.h. ◆ View(). std::string_view TString::View ; (; ); const. inline . Definition at line 452 of file TString.h. ◆ WriteString(). void TString::WriteString ; (; TBuffer & ; b, . const TString * ; a . ). static . Write TString object to buffer. ; Simplified version of TBuffer::WriteObject (does not keep track of mult",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:56832,Modifiability,enhance,enhanced,56832,"t; more convenient of the other Tokenize method when saving the tokens is not needed. ; Definition at line 310 of file TRegexp.cxx. ◆ ToLower(). void TString::ToLower ; (; ). Change string to lower-case. ; Definition at line 1182 of file TString.cxx. ◆ ToUpper(). void TString::ToUpper ; (; ). Change string to upper case. ; Definition at line 1195 of file TString.cxx. ◆ UItoa(). TString TString::UItoa ; (; UInt_t ; value, . Int_t ; base . ). static . Converts a UInt_t (twice the range of an Int_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2119 of file TString.cxx. ◆ ULLtoa(). TString TString::ULLtoa ; (; ULong64_t ; value, . Int_t ; base . ). static . Converts a ULong64_t (twice the range of an Long64_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2171 of file TString.cxx. ◆ UnLink(). void TString::UnLink ; (; ); const. inlineprivate . Definition at line 263 of file TString.h. ◆ View(). std::string_view TString::View ; (; ); const. inline . Definition at line 452 of file TString.h. ◆ WriteString(). void TString::WriteString ; (; TBuffer & ; b, . const TString * ; a . ). static . Write TString object to buffer. ; Simplified version of TBuffer::WriteObject (does not keep track of multiple references to the same string). We need to have it here because TBuffer::ReadObject can only handle descendant of TObject ; Definition at line 1428 of file TString.cxx. ◆ Zero(). void TString::Zero ; (; ). inlineprivate . Definition at line 264 of file TString.h. Friends And Related Symbol Documentation. ◆ operator+ [1/11]. TString operator+ ; (; char ; c, . const TString & ; s . ). friend . Add stri",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:56861,Modifiability,adapt,adapted,56861,"t; more convenient of the other Tokenize method when saving the tokens is not needed. ; Definition at line 310 of file TRegexp.cxx. ◆ ToLower(). void TString::ToLower ; (; ). Change string to lower-case. ; Definition at line 1182 of file TString.cxx. ◆ ToUpper(). void TString::ToUpper ; (; ). Change string to upper case. ; Definition at line 1195 of file TString.cxx. ◆ UItoa(). TString TString::UItoa ; (; UInt_t ; value, . Int_t ; base . ). static . Converts a UInt_t (twice the range of an Int_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2119 of file TString.cxx. ◆ ULLtoa(). TString TString::ULLtoa ; (; ULong64_t ; value, . Int_t ; base . ). static . Converts a ULong64_t (twice the range of an Long64_t) to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). In case of error returns the ""!"" string. ; Definition at line 2171 of file TString.cxx. ◆ UnLink(). void TString::UnLink ; (; ); const. inlineprivate . Definition at line 263 of file TString.h. ◆ View(). std::string_view TString::View ; (; ); const. inline . Definition at line 452 of file TString.h. ◆ WriteString(). void TString::WriteString ; (; TBuffer & ; b, . const TString * ; a . ). static . Write TString object to buffer. ; Simplified version of TBuffer::WriteObject (does not keep track of multiple references to the same string). We need to have it here because TBuffer::ReadObject can only handle descendant of TObject ; Definition at line 1428 of file TString.cxx. ◆ Zero(). void TString::Zero ; (; ). inlineprivate . Definition at line 264 of file TString.h. Friends And Related Symbol Documentation. ◆ operator+ [1/11]. TString operator+ ; (; char ; c, . const TString & ; s . ). friend . Add stri",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:25427,Safety,abort,abort,25427,"(; Ssiz_t ; nc). Return string capacity. ; If nc != current capacity Clone() the string in a string with the desired capacity. ; Definition at line 442 of file TString.cxx. ◆ Chop(). TString & TString::Chop ; (; ). inline . Definition at line 691 of file TString.h. ◆ Class(). static TClass * TString::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TString::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TString::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 473 of file TString.h. ◆ Clear(). void TString::Clear ; (; ). Clear string without changing its capacity. ; Definition at line 1235 of file TString.cxx. ◆ Clobber(). Ssiz_t TString::Clobber ; (; Ssiz_t ; nc). protected . Clear string and make sure it has a capacity of nc. ; WarningIf nc > MaxSize(), then Fatal() is raised, and only MaxSize() elements are allocated if Fatal does not abort ; ReturnsResulting allocated capacity (after clamping, if needed) ; Definition at line 1246 of file TString.cxx. ◆ Clone(). void TString::Clone ; (; Ssiz_t ; tot). private . Make self a distinct copy with capacity of at least tot, where tot cannot be smaller than the current length. ; Preserve previous contents. WarningIf tot > MaxSize(), then Fatal() is raised and only MaxSize() elements are allocated ; Definition at line 1279 of file TString.cxx. ◆ CompareTo() [1/2]. int TString::CompareTo ; (; const char * ; cs2, . ECaseCompare ; cmp = kExact . ); const. Compare a string to char *cs2. ; Returns returns zero if the two strings are identical, otherwise returns the difference between the first two differing bytes (treated as unsigned char values, so that ‘\200’ is greater than ‘\0’, for example). Zero-length strings are always identical. ; Definition at line 457 of file TString.cxx. ◆ CompareTo() [2/2]. int TString::CompareTo ; (; const TString & ; str, . ECaseCompare ; cmp = kExa",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:678,Security,access,accessed,678,". ROOT: TString Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Static Public Attributes |; Protected Types |; Protected Member Functions |; Static Protected Member Functions |; Protected Attributes |; Private Types |; Private Member Functions |; Static Private Member Functions |; Friends |; List of all members ; TString Class ReferenceCore ROOT classes » Base ROOT classes. ; Basic string class. ; Cannot be stored in a TCollection... use TObjString instead.; The underlying string is stored as a char* that can be accessed via TString::Data(). TString provides Short String Optimization (SSO) so that short strings (<15 on 64-bit and <11 on 32-bit) are contained in the TString internal data structure without the need for mallocing the required space.; Substring operations are provided by the TSubString class, which holds a reference to the original string and its data, along with the offset and length of the substring. To retrieve the substring as a TString, construct a TString from it, eg: root [0] TString s(""hello world""); root [1] TString s2( s(0,5) ); root [2] s2; (class TString)""hello""; hellostd::string hello(std::string who, std::string msg)Definition FunModule.C:5; TStringBasic string class.Definition TString.h:139. Definition at line 139 of file TString.h. Classes; struct  LongStr_t;  ; struct  RawStr_t;  ; struct  Rep_t;  ; struct  ShortStr_t;  ; union  UStr_t;  . Public Types; enum  ECaseCompare { kExact; , kIgnoreCase; };  ; enum  EStripType { kLeading = 0x1; , kTrailing = 0x2; , kBoth = 0x3; };  ; using size_type = Ssiz_t;  . Public Member Functions;  TString ();  TString default ctor. ;  ;  TString (char c);  Initialize a string with a single character. ;  ;  TString (char c, Ssiz_t s);  Initialize the first n locations of a TString with character c. ;  ;  TString (const char *s);  Create TString and ",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:4836,Security,hash,hash,4836,"g &pat, ECaseCompare cmp=kExact) const;  ; Bool_t Contains (TPRegexp &pat) const;  ; TString Copy () const;  Copy a string. ;  ; Int_t CountChar (Int_t c) const;  Return number of times character c occurs in the string. ;  ; const char * Data () const;  ; Bool_t EndsWith (const char *pat, ECaseCompare cmp=kExact) const;  Return true if string ends with the specified string. ;  ; Bool_t EqualTo (const char *cs, ECaseCompare cmp=kExact) const;  ; Bool_t EqualTo (const TString &st, ECaseCompare cmp=kExact) const;  ; virtual void FillBuffer (char *&buffer) const;  Copy string into I/O buffer. ;  ; Ssiz_t First (char c) const;  Find first occurrence of a character c. ;  ; Ssiz_t First (const char *cs) const;  Find first occurrence of a character in cs. ;  ; void Form (const char *fmt,...);  Formats a string using a printf style format descriptor. ;  ; Bool_t Gets (FILE *fp, Bool_t chop=kTRUE);  Read one line from the stream, including the \n, or until EOF. ;  ; UInt_t Hash (ECaseCompare cmp=kExact) const;  Return hash value. ;  ; Ssiz_t Index (const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) const;  ; Ssiz_t Index (const char *pat, Ssiz_t patlen, Ssiz_t i, ECaseCompare cmp) const;  Search for a string in the TString. ;  ; Ssiz_t Index (const TRegexp &pat, Ssiz_t *ext, Ssiz_t i=0) const;  Find the first occurrence of the regexp in string and return the position, or -1 if there is no match. ;  ; Ssiz_t Index (const TRegexp &pat, Ssiz_t i=0) const;  Find the first occurrence of the regexp in string and return the position, or -1 if there is no match. ;  ; Ssiz_t Index (const TString &s, Ssiz_t i=0, ECaseCompare cmp=kExact) const;  ; Ssiz_t Index (const TString &s, Ssiz_t patlen, Ssiz_t i, ECaseCompare cmp) const;  ; Ssiz_t Index (TPRegexp &pat, Ssiz_t *ext, Ssiz_t i=0) const;  Find the first occurrence of the regexp in string and return the position. ;  ; Ssiz_t Index (TPRegexp &pat, Ssiz_t i=0) const;  Find the first occurrence of the regexp in string and return the p",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:13329,Security,hash,hash,13329," is used to isolate sequential tokens in a TString. ;  ; Bool_t Tokenize (TString &tok, Ssiz_t &from, const char *delim="" "") const;  Search for tokens delimited by regular expression 'delim' (default "" "") in this string; search starts at 'from' and the token is returned in 'tok'. ;  ; void ToLower ();  Change string to lower-case. ;  ; void ToUpper ();  Change string to upper case. ;  ; std::string_view View () const;  . Static Public Member Functions; static TString BaseConvert (const TString &s_in, Int_t base_in, Int_t base_out);  Converts string from base base_in to base base_out. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TString Format (const char *fmt,...);  Static method which formats a string using a printf style format descriptor and return a TString. ;  ; static Ssiz_t GetInitialCapacity ();  ; static Ssiz_t GetMaxWaste ();  ; static Ssiz_t GetResizeIncrement ();  ; static UInt_t Hash (const void *txt, Int_t ntxt);  Calculates hash index from any char string. ;  ; static Ssiz_t InitialCapacity (Ssiz_t ic=15);  Set default initial capacity for all TStrings. Default is 15. ;  ; static TString Itoa (Int_t value, Int_t base);  Converts an Int_t to a TString with respect to the base specified (2-36). ;  ; static TString LLtoa (Long64_t value, Int_t base);  Converts a Long64_t to a TString with respect to the base specified (2-36). ;  ; static Ssiz_t MaxWaste (Ssiz_t mw=15);  Set maximum space that may be wasted in a string before doing a resize. ;  ; static TString * ReadString (TBuffer &b, const TClass *clReq);  Read TString object from buffer. ;  ; static Ssiz_t ResizeIncrement (Ssiz_t ri=16);  Set default resize increment for all TStrings. Default is 16. ;  ; static TString UItoa (UInt_t value, Int_t base);  Converts a UInt_t (twice the range of an Int_t) to a TString with respect to the base specified (2-36). ;  ; static TString ULLtoa ",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:16016,Security,hash,hash,16016,"tring and make sure it has a capacity of nc. ;  ; void InitChar (char c);  Initialize a string with a single character. ;  . Static Protected Member Functions; static Ssiz_t AdjustCapacity (Ssiz_t oldCap, Ssiz_t newCap);  Calculate a nice capacity greater than or equal to newCap. ;  ; static Ssiz_t Align (Ssiz_t s);  ; static Ssiz_t Recommend (Ssiz_t s);  . Protected Attributes; Rep_t fRep;  . Private Types; enum  { kShortMask = 0x80; , kLongMask = 0x80000000; };  ; enum  ;  ; enum  { kNwords = sizeof(UStr_t) / sizeof(Ssiz_t); };  . Private Member Functions; void Clone (Ssiz_t nc);  Make self a distinct copy with capacity of at least tot, where tot cannot be smaller than the current length. ;  ; void FormImp (const char *fmt, va_list ap);  Formats a string using a printf style format descriptor. ;  ; Ssiz_t GetLongCap () const;  ; char * GetLongPointer ();  ; const char * GetLongPointer () const;  ; Ssiz_t GetLongSize () const;  ; char * GetPointer ();  ; const char * GetPointer () const;  ; char * GetShortPointer ();  ; const char * GetShortPointer () const;  ; Ssiz_t GetShortSize () const;  ; UInt_t HashCase () const;  Return a case-sensitive hash value (endian independent). ;  ; UInt_t HashFoldCase () const;  Return a case-insensitive hash value (endian independent). ;  ; char * Init (Ssiz_t capacity, Ssiz_t nchar);  Private member function returning an empty string representation of size capacity and containing nchar characters. ;  ; Bool_t IsLong () const;  ; void SetLongCap (Ssiz_t s);  ; void SetLongPointer (char *p);  ; void SetLongSize (Ssiz_t s);  ; void SetShortSize (Ssiz_t s);  ; void SetSize (Ssiz_t s);  ; void UnLink () const;  ; void Zero ();  . Static Private Member Functions; static Ssiz_t MaxSize ();  . Friends; TString operator+ (char c, const TString &s);  Add string to char. ;  ; TString operator+ (const char *cs, const TString &s);  Use the special concatenation constructor. ;  ; TString operator+ (const TString &s, char c);  Add char to string.",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:16111,Security,hash,hash,16111,"acity greater than or equal to newCap. ;  ; static Ssiz_t Align (Ssiz_t s);  ; static Ssiz_t Recommend (Ssiz_t s);  . Protected Attributes; Rep_t fRep;  . Private Types; enum  { kShortMask = 0x80; , kLongMask = 0x80000000; };  ; enum  ;  ; enum  { kNwords = sizeof(UStr_t) / sizeof(Ssiz_t); };  . Private Member Functions; void Clone (Ssiz_t nc);  Make self a distinct copy with capacity of at least tot, where tot cannot be smaller than the current length. ;  ; void FormImp (const char *fmt, va_list ap);  Formats a string using a printf style format descriptor. ;  ; Ssiz_t GetLongCap () const;  ; char * GetLongPointer ();  ; const char * GetLongPointer () const;  ; Ssiz_t GetLongSize () const;  ; char * GetPointer ();  ; const char * GetPointer () const;  ; char * GetShortPointer ();  ; const char * GetShortPointer () const;  ; Ssiz_t GetShortSize () const;  ; UInt_t HashCase () const;  Return a case-sensitive hash value (endian independent). ;  ; UInt_t HashFoldCase () const;  Return a case-insensitive hash value (endian independent). ;  ; char * Init (Ssiz_t capacity, Ssiz_t nchar);  Private member function returning an empty string representation of size capacity and containing nchar characters. ;  ; Bool_t IsLong () const;  ; void SetLongCap (Ssiz_t s);  ; void SetLongPointer (char *p);  ; void SetLongSize (Ssiz_t s);  ; void SetShortSize (Ssiz_t s);  ; void SetSize (Ssiz_t s);  ; void UnLink () const;  ; void Zero ();  . Static Private Member Functions; static Ssiz_t MaxSize ();  . Friends; TString operator+ (char c, const TString &s);  Add string to char. ;  ; TString operator+ (const char *cs, const TString &s);  Use the special concatenation constructor. ;  ; TString operator+ (const TString &s, char c);  Add char to string. ;  ; TString operator+ (const TString &s, const char *cs);  Use the special concatenation constructor. ;  ; TString operator+ (const TString &s1, const TString &s2);  Use the special concatenation constructor. ;  ; template<class T > ; std::",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:33618,Security,hash,hash,33618,"er() [2/2]. const char * TString::GetPointer ; (; ); const. inlineprivate . Definition at line 257 of file TString.h. ◆ GetResizeIncrement(). Ssiz_t TString::GetResizeIncrement ; (; ). static . Definition at line 1576 of file TString.cxx. ◆ Gets(). Bool_t TString::Gets ; (; FILE * ; fp, . Bool_t ; chop = kTRUE . ). Read one line from the stream, including the \n, or until EOF. ; Remove the trailing [\r]\n if chop is true. Returns kTRUE if data was read. ; Definition at line 204 of file Stringio.cxx. ◆ GetShortPointer() [1/2]. char * TString::GetShortPointer ; (; ). inlineprivate . Definition at line 254 of file TString.h. ◆ GetShortPointer() [2/2]. const char * TString::GetShortPointer ; (; ); const. inlineprivate . Definition at line 255 of file TString.h. ◆ GetShortSize(). Ssiz_t TString::GetShortSize ; (; ); const. inlineprivate . Definition at line 244 of file TString.h. ◆ Hash() [1/2]. UInt_t TString::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). static . Calculates hash index from any char string. ; (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/ . Definition at line 850 of file TString.cxx. ◆ Hash() [2/2]. UInt_t TString::Hash ; (; ECaseCompare ; cmp = kExact); const. Return hash value. ; Definition at line 677 of file TString.cxx. ◆ HashCase(). UInt_t TString::HashCase ; (; ); const. private . Return a case-sensitive hash value (endian independent). ; Definition at line 633 of file TString.cxx. ◆ HashFoldCase(). UInt_t TString::HashFoldCase ; (; ); const. private . Return a case-insensitive hash value (endian independent). ; Definition at line 662 of file TString.cxx. ◆ Index() [1/8]. Ssiz_t TString::Index ; (; const char * ; pat, . Ssiz",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:33855,Security,hash,hash,33855,", . Bool_t ; chop = kTRUE . ). Read one line from the stream, including the \n, or until EOF. ; Remove the trailing [\r]\n if chop is true. Returns kTRUE if data was read. ; Definition at line 204 of file Stringio.cxx. ◆ GetShortPointer() [1/2]. char * TString::GetShortPointer ; (; ). inlineprivate . Definition at line 254 of file TString.h. ◆ GetShortPointer() [2/2]. const char * TString::GetShortPointer ; (; ); const. inlineprivate . Definition at line 255 of file TString.h. ◆ GetShortSize(). Ssiz_t TString::GetShortSize ; (; ); const. inlineprivate . Definition at line 244 of file TString.h. ◆ Hash() [1/2]. UInt_t TString::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). static . Calculates hash index from any char string. ; (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/ . Definition at line 850 of file TString.cxx. ◆ Hash() [2/2]. UInt_t TString::Hash ; (; ECaseCompare ; cmp = kExact); const. Return hash value. ; Definition at line 677 of file TString.cxx. ◆ HashCase(). UInt_t TString::HashCase ; (; ); const. private . Return a case-sensitive hash value (endian independent). ; Definition at line 633 of file TString.cxx. ◆ HashFoldCase(). UInt_t TString::HashFoldCase ; (; ); const. private . Return a case-insensitive hash value (endian independent). ; Definition at line 662 of file TString.cxx. ◆ Index() [1/8]. Ssiz_t TString::Index ; (; const char * ; pat, . Ssiz_t ; i = 0, . ECaseCompare ; cmp = kExact . ); const. inline . Definition at line 651 of file TString.h. ◆ Index() [2/8]. Ssiz_t TString::Index ; (; const char * ; pattern, . Ssiz_t ; plen, . Ssiz_t ; startIndex, . ECaseCompare ; cmp . ); const. Search for a string in the TString. ; Pl",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:33955,Security,hash,hashes,33955,", . Bool_t ; chop = kTRUE . ). Read one line from the stream, including the \n, or until EOF. ; Remove the trailing [\r]\n if chop is true. Returns kTRUE if data was read. ; Definition at line 204 of file Stringio.cxx. ◆ GetShortPointer() [1/2]. char * TString::GetShortPointer ; (; ). inlineprivate . Definition at line 254 of file TString.h. ◆ GetShortPointer() [2/2]. const char * TString::GetShortPointer ; (; ); const. inlineprivate . Definition at line 255 of file TString.h. ◆ GetShortSize(). Ssiz_t TString::GetShortSize ; (; ); const. inlineprivate . Definition at line 244 of file TString.h. ◆ Hash() [1/2]. UInt_t TString::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). static . Calculates hash index from any char string. ; (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/ . Definition at line 850 of file TString.cxx. ◆ Hash() [2/2]. UInt_t TString::Hash ; (; ECaseCompare ; cmp = kExact); const. Return hash value. ; Definition at line 677 of file TString.cxx. ◆ HashCase(). UInt_t TString::HashCase ; (; ); const. private . Return a case-sensitive hash value (endian independent). ; Definition at line 633 of file TString.cxx. ◆ HashFoldCase(). UInt_t TString::HashFoldCase ; (; ); const. private . Return a case-insensitive hash value (endian independent). ; Definition at line 662 of file TString.cxx. ◆ Index() [1/8]. Ssiz_t TString::Index ; (; const char * ; pat, . Ssiz_t ; i = 0, . ECaseCompare ; cmp = kExact . ); const. inline . Definition at line 651 of file TString.h. ◆ Index() [2/8]. Ssiz_t TString::Index ; (; const char * ; pattern, . Ssiz_t ; plen, . Ssiz_t ; startIndex, . ECaseCompare ; cmp . ); const. Search for a string in the TString. ; Pl",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:34156,Security,hash,hash,34156,"]. char * TString::GetShortPointer ; (; ). inlineprivate . Definition at line 254 of file TString.h. ◆ GetShortPointer() [2/2]. const char * TString::GetShortPointer ; (; ); const. inlineprivate . Definition at line 255 of file TString.h. ◆ GetShortSize(). Ssiz_t TString::GetShortSize ; (; ); const. inlineprivate . Definition at line 244 of file TString.h. ◆ Hash() [1/2]. UInt_t TString::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). static . Calculates hash index from any char string. ; (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/ . Definition at line 850 of file TString.cxx. ◆ Hash() [2/2]. UInt_t TString::Hash ; (; ECaseCompare ; cmp = kExact); const. Return hash value. ; Definition at line 677 of file TString.cxx. ◆ HashCase(). UInt_t TString::HashCase ; (; ); const. private . Return a case-sensitive hash value (endian independent). ; Definition at line 633 of file TString.cxx. ◆ HashFoldCase(). UInt_t TString::HashFoldCase ; (; ); const. private . Return a case-insensitive hash value (endian independent). ; Definition at line 662 of file TString.cxx. ◆ Index() [1/8]. Ssiz_t TString::Index ; (; const char * ; pat, . Ssiz_t ; i = 0, . ECaseCompare ; cmp = kExact . ); const. inline . Definition at line 651 of file TString.h. ◆ Index() [2/8]. Ssiz_t TString::Index ; (; const char * ; pattern, . Ssiz_t ; plen, . Ssiz_t ; startIndex, . ECaseCompare ; cmp . ); const. Search for a string in the TString. ; Plen is the length of pattern, startIndex is the index from which to start and cmp selects the type of case-comparison. ; Definition at line 901 of file TString.cxx. ◆ Index() [3/8]. Ssiz_t TString::Index ; (; const TRegexp & ; r, . Ssiz_t * ; ex",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:34302,Security,hash,hash,34302,"::GetShortPointer ; (; ); const. inlineprivate . Definition at line 255 of file TString.h. ◆ GetShortSize(). Ssiz_t TString::GetShortSize ; (; ); const. inlineprivate . Definition at line 244 of file TString.h. ◆ Hash() [1/2]. UInt_t TString::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). static . Calculates hash index from any char string. ; (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/ . Definition at line 850 of file TString.cxx. ◆ Hash() [2/2]. UInt_t TString::Hash ; (; ECaseCompare ; cmp = kExact); const. Return hash value. ; Definition at line 677 of file TString.cxx. ◆ HashCase(). UInt_t TString::HashCase ; (; ); const. private . Return a case-sensitive hash value (endian independent). ; Definition at line 633 of file TString.cxx. ◆ HashFoldCase(). UInt_t TString::HashFoldCase ; (; ); const. private . Return a case-insensitive hash value (endian independent). ; Definition at line 662 of file TString.cxx. ◆ Index() [1/8]. Ssiz_t TString::Index ; (; const char * ; pat, . Ssiz_t ; i = 0, . ECaseCompare ; cmp = kExact . ); const. inline . Definition at line 651 of file TString.h. ◆ Index() [2/8]. Ssiz_t TString::Index ; (; const char * ; pattern, . Ssiz_t ; plen, . Ssiz_t ; startIndex, . ECaseCompare ; cmp . ); const. Search for a string in the TString. ; Plen is the length of pattern, startIndex is the index from which to start and cmp selects the type of case-comparison. ; Definition at line 901 of file TString.cxx. ◆ Index() [3/8]. Ssiz_t TString::Index ; (; const TRegexp & ; r, . Ssiz_t * ; extent, . Ssiz_t ; start = 0 . ); const. Find the first occurrence of the regexp in string and return the position, or -1 if there is no match. ; Exte",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:34479,Security,hash,hash,34479,"ion at line 244 of file TString.h. ◆ Hash() [1/2]. UInt_t TString::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). static . Calculates hash index from any char string. ; (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/ . Definition at line 850 of file TString.cxx. ◆ Hash() [2/2]. UInt_t TString::Hash ; (; ECaseCompare ; cmp = kExact); const. Return hash value. ; Definition at line 677 of file TString.cxx. ◆ HashCase(). UInt_t TString::HashCase ; (; ); const. private . Return a case-sensitive hash value (endian independent). ; Definition at line 633 of file TString.cxx. ◆ HashFoldCase(). UInt_t TString::HashFoldCase ; (; ); const. private . Return a case-insensitive hash value (endian independent). ; Definition at line 662 of file TString.cxx. ◆ Index() [1/8]. Ssiz_t TString::Index ; (; const char * ; pat, . Ssiz_t ; i = 0, . ECaseCompare ; cmp = kExact . ); const. inline . Definition at line 651 of file TString.h. ◆ Index() [2/8]. Ssiz_t TString::Index ; (; const char * ; pattern, . Ssiz_t ; plen, . Ssiz_t ; startIndex, . ECaseCompare ; cmp . ); const. Search for a string in the TString. ; Plen is the length of pattern, startIndex is the index from which to start and cmp selects the type of case-comparison. ; Definition at line 901 of file TString.cxx. ◆ Index() [3/8]. Ssiz_t TString::Index ; (; const TRegexp & ; r, . Ssiz_t * ; extent, . Ssiz_t ; start = 0 . ); const. Find the first occurrence of the regexp in string and return the position, or -1 if there is no match. ; Extent is length of the matched string and start is the offset at which the matching should start. Please, see the Warning in the class documentation above. ; Definition at line 26",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTString.html:33916,Usability,simpl,simple,33916,", . Bool_t ; chop = kTRUE . ). Read one line from the stream, including the \n, or until EOF. ; Remove the trailing [\r]\n if chop is true. Returns kTRUE if data was read. ; Definition at line 204 of file Stringio.cxx. ◆ GetShortPointer() [1/2]. char * TString::GetShortPointer ; (; ). inlineprivate . Definition at line 254 of file TString.h. ◆ GetShortPointer() [2/2]. const char * TString::GetShortPointer ; (; ); const. inlineprivate . Definition at line 255 of file TString.h. ◆ GetShortSize(). Ssiz_t TString::GetShortSize ; (; ); const. inlineprivate . Definition at line 244 of file TString.h. ◆ Hash() [1/2]. UInt_t TString::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). static . Calculates hash index from any char string. ; (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/ . Definition at line 850 of file TString.cxx. ◆ Hash() [2/2]. UInt_t TString::Hash ; (; ECaseCompare ; cmp = kExact); const. Return hash value. ; Definition at line 677 of file TString.cxx. ◆ HashCase(). UInt_t TString::HashCase ; (; ); const. private . Return a case-sensitive hash value (endian independent). ; Definition at line 633 of file TString.cxx. ◆ HashFoldCase(). UInt_t TString::HashFoldCase ; (; ); const. private . Return a case-insensitive hash value (endian independent). ; Definition at line 662 of file TString.cxx. ◆ Index() [1/8]. Ssiz_t TString::Index ; (; const char * ; pat, . Ssiz_t ; i = 0, . ECaseCompare ; cmp = kExact . ); const. inline . Definition at line 651 of file TString.h. ◆ Index() [2/8]. Ssiz_t TString::Index ; (; const char * ; pattern, . Ssiz_t ; plen, . Ssiz_t ; startIndex, . ECaseCompare ; cmp . ); const. Search for a string in the TString. ; Pl",MatchSource.WIKI,doc/v632/classTString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTString.html
https://root.cern/doc/v632/classTTree.html:7363,Availability,avail,available,7363,"ress before filling the branch again. This is done via the TBranch::SetAddress member function. Add a column holding objects; MyClass object;; auto branch = tree.Branch(branchname, &object, bufsize, splitlevel); object; Note: The 2nd parameter must be the address of a valid object. The object must not be destroyed (i.e. be deleted) until the TTree is deleted or TTree::ResetBranchAddress is called. if splitlevel=0, the object is serialized in the branch buffer.; if splitlevel=1 (default), this branch will automatically be split into subbranches, with one subbranch for each data member or object of the object itself. In case the object member is a TClonesArray, the mechanism described in case C is applied to this array.; if splitlevel=2 ,this branch will automatically be split into subbranches, with one subbranch for each data member or object of the object itself. In case the object member is a TClonesArray, it is processed as a TObject*, only one branch. Another available syntax is the following:; auto branch = tree.Branch(branchname, &p_object, bufsize, splitlevel); auto branch = tree.Branch(branchname, className, &p_object, bufsize, splitlevel). p_object is a pointer to an object.; If className is not specified, Branch uses the type of p_object to determine the type of the object.; If className is used to specify explicitly the object type, the className must be of a type related to the one pointed to by the pointer. It should be either a parent or derived class. Note: The pointer whose address is passed to TTree::Branch must not be destroyed (i.e. go out of scope) until the TTree is deleted or TTree::ResetBranchAddress is called.; Note: The pointer p_object must be initialized before calling TTree::Branch; Do either: MyDataClass* p_object = nullptr;; tree.Branch(branchname, &p_object);. Or: auto p_object = new MyDataClass;; tree.Branch(branchname, &p_object);; Whether the pointer is set to zero or not, the ownership of the object is not taken over by the TTree. I",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:14864,Availability,avail,available,14864,"e.Print();; ; // Save all objects in this file; hfile.Write();; ; // Close the file. Note that this is automatically done when you leave; // the application upon file destruction.; hfile.Close();; ; return 0;; }; mainint main()Definition Prototype.cxx:12; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; TFile.h; TH1.h; TH2.h; TProfile.h; TRandom.h; TTree.h; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:621; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TProfileProfile Histogram.Definition TProfile.h:32; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169. PyROOT; The TTree class has several additions for its use from Python, which are also available in its subclasses e.g. TChain and TNtuple.; First, TTree instances are iterable in Python. Therefore, assuming t is a TTree instance, we can do: for entry in t:; x = entry.branch_name; ...; At each iteration, a new entry of the tree will be read. In the code above, entry allows to access the branch values for the current entry. This can be done with the syntax entry.branch_name or, if the branch name is incompatible with Python naming rules, with e.g. ""getattr(entry, '1_branch_name')"".; Please note that iterating in Python can be slow, so only iterate over a tree as described above if performance is not an issue or when dealing with a small dataset. To read and process the entries of a tree in a much faster way, please use ROOT::RDataFrame.; Second, a couple of TTree methods have been modified to facilitate their use from Python: TTree::Branch and TTree::SetBranchAddress.; Regarding TTree::Branch, the following example shows how we can create diffe",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:37514,Availability,recover,recover,37514,"askets, buffers and entries count in all branches and leaves. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Resets the state of this TTree after a merge (keep the customization but forget the data). ;  ; virtual void ResetBranchAddress (TBranch *);  Tell all of our branches to set their addresses to zero. ;  ; virtual void ResetBranchAddresses ();  Tell all of our branches to drop their current objects and allocate new ones. ;  ; virtual Long64_t Scan (const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop over tree entries and print entries passing selection. ;  ; virtual bool SetAlias (const char *aliasName, const char *aliasFormula);  Set a tree variable alias. ;  ; virtual void SetAutoFlush (Long64_t autof=-30000000);  This function may be called at the start of a program to change the default value for fAutoFlush. ;  ; virtual void SetAutoSave (Long64_t autos=-300000000);  In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ;  ; virtual void SetBasketSize (const char *bname, Int_t buffsize=16000);  Set a branch's basket size. ;  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr=nullptr);  Change branch address, dealing with clone trees properly. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual void SetBranchStatus (const char *bname, bool s",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:45068,Availability,error,error,45068," *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:45157,Availability,error,error,45157,"ave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:45312,Availability,error,error,45312,"hether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:45609,Availability,error,error,45609,"putes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:49328,Availability,error,error,49328,"is method must be overridden if a class wants to paint itself. ;  ; virtual void Pop ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t DistancetoLine (Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2);  Compute distance from point px,py to a line. ;  ; virtual Color_t GetLineColor () const;  Return the line color. ;  ; virtual Style_t GetLineStyle () const;  Return the line style. ;  ; virtual Width_t GetLineWidth () const;  Return the line width. ;  ; virtual void Modify ();  Change current line attributes if necessary. ;  ; virtual void ResetAttLine (",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:69415,Availability,error,error,69415,"se the various functions Branch below to add branches to this tree.; If the first character of title is a ""/"", the function assumes a folder name. In this case, it creates automatically branches following the folder hierarchy. splitlevel may be used in this case to control the split level. ; Definition at line 817 of file TTree.cxx. ◆ ~TTree(). TTree::~TTree ; (; ). override . Destructor. ; Definition at line 920 of file TTree.cxx. ◆ TTree() [3/3]. TTree::TTree ; (; const TTree & ; tt). delete . Member Function Documentation. ◆ AddAllocationCount(). void TTree::AddAllocationCount ; (; UInt_t ; count). inline . Definition at line 337 of file TTree.h. ◆ AddBranchToCache() [1/2]. Int_t TTree::AddBranchToCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Add branch with name bname to the Tree cache. ; If bname=""*"" all branches are added to the cache. if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1059 of file TTree.cxx. ◆ AddBranchToCache() [2/2]. Int_t TTree::AddBranchToCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Add branch b to the Tree cache. ; if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (current directory); adds the Tree to the list of friends see other AddFriend fu",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:69761,Availability,error,error,69761," TTree::~TTree ; (; ). override . Destructor. ; Definition at line 920 of file TTree.cxx. ◆ TTree() [3/3]. TTree::TTree ; (; const TTree & ; tt). delete . Member Function Documentation. ◆ AddAllocationCount(). void TTree::AddAllocationCount ; (; UInt_t ; count). inline . Definition at line 337 of file TTree.h. ◆ AddBranchToCache() [1/2]. Int_t TTree::AddBranchToCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Add branch with name bname to the Tree cache. ; If bname=""*"" all branches are added to the cache. if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1059 of file TTree.cxx. ◆ AddBranchToCache() [2/2]. Int_t TTree::AddBranchToCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Add branch b to the Tree cache. ; if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (current directory); adds the Tree to the list of friends see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file. When a TFriendElement TF is added to the list of friends of an existing TTree T, any variable from TF can be referenced in a query to T.; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:75462,Availability,recover,recovered,75462,"ual . AutoSave tree header every fAutoSave bytes. ; When large Trees are produced, it is safe to activate the AutoSave procedure. Some branches may have buffers holding many entries. If fAutoSave is negative, AutoSave is automatically called by TTree::Fill when the number of bytes generated since the previous AutoSave is greater than -fAutoSave bytes. If fAutoSave is positive, AutoSave is automatically called by TTree::Fill every N entries. This function may also be invoked by the user. Each AutoSave generates a new key on the file. Once the key with the tree header has been written, the previous cycle (if any) is deleted.; Note that calling TTree::AutoSave too frequently (or similarly calling TTree::SetAutoSave with a small value) is an expensive operation. You should make tests for your own application to find a compromise between speed and the quantity of information you may loose in case of a job crash.; In case your program crashes before closing the file holding this tree, the file will be automatically recovered when you will connect the file in UPDATE mode. The Tree will be recovered at the status corresponding to the last AutoSave.; if option contains ""SaveSelf"", gDirectory->SaveSelf() is called. This allows another process to analyze the Tree while the Tree is being filled.; if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all the current basket are closed-out and written to disk individually.; By default the previous header is deleted after having written the new header. if option contains ""Overwrite"", the previous Tree header is deleted before written the new header. This option is slightly faster, but the default option is safer in case of a problem (disk quota exceeded) when writing the new header.; The function returns the number of bytes written to the file. if the number of bytes is null, an error has occurred while writing the header to the file. How to write a Tree in one process and view it from another process; The following t",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:75536,Availability,recover,recovered,75536,"procedure. Some branches may have buffers holding many entries. If fAutoSave is negative, AutoSave is automatically called by TTree::Fill when the number of bytes generated since the previous AutoSave is greater than -fAutoSave bytes. If fAutoSave is positive, AutoSave is automatically called by TTree::Fill every N entries. This function may also be invoked by the user. Each AutoSave generates a new key on the file. Once the key with the tree header has been written, the previous cycle (if any) is deleted.; Note that calling TTree::AutoSave too frequently (or similarly calling TTree::SetAutoSave with a small value) is an expensive operation. You should make tests for your own application to find a compromise between speed and the quantity of information you may loose in case of a job crash.; In case your program crashes before closing the file holding this tree, the file will be automatically recovered when you will connect the file in UPDATE mode. The Tree will be recovered at the status corresponding to the last AutoSave.; if option contains ""SaveSelf"", gDirectory->SaveSelf() is called. This allows another process to analyze the Tree while the Tree is being filled.; if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all the current basket are closed-out and written to disk individually.; By default the previous header is deleted after having written the new header. if option contains ""Overwrite"", the previous Tree header is deleted before written the new header. This option is slightly faster, but the default option is safer in case of a problem (disk quota exceeded) when writing the new header.; The function returns the number of bytes written to the file. if the number of bytes is null, an error has occurred while writing the header to the file. How to write a Tree in one process and view it from another process; The following two scripts illustrate how to do this. The script treew.C is executed by process1, treer.C by process2; script treew.C: ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:76297,Availability,error,error,76297," information you may loose in case of a job crash.; In case your program crashes before closing the file holding this tree, the file will be automatically recovered when you will connect the file in UPDATE mode. The Tree will be recovered at the status corresponding to the last AutoSave.; if option contains ""SaveSelf"", gDirectory->SaveSelf() is called. This allows another process to analyze the Tree while the Tree is being filled.; if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all the current basket are closed-out and written to disk individually.; By default the previous header is deleted after having written the new header. if option contains ""Overwrite"", the previous Tree header is deleted before written the new header. This option is slightly faster, but the default option is safer in case of a problem (disk quota exceeded) when writing the new header.; The function returns the number of bytes written to the file. if the number of bytes is null, an error has occurred while writing the header to the file. How to write a Tree in one process and view it from another process; The following two scripts illustrate how to do this. The script treew.C is executed by process1, treer.C by process2; script treew.C: void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TTree::AutoSavevirtual Long64_t AutoSave(Option_t *option="""")AutoSave tree header every fAutoSave",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:92793,Availability,avail,available,92793,"t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1635 of file TTree.cxx. ◆ BranchImpRef() [2/2]. TBranch * TTree::BranchImpRef ; (; const char * ; branchname, . TClass * ; ptrClass, . EDataType ; datatype, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1695 of file TTree.cxx. ◆ BranchOld(). TBranch * TTree::BranchOld ; (; const char * ; name, . const char * ; classname, . void * ; addobj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 1 . ). virtual . Create a new TTree BranchObject. ; Build a TBranchObject for an object of class classname. addobj is the address of a pointer to an object of class classname. IMPORTANT: classname must derive from TObject. The class dictionary must be available (ClassDef in class header).; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object. See the next Branch constructor for a more efficient storage in case the entry consists of arrays of identical objects.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:96073,Availability,avail,available,96073,"99 . ). virtual . Create a new TTree BranchElement. . WARNING about this new function; This function is designed to replace the internal implementation of the old TTree::Branch (whose implementation has been moved to BranchOld).; NOTE: The 'Bronch' method supports only one possible calls signature (where the object type has to be specified explicitly and the address must be the address of a pointer). For more flexibility use 'Branch'. Use Bronch only in (rare) cases (likely to be legacy cases) where both the new and old implementation of Branch needs to be used at the same time.; This function is far more powerful than the old Branch function. It supports the full C++, including STL and has the same behaviour in split or non-split mode. classname does not have to derive from TObject. The function is based on the new TStreamerInfo.; Build a TBranchElement for an object of class classname.; addr is the address of a pointer to an object of class classname. The class dictionary must be available (ClassDef in class header).; Note: See the comments in TBranchElement::SetAddress() for a more detailed discussion of the meaning of the addr parameter.; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass""",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:98718,Availability,failure,failure,98718,"treamer; Note: if the split level is set to the default (99), TTree::Branch will not issue a warning if the class can not be split. ; Reimplemented in TTreeSQL.; Definition at line 2404 of file TTree.cxx. ◆ BronchExec(). TBranch * TTree::BronchExec ; (; const char * ; name, . const char * ; classname, . void * ; addobj, . bool ; isptrptr, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ; Definition at line 2412 of file TTree.cxx. ◆ Browse(). void TTree::Browse ; (; TBrowser * ; b). overridevirtual . Browse content of the TTree. ; Reimplemented from TObject.; Definition at line 2609 of file TTree.cxx. ◆ BuildIndex(). Int_t TTree::BuildIndex ; (; const char * ; majorname, . const char * ; minorname = ""0"" . ). virtual . Build a Tree Index (default is TTreeIndex). ; See a description of the parameters and functionality in TTreeIndex::TTreeIndex().; The return value is the number of entries in the Index (< 0 indicates failure).; A TTreeIndex object pointed by fTreeIndex is created. This object will be automatically deleted by the TTree destructor. If an index is already existing, this is replaced by the new one without being deleted. This behaviour prevents the deletion of a previously external index assigned to the TTree via the TTree::SetTreeIndex() method. See alsoalso comments in TTree::SetTreeIndex(). ; Definition at line 2637 of file TTree.cxx. ◆ BuildStreamerInfo(). TStreamerInfo * TTree::BuildStreamerInfo ; (; TClass * ; cl, . void * ; pointer = nullptr, . bool ; canOptimize = true . ). Build StreamerInfo for class cl. ; pointer is an optional argument that may contain a pointer to an object of cl. ; Definition at line 2652 of file TTree.cxx. ◆ ChangeFile(). TFile * TTree::ChangeFile ; (; TFile * ; file). virtual . Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize. ; Create a new file. If the original file is named ""myfile.root"", subsequen",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:102024,Availability,error,error,102024,".root"",""recreate"");; TTree *T = new TTree(""T"",""title"");; T->Fill(); // Loop; file = T->GetCurrentFile(); // To get the pointer to the current file; file->Write();; file->Close();. NoteThis method is never called if the input file is a TMemFile or derivate. ; Definition at line 2749 of file TTree.cxx. ◆ CheckBranchAddressType(). Int_t TTree::CheckBranchAddressType ; (; TBranch * ; branch, . TClass * ; ptrClass, . EDataType ; datatype, . bool ; isptr . ). protectedvirtual . Check whether or not the address described by the last 3 parameters matches the content of the branch. ; If a Data Model Evolution conversion is involved, reset the fInfo of the branch. The return values are:; kMissingBranch (-5) : Missing branch; kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. In addition this can be multiplexed with the two bits:; kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode. This bits can be masked out by using kDecomposedObjMask . Definition at line 2867 of file TTree.cxx. ◆ Class(). static TClass * TTree::Class ; (; ). static . ReturnsTClass describing this class",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:102702,Availability,avail,available,102702," datatype, . bool ; isptr . ). protectedvirtual . Check whether or not the address described by the last 3 parameters matches the content of the branch. ; If a Data Model Evolution conversion is involved, reset the fInfo of the branch. The return values are:; kMissingBranch (-5) : Missing branch; kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. In addition this can be multiplexed with the two bits:; kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode. This bits can be masked out by using kDecomposedObjMask . Definition at line 2867 of file TTree.cxx. ◆ Class(). static TClass * TTree::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTree::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTree::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 659 of file TTree.h. ◆ CloneTree(). TTree * TTree::CloneTree ; (; Long64_t ; nentries = -1, . Option_t * ; option = """" . ). virtual . Create a clone of this tree and copy nentr",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:103093,Availability,mask,masked,103093,"piledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. In addition this can be multiplexed with the two bits:; kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode. This bits can be masked out by using kDecomposedObjMask . Definition at line 2867 of file TTree.cxx. ◆ Class(). static TClass * TTree::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTree::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTree::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 659 of file TTree.h. ◆ CloneTree(). TTree * TTree::CloneTree ; (; Long64_t ; nentries = -1, . Option_t * ; option = """" . ). virtual . Create a clone of this tree and copy nentries. ; By default copy all entries. The compression level of the cloned tree is set to the destination file's compression level.; NOTE: Only active branches are copied. See TTree::SetBranchStatus for more information and usage regarding the (de)activation of branches. More examples are provided in the tutorials listed below.; NOTE: If the TTree is a TChain, the structure of the first TTree is used for the",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:111095,Availability,error,error,111095,"n at line 659 of file TTree.h. ◆ Delete(). void TTree::Delete ; (; Option_t * ; option = """"). overridevirtual . Delete this tree from memory or/and disk. . if option == ""all"" delete Tree object from memory AND from disk all baskets on disk are deleted. All keys with same name are deleted.; if option =="""" only Tree object in memory is deleted. . Reimplemented from TObject.; Definition at line 3747 of file TTree.cxx. ◆ DirectoryAutoAdd(). void TTree::DirectoryAutoAdd ; (; TDirectory * ; dir). virtual . Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file. ; Reimplemented in TChain.; Definition at line 3819 of file TTree.cxx. ◆ Draw() [1/3]. Long64_t TTree::Draw ; (; const char * ; varexp, . const char * ; selection, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Draw expression varexp for entries and objects that pass a (optional) selection. ; Returns-1 in case of error or number of selected events in case of success.; Parameters. [in]varexpA string that takes one of these general forms:; ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1"" on the y-axis versus ""e2"" on the x-axis; ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1"" vs ""e2"" vs ""e3"" on the z-, y-, x-axis, respectively; ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1"" vs ""e2"" vs ""e3"" and ""e4"" mapped on the current color palette. (to create histograms in the 2, 3, and 4 dimensional case, see section ""Saving the result of Draw to an histogram""); ""e1:e2:e3:e4:e5"" with option ""GL5D"" produces a 5D plot using OpenGL. gStyle->SetCanvasPreferGL(true) is needed.; Any number of variables no fewer than two can be used with the options ""CANDLE"" and ""PARA""; An arbitrary number of variables can be used with the option ""GOFF"". Examples:; ""x"": the simplest case, it draws a 1-Dim histogram of column ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:125916,Availability,avail,available,125916,"r.; Sum$(formula ) : return the sum of the value of the elements of the formula given as a parameter. For example the mean for all the elements in one entry can be calculated with: Sum$(formula )/Length$(formula ); Min$(formula ) : return the minimum (within one TTree entry) of the value of the elements of the formula given as a parameter.; Max$(formula ) : return the maximum (within one TTree entry) of the value of the elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition) : return the minimum (maximum) (within one TTree entry) of the value of the elements of the formula given as a parameter if they match the condition. If no element matches the condition, the result is zero. To avoid the resulting peak at zero, use the pattern: tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match for the condition.; Alt$(primary,alternate) : return the value of ""primary"" if it is available for the current iteration otherwise return the value of ""alternate"". For example, with arr1[3] and arr2[2] tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0 Or with a variable size array arr3 tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1) As a comparison tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the actual_size_of_arr3 is greater or equal to 3. Note that the array in 'primary' is flattened/linearized thus using Alt$ with multi-dimensional arrays of different dimensions in unlikely to yield the expected results. To visualize a bit more what elements would be matched by TTree::Draw, TTree::Scan can be used: tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be matched by tree->Draw(""arr1-Alt$(arr2,0)"");; The ternary operator is not directly supported in TTree::",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:127759,Availability,avail,available,127759,"int on one line the value of arr1 and (arr2,0) that will be matched by tree->Draw(""arr1-Alt$(arr2,0)"");; The ternary operator is not directly supported in TTree::Draw however, to plot the equivalent of var2<20 ? -99 : var1, you can use: tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly; If the formula contains a file name, TTree::MakeProxy will be used to load and execute this file. In particular it will draw the result of a function with the same name as the file. The function will be executed in a context where the name of the branches can be used as a C++ variable.; For example draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; hsimpleDefinition hsimple.py:1; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; Drawth1 Draw(); A more complete example is available in the tutorials directory: h1analysisProxy.cxx, h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C; The main features of this facility are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bound; ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram; In case of a 2-Dim expression, one can generate a TProfile histogram instead of a TH2F histogram by specifying option=prof or option=profs or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of y:x>>pf where pf is an existing TProfile histogram. Making a 2D Profile histogram; In case of a 3-Dim expression, one can generate a TProfile2D histogram instead of a TH3F histogram ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:128148,Availability,avail,available,128148,"ser function accessing the TTree data directly; If the formula contains a file name, TTree::MakeProxy will be used to load and execute this file. In particular it will draw the result of a function with the same name as the file. The function will be executed in a context where the name of the branches can be used as a C++ variable.; For example draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; hsimpleDefinition hsimple.py:1; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; Drawth1 Draw(); A more complete example is available in the tutorials directory: h1analysisProxy.cxx, h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C; The main features of this facility are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bound; ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram; In case of a 2-Dim expression, one can generate a TProfile histogram instead of a TH2F histogram by specifying option=prof or option=profs or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of y:x>>pf where pf is an existing TProfile histogram. Making a 2D Profile histogram; In case of a 3-Dim expression, one can generate a TProfile2D histogram instead of a TH3F histogram by specifying option=prof or option=profs. or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of z:y:x>>pf where pf is an existing TProf",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:128443,Availability,error,error,128443,"an be used as a C++ variable.; For example draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; hsimpleDefinition hsimple.py:1; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; Drawth1 Draw(); A more complete example is available in the tutorials directory: h1analysisProxy.cxx, h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C; The main features of this facility are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bound; ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram; In case of a 2-Dim expression, one can generate a TProfile histogram instead of a TH2F histogram by specifying option=prof or option=profs or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of y:x>>pf where pf is an existing TProfile histogram. Making a 2D Profile histogram; In case of a 3-Dim expression, one can generate a TProfile2D histogram instead of a TH3F histogram by specifying option=prof or option=profs. or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of z:y:x>>pf where pf is an existing TProfile2D histogram. Making a 5D plot using GL; If option GL5D is specified together with 5 variables, a 5D plot is drawn using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot; In case of a 2-Dim or more expression with the option=para, one can generate a parallel co",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:128881,Availability,error,error,128881,"lector found in h1analysis.C; The main features of this facility are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bound; ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram; In case of a 2-Dim expression, one can generate a TProfile histogram instead of a TH2F histogram by specifying option=prof or option=profs or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of y:x>>pf where pf is an existing TProfile histogram. Making a 2D Profile histogram; In case of a 3-Dim expression, one can generate a TProfile2D histogram instead of a TH3F histogram by specifying option=prof or option=profs. or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of z:y:x>>pf where pf is an existing TProfile2D histogram. Making a 5D plot using GL; If option GL5D is specified together with 5 variables, a 5D plot is drawn using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot; In case of a 2-Dim or more expression with the option=para, one can generate a parallel coordinates plot. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error. Making a candle sticks chart; In case of a 2-Dim or more expression with the option=candle, one can generate a candle sticks chart. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error. Normalizing the output histogram to 1; When",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:129536,Availability,error,error,129536,"ption for details on the differences. The option=prof is automatically selected in case of y:x>>pf where pf is an existing TProfile histogram. Making a 2D Profile histogram; In case of a 3-Dim expression, one can generate a TProfile2D histogram instead of a TH3F histogram by specifying option=prof or option=profs. or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of z:y:x>>pf where pf is an existing TProfile2D histogram. Making a 5D plot using GL; If option GL5D is specified together with 5 variables, a 5D plot is drawn using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot; In case of a 2-Dim or more expression with the option=para, one can generate a parallel coordinates plot. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error. Making a candle sticks chart; In case of a 2-Dim or more expression with the option=candle, one can generate a candle sticks chart. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error. Normalizing the output histogram to 1; When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray; TTree::Draw can be used to fill a TEventList object (list of entry numbers) instead of histogramming one variable. If varexp0 has the form >>elist , a TEventList object named ""elist"" is created in the current directory. elist will contain the list of entry numbers satisfying the current selection. If option ""entrylist"" is used, a TEntryList object is created If the selection contains arrays, vectors or any container class and option ""entrylistarray"" is used,",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:129833,Availability,error,error,129833,"f or option=profs. or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of z:y:x>>pf where pf is an existing TProfile2D histogram. Making a 5D plot using GL; If option GL5D is specified together with 5 variables, a 5D plot is drawn using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot; In case of a 2-Dim or more expression with the option=para, one can generate a parallel coordinates plot. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error. Making a candle sticks chart; In case of a 2-Dim or more expression with the option=candle, one can generate a candle sticks chart. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error. Normalizing the output histogram to 1; When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray; TTree::Draw can be used to fill a TEventList object (list of entry numbers) instead of histogramming one variable. If varexp0 has the form >>elist , a TEventList object named ""elist"" is created in the current directory. elist will contain the list of entry numbers satisfying the current selection. If option ""entrylist"" is used, a TEntryList object is created If the selection contains arrays, vectors or any container class and option ""entrylistarray"" is used, a TEntryListArray object is created containing also the subentries satisfying the selection, i.e. the indices of the branches which hold containers classes. Example: tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory. In an interactive session, one",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:136493,Availability,error,error,136493,"er entry), use tree->SetEstimate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows you need to look at is greater than 1000000.; You can use the option ""goff"" to turn off the graphics output of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer; A complete graphical interface to this function is implemented in the class TTreeViewer. To start the TTreeViewer, three possibilities:; select TTree context menu item ""StartViewer""; type the command ""TTreeViewer TV(treeName)""; execute statement ""tree->StartViewer();"" . Reimplemented in TChain, and TProofChain.; Definition at line 4507 of file TTree.cxx. ◆ Draw() [2/3]. Long64_t TTree::Draw ; (; const char * ; varexp, . const TCut & ; selection, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Draw expression varexp for specified entries. ; Returns-1 in case of error or number of selected events in case of success.; This function accepts TCut objects as arguments. Useful to use the string operator +; Example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Reimplemented in TChain, and TProofChain.; Definition at line 3855 of file TTree.cxx. ◆ Draw() [3/3]. void TTree::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 431 of file TTree.h. ◆ DropBaskets(). void TTree::DropBaskets ; (; ). virtual . Remove some baskets from memory. ; Definition at line 4518 of file TTree.cxx. ◆ DropBranchFromCache() [1/2]. Int_t TTree::DropBranchFromCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove the branch with name 'bname' from the Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at l",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:137485,Availability,error,error,137485,"ntries. ; Returns-1 in case of error or number of selected events in case of success.; This function accepts TCut objects as arguments. Useful to use the string operator +; Example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Reimplemented in TChain, and TProofChain.; Definition at line 3855 of file TTree.cxx. ◆ Draw() [3/3]. void TTree::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 431 of file TTree.h. ◆ DropBaskets(). void TTree::DropBaskets ; (; ). virtual . Remove some baskets from memory. ; Definition at line 4518 of file TTree.cxx. ◆ DropBranchFromCache() [1/2]. Int_t TTree::DropBranchFromCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove the branch with name 'bname' from the Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a ca",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:137850,Availability,error,error,137850,"lineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 431 of file TTree.h. ◆ DropBaskets(). void TTree::DropBaskets ; (; ). virtual . Remove some baskets from memory. ; Definition at line 4518 of file TTree.cxx. ◆ DropBranchFromCache() [1/2]. Int_t TTree::DropBranchFromCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove the branch with name 'bname' from the Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a cache attached to the TTree (either pre-exisiting or created as part of this call) ; Definition at line 2685 of file TTree.cxx. ◆ Fill(). Int_t TTree::Fill ; (; ). virtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a s",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:139349,Availability,error,error,139349,"them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a cache attached to the TTree (either pre-exisiting or created as part of this call) ; Definition at line 2685 of file TTree.cxx. ◆ Fill(). Int_t TTree::Fill ; (; ). virtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a simple data type, a simple conversion to a machine independent format has to be done.; This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to flush the baskets happen, we also take this opportunity to optimize the baskets buffers. We also check if the amount of data written is greater than fAutoSave (see SetAutoSave). In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes. The decisions to FlushBaskets and Auto Save can be made based either on the number of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries written (fAutoFlush and ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:140104,Availability,recover,recoverable,140104,"operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to flush the baskets happen, we also take this opportunity to optimize the baskets buffers. We also check if the amount of data written is greater than fAutoSave (see SetAutoSave). In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes. The decisions to FlushBaskets and Auto Save can be made based either on the number of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries written (fAutoFlush and fAutoSave positive). Note that the user can decide to call FlushBaskets and AutoSave in her event loop base on the number of events written instead of the number of bytes written.; NoteCalling TTree::FlushBaskets too often increases the IO time. Calling TTree::AutoSave too often increases the IO time and also the file size. This method calls TTree::ChangeFile when the tree reaches a size greater than TTree::fgMaxTreeSize. This doesn't happen if the tree is attached to a TMemFile or derivate. ; Reimplemented in TChain, TNtuple, TNtupleD, and TTreeSQL.; Definition at line 4603 of file TTree.cxx. ◆ FindBranch(). TBranch * TTree::FindBranch ; (; const char * ; branchname). virtual . Return the branch that correspond to the path 'branchname', which can includ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:143921,Availability,error,error,143921,"n parallel via TThreadExecutor to do this operation; one per basket compression. If the caller utilizes TBB also, care must be taken to prevent deadlocks.; For example, let's say the caller holds mutex A and calls FlushBaskets; while TBB is waiting for the ROOT compression tasks to complete, it may decide to run another one of the user's tasks in this thread. If the second user task tries to acquire A, then a deadlock will occur. The example call sequence looks like this:. User acquires mutex A; User calls FlushBaskets.; ROOT launches N tasks and calls wait.; TBB schedules another user task, T2.; T2 tries to acquire mutex A. At this point, the thread will deadlock: the code may function with IMT-mode disabled if the user assumed the legacy code never would run their own TBB tasks.; SO: users of TBB who want to enable IMT-mode should carefully review their locking patterns and make sure they hold no coarse-grained application locks when they invoke ROOT.; Return the number of bytes written or -1 in case of write error. ; Definition at line 5129 of file TTree.cxx. ◆ FlushBasketsImpl(). Int_t TTree::FlushBasketsImpl ; (; ); const. private . Internal implementation of the FlushBaskets algorithm. ; Unlike the public interface, this does NOT create an explicit event cluster boundary; it is up to the (internal) caller to determine whether that should done.; Otherwise, the comments for FlushBaskets applies. ; Definition at line 5146 of file TTree.cxx. ◆ GetAlias(). const char * TTree::GetAlias ; (; const char * ; aliasName); const. virtual . Returns the expanded value of the alias. Search in the friends if any. ; Reimplemented in TChain.; Definition at line 5226 of file TTree.cxx. ◆ GetAllocationCount(). UInt_t TTree::GetAllocationCount ; (; ); const. inline . Definition at line 443 of file TTree.h. ◆ GetAutoFlush(). virtual Long64_t TTree::GetAutoFlush ; (; ); const. inlinevirtual . Definition at line 447 of file TTree.h. ◆ GetAutoSave(). virtual Long64_t TTree::GetAutoSav",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:148598,Availability,error,errors,148598,"virtual . Definition at line 457 of file TTree.h. ◆ GetCurrentFile(). TFile * TTree::GetCurrentFile ; (; ); const. Return pointer to the current file. ; Definition at line 5479 of file TTree.cxx. ◆ GetDebugMax(). Long64_t TTree::GetDebugMax ; (; ); const. inline . Definition at line 460 of file TTree.h. ◆ GetDebugMin(). Long64_t TTree::GetDebugMin ; (; ); const. inline . Definition at line 461 of file TTree.h. ◆ GetDefaultEntryOffsetLen(). Int_t TTree::GetDefaultEntryOffsetLen ; (; ); const. inline . Definition at line 459 of file TTree.h. ◆ GetDirectory(). TDirectory * TTree::GetDirectory ; (; ); const. inline . Definition at line 462 of file TTree.h. ◆ GetEntries() [1/2]. virtual Long64_t TTree::GetEntries ; (; ); const. inlinevirtual . Reimplemented in TProofChain, TChain, and TTreeSQL.; Definition at line 463 of file TTree.h. ◆ GetEntries() [2/2]. Long64_t TTree::GetEntries ; (; const char * ; selection). virtual . Return the number of entries matching the selection. ; Return -1 in case of errors.; If the selection uses any arrays or containers, we return the number of entries where at least one element match the selection. GetEntries is implemented using the selector class TSelectorEntries, which can be used directly (see code in TTreePlayer::GetEntries) for additional option. If SetEventList was used on the TTree or TChain, only that subset of entries will be considered. ; Reimplemented in TProofChain, TChain, and TTreeSQL.; Definition at line 5499 of file TTree.cxx. ◆ GetEntriesFast(). virtual Long64_t TTree::GetEntriesFast ; (; ); const. inlinevirtual . Reimplemented in TTreeSQL.; Definition at line 465 of file TTree.h. ◆ GetEntriesFriend(). Long64_t TTree::GetEntriesFriend ; (; ); const. virtual . Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ; Definition at line 5512 of file TTree.cxx. ◆ GetEntry(). Int_t TTree::GetEntry ; (; Long64_t ; entry, . Int_t ; getall = 0 . ). virtual . Read all bran",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:149842,Availability,error,error,149842,"::GetEntries) for additional option. If SetEventList was used on the TTree or TChain, only that subset of entries will be considered. ; Reimplemented in TProofChain, TChain, and TTreeSQL.; Definition at line 5499 of file TTree.cxx. ◆ GetEntriesFast(). virtual Long64_t TTree::GetEntriesFast ; (; ); const. inlinevirtual . Reimplemented in TTreeSQL.; Definition at line 465 of file TTree.h. ◆ GetEntriesFriend(). Long64_t TTree::GetEntriesFriend ; (; ); const. virtual . Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ; Definition at line 5512 of file TTree.cxx. ◆ GetEntry(). Int_t TTree::GetEntry ; (; Long64_t ; entry, . Int_t ; getall = 0 . ). virtual . Read all branches of entry and return total number of bytes read. . getall = 0 : get only active branches; getall = 1 : get all branches. The function returns the number of bytes read from the input buffer. If entry does not exist the function returns 0. If an I/O error occurs, the function returns -1.; If the Tree has friends, also read the friends entry.; To activate/deactivate one or more branches, use TBranch::SetBranchStatus For example, if you have a Tree with several hundred branches, and you are interested only by branches named ""a"" and ""b"", do mytree.SetBranchStatus(""*"",0); //disable all branches; mytree.SetBranchStatus(""a"",1);; mytree.SetBranchStatus(""b"",1);; when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read.; WARNING!! If your Tree has been created in split mode with a parent branch ""parent."", mytree.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do: mytree.SetBranchStatus(""parent*"",1);; Without the trailing dot in the branch creation you have no choice but to call SetBranchStatus explicitly for each of the sub branches.; An alternative is to call directly brancha.GetEntry(i); branchb.GetEntry(i);; ; IMPORTANT NOTE; By default, GetEntry reuses the space allocated by the previous object",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:153541,Availability,avail,available,153541,"vent);; branch->SetAutoDelete(true);; for (Long64_t i=0;i<nentries;i++) {; T.GetEntry(i);; // the object event has been filled at this point; }; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::SetAddressvirtual void SetAddress(void *add)Set address of this branch.Definition TBranch.cxx:2682; TBranch::SetAutoDeletevirtual void SetAutoDelete(bool autodel=true)Set the automatic delete bit.Definition TBranch.cxx:2716; In this case, at each iteration, the object event is deleted by GetEntry and a new instance of Event is created and filled. OPTION 3; Same as option 1, but you delete yourself the event.; ; for (Long64_t i=0;i<nentries;i++) {; delete event;; event = 0; // EXTREMELY IMPORTANT; T.GetEntry(i);; // the object event has been filled at this point; }; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; It is strongly recommended to use the default option 1. It has the additional advantage that functions like TTree::Draw (internally calling TTree::GetEntry) will be functional even when the classes in the file are not available.; Note: See the comments in TBranchElement::SetAddress() for the object ownership policy of the underlying (user) data. ; Reimplemented in THbookTree, TChain, and TTreeSQL.; Definition at line 5638 of file TTree.cxx. ◆ GetEntryList(). TEntryList * TTree::GetEntryList ; (; ). virtual . Returns the entry list assigned to this tree. ; Definition at line 5854 of file TTree.cxx. ◆ GetEntryNumber(). Long64_t TTree::GetEntryNumber ; (; Long64_t ; entry); const. virtual . Return entry number corresponding to entry. ; if no TEntryList set returns entry else returns the entry number corresponding to the list index=entry ; Reimplemented in TChain.; Definition at line 5865 of file TTree.cxx. ◆ GetEntryNumberWithBestIndex(). Long64_t TTree::GetEntryNumberWithBestIndex ; (; Long64_t ; major, . Long64_t ; minor = 0 . ); const. virtual . Return entry number corresponding to major and minor number. ; Note that this fu",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:170858,Availability,error,error,170858,"2 of file TTree.cxx. ◆ IsA(). TClass * TTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 659 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 547 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:171358,Availability,error,error,171358,"p a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by LoadTree() when the masterTree looks for the entry number in a friend tree (us) corresponding to the passed entry number in the masterTree.; If we have no index, our entry number and the masterTree entry number are the same.; If we do have an index, we must find the (major, minor) value pair in masterTree to locate our corresponding entry. ; Definition at line 6557 of file TTree.cxx. ◆ MakeClass(). Int_t TTree::MakeClass ; (; const char * ; classname = nullptr, . Option_t * ; option = """" . ). virtual . Generate a skeleton analysis class for",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:176342,Availability,error,errors,176342,"efix.h; located in the current directory or in 'path/' if it is specified. The class generated will be named 'fileprefix'; ""macrofilename"" and optionally ""cutfilename"" are expected to point to source files which will be included by the generated skeleton. Method of the same name as the file(minus the extension and path) will be called by the generated skeleton's Process method as follow: [if (cutfilename())] htemp->Fill(macrofilename());; ""option"" can be used select some of the optional features during the code generation. The possible options are:. nohist : indicates that the generated ProcessFill should not fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the system 'unroll' classes that are not split. Unrolling a class allows direct access to its data members (this emulates the behavior of TTreeFormula).; The main features of this skeleton are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bounds errors; ability to use the branch data as an object (when the user code is available). For example with Event.root, if Double_t somePx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somePx will updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; These two functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For exampl",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:176417,Availability,avail,available,176417,"efix.h; located in the current directory or in 'path/' if it is specified. The class generated will be named 'fileprefix'; ""macrofilename"" and optionally ""cutfilename"" are expected to point to source files which will be included by the generated skeleton. Method of the same name as the file(minus the extension and path) will be called by the generated skeleton's Process method as follow: [if (cutfilename())] htemp->Fill(macrofilename());; ""option"" can be used select some of the optional features during the code generation. The possible options are:. nohist : indicates that the generated ProcessFill should not fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the system 'unroll' classes that are not split. Unrolling a class allows direct access to its data members (this emulates the behavior of TTreeFormula).; The main features of this skeleton are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bounds errors; ability to use the branch data as an object (when the user code is available). For example with Event.root, if Double_t somePx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somePx will updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; These two functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For exampl",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:177156,Availability,avail,available,177156,"t are not split. Unrolling a class allows direct access to its data members (this emulates the behavior of TTreeFormula).; The main features of this skeleton are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bounds errors; ability to use the branch data as an object (when the user code is available). For example with Event.root, if Double_t somePx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somePx will updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; These two functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example: Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; nconst Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1anal",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:178938,Availability,avail,available,178938,"ysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.; The default histogram is accessible via the variable named 'htemp'.; If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed include statements and give the ability to access the object stored in the branches.; To draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C ; Definition at line 6768 of file TTree.cxx. ◆ MakeSelector(). Int_t TTree::MakeSelector ; (; const char * ; selector = nullptr, . Option_t * ; option = """" . ). virtual . Generate skeleton selector class for this tree. ; The following files are produced: selector.h and selector.C. If selector is 0, the selector will be called ""nameoftree"". The option can be used to specify the branches that will have a data member.; If option is ""=legacy"", a pre-ROOT6 selector will be generated (data members and branch pointers instead of TTreeReaders).; If option is empty, readers will be generated for each leaf.; If option is ""@"", readers will be generated for the topmost branches.; Individual branches can also be picked by their name:; ""X"" generates readers for leaves of X.; ""@X"" generates a reader for X as a whole.; ""@X;Y"" generates a reader for X as a whol",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:187312,Availability,error,error,187312,"_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245; if option = ""a"" the list of blocks in the cache is printed ; Definition at line 7370 of file TTree.cxx. ◆ Process() [1/2]. Long64_t TTree::Process ; (; const char * ; filename, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Process this tree executing the TSelector code in the specified filename. ; The return value is -1 in case of error and TSelector::GetStatus() in in case of success.; The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector, where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts, a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the slave servers.; Process(): called for each event, in this function you decide what to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF called only on the slave servers.; Terminate(): called at the end of the loop on the tree, a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. A",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:191278,Availability,error,error,191278,"(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and...Definition TSelector.h:31; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; or use ACLIC to compile the selector. Workaround 2; void stubs2() {; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(""h1test.C+"");; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(""h1test.C+"");; }. Reimplemented in TChain, and TProofChain.; Definition at line 7450 of file TTree.cxx. ◆ Process() [2/2]. Long64_t TTree::Process ; (; TSelector * ; selector, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Process this tree executing the code in the specified selector. ; The return value is -1 in case of error and TSelector::GetStatus() in in case of success.; The TSelector class has the following member functions:. Begin(): called every time a loop on the tree starts, a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the slave servers.; Process(): called for each event, in this function you decide what to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF called only on the slave servers.; Terminate(): called at the end of the loop on the tree, a convenient place to draw/fit your histograms.; If the Tree (Chain) has an associated EventList, the loop is on the nentries of the EventList, starting at firstentry, otherwise the loop is on the specified Tree entries. . Reimplemented in TChain, and TProofChain.; Definition at line 7481 of file TTree.cxx. ◆ Project(). Long64_t TTree::Project ; (; const char * ; hname, . const char * ; varexp, . const char * ; selection = """", . Option_t *",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:200761,Availability,recover,recover,200761,"skets TTree::Fill will replace fAutoFlush by the current value of fEntries.; Calling this function with autof<0 is interesting when it is hard to estimate the size of one entry. This value is also independent of the Tree.; The Tree is initialized with fAutoFlush=-30000000, ie that, by default, the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0; The AutoFlush mechanism is disabled.; Flushing the buffers at regular intervals optimize the location of consecutive entries on the disk by creating clusters of baskets.; A cluster of baskets is a set of baskets that contains all the data for a (consecutive) set of entries and that is stored consecutively on the disk. When reading all the branches, this is the minimum set of baskets that the TTreeCache will read. ; Definition at line 8191 of file TTree.cxx. ◆ SetAutoSave(). void TTree::SetAutoSave ; (; Long64_t ; autos = -300000000). virtual . In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ; This function may be called before filling a TTree to specify when the branch buffers and TTree header are flushed to disk as part of TTree::Fill(). The default is -300000000, ie the TTree will write data to disk once it exceeds 300 MBytes. CASE 1: If fAutoSave is positive the watermark is reached when a multiple of fAutoSave entries have been filled. CASE 2: If fAutoSave is negative the watermark is reached when -fAutoSave bytes can be written to the file. CASE 3: If fAutoSave is 0, AutoSave() will never be called automatically as part of TTree::Fill(). ; Definition at line 8337 of file TTree.cxx. ◆ SetBasketSize(). void TTree::SetBasketSize ; (; const char * ; bname, . Int_t ; buffsize = 16000 . ). virtual . Set a branch's basket size. ; bname is the name of a branch. if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx. see TRegexp for wildcarding options buffsize = branc ba",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:206741,Availability,error,error,206741,"split' you need to make sure the name of the top level branch is prefixed to the sub-branches' name (by adding a dot ('.') at the end of the Branch creation and use the corresponding bname.; I.e If your Tree has been created in split mode with a parent branch ""parent."" (note the trailing dot). T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do: T.SetBranchStatus(""parent*"",1);; Without the trailing dot in the branch creation you have no choice but to call SetBranchStatus explicitly for each of the sub branches.; An alternative to this function is to read directly and only the interesting branches. Example: TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);; TBranch::GetEntryvirtual Int_t GetEntry(Long64_t entry=0, Int_t getall=0)Read all leaves of entry and return total number of bytes read.Definition TBranch.cxx:1706; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cac",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:207280,Availability,error,error,207280,"h of the sub branches.; An alternative to this function is to read directly and only the interesting branches. Example: TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);; TBranch::GetEntryvirtual Int_t GetEntry(Long64_t entry=0, Int_t getall=0)Read all leaves of entry and return total number of bytes read.Definition TBranch.cxx:1706; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an exist",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:207894,Availability,error,error,207894,"chStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of fi",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208689,Availability,error,error,208689," cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results of the last maxEntries events. NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before merging circular Trees that have been saved on files. NOTE 3:; SetCircular with maxEntries <= 0 is automatically called by TChain::Merge NOTE 4:; A circular Tree can still be saved in a file. When read back, it i",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:218916,Availability,error,error,218916,"our using the weights of each tree in the chain (see TChain::SetWeight). ; Reimplemented in TChain.; Definition at line 9364 of file TTree.cxx. ◆ Show(). void TTree::Show ; (; Long64_t ; entry = -1, . Int_t ; lenmax = 20 . ). virtual . Print values of all active leaves for entry. . if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. . Definition at line 9375 of file TTree.cxx. ◆ SortBranchesByTime(). void TTree::SortBranchesByTime ; (; ). private . Sorts top-level branches by the last average task time recorded per branch. ; Definition at line 5834 of file TTree.cxx. ◆ StartViewer(). void TTree::StartViewer ; (; ). virtual . Start the TTreeViewer on this tree. . ww is the width of the canvas in pixels; wh is the height of the canvas in pixels . Definition at line 9449 of file TTree.cxx. ◆ StopCacheLearningPhase(). Int_t TTree::StopCacheLearningPhase ; (; ). virtual . Stop the cache learning phase. ; Returns:; 0 learning phase stopped or not active; -1 on error . Definition at line 9464 of file TTree.cxx. ◆ Streamer(). void TTree::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 9535 of file TTree.cxx. ◆ StreamerNVirtual(). void TTree::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 659 of file TTree.h. ◆ UnbinnedFit(). Int_t TTree::UnbinnedFit ; (; const char * ; funcname, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Unbinned fit of one or more variable(s) from a tree. ; funcname is a TF1 function.; See alsoTTree::Draw for explanations of the other parameters.; Fit the variable varexp using the function funcname using the selection cuts given by selection.; The list of fit options is given in parameter option. option = ""Q"" Quiet mode (minimum printing",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:221895,Availability,error,error,221895,"1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TF11-Dim function classDefinition TF1.h:233; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:670; 1, 2 and 3 Dimensional fits are supported. See also TTree::Fit; Return status:. The function return the status of the fit in the following form fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1 . Definition at line 9692 of file TTree.cxx. ◆ UseCurrentStyle(). void TTree::UseCurrentStyle ; (; ). overridevirtual . Replace current attributes by current style. ; Reimplemented from TObject.; Definition at line 9704 of file TTree.cxx. ◆ Write() [1/2]. Int_t TTree::Write ; (; const char * ; name = nullptr, . Int_t ; option = 0, . Int_t ; bufsize = 0 . ); const. overridevirtual . Write this object to the current directory. ; For more see TObject::Write If option & kFlushBasket, call FlushBasket before writing the tree. ; Reimplemented from TObject.; Definition at line 9731 of file TTree.cxx. ◆ Write() [2/2]. Int_t TTree::Write ; (; const char * ; name = nullptr, . Int_t ; option = 0, . Int_t ; bufsize = 0 . ). overridevirtual . Write this object to the current directory. ; For more see TObject::Wr",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:9777,Deployability,update,update,9777,"er of the object TTrack. Fill the Tree; A TTree instance is filled with the invocation of the TTree::Fill method: tree.Fill(); Upon its invocation, a loop on all defined branches takes place that for each branch invokes the TBranch::Fill method. Add a column to an already existing Tree; You may want to add a branch to an existing tree. For example, if one variable in the tree was computed with a certain algorithm, you may want to try another algorithm and compare the results. One solution is to add a new branch, fill it, and save the tree. The code below adds a simple branch to an existing tree. Note the kOverwrite option in the Write method, it overwrites the existing tree. If it is not specified, two copies of the tree headers are saved. void tree3AddBranch() {; TFile f(""tree3.root"", ""update"");; ; Float_t new_v;; auto t3 = f->Get<TTree>(""t3"");; auto newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");; ; Long64_t nentries = t3->GetEntries(); // read the number of entries in the t3; ; for (Long64_t i = 0; i < nentries; i++) {; new_v = gRandom->Gaus(0, 1);; newBranch->Fill();; }; ; t3->Write("""", TObject::kOverwrite); // save only the new version of the tree; }; f#define f(i)Definition RSha256.hxx:104; Float_tfloat Float_tDefinition RtypesCore.h:57; Long64_tlong long Long64_tDefinition RtypesCore.h:80; nentriesint nentriesDefinition THbookFile.cxx:91; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TObject::kOverwrite@ kOverwriteoverwrite existing object with same nameDefinition TObject.h:92; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TTree::Fillvirtual Int_t Fill()Fill all branches.Definition TTree.cxx:4603; TTree::BranchTBranch * Branch(const char *name, T *obj, Int_t buf",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:32301,Deployability,update,update,32301,"ual Int_t GetScanField () const;  ; TTreeFormula * GetSelect ();  ; virtual Long64_t GetSelectedRows ();  ; Float_t GetTargetMemoryRatio () const;  ; virtual Int_t GetTimerInterval () const;  ; virtual Long64_t GetTotBytes () const;  ; TBuffer * GetTransientBuffer (Int_t size);  Returns the transient buffer currently used by this TTree for reading/writing baskets. ;  ; virtual TTree * GetTree () const;  ; virtual TVirtualIndex * GetTreeIndex () const;  ; virtual Int_t GetTreeNumber () const;  ; virtual Int_t GetUpdate () const;  ; virtual TList * GetUserInfo ();  Return a pointer to the list containing user objects associated to this tree. ;  ; virtual Double_t * GetV1 ();  ; virtual Double_t * GetV2 ();  ; virtual Double_t * GetV3 ();  ; virtual Double_t * GetV4 ();  ; virtual Double_t * GetVal (Int_t i);  ; TTreeFormula * GetVar (Int_t i);  ; TTreeFormula * GetVar1 ();  ; TTreeFormula * GetVar2 ();  ; TTreeFormula * GetVar3 ();  ; TTreeFormula * GetVar4 ();  ; virtual Double_t * GetW ();  ; virtual Double_t GetWeight () const;  ; virtual Long64_t GetZipBytes () const;  ; virtual void IncrementTotalBuffers (Int_t nbytes);  ; virtual bool InPlaceClone (TDirectory *newdirectory, const char *options="""");  Copy the content to a new new file, update this TTree with the new location information and attach this TTree to the new directory. ;  ; TClass * IsA () const override;  ; bool IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; virtual Int_t LoadBaskets (Long64_t maxmemory=2000000000);  Read in memory all baskets from all branches up to the limit of maxmemory bytes. ;  ; virtual Long64_t LoadTree (Long64_t entry);  Set current entry. ;  ; virtual Long64_t LoadTreeFriend (Long64_t entry, TTree *T);  Load entry on behalf of our master tree, we may use an index. ;  ; virtual Int_t MakeClass (const char *classname=nullptr, Option_t *option="""");  Generate a skeleton analysis class for this ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:39312,Deployability,update,updateExisting,39312,", EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual void SetBranchStatus (const char *bname, bool status=true, UInt_t *found=nullptr);  Set branch status to Process or DoNotProcess. ;  ; virtual Int_t SetCacheEntryRange (Long64_t first, Long64_t last);  interface to TTreeCache to set the cache entry range ;  ; virtual void SetCacheLearnEntries (Int_t n=10);  Interface to TTreeCache to set the number of entries for the learning phase. ;  ; virtual Int_t SetCacheSize (Long64_t cachesize=-1);  Set maximum size of the file cache . ;  ; virtual void SetChainOffset (Long64_t offset=0);  ; virtual void SetCircular (Long64_t maxEntries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual void SetDirectory (TDirectory *dir);  Change the tree's directory. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEntryList (TEntryList *list, Option_t *opt="""");  Set an EntryList. ;  ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetEventList (TEventList *list);  This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TTree and gets deleted when the tree is deleted. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void SetImplicitMT (bool enabled);  ; ROOT::TIOFeatures SetIOFeatures (const ROOT::TIOFeatures &);  Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ;  ; virtual void SetMakeClass (Int_t make);  Set all the br",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:146123,Deployability,configurat,configuration,146123,"r its friends. ; The search is done breadth first. ; Reimplemented in TProofChain, and TChain.; Definition at line 5294 of file TTree.cxx. ◆ GetBranchRef(). virtual TBranchRef * TTree::GetBranchRef ; (; ); const. inlinevirtual . Definition at line 450 of file TTree.h. ◆ GetBranchStatus(). bool TTree::GetBranchStatus ; (; const char * ; branchname); const. virtual . Return status of branch with name branchname. . 0 if branch is not activated; 1 if branch is activated . Reimplemented in TProofChain, and TChain.; Definition at line 5380 of file TTree.cxx. ◆ GetBranchStyle(). Int_t TTree::GetBranchStyle ; (; ). static . Static function returning the current branch style. . style = 0 old Branch; style = 1 new Bronch . Definition at line 5395 of file TTree.cxx. ◆ GetCacheAutoSize(). Long64_t TTree::GetCacheAutoSize ; (; bool ; withDefault = false). protected . Used for automatic sizing of the cache. ; Estimates a suitable size for the tree cache based on AutoFlush. A cache sizing factor is taken from the configuration. If this yields zero and withDefault is true the historical algorithm for default size is used. ; Definition at line 5407 of file TTree.cxx. ◆ GetCacheSize(). virtual Long64_t TTree::GetCacheSize ; (; ); const. inlinevirtual . Reimplemented in TChain.; Definition at line 453 of file TTree.h. ◆ GetChainEntryNumber(). virtual Long64_t TTree::GetChainEntryNumber ; (; Long64_t ; entry); const. inlinevirtual . Reimplemented in TChain.; Definition at line 455 of file TTree.h. ◆ GetChainOffset(). virtual Long64_t TTree::GetChainOffset ; (; ); const. inlinevirtual . Definition at line 456 of file TTree.h. ◆ GetClusterIterator(). TTree::TClusterIterator TTree::GetClusterIterator ; (; Long64_t ; firstentry). virtual . Return an iterator over the cluster of baskets starting at firstentry. ; This iterator is not yet supported for TChain object. TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; Long64_t clusterStart;; while( (clusterStart = clusterIt",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:169443,Deployability,update,update,169443,"ven if IMT is on, some branches might need to be processed first and in a sequential fashion: in the parallelization of GetEntry, those are the branches that store the size of another branch for every entry (e.g. the size of an array branch). If such branches were processed in parallel with the rest, there could be two threads invoking TBranch::GetEntry on one of them at the same time, since a branch that depends on a size (or count) branch will also invoke GetEntry on the latter. This method can be invoked several times during the event loop if the TTree is being written, for example when adding new branches. In these cases, the checkLeafCount parameter is false. Parameters. [in]checkLeafCountTrue if we need to check whether some branches are count leaves. . Definition at line 5781 of file TTree.cxx. ◆ InPlaceClone(). bool TTree::InPlaceClone ; (; TDirectory * ; newdirectory, . const char * ; options = """" . ). virtual . Copy the content to a new new file, update this TTree with the new location information and attach this TTree to the new directory. ; options: Indicates a basket sorting method, see TTreeCloner::TTreeCloner for details; If new and old directory are in the same file, the data is untouched, this ""just"" does a call to SetDirectory. Equivalent to an ""in place"" cloning of the TTree. ; Reimplemented in TChain.; Definition at line 7012 of file TTree.cxx. ◆ IsA(). TClass * TTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 659 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 547 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ Loa",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:176566,Deployability,update,updated,176566," generated skeleton. Method of the same name as the file(minus the extension and path) will be called by the generated skeleton's Process method as follow: [if (cutfilename())] htemp->Fill(macrofilename());; ""option"" can be used select some of the optional features during the code generation. The possible options are:. nohist : indicates that the generated ProcessFill should not fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the system 'unroll' classes that are not split. Unrolling a class allows direct access to its data members (this emulates the behavior of TTreeFormula).; The main features of this skeleton are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bounds errors; ability to use the branch data as an object (when the user code is available). For example with Event.root, if Double_t somePx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somePx will updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; These two functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example: Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; nconst Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Also, optionally, the generated selector will also call",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:195792,Deployability,update,updated,195792,"ceed as indicated above for the first input file and omit the second argument for subsequent calls T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. Definition at line 7564 of file TTree.cxx. ◆ ReadStream(). Long64_t TTree::ReadStream ; (; std::istream & ; inputStream, . const char * ; branchDescriptor = """", . char ; delimiter = ' ' . ). virtual . Create or simply read branches from an input stream. ; See alsoreference information for TTree::ReadFile ; Reimplemented in TNtuple, and TNtupleD.; Definition at line 7615 of file TTree.cxx. ◆ RecursiveRemove(). void TTree::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Make sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree. ; Reimplemented from TObject.; Definition at line 7881 of file TTree.cxx. ◆ Refresh(). void TTree::Refresh ; (; ). virtual . Refresh contents of this tree and its branches from the current status on disk. ; One can call this function in case the tree file is being updated by another process. ; Reimplemented in TTreeSQL.; Definition at line 7916 of file TTree.cxx. ◆ RegisterExternalFriend(). void TTree::RegisterExternalFriend ; (; TFriendElement * ; fe). virtual . Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ; Definition at line 7957 of file TTree.cxx. ◆ RemoveExternalFriend(). void TTree::RemoveExternalFriend ; (; TFriendElement * ; fe). virtual . Removes external friend. ; Definition at line 7968 of file TTree.cxx. ◆ RemoveFriend(). void TTree::RemoveFriend ; (; TTree * ; oldFriend). virtual . Remove a friend from the list of friends. ; Reimplemented in TChain.; Definition at line 7977 of file TTree.cxx. ◆ Reset(). void TTree::Reset ; (; Option_t * ; option = """"). virtual . Reset baskets, buffers and entries count in all branches and leaves. ; Reimplemented in TChain.; Definition at line 8003 of file TTree.cxx. ◆ ResetAfte",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:210410,Deployability,update,updateExisting,210410,"r with maxEntries <= 0 is necessary before merging circular Trees that have been saved on files. NOTE 3:; SetCircular with maxEntries <= 0 is automatically called by TChain::Merge NOTE 4:; A circular Tree can still be saved in a file. When read back, it is still a circular Tree and can be filled again. ; Definition at line 8882 of file TTree.cxx. ◆ SetClusterPrefetch(). virtual void TTree::SetClusterPrefetch ; (; bool ; enabled). inlinevirtual . Definition at line 611 of file TTree.h. ◆ SetDebug(). void TTree::SetDebug ; (; Int_t ; level = 1, . Long64_t ; min = 0, . Long64_t ; max = 9999999 . ). virtual . Set the debug level and the debug range. ; For entries in the debug range, the functions TBranchElement::Fill and TBranchElement::GetEntry will print the number of bytes filled or read for each branch. ; Reimplemented in TProofChain.; Definition at line 8918 of file TTree.cxx. ◆ SetDefaultEntryOffsetLen(). void TTree::SetDefaultEntryOffsetLen ; (; Int_t ; newdefault, . bool ; updateExisting = false . ). virtual . Update the default value for the branch's fEntryOffsetLen. ; If updateExisting is true, also update all the existing branches. If newdefault is less than 10, the new default value will be 10. ; Definition at line 8930 of file TTree.cxx. ◆ SetDirectory(). void TTree::SetDirectory ; (; TDirectory * ; dir). virtual . Change the tree's directory. ; Remove reference to this tree from current directory and add reference to new directory dir. The dir parameter can be 0 in which case the tree does not belong to any directory. ; Reimplemented in TChain.; Definition at line 8956 of file TTree.cxx. ◆ SetEntries(). Long64_t TTree::SetEntries ; (; Long64_t ; n = -1). virtual . Change number of entries in the tree. ; If n >= 0, set number of entries in the tree = n.; If n < 0, set number of entries in the tree to match the number of entries in each branch. (default for n is -1); This function should be called only when one fills each branch independently via TBranch::Fi",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:210512,Deployability,update,updateExisting,210512," maxEntries <= 0 is automatically called by TChain::Merge NOTE 4:; A circular Tree can still be saved in a file. When read back, it is still a circular Tree and can be filled again. ; Definition at line 8882 of file TTree.cxx. ◆ SetClusterPrefetch(). virtual void TTree::SetClusterPrefetch ; (; bool ; enabled). inlinevirtual . Definition at line 611 of file TTree.h. ◆ SetDebug(). void TTree::SetDebug ; (; Int_t ; level = 1, . Long64_t ; min = 0, . Long64_t ; max = 9999999 . ). virtual . Set the debug level and the debug range. ; For entries in the debug range, the functions TBranchElement::Fill and TBranchElement::GetEntry will print the number of bytes filled or read for each branch. ; Reimplemented in TProofChain.; Definition at line 8918 of file TTree.cxx. ◆ SetDefaultEntryOffsetLen(). void TTree::SetDefaultEntryOffsetLen ; (; Int_t ; newdefault, . bool ; updateExisting = false . ). virtual . Update the default value for the branch's fEntryOffsetLen. ; If updateExisting is true, also update all the existing branches. If newdefault is less than 10, the new default value will be 10. ; Definition at line 8930 of file TTree.cxx. ◆ SetDirectory(). void TTree::SetDirectory ; (; TDirectory * ; dir). virtual . Change the tree's directory. ; Remove reference to this tree from current directory and add reference to new directory dir. The dir parameter can be 0 in which case the tree does not belong to any directory. ; Reimplemented in TChain.; Definition at line 8956 of file TTree.cxx. ◆ SetEntries(). Long64_t TTree::SetEntries ; (; Long64_t ; n = -1). virtual . Change number of entries in the tree. ; If n >= 0, set number of entries in the tree = n.; If n < 0, set number of entries in the tree to match the number of entries in each branch. (default for n is -1); This function should be called only when one fills each branch independently via TBranch::Fill without calling TTree::Fill. Calling TTree::SetEntries() make sense only if the number of entries in each branch is ide",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:210541,Deployability,update,update,210541," maxEntries <= 0 is automatically called by TChain::Merge NOTE 4:; A circular Tree can still be saved in a file. When read back, it is still a circular Tree and can be filled again. ; Definition at line 8882 of file TTree.cxx. ◆ SetClusterPrefetch(). virtual void TTree::SetClusterPrefetch ; (; bool ; enabled). inlinevirtual . Definition at line 611 of file TTree.h. ◆ SetDebug(). void TTree::SetDebug ; (; Int_t ; level = 1, . Long64_t ; min = 0, . Long64_t ; max = 9999999 . ). virtual . Set the debug level and the debug range. ; For entries in the debug range, the functions TBranchElement::Fill and TBranchElement::GetEntry will print the number of bytes filled or read for each branch. ; Reimplemented in TProofChain.; Definition at line 8918 of file TTree.cxx. ◆ SetDefaultEntryOffsetLen(). void TTree::SetDefaultEntryOffsetLen ; (; Int_t ; newdefault, . bool ; updateExisting = false . ). virtual . Update the default value for the branch's fEntryOffsetLen. ; If updateExisting is true, also update all the existing branches. If newdefault is less than 10, the new default value will be 10. ; Definition at line 8930 of file TTree.cxx. ◆ SetDirectory(). void TTree::SetDirectory ; (; TDirectory * ; dir). virtual . Change the tree's directory. ; Remove reference to this tree from current directory and add reference to new directory dir. The dir parameter can be 0 in which case the tree does not belong to any directory. ; Reimplemented in TChain.; Definition at line 8956 of file TTree.cxx. ◆ SetEntries(). Long64_t TTree::SetEntries ; (; Long64_t ; n = -1). virtual . Change number of entries in the tree. ; If n >= 0, set number of entries in the tree = n.; If n < 0, set number of entries in the tree to match the number of entries in each branch. (default for n is -1); This function should be called only when one fills each branch independently via TBranch::Fill without calling TTree::Fill. Calling TTree::SetEntries() make sense only if the number of entries in each branch is ide",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:735,Energy Efficiency,allocate,allocated,735,". ROOT: TTree Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Static Public Attributes |; Protected Types |; Protected Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Types |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; TTree Class ReferenceTree Library. ; A TTree represents a columnar dataset. ; Any C++ type can be stored in its columns.; A TTree, often called in jargon tree, consists of a list of independent columns or branches, represented by the TBranch class. Behind each branch, buffers are allocated automatically by ROOT. Such buffers are automatically written to disk or kept in memory until the size stored in the attribute fMaxVirtualSize is reached. Variables of one branch are written to the same buffer. A branch buffer is automatically compressed if the file compression attribute is set (default). Branches may be written to different files (see TBranch::SetFile).; The ROOT user can decide to make one single branch and serialize one object into one single I/O buffer or to make several branches. Making several branches is particularly interesting in the data analysis phase, when it is desirable to have a high reading rate and not all columns are equally interesting. Create a TTree to store columnar data. Construct a TTree; Add a column of Fundamental Types and Arrays thereof; Add a column of a STL Collection instances; Add a column holding an object; Add a column holding a TObjectArray; Fill the tree; Add a column to an already existing Tree; An Example. Construct a TTree; TTree tree(name, title); namechar name[80]Definition TGX11.cxx:110; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Creates a Tree with name and title.; Various kinds of branches can be added to a tree:; Variables representing fundamental types",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:8420,Energy Efficiency,allocate,allocated,8420,"evel); auto branch = tree.Branch(branchname, className, &p_object, bufsize, splitlevel). p_object is a pointer to an object.; If className is not specified, Branch uses the type of p_object to determine the type of the object.; If className is used to specify explicitly the object type, the className must be of a type related to the one pointed to by the pointer. It should be either a parent or derived class. Note: The pointer whose address is passed to TTree::Branch must not be destroyed (i.e. go out of scope) until the TTree is deleted or TTree::ResetBranchAddress is called.; Note: The pointer p_object must be initialized before calling TTree::Branch; Do either: MyDataClass* p_object = nullptr;; tree.Branch(branchname, &p_object);. Or: auto p_object = new MyDataClass;; tree.Branch(branchname, &p_object);; Whether the pointer is set to zero or not, the ownership of the object is not taken over by the TTree. I.e. even though an object will be allocated by TTree::Branch if the pointer p_object is zero, the object will not be deleted when the TTree is deleted. Add a column holding TClonesArray instances; It is recommended to use STL containers instead of TClonesArrays*.; // clonesarray is the address of a pointer to a TClonesArray.; auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel); The TClonesArray is a direct access list of objects of the same class. For example, if the TClonesArray is an array of TTrack objects, this function will create one subbranch for each data member of the object TTrack. Fill the Tree; A TTree instance is filled with the invocation of the TTree::Fill method: tree.Fill(); Upon its invocation, a loop on all defined branches takes place that for each branch invokes the TBranch::Fill method. Add a column to an already existing Tree; You may want to add a branch to an existing tree. For example, if one variable in the tree was computed with a certain algorithm, you may want to try another algorithm and compare the results. One",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:36906,Energy Efficiency,allocate,allocate,36906," is being deleted or will soon be) is no longer referenced by this TTree. ;  ; virtual void Refresh ();  Refresh contents of this tree and its branches from the current status on disk. ;  ; virtual void RegisterExternalFriend (TFriendElement *);  Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual void RemoveFriend (TTree *);  Remove a friend from the list of friends. ;  ; virtual void Reset (Option_t *option="""");  Reset baskets, buffers and entries count in all branches and leaves. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Resets the state of this TTree after a merge (keep the customization but forget the data). ;  ; virtual void ResetBranchAddress (TBranch *);  Tell all of our branches to set their addresses to zero. ;  ; virtual void ResetBranchAddresses ();  Tell all of our branches to drop their current objects and allocate new ones. ;  ; virtual Long64_t Scan (const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop over tree entries and print entries passing selection. ;  ; virtual bool SetAlias (const char *aliasName, const char *aliasFormula);  Set a tree variable alias. ;  ; virtual void SetAutoFlush (Long64_t autof=-30000000);  This function may be called at the start of a program to change the default value for fAutoFlush. ;  ; virtual void SetAutoSave (Long64_t autos=-300000000);  In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ;  ; virtual void SetBasketSize (const char *bname, Int_t buffsize=16000);  Set a branch's basket size. ;  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:62148,Energy Efficiency,allocate,allocated,62148,event selection list (if one) ;  ; Long64_t fEstimate;  Number of entries to estimate histogram limits. ;  ; TEventList * fEventList;  ! Pointer to event selection list (if one) ;  ; TList * fExternalFriends;  ! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned. ;  ; Int_t fFileNumber;  ! current file number (if file extensions) ;  ; Long64_t fFlushedBytes;  Number of auto-flushed bytes. ;  ; UInt_t fFriendLockStatus;  ! Record which method is locking the friend recursion ;  ; TList * fFriends;  pointer to list of friend elements ;  ; bool fIMTEnabled;  ! true if implicit multi-threading is enabled for this tree ;  ; TArrayI fIndex;  Index of sorted values. ;  ; TArrayD fIndexValues;  Sorted index values. ;  ; TIOFeatures fIOFeatures {0};  IO features to define for newly-written baskets and branches. ;  ; TObjArray fLeaves;  Direct pointers to individual branch leaves. ;  ; Int_t fMakeClass;  ! not zero when processing code generated by MakeClass ;  ; Int_t fMaxClusterRange;  ! Memory allocated for the cluster range. ;  ; Long64_t fMaxEntries;  Maximum number of entries in case of circular buffers. ;  ; Long64_t fMaxEntryLoop;  Maximum number of entries to process. ;  ; Long64_t fMaxVirtualSize;  Maximum total size of buffers kept in memory. ;  ; Int_t fNClusterRange;  Number of Cluster range in addition to the one defined by 'AutoFlush'. ;  ; UInt_t fNEntriesSinceSorting;  ! Number of entries processed since the last re-sorting of branches ;  ; Int_t fNfill;  ! Local for EntryLoop ;  ; TObject * fNotify;  Object to be notified when loading a Tree. ;  ; Int_t fPacketSize;  ! Number of entries in one packet for parallel root ;  ; TVirtualPerfStats * fPerfStats;  ! pointer to the current perf stats object ;  ; TVirtualTreePlayer * fPlayer;  ! Pointer to current Tree player ;  ; Long64_t fReadEntry;  ! Number of the entry being processed ;  ; Long64_t fSavedBytes;  Number of autosaved bytes. ;  ; Int_t fScanField;  Number of r,MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:93040,Energy Efficiency,efficient,efficient,93040,"pRef ; (; const char * ; branchname, . TClass * ; ptrClass, . EDataType ; datatype, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1695 of file TTree.cxx. ◆ BranchOld(). TBranch * TTree::BranchOld ; (; const char * ; name, . const char * ; classname, . void * ; addobj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 1 . ). virtual . Create a new TTree BranchObject. ; Build a TBranchObject for an object of class classname. addobj is the address of a pointer to an object of class classname. IMPORTANT: classname must derive from TObject. The class dictionary must be available (ClassDef in class header).; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object. See the next Branch constructor for a more efficient storage in case the entry consists of arrays of identical objects.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; bufsize is the buffer size in bytes for this branch The default value is 32000 ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:95689,Energy Efficiency,power,powerful,95689,"o the TBranchRef basket. When the Tree header is saved (via TTree::Write), the branch is saved keeping the information with the pointers to the branches having referenced objects. ; Definition at line 2328 of file TTree.cxx. ◆ Bronch(). TBranch * TTree::Bronch ; (; const char * ; name, . const char * ; classname, . void * ; addr, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). virtual . Create a new TTree BranchElement. . WARNING about this new function; This function is designed to replace the internal implementation of the old TTree::Branch (whose implementation has been moved to BranchOld).; NOTE: The 'Bronch' method supports only one possible calls signature (where the object type has to be specified explicitly and the address must be the address of a pointer). For more flexibility use 'Branch'. Use Bronch only in (rare) cases (likely to be legacy cases) where both the new and old implementation of Branch needs to be used at the same time.; This function is far more powerful than the old Branch function. It supports the full C++, including STL and has the same behaviour in split or non-split mode. classname does not have to derive from TObject. The function is based on the new TStreamerInfo.; Build a TBranchElement for an object of class classname.; addr is the address of a pointer to an object of class classname. The class dictionary must be available (ClassDef in class header).; Note: See the comments in TBranchElement::SetAddress() for a more detailed discussion of the meaning of the addr parameter.; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at th",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:143464,Energy Efficiency,schedul,schedules,143464," file TTree.cxx. ◆ FlushBaskets(). Int_t TTree::FlushBaskets ; (; bool ; create_cluster = true); const. virtual . Write to disk all the basket that have not yet been individually written and create an event cluster boundary (by default). ; If the caller wishes to flush the baskets but not create an event cluster, then set create_cluster to false.; If ROOT has IMT-mode enabled, this will launch multiple TBB tasks in parallel via TThreadExecutor to do this operation; one per basket compression. If the caller utilizes TBB also, care must be taken to prevent deadlocks.; For example, let's say the caller holds mutex A and calls FlushBaskets; while TBB is waiting for the ROOT compression tasks to complete, it may decide to run another one of the user's tasks in this thread. If the second user task tries to acquire A, then a deadlock will occur. The example call sequence looks like this:. User acquires mutex A; User calls FlushBaskets.; ROOT launches N tasks and calls wait.; TBB schedules another user task, T2.; T2 tries to acquire mutex A. At this point, the thread will deadlock: the code may function with IMT-mode disabled if the user assumed the legacy code never would run their own TBB tasks.; SO: users of TBB who want to enable IMT-mode should carefully review their locking patterns and make sure they hold no coarse-grained application locks when they invoke ROOT.; Return the number of bytes written or -1 in case of write error. ; Definition at line 5129 of file TTree.cxx. ◆ FlushBasketsImpl(). Int_t TTree::FlushBasketsImpl ; (; ); const. private . Internal implementation of the FlushBaskets algorithm. ; Unlike the public interface, this does NOT create an explicit event cluster boundary; it is up to the (internal) caller to determine whether that should done.; Otherwise, the comments for FlushBaskets applies. ; Definition at line 5146 of file TTree.cxx. ◆ GetAlias(). const char * TTree::GetAlias ; (; const char * ; aliasName); const. virtual . Returns the expanded va",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:150824,Energy Efficiency,allocate,allocated,150824,"unction returns 0. If an I/O error occurs, the function returns -1.; If the Tree has friends, also read the friends entry.; To activate/deactivate one or more branches, use TBranch::SetBranchStatus For example, if you have a Tree with several hundred branches, and you are interested only by branches named ""a"" and ""b"", do mytree.SetBranchStatus(""*"",0); //disable all branches; mytree.SetBranchStatus(""a"",1);; mytree.SetBranchStatus(""b"",1);; when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read.; WARNING!! If your Tree has been created in split mode with a parent branch ""parent."", mytree.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do: mytree.SetBranchStatus(""parent*"",1);; Without the trailing dot in the branch creation you have no choice but to call SetBranchStatus explicitly for each of the sub branches.; An alternative is to call directly brancha.GetEntry(i); branchb.GetEntry(i);; ; IMPORTANT NOTE; By default, GetEntry reuses the space allocated by the previous object for each branch. You can force the previous object to be automatically deleted if you call mybranch.SetAutoDelete(true) (default is false).; Example:; Consider the example in $ROOTSYS/test/Event.h The top level branch in the tree T is declared with: Event *event = 0; //event must be null or point to a valid object; //it must be initialized; T.SetBranchAddress(""event"",&event);; When reading the Tree, one can choose one of these 3 options:. OPTION 1; for (Long64_t i=0;i<nentries;i++) {; T.GetEntry(i);; // the object event has been filled at this point; }; The default (recommended). At the first entry an object of the class Event will be created and pointed by event. At the following entries, event will be overwritten by the new data. All internal members that are TObject* are automatically deleted. It is important that these members be in a valid state when GetEntry is called. Pointers must be correctly initialized. However these internal member",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:177278,Energy Efficiency,efficient,efficient,177278,"branchname' as if it was a data member; protection against array out-of-bounds errors; ability to use the branch data as an object (when the user code is available). For example with Event.root, if Double_t somePx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somePx will updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; These two functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example: Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; nconst Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:177443,Energy Efficiency,efficient,efficient,177443,"h the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; These two functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example: Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; nconst Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.; The default histogram is accessible via the variable named 'htemp'.; If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed include statements and give the abi",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:197456,Energy Efficiency,allocate,allocate,197456,"al . Remove a friend from the list of friends. ; Reimplemented in TChain.; Definition at line 7977 of file TTree.cxx. ◆ Reset(). void TTree::Reset ; (; Option_t * ; option = """"). virtual . Reset baskets, buffers and entries count in all branches and leaves. ; Reimplemented in TChain.; Definition at line 8003 of file TTree.cxx. ◆ ResetAfterMerge(). void TTree::ResetAfterMerge ; (; TFileMergeInfo * ; info). virtual . Resets the state of this TTree after a merge (keep the customization but forget the data). ; Reimplemented in TChain.; Definition at line 8034 of file TTree.cxx. ◆ ResetBranchAddress(). void TTree::ResetBranchAddress ; (; TBranch * ; br). virtual . Tell all of our branches to set their addresses to zero. ; Note: If any of our branches own any objects, they are deleted. ; Reimplemented in TChain, TNtuple, and TNtupleD.; Definition at line 8065 of file TTree.cxx. ◆ ResetBranchAddresses(). void TTree::ResetBranchAddresses ; (; ). virtual . Tell all of our branches to drop their current objects and allocate new ones. ; Reimplemented in TChain, TNtuple, and TNtupleD.; Definition at line 8075 of file TTree.cxx. ◆ Scan(). Long64_t TTree::Scan ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Loop over tree entries and print entries passing selection. . If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can be made using ""var1:var2:var3"". See alsoTTreePlayer::Scan for more information ; Reimplemented in TChain.; Definition at line 8094 of file TTree.cxx. ◆ SetAlias(). bool TTree::SetAlias ; (; const char * ; aliasName, . const char * ; aliasFormula . ). virtual . Set a tree variable alias. ; Set an alias for an expression/formula based on the tree 'variables'.; The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw, TTree::Scan, TTreeViewer) and will be ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:229577,Energy Efficiency,allocate,allocated,229577,tal bytes for the IMT flush baskets ; Definition at line 160 of file TTree.h. ◆ fIMTZipBytes. std::atomic<Long64_t> TTree::fIMTZipBytes. mutableprivate . ! Zip bytes for the IMT flush baskets. ; Definition at line 161 of file TTree.h. ◆ fIndex. TArrayI TTree::fIndex. protected . Index of sorted values. ; Definition at line 128 of file TTree.h. ◆ fIndexValues. TArrayD TTree::fIndexValues. protected . Sorted index values. ; Definition at line 127 of file TTree.h. ◆ fIOFeatures. TIOFeatures TTree::fIOFeatures {0}. protected . IO features to define for newly-written baskets and branches. ; Definition at line 114 of file TTree.h. ◆ fLeaves. TObjArray TTree::fLeaves. protected . Direct pointers to individual branch leaves. ; Definition at line 123 of file TTree.h. ◆ fMakeClass. Int_t TTree::fMakeClass. protected . ! not zero when processing code generated by MakeClass ; Definition at line 115 of file TTree.h. ◆ fMaxClusterRange. Int_t TTree::fMaxClusterRange. protected . ! Memory allocated for the cluster range. ; Definition at line 96 of file TTree.h. ◆ fMaxEntries. Long64_t TTree::fMaxEntries. protected . Maximum number of entries in case of circular buffers. ; Definition at line 97 of file TTree.h. ◆ fMaxEntryLoop. Long64_t TTree::fMaxEntryLoop. protected . Maximum number of entries to process. ; Definition at line 98 of file TTree.h. ◆ fMaxVirtualSize. Long64_t TTree::fMaxVirtualSize. protected . Maximum total size of buffers kept in memory. ; Definition at line 99 of file TTree.h. ◆ fNClusterRange. Int_t TTree::fNClusterRange. protected . Number of Cluster range in addition to the one defined by 'AutoFlush'. ; Definition at line 95 of file TTree.h. ◆ fNEntriesSinceSorting. UInt_t TTree::fNEntriesSinceSorting. protected . ! Number of entries processed since the last re-sorting of branches ; Definition at line 143 of file TTree.h. ◆ fNfill. Int_t TTree::fNfill. protected . ! Local for EntryLoop ; Definition at line 110 of file TTree.h. ◆ fNotify. TObject* TTree::fNotif,MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:38643,Integrability,interface,interface,38643,"T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr=nullptr);  Change branch address, dealing with clone trees properly. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual void SetBranchStatus (const char *bname, bool status=true, UInt_t *found=nullptr);  Set branch status to Process or DoNotProcess. ;  ; virtual Int_t SetCacheEntryRange (Long64_t first, Long64_t last);  interface to TTreeCache to set the cache entry range ;  ; virtual void SetCacheLearnEntries (Int_t n=10);  Interface to TTreeCache to set the number of entries for the learning phase. ;  ; virtual Int_t SetCacheSize (Long64_t cachesize=-1);  Set maximum size of the file cache . ;  ; virtual void SetChainOffset (Long64_t offset=0);  ; virtual void SetCircular (Long64_t maxEntries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual void SetDirectory (TDirectory *dir);  Change the tree's directory. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEntryList (TEntryList *list, Option_t *opt="""");  Set an EntryList. ;  ; virtual void SetEstimate (Long64_t nentri",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:45074,Integrability,message,message,45074," *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:45615,Integrability,message,message,45615,"putes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:46605,Integrability,message,message,46605,"ssue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ;  ; void Obsolete (const char *method, const char *a",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:49334,Integrability,message,message,49334,"is method must be overridden if a class wants to paint itself. ;  ; virtual void Pop ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t DistancetoLine (Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2);  Compute distance from point px,py to a line. ;  ; virtual Color_t GetLineColor () const;  Return the line color. ;  ; virtual Style_t GetLineStyle () const;  Return the line style. ;  ; virtual Width_t GetLineWidth () const;  Return the line width. ;  ; virtual void Modify ();  Change current line attributes if necessary. ;  ; virtual void ResetAttLine (",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:49525,Integrability,message,message,49525,"  Read contents of object with specified name from the current directory. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t DistancetoLine (Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2);  Compute distance from point px,py to a line. ;  ; virtual Color_t GetLineColor () const;  Return the line color. ;  ; virtual Style_t GetLineStyle () const;  Return the line style. ;  ; virtual Width_t GetLineWidth () const;  Return the line width. ;  ; virtual void Modify ();  Change current line attributes if necessary. ;  ; virtual void ResetAttLine (Option_t *option="""");  Reset this line attributes to default values. ;  ; virtual void SaveLineAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1); ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:106913,Integrability,rout,routines,106913,"Tree to a new TTree. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1; copytree2.C: A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1 . Reimplemented in TNtuple.; Definition at line 3139 of file TTree.cxx. ◆ CopyAddresses(). void TTree::CopyAddresses ; (; TTree * ; tree, . bool ; undo = false . ). virtual . Set branch addresses of passed tree equal to ours. ; If undo is true, reset the branch addresses instead of copying them. This ensures 'separation' of a cloned tree from its original. ; Definition at line 3299 of file TTree.cxx. ◆ CopyEntries(). Long64_t TTree::CopyEntries ; (; TTree * ; tree, . Long64_t ; nentries = -1, . Option_t * ; option = """", . bool ; needCopyAddresses = false . ). virtual . Copy nentries from given tree to this tree. ; This routines assumes that the branches that intended to be copied are already connected. The typical case is that this tree was created using tree->CloneTree(0).; By default copy all entries.; Returns number of bytes copied to this tree.; If 'option' contains the word 'fast' and nentries is -1, the cloning will be done without unzipping or unstreaming the baskets (i.e., a direct copy of the raw bytes on disk).; When 'fast' is specified, 'option' can also contains a sorting order for the baskets in the output file.; There are currently 3 supported sorting order:. SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. See TTree::CloneTree for a detailed explanation of the semantics of these 3 options.; If the tree or any of the underlying tree of the chain has an index, that index and any index in the subsequent underlying TTree objects will be merged.; There are currently three 'options' to control this merging:; NoIndex : all the TTreeIndex object are dropped.; DropIndexOnError : if any of the underlying T",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:127638,Integrability,interface,interface,127638,"visualize a bit more what elements would be matched by TTree::Draw, TTree::Scan can be used: tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be matched by tree->Draw(""arr1-Alt$(arr2,0)"");; The ternary operator is not directly supported in TTree::Draw however, to plot the equivalent of var2<20 ? -99 : var1, you can use: tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly; If the formula contains a file name, TTree::MakeProxy will be used to load and execute this file. In particular it will draw the result of a function with the same name as the file. The function will be executed in a context where the name of the branches can be used as a C++ variable.; For example draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; hsimpleDefinition hsimple.py:1; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; Drawth1 Draw(); A more complete example is available in the tutorials directory: h1analysisProxy.cxx, h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C; The main features of this facility are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bound; ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram; In case of a 2-Dim expression, one can generate a TProfile histogram instead of a TH2F histogram by specifying option=prof or option=profs or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of y:x>>pf where pf is an existing TProfile histog",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:131805,Integrability,interface,interface,131805,"ll create a TEventList object named ""yplus"" in the current directory. In an interactive session, one can type (after TTree::Draw) yplus.Print(""all""); to print the list of entry numbers in the list. tree.Draw("">>yplus"", ""y>0"", ""entrylist""); will create a TEntryList object names ""yplus"" in the current directory tree.Draw("">>yplus"", ""y>0"", ""entrylistarray""); will create a TEntryListArray object names ""yplus"" in the current directory; By default, the specified entry list is reset. To continue to append data to an existing list, use ""+"" in front of the list name; tree.Draw("">>+yplus"",""y>0""); will not reset yplus, but will enter the selected entries at the end of the existing list. Using a TEventList, TEntryList or TEntryListArray as Input; Once a TEventList or a TEntryList object has been generated, it can be used as input for TTree::Draw. Use TTree::SetEventList or TTree::SetEntryList to set the current event list; Example 1: TEventList *elist = (TEventList*)gDirectory->Get(""yplus"");; tree->SetEventList(elist);; tree->Draw(""py"");; TEventList<div class=""legacybox""><h2>Legacy Code</h2> TEventList is a legacy interface: there will be no bug fi...Definition TEventList.h:31; Example 2: TEntryList *elist = (TEntryList*)gDirectory->Get(""yplus"");; tree->SetEntryList(elist);; tree->Draw(""py"");; TEntryListA List of entry numbers in a TTree or TChain.Definition TEntryList.h:26; If a TEventList object is used as input, a new TEntryList object is created inside the SetEventList function. In case of a TChain, all tree headers are loaded for this transformation. This new object is owned by the chain and is deleted with it, unless the user extracts it by calling GetEntryList() function. See also comments to SetEventList() function of TTree and TChain.; If arrays are used in the selection criteria and TEntryListArray is not used, all the entries that have at least one element of the array that satisfy the selection are entered in the list.; Example: tree.Draw("">>pyplus"",""fTracks.fPy>0"");",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:135820,Integrability,interface,interface,135820,"Val() method.; creates a TGraph object with a number of points corresponding to the number of entries selected by the expression ""pz>4"", the x points of the graph being the px values of the Tree and the y points the py values.; Important note: By default TTree::Draw creates the arrays obtained with GetW, GetV1, GetV2, GetV3, GetV4, GetVal with a length corresponding to the parameter fEstimate. The content will be the last GetSelectedRows() % GetEstimate() values calculated. By default fEstimate=1000000 and can be modified via TTree::SetEstimate. To keep in memory all the results (in case where there is only one result per entry), use tree->SetEstimate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows you need to look at is greater than 1000000.; You can use the option ""goff"" to turn off the graphics output of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer; A complete graphical interface to this function is implemented in the class TTreeViewer. To start the TTreeViewer, three possibilities:; select TTree context menu item ""StartViewer""; type the command ""TTreeViewer TV(treeName)""; execute statement ""tree->StartViewer();"" . Reimplemented in TChain, and TProofChain.; Definition at line 4507 of file TTree.cxx. ◆ Draw() [2/3]. Long64_t TTree::Draw ; (; const char * ; varexp, . const TCut & ; selection, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Draw expression varexp for specified entries. ; Returns-1 in case of error or number of selected events in case of success.; This function accepts TCut objects as arguments. Useful to use the string operator +; Example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Reimplemented in TChain, and TProofChain.; Definition at line 3855 of file TTree.cxx. ◆ Draw() [3/3]. void TTree::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objec",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:135887,Integrability,interface,interface,135887,"Val() method.; creates a TGraph object with a number of points corresponding to the number of entries selected by the expression ""pz>4"", the x points of the graph being the px values of the Tree and the y points the py values.; Important note: By default TTree::Draw creates the arrays obtained with GetW, GetV1, GetV2, GetV3, GetV4, GetVal with a length corresponding to the parameter fEstimate. The content will be the last GetSelectedRows() % GetEstimate() values calculated. By default fEstimate=1000000 and can be modified via TTree::SetEstimate. To keep in memory all the results (in case where there is only one result per entry), use tree->SetEstimate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows you need to look at is greater than 1000000.; You can use the option ""goff"" to turn off the graphics output of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer; A complete graphical interface to this function is implemented in the class TTreeViewer. To start the TTreeViewer, three possibilities:; select TTree context menu item ""StartViewer""; type the command ""TTreeViewer TV(treeName)""; execute statement ""tree->StartViewer();"" . Reimplemented in TChain, and TProofChain.; Definition at line 4507 of file TTree.cxx. ◆ Draw() [2/3]. Long64_t TTree::Draw ; (; const char * ; varexp, . const TCut & ; selection, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Draw expression varexp for specified entries. ; Returns-1 in case of error or number of selected events in case of success.; This function accepts TCut objects as arguments. Useful to use the string operator +; Example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Reimplemented in TChain, and TProofChain.; Definition at line 3855 of file TTree.cxx. ◆ Draw() [3/3]. void TTree::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objec",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:144125,Integrability,interface,interface,144125,"e, it may decide to run another one of the user's tasks in this thread. If the second user task tries to acquire A, then a deadlock will occur. The example call sequence looks like this:. User acquires mutex A; User calls FlushBaskets.; ROOT launches N tasks and calls wait.; TBB schedules another user task, T2.; T2 tries to acquire mutex A. At this point, the thread will deadlock: the code may function with IMT-mode disabled if the user assumed the legacy code never would run their own TBB tasks.; SO: users of TBB who want to enable IMT-mode should carefully review their locking patterns and make sure they hold no coarse-grained application locks when they invoke ROOT.; Return the number of bytes written or -1 in case of write error. ; Definition at line 5129 of file TTree.cxx. ◆ FlushBasketsImpl(). Int_t TTree::FlushBasketsImpl ; (; ); const. private . Internal implementation of the FlushBaskets algorithm. ; Unlike the public interface, this does NOT create an explicit event cluster boundary; it is up to the (internal) caller to determine whether that should done.; Otherwise, the comments for FlushBaskets applies. ; Definition at line 5146 of file TTree.cxx. ◆ GetAlias(). const char * TTree::GetAlias ; (; const char * ; aliasName); const. virtual . Returns the expanded value of the alias. Search in the friends if any. ; Reimplemented in TChain.; Definition at line 5226 of file TTree.cxx. ◆ GetAllocationCount(). UInt_t TTree::GetAllocationCount ; (; ); const. inline . Definition at line 443 of file TTree.h. ◆ GetAutoFlush(). virtual Long64_t TTree::GetAutoFlush ; (; ); const. inlinevirtual . Definition at line 447 of file TTree.h. ◆ GetAutoSave(). virtual Long64_t TTree::GetAutoSave ; (; ); const. inlinevirtual . Definition at line 448 of file TTree.h. ◆ GetBranch(). TBranch * TTree::GetBranch ; (; const char * ; name). virtual . Return pointer to the branch with the given name in this tree or its friends. ; The search is done breadth first. ; Reimplemented in TProof",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:168881,Integrability,depend,depends,168881,"the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ; This is used when doing a fast cloning (by TTreeCloner). See also fAutoFlush and fAutoSave if needed. ; Definition at line 6372 of file TTree.cxx. ◆ IncrementTotalBuffers(). virtual void TTree::IncrementTotalBuffers ; (; Int_t ; nbytes). inlinevirtual . Definition at line 546 of file TTree.h. ◆ InitializeBranchLists(). void TTree::InitializeBranchLists ; (; bool ; checkLeafCount). private . Divides the top-level branches into two vectors: (i) branches to be processed sequentially and (ii) branches to be processed in parallel. ; Even if IMT is on, some branches might need to be processed first and in a sequential fashion: in the parallelization of GetEntry, those are the branches that store the size of another branch for every entry (e.g. the size of an array branch). If such branches were processed in parallel with the rest, there could be two threads invoking TBranch::GetEntry on one of them at the same time, since a branch that depends on a size (or count) branch will also invoke GetEntry on the latter. This method can be invoked several times during the event loop if the TTree is being written, for example when adding new branches. In these cases, the checkLeafCount parameter is false. Parameters. [in]checkLeafCountTrue if we need to check whether some branches are count leaves. . Definition at line 5781 of file TTree.cxx. ◆ InPlaceClone(). bool TTree::InPlaceClone ; (; TDirectory * ; newdirectory, . const char * ; options = """" . ). virtual . Copy the content to a new new file, update this TTree with the new location information and attach this TTree to the new directory. ; options: Indicates a basket sorting method, see TTreeCloner::TTreeCloner for details; If new and old directory are in the same file, the data is untouched, this ""just"" does a call to SetDirectory. Equivalent to an ""in place"" cloning of the TTree. ; Reimplemented in TChain.; Definition at line 7",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:178833,Integrability,interface,interface,178833,"thod (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.; The default histogram is accessible via the variable named 'htemp'.; If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed include statements and give the ability to access the object stored in the branches.; To draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C ; Definition at line 6768 of file TTree.cxx. ◆ MakeSelector(). Int_t TTree::MakeSelector ; (; const char * ; selector = nullptr, . Option_t * ; option = """" . ). virtual . Generate skeleton selector class for this tree. ; The following files are produced: selector.h and selector.C. If selector is 0, the selector will be called ""nameoftree"". The option can be used to specify the branches that will have a data member.; If option is ""=legacy"", a pre-ROOT6 selector will be generated (data members and branch pointers instead of TTreeReaders).; If option is empty, readers will be generated for each leaf.; If option is ""@"", readers will be generated for the topmost branches.; Individual branches can also be pic",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:206747,Integrability,message,message,206747,"split' you need to make sure the name of the top level branch is prefixed to the sub-branches' name (by adding a dot ('.') at the end of the Branch creation and use the corresponding bname.; I.e If your Tree has been created in split mode with a parent branch ""parent."" (note the trailing dot). T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do: T.SetBranchStatus(""parent*"",1);; Without the trailing dot in the branch creation you have no choice but to call SetBranchStatus explicitly for each of the sub branches.; An alternative to this function is to read directly and only the interesting branches. Example: TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);; TBranch::GetEntryvirtual Int_t GetEntry(Long64_t entry=0, Int_t getall=0)Read all leaves of entry and return total number of bytes read.Definition TBranch.cxx:1706; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cac",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:207190,Integrability,interface,interface,207190,"h of the sub branches.; An alternative to this function is to read directly and only the interesting branches. Example: TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);; TBranch::GetEntryvirtual Int_t GetEntry(Long64_t entry=0, Int_t getall=0)Read all leaves of entry and return total number of bytes read.Definition TBranch.cxx:1706; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an exist",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:217119,Integrability,interface,interface,217119,"line 9281 of file TTree.cxx. ◆ SetPerfStats(). void TTree::SetPerfStats ; (; TVirtualPerfStats * ; perf). virtual . Set perf stats. ; Definition at line 9319 of file TTree.cxx. ◆ SetScanField(). virtual void TTree::SetScanField ; (; Int_t ; n = 50). inlinevirtual . Definition at line 645 of file TTree.h. ◆ SetTargetMemoryRatio(). void TTree::SetTargetMemoryRatio ; (; Float_t ; ratio). inline . Definition at line 646 of file TTree.h. ◆ SetTimerInterval(). virtual void TTree::SetTimerInterval ; (; Int_t ; msec = 333). inlinevirtual . Definition at line 647 of file TTree.h. ◆ SetTreeIndex(). void TTree::SetTreeIndex ; (; TVirtualIndex * ; index). virtual . The current TreeIndex is replaced by the new index. ; Note that this function does not delete the previous index. This gives the possibility to play with more than one index, e.g., TVirtualIndex* oldIndex = tree.GetTreeIndex();; tree.SetTreeIndex(newIndex);; tree.Draw();; tree.SetTreeIndex(oldIndex);; tree.Draw(); etc; TVirtualIndexAbstract interface for Tree Index.Definition TVirtualIndex.h:30. Definition at line 9336 of file TTree.cxx. ◆ SetUpdate(). virtual void TTree::SetUpdate ; (; Int_t ; freq = 0). inlinevirtual . Definition at line 650 of file TTree.h. ◆ SetWeight(). void TTree::SetWeight ; (; Double_t ; w = 1, . Option_t * ; option = """" . ). virtual . Set tree weight. ; The weight is used by TTree::Draw to automatically weight each selected entry in the resulting histogram.; For example the equivalent of: T.Draw(""x"", ""w""); is: T.SetWeight(w);; T.Draw(""x"");; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; This function is redefined by TChain::SetWeight. In case of a TChain, an option ""global"" may be specified to set the same weight for all trees in the TChain instead of the default behaviour using the weights of each tree in the chain (see TChain::SetWeight). ; Reimplemented in TChain.; Definition at line 9364 of file TTree.cxx. ◆ Show(). void TTree::Show ; (; Long64_t ; entry = -1, . Int_t ; lenmax = 20 . )",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:2040,Modifiability,variab,variables,2040," if the file compression attribute is set (default). Branches may be written to different files (see TBranch::SetFile).; The ROOT user can decide to make one single branch and serialize one object into one single I/O buffer or to make several branches. Making several branches is particularly interesting in the data analysis phase, when it is desirable to have a high reading rate and not all columns are equally interesting. Create a TTree to store columnar data. Construct a TTree; Add a column of Fundamental Types and Arrays thereof; Add a column of a STL Collection instances; Add a column holding an object; Add a column holding a TObjectArray; Fill the tree; Add a column to an already existing Tree; An Example. Construct a TTree; TTree tree(name, title); namechar name[80]Definition TGX11.cxx:110; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Creates a Tree with name and title.; Various kinds of branches can be added to a tree:; Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran structures.; Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures. It is strongly recommended to persistify those as objects rather than lists of leaves.; auto branch = tree.Branch(branchname, address, leaflist, bufsize). address is the address of the first item of a structure; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type must be 1 character. (Characters after the first are legal and will be appended to the visible name of the leaf, but have no effect.) If no type is given, the type of the variable is assumed to be the sa",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:2351,Modifiability,variab,variables,2351," in the data analysis phase, when it is desirable to have a high reading rate and not all columns are equally interesting. Create a TTree to store columnar data. Construct a TTree; Add a column of Fundamental Types and Arrays thereof; Add a column of a STL Collection instances; Add a column holding an object; Add a column holding a TObjectArray; Fill the tree; Add a column to an already existing Tree; An Example. Construct a TTree; TTree tree(name, title); namechar name[80]Definition TGX11.cxx:110; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Creates a Tree with name and title.; Various kinds of branches can be added to a tree:; Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran structures.; Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures. It is strongly recommended to persistify those as objects rather than lists of leaves.; auto branch = tree.Branch(branchname, address, leaflist, bufsize). address is the address of the first item of a structure; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type must be 1 character. (Characters after the first are legal and will be appended to the visible name of the leaf, but have no effect.) If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : a",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:2651,Modifiability,variab,variable,2651," Add a column to an already existing Tree; An Example. Construct a TTree; TTree tree(name, title); namechar name[80]Definition TGX11.cxx:110; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Creates a Tree with name and title.; Various kinds of branches can be added to a tree:; Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran structures.; Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures. It is strongly recommended to persistify those as objects rather than lists of leaves.; auto branch = tree.Branch(branchname, address, leaflist, bufsize). address is the address of the first item of a structure; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type must be 1 character. (Characters after the first are legal and will be appended to the visible name of the leaf, but have no effect.) If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated f",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:2713,Modifiability,variab,variable,2713," Add a column to an already existing Tree; An Example. Construct a TTree; TTree tree(name, title); namechar name[80]Definition TGX11.cxx:110; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Creates a Tree with name and title.; Various kinds of branches can be added to a tree:; Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran structures.; Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures. It is strongly recommended to persistify those as objects rather than lists of leaves.; auto branch = tree.Branch(branchname, address, leaflist, bufsize). address is the address of the first item of a structure; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type must be 1 character. (Characters after the first are legal and will be appended to the visible name of the leaf, but have no effect.) If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated f",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:2735,Modifiability,variab,variable,2735," Add a column to an already existing Tree; An Example. Construct a TTree; TTree tree(name, title); namechar name[80]Definition TGX11.cxx:110; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Creates a Tree with name and title.; Various kinds of branches can be added to a tree:; Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran structures.; Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures. It is strongly recommended to persistify those as objects rather than lists of leaves.; auto branch = tree.Branch(branchname, address, leaflist, bufsize). address is the address of the first item of a structure; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type must be 1 character. (Characters after the first are legal and will be appended to the visible name of the leaf, but have no effect.) If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated f",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:2783,Modifiability,variab,variable,2783,".cxx:110; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Creates a Tree with name and title.; Various kinds of branches can be added to a tree:; Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran structures.; Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures. It is strongly recommended to persistify those as objects rather than lists of leaves.; auto branch = tree.Branch(branchname, address, leaflist, bufsize). address is the address of the first item of a structure; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type must be 1 character. (Characters after the first are legal and will be appended to the visible name of the leaf, but have no effect.) If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed inte",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:2968,Modifiability,variab,variable,2968,"nting fundamental types, simple classes/structures or list of variables: for example for C or Fortran structures.; Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures. It is strongly recommended to persistify those as objects rather than lists of leaves.; auto branch = tree.Branch(branchname, address, leaflist, bufsize). address is the address of the first item of a structure; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type must be 1 character. (Characters after the first are legal and will be appended to the visible name of the leaf, but have no effect.) If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integer, stored as 64 bit (Long_t); g : a long unsigned integer, stored as 64 bit (ULong_t); O : [the letter o, not a zero] a boolean (bool). Examples:; A int: ""myVar/I""; A float array ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:3019,Modifiability,variab,variable,3019,"nting fundamental types, simple classes/structures or list of variables: for example for C or Fortran structures.; Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures. It is strongly recommended to persistify those as objects rather than lists of leaves.; auto branch = tree.Branch(branchname, address, leaflist, bufsize). address is the address of the first item of a structure; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type must be 1 character. (Characters after the first are legal and will be appended to the visible name of the leaf, but have no effect.) If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integer, stored as 64 bit (Long_t); g : a long unsigned integer, stored as 64 bit (ULong_t); O : [the letter o, not a zero] a boolean (bool). Examples:; A int: ""myVar/I""; A float array ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:3042,Modifiability,variab,variable,3042," or Fortran structures.; Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures. It is strongly recommended to persistify those as objects rather than lists of leaves.; auto branch = tree.Branch(branchname, address, leaflist, bufsize). address is the address of the first item of a structure; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type must be 1 character. (Characters after the first are legal and will be appended to the visible name of the leaf, but have no effect.) If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integer, stored as 64 bit (Long_t); g : a long unsigned integer, stored as 64 bit (ULong_t); O : [the letter o, not a zero] a boolean (bool). Examples:; A int: ""myVar/I""; A float array with fixed size: ""myArrfloat[42]/F""; An double array with variable size, held by the myva",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:4037,Modifiability,variab,variable,4037,"ist of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integer, stored as 64 bit (Long_t); g : a long unsigned integer, stored as 64 bit (ULong_t); O : [the letter o, not a zero] a boolean (bool). Examples:; A int: ""myVar/I""; A float array with fixed size: ""myArrfloat[42]/F""; An double array with variable size, held by the myvar column: ""myArrdouble[myvar]/D""; An Double32_t array with variable size, held by the myvar column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; The myvar column, which holds the variable size, MUST be an Int_t (/I). If the address points to a single numerical variable, the leaflist is optional: int value;; tree->Branch(branchname, &value);; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142. If the address points to more than one numerical variable, we strongly recommend that the variable be sorted in decreasing order of size. Any other order will result in a non-portable TTree (i.e. you will not be able to read it back on a platform with a different padding strategy). We recommend to persistify objects rather than composite leaflists.; In case of the truncated floating point types (Float16_t and Double32_t) you can furthermore specify the range in the style [xmin,xma",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:4127,Modifiability,variab,variable,4127,"ist of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integer, stored as 64 bit (Long_t); g : a long unsigned integer, stored as 64 bit (ULong_t); O : [the letter o, not a zero] a boolean (bool). Examples:; A int: ""myVar/I""; A float array with fixed size: ""myArrfloat[42]/F""; An double array with variable size, held by the myvar column: ""myArrdouble[myvar]/D""; An Double32_t array with variable size, held by the myvar column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; The myvar column, which holds the variable size, MUST be an Int_t (/I). If the address points to a single numerical variable, the leaflist is optional: int value;; tree->Branch(branchname, &value);; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142. If the address points to more than one numerical variable, we strongly recommend that the variable be sorted in decreasing order of size. Any other order will result in a non-portable TTree (i.e. you will not be able to read it back on a platform with a different padding strategy). We recommend to persistify objects rather than composite leaflists.; In case of the truncated floating point types (Float16_t and Double32_t) you can furthermore specify the range in the style [xmin,xma",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:4257,Modifiability,variab,variable,4257,"ist of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integer, stored as 64 bit (Long_t); g : a long unsigned integer, stored as 64 bit (ULong_t); O : [the letter o, not a zero] a boolean (bool). Examples:; A int: ""myVar/I""; A float array with fixed size: ""myArrfloat[42]/F""; An double array with variable size, held by the myvar column: ""myArrdouble[myvar]/D""; An Double32_t array with variable size, held by the myvar column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; The myvar column, which holds the variable size, MUST be an Int_t (/I). If the address points to a single numerical variable, the leaflist is optional: int value;; tree->Branch(branchname, &value);; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142. If the address points to more than one numerical variable, we strongly recommend that the variable be sorted in decreasing order of size. Any other order will result in a non-portable TTree (i.e. you will not be able to read it back on a platform with a different padding strategy). We recommend to persistify objects rather than composite leaflists.; In case of the truncated floating point types (Float16_t and Double32_t) you can furthermore specify the range in the style [xmin,xma",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:4339,Modifiability,variab,variable,4339,"i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integer, stored as 64 bit (Long_t); g : a long unsigned integer, stored as 64 bit (ULong_t); O : [the letter o, not a zero] a boolean (bool). Examples:; A int: ""myVar/I""; A float array with fixed size: ""myArrfloat[42]/F""; An double array with variable size, held by the myvar column: ""myArrdouble[myvar]/D""; An Double32_t array with variable size, held by the myvar column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; The myvar column, which holds the variable size, MUST be an Int_t (/I). If the address points to a single numerical variable, the leaflist is optional: int value;; tree->Branch(branchname, &value);; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142. If the address points to more than one numerical variable, we strongly recommend that the variable be sorted in decreasing order of size. Any other order will result in a non-portable TTree (i.e. you will not be able to read it back on a platform with a different padding strategy). We recommend to persistify objects rather than composite leaflists.; In case of the truncated floating point types (Float16_t and Double32_t) you can furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after the type character. For example, for storing a variable size array myArr of Double32_t with values within a range of [0, 2*pi] and the size of which is stored in an Int_t (/I) branch called myArrSize, the syntax for the leaflist string would be: myArr[myArrSize]/d[0,twopi]. Of course the number of bits could be ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:4679,Modifiability,variab,variable,4679," 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integer, stored as 64 bit (Long_t); g : a long unsigned integer, stored as 64 bit (ULong_t); O : [the letter o, not a zero] a boolean (bool). Examples:; A int: ""myVar/I""; A float array with fixed size: ""myArrfloat[42]/F""; An double array with variable size, held by the myvar column: ""myArrdouble[myvar]/D""; An Double32_t array with variable size, held by the myvar column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; The myvar column, which holds the variable size, MUST be an Int_t (/I). If the address points to a single numerical variable, the leaflist is optional: int value;; tree->Branch(branchname, &value);; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142. If the address points to more than one numerical variable, we strongly recommend that the variable be sorted in decreasing order of size. Any other order will result in a non-portable TTree (i.e. you will not be able to read it back on a platform with a different padding strategy). We recommend to persistify objects rather than composite leaflists.; In case of the truncated floating point types (Float16_t and Double32_t) you can furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after the type character. For example, for storing a variable size array myArr of Double32_t with values within a range of [0, 2*pi] and the size of which is stored in an Int_t (/I) branch called myArrSize, the syntax for the leaflist string would be: myArr[myArrSize]/d[0,twopi]. Of course the number of bits could be specified, the standard rules of opaque typedefs annotation are valid. For example, if only 18 bits were sufficient, the syntax would become: myArr[myArrSize]/d[0,twopi,18]. Adding a column holding STL collection instances (e.g. std::vector",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:4720,Modifiability,variab,variable,4720," 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integer, stored as 64 bit (Long_t); g : a long unsigned integer, stored as 64 bit (ULong_t); O : [the letter o, not a zero] a boolean (bool). Examples:; A int: ""myVar/I""; A float array with fixed size: ""myArrfloat[42]/F""; An double array with variable size, held by the myvar column: ""myArrdouble[myvar]/D""; An Double32_t array with variable size, held by the myvar column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; The myvar column, which holds the variable size, MUST be an Int_t (/I). If the address points to a single numerical variable, the leaflist is optional: int value;; tree->Branch(branchname, &value);; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142. If the address points to more than one numerical variable, we strongly recommend that the variable be sorted in decreasing order of size. Any other order will result in a non-portable TTree (i.e. you will not be able to read it back on a platform with a different padding strategy). We recommend to persistify objects rather than composite leaflists.; In case of the truncated floating point types (Float16_t and Double32_t) you can furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after the type character. For example, for storing a variable size array myArr of Double32_t with values within a range of [0, 2*pi] and the size of which is stored in an Int_t (/I) branch called myArrSize, the syntax for the leaflist string would be: myArr[myArrSize]/d[0,twopi]. Of course the number of bits could be specified, the standard rules of opaque typedefs annotation are valid. For example, if only 18 bits were sufficient, the syntax would become: myArr[myArrSize]/d[0,twopi,18]. Adding a column holding STL collection instances (e.g. std::vector",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:4805,Modifiability,portab,portable,4805,"nteger, stored as 64 bit (Long_t); g : a long unsigned integer, stored as 64 bit (ULong_t); O : [the letter o, not a zero] a boolean (bool). Examples:; A int: ""myVar/I""; A float array with fixed size: ""myArrfloat[42]/F""; An double array with variable size, held by the myvar column: ""myArrdouble[myvar]/D""; An Double32_t array with variable size, held by the myvar column , with values between 0 and 16: ""myArr[myvar]/d[0,10]""; The myvar column, which holds the variable size, MUST be an Int_t (/I). If the address points to a single numerical variable, the leaflist is optional: int value;; tree->Branch(branchname, &value);; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142. If the address points to more than one numerical variable, we strongly recommend that the variable be sorted in decreasing order of size. Any other order will result in a non-portable TTree (i.e. you will not be able to read it back on a platform with a different padding strategy). We recommend to persistify objects rather than composite leaflists.; In case of the truncated floating point types (Float16_t and Double32_t) you can furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after the type character. For example, for storing a variable size array myArr of Double32_t with values within a range of [0, 2*pi] and the size of which is stored in an Int_t (/I) branch called myArrSize, the syntax for the leaflist string would be: myArr[myArrSize]/d[0,twopi]. Of course the number of bits could be specified, the standard rules of opaque typedefs annotation are valid. For example, if only 18 bits were sufficient, the syntax would become: myArr[myArrSize]/d[0,twopi,18]. Adding a column holding STL collection instances (e.g. std::vector, std::list, std::unordered_map); auto branch = tree.Branch( branchname, STLcollection, buffsize,",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:5192,Modifiability,variab,variable,5192,"I). If the address points to a single numerical variable, the leaflist is optional: int value;; tree->Branch(branchname, &value);; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142. If the address points to more than one numerical variable, we strongly recommend that the variable be sorted in decreasing order of size. Any other order will result in a non-portable TTree (i.e. you will not be able to read it back on a platform with a different padding strategy). We recommend to persistify objects rather than composite leaflists.; In case of the truncated floating point types (Float16_t and Double32_t) you can furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after the type character. For example, for storing a variable size array myArr of Double32_t with values within a range of [0, 2*pi] and the size of which is stored in an Int_t (/I) branch called myArrSize, the syntax for the leaflist string would be: myArr[myArrSize]/d[0,twopi]. Of course the number of bits could be specified, the standard rules of opaque typedefs annotation are valid. For example, if only 18 bits were sufficient, the syntax would become: myArr[myArrSize]/d[0,twopi,18]. Adding a column holding STL collection instances (e.g. std::vector, std::list, std::unordered_map); auto branch = tree.Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list, std::deque, std::set or std::multiset containing pointers to objects. If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers) then the collection will be written in split mode, e.g. if it contains objects of any types deriving from TTrack this function will sort the objects based on their type and store them in separate branches in split mode.; branch->SetAddress(void *address); In cas",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:9337,Modifiability,variab,variable,9337,"e. even though an object will be allocated by TTree::Branch if the pointer p_object is zero, the object will not be deleted when the TTree is deleted. Add a column holding TClonesArray instances; It is recommended to use STL containers instead of TClonesArrays*.; // clonesarray is the address of a pointer to a TClonesArray.; auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel); The TClonesArray is a direct access list of objects of the same class. For example, if the TClonesArray is an array of TTrack objects, this function will create one subbranch for each data member of the object TTrack. Fill the Tree; A TTree instance is filled with the invocation of the TTree::Fill method: tree.Fill(); Upon its invocation, a loop on all defined branches takes place that for each branch invokes the TBranch::Fill method. Add a column to an already existing Tree; You may want to add a branch to an existing tree. For example, if one variable in the tree was computed with a certain algorithm, you may want to try another algorithm and compare the results. One solution is to add a new branch, fill it, and save the tree. The code below adds a simple branch to an existing tree. Note the kOverwrite option in the Write method, it overwrites the existing tree. If it is not specified, two copies of the tree headers are saved. void tree3AddBranch() {; TFile f(""tree3.root"", ""update"");; ; Float_t new_v;; auto t3 = f->Get<TTree>(""t3"");; auto newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");; ; Long64_t nentries = t3->GetEntries(); // read the number of entries in the t3; ; for (Long64_t i = 0; i < nentries; i++) {; new_v = gRandom->Gaus(0, 1);; newBranch->Fill();; }; ; t3->Write("""", TObject::kOverwrite); // save only the new version of the tree; }; f#define f(i)Definition RSha256.hxx:104; Float_tfloat Float_tDefinition RtypesCore.h:57; Long64_tlong long Long64_tDefinition RtypesCore.h:80; nentriesint nentriesDefinition THbookFile.cxx:91; gRandomR__EXTERN TRandom * gRandomDef",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:19039,Modifiability,inherit,inherited,19039,".MyStruct(); ds.SetBranchAddress('structb', ms). Definition at line 79 of file TTree.h. Classes; class  TClusterIterator;  Helper class to iterate over cluster of baskets. More...;  ; class  TFriendLock;  Helper class to prevent infinite recursion in the usage of TTree Friends. More...;  . Public Types; enum  { kSplitCollectionOfPointers = 100; };  ; enum  ESetBranchAddressStatus { ;   kMissingBranch = -5; , kInternalError = -4; , kMissingCompiledCollectionProxy = -3; , kMismatch = -2; , ;   kClassMismatch = -1; , kMatch = 0; , kMatchConversion = 1; , kMatchConversionCollection = 2; , ;   kMakeClass = 3; , kVoidPtr = 4; , kNoCheck = 5; , kNeedEnableDecomposedObj = (1ULL << ( 29 )); , ;   kNeedDisableDecomposedObj = (1ULL << ( 30 )); , kDecomposedObjMask = kNeedEnableDecomposedObj | kNeedDisableDecomposedObj. };  ; enum  EStatusBits { kForceRead = (1ULL << ( 11 )); , kCircular = (1ULL << ( 12 )); , kOnlyFlushAtCluster = (1ULL << ( 14 )); , kEntriesReshuffled = (1ULL << ( 19 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTree ();  Default constructor and I/O constructor. ;  ;  TTree (const char *name, const char *title, Int_t splitlevel=99, TDirectory *dir=(::ROOT::Internal::TDirectoryAtomicAdapter{}));  Normal tree constructor. ;  ;  TTree (const TTree &tt)=delete;  ;  ~TTree () override;  Destructor. ;  ; void AddAllocationCount (UInt_t count);  ; vir",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:37229,Modifiability,variab,variable,37229,"e (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual void RemoveFriend (TTree *);  Remove a friend from the list of friends. ;  ; virtual void Reset (Option_t *option="""");  Reset baskets, buffers and entries count in all branches and leaves. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Resets the state of this TTree after a merge (keep the customization but forget the data). ;  ; virtual void ResetBranchAddress (TBranch *);  Tell all of our branches to set their addresses to zero. ;  ; virtual void ResetBranchAddresses ();  Tell all of our branches to drop their current objects and allocate new ones. ;  ; virtual Long64_t Scan (const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop over tree entries and print entries passing selection. ;  ; virtual bool SetAlias (const char *aliasName, const char *aliasFormula);  Set a tree variable alias. ;  ; virtual void SetAutoFlush (Long64_t autof=-30000000);  This function may be called at the start of a program to change the default value for fAutoFlush. ;  ; virtual void SetAutoSave (Long64_t autos=-300000000);  In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ;  ; virtual void SetBasketSize (const char *bname, Int_t buffsize=16000);  Set a branch's basket size. ;  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr=nullptr);  Change branch ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:39746,Modifiability,variab,variable,39746,"al void SetCacheLearnEntries (Int_t n=10);  Interface to TTreeCache to set the number of entries for the learning phase. ;  ; virtual Int_t SetCacheSize (Long64_t cachesize=-1);  Set maximum size of the file cache . ;  ; virtual void SetChainOffset (Long64_t offset=0);  ; virtual void SetCircular (Long64_t maxEntries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual void SetDirectory (TDirectory *dir);  Change the tree's directory. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEntryList (TEntryList *list, Option_t *opt="""");  Set an EntryList. ;  ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetEventList (TEventList *list);  This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TTree and gets deleted when the tree is deleted. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void SetImplicitMT (bool enabled);  ; ROOT::TIOFeatures SetIOFeatures (const ROOT::TIOFeatures &);  Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ;  ; virtual void SetMakeClass (Int_t make);  Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode). ;  ; virtual void SetMaxEntryLoop (Long64_t maxev=kMaxEntries);  ; virtual void SetMaxVirtualSize (Long64_t size=0);  ; void SetName (const char *name) override;  Change the name of this tree. ;  ; virtual void SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is lo",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:41987,Modifiability,variab,variable,41987,"pt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void SetWeight (Double_t w=1, Option_t *option="""");  Set tree weight. ;  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning phase. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t UnbinnedFit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Unbinned fit of one or more variable(s) from a tree. ;  ; void UseCurrentStyle () override;  Replace current attributes by current style. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write this object to the current directory. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:42397,Modifiability,inherit,inherited,42397,"x=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning phase. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t UnbinnedFit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Unbinned fit of one or more variable(s) from a tree. ;  ; void UseCurrentStyle () override;  Replace current attributes by current style. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write this object to the current directory. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:43866,Modifiability,inherit,inherited,43866," ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:44704,Modifiability,inherit,inheritance,44704,"zeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in de",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:46703,Modifiability,inherit,inherits,46703,"e) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ;  ; void Obsolete (const char *method, const char *asOfVers, const char *removedFromVers) const;  Use this method to declare a ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:46820,Modifiability,inherit,inherits,46820,"t be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ;  ; void Obsolete (const char *method, const char *asOfVers, const char *removedFromVers) const;  Use this method to declare a method obsolete. ;  ; void operator delete (void *ptr);  Operator delete. ;  ; void operator delete (void *ptr, void",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:49564,Modifiability,inherit,inherited,49564,"rectory. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t DistancetoLine (Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2);  Compute distance from point px,py to a line. ;  ; virtual Color_t GetLineColor () const;  Return the line color. ;  ; virtual Style_t GetLineStyle () const;  Return the line style. ;  ; virtual Width_t GetLineWidth () const;  Return the line width. ;  ; virtual void Modify ();  Change current line attributes if necessary. ;  ; virtual void ResetAttLine (Option_t *option="""");  Reset this line attributes to default values. ;  ; virtual void SaveLineAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1);  Save line attributes as C++ statement(s) on output stream out. ; ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:51069,Modifiability,inherit,inherited,51069,";  Return the line color. ;  ; virtual Style_t GetLineStyle () const;  Return the line style. ;  ; virtual Width_t GetLineWidth () const;  Return the line width. ;  ; virtual void Modify ();  Change current line attributes if necessary. ;  ; virtual void ResetAttLine (Option_t *option="""");  Reset this line attributes to default values. ;  ; virtual void SaveLineAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1);  Save line attributes as C++ statement(s) on output stream out. ;  ; virtual void SetLineAttributes ();  Invoke the DialogCanvas Line attributes. ;  ; virtual void SetLineColor (Color_t lcolor);  Set the line color. ;  ; virtual void SetLineColorAlpha (Color_t lcolor, Float_t lalpha);  Set a transparent line color. ;  ; virtual void SetLineStyle (Style_t lstyle);  Set the line style. ;  ; virtual void SetLineWidth (Width_t lwidth);  Set the line width. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAttFill;  TAttFill ();  AttFill default constructor. ;  ;  TAttFill (Color_t fcolor, Style_t fstyle);  AttFill normal constructor. ;  ; virtual ~TAttFill ();  AttFill destructor. ;  ; void Copy (TAttFill &attfill) const;  Copy this fill attributes to a new TAttFill. ;  ; virtual Color_t GetFillColor () const;  Return the fill area color. ;  ; virtual Style_t GetFillStyle () const;  Return the fill area style. ;  ; virtual Bool_t IsTransparent () const;  ; virtual void Modify ();  Change current fill area attributes if necessary. ;  ; virtual void ResetAttFill (Option_t *option="""");  Reset this fill attributes to default values. ;  ; virtual void SaveFillAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1001);  Save fill attributes as C++ statement(s) on output stream out. ;  ; virtual void SetFillAttributes ();  Invoke the DialogCanvas Fill attributes. ;  ; virtual void SetFillColor (Color_t fcolor);  Set the fill area color. ; ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:52324,Modifiability,inherit,inherited,52324,"his fill attributes to a new TAttFill. ;  ; virtual Color_t GetFillColor () const;  Return the fill area color. ;  ; virtual Style_t GetFillStyle () const;  Return the fill area style. ;  ; virtual Bool_t IsTransparent () const;  ; virtual void Modify ();  Change current fill area attributes if necessary. ;  ; virtual void ResetAttFill (Option_t *option="""");  Reset this fill attributes to default values. ;  ; virtual void SaveFillAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1001);  Save fill attributes as C++ statement(s) on output stream out. ;  ; virtual void SetFillAttributes ();  Invoke the DialogCanvas Fill attributes. ;  ; virtual void SetFillColor (Color_t fcolor);  Set the fill area color. ;  ; virtual void SetFillColorAlpha (Color_t fcolor, Float_t falpha);  Set a transparent fill color. ;  ; virtual void SetFillStyle (Style_t fstyle);  Set the fill area style. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAttMarker;  TAttMarker ();  TAttMarker default constructor. ;  ;  TAttMarker (Color_t color, Style_t style, Size_t msize);  TAttMarker normal constructor. ;  ; virtual ~TAttMarker ();  TAttMarker destructor. ;  ; void Copy (TAttMarker &attmarker) const;  Copy this marker attributes to a new TAttMarker. ;  ; virtual Color_t GetMarkerColor () const;  Return the marker color. ;  ; virtual Size_t GetMarkerSize () const;  Return the marker size. ;  ; virtual Style_t GetMarkerStyle () const;  Return the marker style. ;  ; virtual void Modify ();  Change current marker attributes if necessary. ;  ; virtual void ResetAttMarker (Option_t *toption="""");  Reset this marker attributes to the default values. ;  ; virtual void SaveMarkerAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t sizdef=1);  Save line attributes as C++ statement(s) on output stream out. ;  ; virtual void SetMarkerAttributes ();  Invoke the DialogCanvas Marker attrib",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:54478,Modifiability,inherit,inherited,54478," &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetBranchStyle ();  Static function returning the current branch style. ;  ; static Long64_t GetMaxTreeSize ();  Static function which returns the tree file size limit in bytes. ;  ; static TTree * MergeTrees (TList *list, Option_t *option="""");  Static function merging the trees in the TList into a new tree. ;  ; static void SetBranchStyle (Int_t style=1);  Set the current branch style. ;  ; static void SetMaxTreeSize (Long64_t maxsize=100000000000LL);  Set the maximum size in bytes of a Tree file (static function). ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttMarker; static TClass * Class ();  ;",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:54688,Modifiability,inherit,inherited,54688," &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetBranchStyle ();  Static function returning the current branch style. ;  ; static Long64_t GetMaxTreeSize ();  Static function which returns the tree file size limit in bytes. ;  ; static TTree * MergeTrees (TList *list, Option_t *option="""");  Static function merging the trees in the TList into a new tree. ;  ; static void SetBranchStyle (Int_t style=1);  Set the current branch style. ;  ; static void SetMaxTreeSize (Long64_t maxsize=100000000000LL);  Set the maximum size in bytes of a Tree file (static function). ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttMarker; static TClass * Class ();  ;",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:55206,Modifiability,inherit,inherited,55206,"e ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttMarker; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Static Public Attributes; static constexpr Long64_t kMaxEntries = TVirtualTreePlayer::kMaxEntries;  . Protected Types; enum  ELockStatusBits { ;   kFindBranch = (1ULL << ( 0 )); , kFindLeaf = (1ULL << ( 1 )); , kGetAlias = (1ULL << ( 2 )); , kGetBranch = (1ULL << ( 3 )); , ;   kGetEntry = (1ULL << ( 4 )); , kGetEntryWithIndex = (1ULL << ( 5 )); , kGetFriend = (1ULL << ( 6 )); , kGetFriendAlias = (1ULL << ( 7 )); , ;   kGetLeaf = (1ULL << ( 8 )); , kLoadTree = (1ULL << ( 9 )); , kPrint = (1ULL << ( 10 )); , kRe",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:55418,Modifiability,inherit,inherited,55418,"e ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttMarker; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Static Public Attributes; static constexpr Long64_t kMaxEntries = TVirtualTreePlayer::kMaxEntries;  . Protected Types; enum  ELockStatusBits { ;   kFindBranch = (1ULL << ( 0 )); , kFindLeaf = (1ULL << ( 1 )); , kGetAlias = (1ULL << ( 2 )); , kGetBranch = (1ULL << ( 3 )); , ;   kGetEntry = (1ULL << ( 4 )); , kGetEntryWithIndex = (1ULL << ( 5 )); , kGetFriend = (1ULL << ( 6 )); , kGetFriendAlias = (1ULL << ( 7 )); , ;   kGetLeaf = (1ULL << ( 8 )); , kLoadTree = (1ULL << ( 9 )); , kPrint = (1ULL << ( 10 )); , kRe",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:55630,Modifiability,inherit,inherited,55630,"e ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttLine; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttFill; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TAttMarker; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Static Public Attributes; static constexpr Long64_t kMaxEntries = TVirtualTreePlayer::kMaxEntries;  . Protected Types; enum  ELockStatusBits { ;   kFindBranch = (1ULL << ( 0 )); , kFindLeaf = (1ULL << ( 1 )); , kGetAlias = (1ULL << ( 2 )); , kGetBranch = (1ULL << ( 3 )); , ;   kGetEntry = (1ULL << ( 4 )); , kGetEntryWithIndex = (1ULL << ( 5 )); , kGetFriend = (1ULL << ( 6 )); , kGetFriendAlias = (1ULL << ( 7 )); , ;   kGetLeaf = (1ULL << ( 8 )); , kLoadTree = (1ULL << ( 9 )); , kPrint = (1ULL << ( 10 )); , kRe",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:56745,Modifiability,inherit,inherited,56745,"  ; static const char * DeclFileName ();  ; static Width_t GetMarkerLineWidth (Style_t style);  Internal helper function that returns the line width of the given marker style (0 = filled marker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Static Public Attributes; static constexpr Long64_t kMaxEntries = TVirtualTreePlayer::kMaxEntries;  . Protected Types; enum  ELockStatusBits { ;   kFindBranch = (1ULL << ( 0 )); , kFindLeaf = (1ULL << ( 1 )); , kGetAlias = (1ULL << ( 2 )); , kGetBranch = (1ULL << ( 3 )); , ;   kGetEntry = (1ULL << ( 4 )); , kGetEntryWithIndex = (1ULL << ( 5 )); , kGetFriend = (1ULL << ( 6 )); , kGetFriendAlias = (1ULL << ( 7 )); , ;   kGetLeaf = (1ULL << ( 8 )); , kLoadTree = (1ULL << ( 9 )); , kPrint = (1ULL << ( 10 )); , kRemoveFriend = (1ULL << ( 11 )); , ;   kSetBranchStatus = (1ULL << ( 12 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:59298,Modifiability,inherit,inherited,59298,". ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ;  ; Long64_t fAutoSave;  Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ;  ; TObjArray fBranches;  List of Branches. ;  ; TBranchRef * fBranchRef;  Branch supporting the TRefTable (if any) ;  ; bool fCacheDoAutoInit;  ! true if cache auto creation or resize check is needed ;  ; bool fCacheDoClusterPrefetch;  ! true if cache is prefetching whole clusters ;  ; Long64_t fCacheSize;  ! Maximum size of file buffers ;  ; bool fCacheUserSet;  ! true if the cache setting was explicitly g",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:64186,Modifiability,inherit,inherited,64186,"td::vector< std::pair< Long64_t, TBranch * > > fSortedBranches;  ! Branches to be processed in parallel when IMT is on, sorted by average task time ;  ; Float_t fTargetMemoryRatio {1.1f};  ! Ratio for memory usage in uncompressed buffers versus actual occupancy. ;  ; Int_t fTimerInterval;  Timer interval in milliseconds. ;  ; std::atomic< Long64_t > fTotalBuffers;  ! Total number of bytes in branch buffers ;  ; Long64_t fTotBytes;  Total number of bytes in all branches before compression. ;  ; TBuffer * fTransientBuffer;  ! Pointer to the current transient buffer. ;  ; TVirtualIndex * fTreeIndex;  Pointer to the tree Index (if any) ;  ; Int_t fUpdate;  Update frequency for EntryLoop. ;  ; TList * fUserInfo;  pointer to a list of user objects associated to this Tree ;  ; Double_t fWeight;  Tree weight (see TTree::SetWeight) ;  ; Long64_t fZipBytes;  Total number of bytes in all branches after compression. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fFillColor;  Fill area color. ;  ; Style_t fFillStyle;  Fill area style. ;  ;  Protected Attributes inherited from TAttMarker; Color_t fMarkerColor;  Marker color. ;  ; Size_t fMarkerSize;  Marker size. ;  ; Style_t fMarkerStyle;  Marker style. ;  . Static Protected Attributes; static Int_t fgBranchStyle = 1;  Old/New branch style. ;  ; static Long64_t fgMaxTreeSize = 100000000000LL;  Maximum size of a file containing a Tree. ;  . Private Types; using TIOFeatures = ROOT::TIOFeatures;  . Private Member Functions; Int_t FlushBasketsImpl () const;  Internal implementation of the FlushBaskets algorithm. ;  ; Long64_t GetMedianClusterSize ();  Estimate the median cluster size for the TTree. ;  ; void InitializeBranchLists (bool checkLeafCount);  Divides the top-level branche",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:64268,Modifiability,inherit,inherited,64268,"td::vector< std::pair< Long64_t, TBranch * > > fSortedBranches;  ! Branches to be processed in parallel when IMT is on, sorted by average task time ;  ; Float_t fTargetMemoryRatio {1.1f};  ! Ratio for memory usage in uncompressed buffers versus actual occupancy. ;  ; Int_t fTimerInterval;  Timer interval in milliseconds. ;  ; std::atomic< Long64_t > fTotalBuffers;  ! Total number of bytes in branch buffers ;  ; Long64_t fTotBytes;  Total number of bytes in all branches before compression. ;  ; TBuffer * fTransientBuffer;  ! Pointer to the current transient buffer. ;  ; TVirtualIndex * fTreeIndex;  Pointer to the tree Index (if any) ;  ; Int_t fUpdate;  Update frequency for EntryLoop. ;  ; TList * fUserInfo;  pointer to a list of user objects associated to this Tree ;  ; Double_t fWeight;  Tree weight (see TTree::SetWeight) ;  ; Long64_t fZipBytes;  Total number of bytes in all branches after compression. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fFillColor;  Fill area color. ;  ; Style_t fFillStyle;  Fill area style. ;  ;  Protected Attributes inherited from TAttMarker; Color_t fMarkerColor;  Marker color. ;  ; Size_t fMarkerSize;  Marker size. ;  ; Style_t fMarkerStyle;  Marker style. ;  . Static Protected Attributes; static Int_t fgBranchStyle = 1;  Old/New branch style. ;  ; static Long64_t fgMaxTreeSize = 100000000000LL;  Maximum size of a file containing a Tree. ;  . Private Types; using TIOFeatures = ROOT::TIOFeatures;  . Private Member Functions; Int_t FlushBasketsImpl () const;  Internal implementation of the FlushBaskets algorithm. ;  ; Long64_t GetMedianClusterSize ();  Estimate the median cluster size for the TTree. ;  ; void InitializeBranchLists (bool checkLeafCount);  Divides the top-level branche",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:64429,Modifiability,inherit,inherited,64429,ry usage in uncompressed buffers versus actual occupancy. ;  ; Int_t fTimerInterval;  Timer interval in milliseconds. ;  ; std::atomic< Long64_t > fTotalBuffers;  ! Total number of bytes in branch buffers ;  ; Long64_t fTotBytes;  Total number of bytes in all branches before compression. ;  ; TBuffer * fTransientBuffer;  ! Pointer to the current transient buffer. ;  ; TVirtualIndex * fTreeIndex;  Pointer to the tree Index (if any) ;  ; Int_t fUpdate;  Update frequency for EntryLoop. ;  ; TList * fUserInfo;  pointer to a list of user objects associated to this Tree ;  ; Double_t fWeight;  Tree weight (see TTree::SetWeight) ;  ; Long64_t fZipBytes;  Total number of bytes in all branches after compression. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fFillColor;  Fill area color. ;  ; Style_t fFillStyle;  Fill area style. ;  ;  Protected Attributes inherited from TAttMarker; Color_t fMarkerColor;  Marker color. ;  ; Size_t fMarkerSize;  Marker size. ;  ; Style_t fMarkerStyle;  Marker style. ;  . Static Protected Attributes; static Int_t fgBranchStyle = 1;  Old/New branch style. ;  ; static Long64_t fgMaxTreeSize = 100000000000LL;  Maximum size of a file containing a Tree. ;  . Private Types; using TIOFeatures = ROOT::TIOFeatures;  . Private Member Functions; Int_t FlushBasketsImpl () const;  Internal implementation of the FlushBaskets algorithm. ;  ; Long64_t GetMedianClusterSize ();  Estimate the median cluster size for the TTree. ;  ; void InitializeBranchLists (bool checkLeafCount);  Divides the top-level branches into two vectors: (i) branches to be processed sequentially and (ii) branches to be processed in parallel. ;  ; void MarkEventCluster ();  Mark the previous event as being at the end of the event cluste,MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:64562,Modifiability,inherit,inherited,64562,c< Long64_t > fTotalBuffers;  ! Total number of bytes in branch buffers ;  ; Long64_t fTotBytes;  Total number of bytes in all branches before compression. ;  ; TBuffer * fTransientBuffer;  ! Pointer to the current transient buffer. ;  ; TVirtualIndex * fTreeIndex;  Pointer to the tree Index (if any) ;  ; Int_t fUpdate;  Update frequency for EntryLoop. ;  ; TList * fUserInfo;  pointer to a list of user objects associated to this Tree ;  ; Double_t fWeight;  Tree weight (see TTree::SetWeight) ;  ; Long64_t fZipBytes;  Total number of bytes in all branches after compression. ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fFillColor;  Fill area color. ;  ; Style_t fFillStyle;  Fill area style. ;  ;  Protected Attributes inherited from TAttMarker; Color_t fMarkerColor;  Marker color. ;  ; Size_t fMarkerSize;  Marker size. ;  ; Style_t fMarkerStyle;  Marker style. ;  . Static Protected Attributes; static Int_t fgBranchStyle = 1;  Old/New branch style. ;  ; static Long64_t fgMaxTreeSize = 100000000000LL;  Maximum size of a file containing a Tree. ;  . Private Types; using TIOFeatures = ROOT::TIOFeatures;  . Private Member Functions; Int_t FlushBasketsImpl () const;  Internal implementation of the FlushBaskets algorithm. ;  ; Long64_t GetMedianClusterSize ();  Estimate the median cluster size for the TTree. ;  ; void InitializeBranchLists (bool checkLeafCount);  Divides the top-level branches into two vectors: (i) branches to be processed sequentially and (ii) branches to be processed in parallel. ;  ; void MarkEventCluster ();  Mark the previous event as being at the end of the event cluster. ;  ; void SortBranchesByTime ();  Sorts top-level branches by the last average task time recorded per branch. ;  . Private Attribut,MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:70545,Modifiability,variab,variable,70545,"; TBranch * ; b, . bool ; subbranches = false . ). virtual . Add branch b to the Tree cache. ; if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (current directory); adds the Tree to the list of friends see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file. When a TFriendElement TF is added to the list of friends of an existing TTree T, any variable from TF can be referenced in a query to T.; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The tree in the diagram below has two friends (friend_tree1 and friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfi",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:71003,Modifiability,variab,variables,71003,"r when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (current directory); adds the Tree to the list of friends see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file. When a TFriendElement TF is added to the list of friends of an existing TTree T, any variable from TF can be referenced in a query to T.; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The tree in the diagram below has two friends (friend_tree1 and friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in the Draw method, use the syntax: <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable ""var"" in the TTree tree versus variable ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:71609,Modifiability,variab,variables,71609,"ry to T.; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The tree in the diagram below has two friends (friend_tree1 and friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in the Draw method, use the syntax: <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable ""var"" in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; . The picture illustrates the access of the tree and its friends with a Draw command. When AddFriend is called, the ROOT file is automatically opened and the friend tree (ft1) is read into memory. The new friend (ft1) is added to the list of friends of tree. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries a warning is given and the missing entries are not ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:71753,Modifiability,variab,variablename,71753," taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The tree in the diagram below has two friends (friend_tree1 and friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in the Draw method, use the syntax: <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable ""var"" in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; . The picture illustrates the access of the tree and its friends with a Draw command. When AddFriend is called, the ROOT file is automatically opened and the friend tree (ft1) is read into memory. The new friend (ft1) is added to the list of friends of tree. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries a warning is given and the missing entries are not included in the histogram. To retrieve the list of friends from a tree use TTree::GetListOfFriends. When the tree is written to file (TTree::Write), the friends list is saved with it. And when the tree is re",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:71801,Modifiability,variab,variable,71801," taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The tree in the diagram below has two friends (friend_tree1 and friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in the Draw method, use the syntax: <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable ""var"" in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; . The picture illustrates the access of the tree and its friends with a Draw command. When AddFriend is called, the ROOT file is automatically opened and the friend tree (ft1) is read into memory. The new friend (ft1) is added to the list of friends of tree. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries a warning is given and the missing entries are not included in the histogram. To retrieve the list of friends from a tree use TTree::GetListOfFriends. When the tree is written to file (TTree::Write), the friends list is saved with it. And when the tree is re",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:71917,Modifiability,variab,variable,71917,"o friends (friend_tree1 and friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in the Draw method, use the syntax: <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable ""var"" in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; . The picture illustrates the access of the tree and its friends with a Draw command. When AddFriend is called, the ROOT file is automatically opened and the friend tree (ft1) is read into memory. The new friend (ft1) is added to the list of friends of tree. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries a warning is given and the missing entries are not included in the histogram. To retrieve the list of friends from a tree use TTree::GetListOfFriends. When the tree is written to file (TTree::Write), the friends list is saved with it. And when the tree is retrieved, the trees on the friends list are also retrieved and the friendship restored. When a tree is deleted, the elements of the friend li",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:71957,Modifiability,variab,variable,71957,"o friends (friend_tree1 and friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in the Draw method, use the syntax: <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable ""var"" in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; . The picture illustrates the access of the tree and its friends with a Draw command. When AddFriend is called, the ROOT file is automatically opened and the friend tree (ft1) is read into memory. The new friend (ft1) is added to the list of friends of tree. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries a warning is given and the missing entries are not included in the histogram. To retrieve the list of friends from a tree use TTree::GetListOfFriends. When the tree is written to file (TTree::Write), the friends list is saved with it. And when the tree is retrieved, the trees on the friends list are also retrieved and the friendship restored. When a tree is deleted, the elements of the friend li",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:71989,Modifiability,variab,variable,71989,"o friends (friend_tree1 and friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in the Draw method, use the syntax: <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable ""var"" in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; . The picture illustrates the access of the tree and its friends with a Draw command. When AddFriend is called, the ROOT file is automatically opened and the friend tree (ft1) is read into memory. The new friend (ft1) is added to the list of friends of tree. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries a warning is given and the missing entries are not included in the histogram. To retrieve the list of friends from a tree use TTree::GetListOfFriends. When the tree is written to file (TTree::Write), the friends list is saved with it. And when the tree is retrieved, the trees on the friends list are also retrieved and the friendship restored. When a tree is deleted, the elements of the friend li",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:76956,Modifiability,variab,variables,76956,"Tree::FlushBaskets is called and all the current basket are closed-out and written to disk individually.; By default the previous header is deleted after having written the new header. if option contains ""Overwrite"", the previous Tree header is deleted before written the new header. This option is slightly faster, but the default option is safer in case of a problem (disk quota exceeded) when writing the new header.; The function returns the number of bytes written to the file. if the number of bytes is null, an error has occurred while writing the header to the file. How to write a Tree in one process and view it from another process; The following two scripts illustrate how to do this. The script treew.C is executed by process1, treer.C by process2; script treew.C: void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TTree::AutoSavevirtual Long64_t AutoSave(Option_t *option="""")AutoSave tree header every fAutoSave bytes.Definition TTree.cxx:1500; int; script treer.C: void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:555",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:83853,Modifiability,variab,variables,83853,"ll(), the current value of the type/object will be saved. ; [in]bufsizeThe buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc. The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes). A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode. ; [in]splitlevelIf T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 353 of file TTree.h. ◆ Branch() [11/13]. TBranch * TTree::Branch ; (; const char * ; name, . void * ; address, . const char * ; leaflist, . Int_t ; bufsize = 32000 . ). virtual . Create a new TTree Branch. ; This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file. address is the address of the first item of a structure.; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type may be 0,1 or 2 characters. If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:83899,Modifiability,variab,variables,83899,"ll(), the current value of the type/object will be saved. ; [in]bufsizeThe buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc. The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes). A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode. ; [in]splitlevelIf T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 353 of file TTree.h. ◆ Branch() [11/13]. TBranch * TTree::Branch ; (; const char * ; name, . void * ; address, . const char * ; leaflist, . Int_t ; bufsize = 32000 . ). virtual . Create a new TTree Branch. ; This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file. address is the address of the first item of a structure.; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type may be 0,1 or 2 characters. If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:84214,Modifiability,variab,variable,84214,"eneficial if entries in the Tree are accessed randomly and the Tree is in split mode. ; [in]splitlevelIf T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 353 of file TTree.h. ◆ Branch() [11/13]. TBranch * TTree::Branch ; (; const char * ; name, . void * ; address, . const char * ; leaflist, . Int_t ; bufsize = 32000 . ). virtual . Create a new TTree Branch. ; This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file. address is the address of the first item of a structure.; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type may be 0,1 or 2 characters. If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:84276,Modifiability,variab,variable,84276,"eneficial if entries in the Tree are accessed randomly and the Tree is in split mode. ; [in]splitlevelIf T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 353 of file TTree.h. ◆ Branch() [11/13]. TBranch * TTree::Branch ; (; const char * ; name, . void * ; address, . const char * ; leaflist, . Int_t ; bufsize = 32000 . ). virtual . Create a new TTree Branch. ; This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file. address is the address of the first item of a structure.; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type may be 0,1 or 2 characters. If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:84298,Modifiability,variab,variable,84298,"eneficial if entries in the Tree are accessed randomly and the Tree is in split mode. ; [in]splitlevelIf T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 353 of file TTree.h. ◆ Branch() [11/13]. TBranch * TTree::Branch ; (; const char * ; name, . void * ; address, . const char * ; leaflist, . Int_t ; bufsize = 32000 . ). virtual . Create a new TTree Branch. ; This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file. address is the address of the first item of a structure.; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type may be 0,1 or 2 characters. If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:84346,Modifiability,variab,variable,84346,"s a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 353 of file TTree.h. ◆ Branch() [11/13]. TBranch * TTree::Branch ; (; const char * ; name, . void * ; address, . const char * ; leaflist, . Int_t ; bufsize = 32000 . ). virtual . Create a new TTree Branch. ; This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file. address is the address of the first item of a structure.; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type may be 0,1 or 2 characters. If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integer, stored as 64 bit (Long_t); g : a long unsigned integer, stored as 64 bit (ULong_t); O : [the letter o, n",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:84425,Modifiability,variab,variable,84425,"rialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 353 of file TTree.h. ◆ Branch() [11/13]. TBranch * TTree::Branch ; (; const char * ; name, . void * ; address, . const char * ; leaflist, . Int_t ; bufsize = 32000 . ). virtual . Create a new TTree Branch. ; This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file. address is the address of the first item of a structure.; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type may be 0,1 or 2 characters. If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integer, stored as 64 bit (Long_t); g : a long unsigned integer, stored as 64 bit (ULong_t); O : [the letter o, not a zero] a boolean (bool). Arrays of values are supported with the fol",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:84476,Modifiability,variab,variable,84476,"rialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 353 of file TTree.h. ◆ Branch() [11/13]. TBranch * TTree::Branch ; (; const char * ; name, . void * ; address, . const char * ; leaflist, . Int_t ; bufsize = 32000 . ). virtual . Create a new TTree Branch. ; This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file. address is the address of the first item of a structure.; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type may be 0,1 or 2 characters. If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integer, stored as 64 bit (Long_t); g : a long unsigned integer, stored as 64 bit (ULong_t); O : [the letter o, not a zero] a boolean (bool). Arrays of values are supported with the fol",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:84499,Modifiability,variab,variable,84499,"ch is owned by the tree. ; Definition at line 353 of file TTree.h. ◆ Branch() [11/13]. TBranch * TTree::Branch ; (; const char * ; name, . void * ; address, . const char * ; leaflist, . Int_t ; bufsize = 32000 . ). virtual . Create a new TTree Branch. ; This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file. address is the address of the first item of a structure.; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type may be 0,1 or 2 characters. If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integer, stored as 64 bit (Long_t); g : a long unsigned integer, stored as 64 bit (ULong_t); O : [the letter o, not a zero] a boolean (bool). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then i",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:85567,Modifiability,variab,variable,85567,"able does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 bit signed integer (Int_t); i : a 32 bit unsigned integer (UInt_t); F : a 32 bit floating point (Float_t); f : a 24 bit floating point with truncated mantissa (Float16_t); D : a 64 bit floating point (Double_t); d : a 24 bit truncated floating point (Double32_t); L : a 64 bit signed integer (Long64_t); l : a 64 bit unsigned integer (ULong64_t); G : a long signed integer, stored as 64 bit (Long_t); g : a long unsigned integer, stored as 64 bit (ULong_t); O : [the letter o, not a zero] a boolean (bool). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then if nelem is a leaf name, it is used as the variable size of the array, otherwise return 0. The leaf referred to by nelem MUST be an int (/I),; If leaf name has the form var[nelem], where nelem is a non-negative integer, then it is used as the fixed size of the array.; If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]) where nelem and nelem2 are non-negative integer) then it is used as a 2 dimensional array of fixed size.; In case of the truncated floating point types (Float16_t and Double32_t) you can furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after the type character. See TStreamerElement::GetRange() for further information. Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory. On some platform, this is not always true of the member of a struct or a class, due to padding and alignment. Sorting your data member in order of decreasing sizeof usual",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:111891,Modifiability,variab,variables,111891,"_t ; firstentry = 0 . ). virtual . Draw expression varexp for entries and objects that pass a (optional) selection. ; Returns-1 in case of error or number of selected events in case of success.; Parameters. [in]varexpA string that takes one of these general forms:; ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1"" on the y-axis versus ""e2"" on the x-axis; ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1"" vs ""e2"" vs ""e3"" on the z-, y-, x-axis, respectively; ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1"" vs ""e2"" vs ""e3"" and ""e4"" mapped on the current color palette. (to create histograms in the 2, 3, and 4 dimensional case, see section ""Saving the result of Draw to an histogram""); ""e1:e2:e3:e4:e5"" with option ""GL5D"" produces a 5D plot using OpenGL. gStyle->SetCanvasPreferGL(true) is needed.; Any number of variables no fewer than two can be used with the options ""CANDLE"" and ""PARA""; An arbitrary number of variables can be used with the option ""GOFF"". Examples:; ""x"": the simplest case, it draws a 1-Dim histogram of column x; ""sqrt(x)"", ""x*y/z"": draw histogram with the values of the specified numerical expression across TTree events; ""y:sqrt(x)"": 2-Dim histogram of y versus sqrt(x); ""px:py:pz:2.5*E"": produces a 3-d scatter-plot of px vs py ps pz and the color number of each marker will be 2.5*E. If the color number is negative it is set to 0. If the color number is greater than the current number of colors it is set to the highest color number. The default number of colors is 50. See TStyle::SetPalette for setting a new color palette. The expressions can use all the operations and built-in functions supported by TFormula (see TFormula::Analyze()), including free functions taking numerical arguments (e.g. TMath::Bessel()). In addition, you can call member functions taking numerical arguments. For example, these are two valid expressions: TMath::BreitWign",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:111992,Modifiability,variab,variables,111992,"_t ; firstentry = 0 . ). virtual . Draw expression varexp for entries and objects that pass a (optional) selection. ; Returns-1 in case of error or number of selected events in case of success.; Parameters. [in]varexpA string that takes one of these general forms:; ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1"" on the y-axis versus ""e2"" on the x-axis; ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1"" vs ""e2"" vs ""e3"" on the z-, y-, x-axis, respectively; ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1"" vs ""e2"" vs ""e3"" and ""e4"" mapped on the current color palette. (to create histograms in the 2, 3, and 4 dimensional case, see section ""Saving the result of Draw to an histogram""); ""e1:e2:e3:e4:e5"" with option ""GL5D"" produces a 5D plot using OpenGL. gStyle->SetCanvasPreferGL(true) is needed.; Any number of variables no fewer than two can be used with the options ""CANDLE"" and ""PARA""; An arbitrary number of variables can be used with the option ""GOFF"". Examples:; ""x"": the simplest case, it draws a 1-Dim histogram of column x; ""sqrt(x)"", ""x*y/z"": draw histogram with the values of the specified numerical expression across TTree events; ""y:sqrt(x)"": 2-Dim histogram of y versus sqrt(x); ""px:py:pz:2.5*E"": produces a 3-d scatter-plot of px vs py ps pz and the color number of each marker will be 2.5*E. If the color number is negative it is set to 0. If the color number is greater than the current number of colors it is set to the highest color number. The default number of colors is 50. See TStyle::SetPalette for setting a new color palette. The expressions can use all the operations and built-in functions supported by TFormula (see TFormula::Analyze()), including free functions taking numerical arguments (e.g. TMath::Bessel()). In addition, you can call member functions taking numerical arguments. For example, these are two valid expressions: TMath::BreitWign",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:116317,Modifiability,variab,variable,116317,"ray elements; Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array, or a TClonesArray. In a TTree::Draw expression you can now access fMatrix using the following syntaxes:. String passed What is used for each entry of the tree . fMatrix the 9 elements of fMatrix . fMatrix[][] the 9 elements of fMatrix . fMatrix[2][2] only the elements fMatrix[2][2] . fMatrix[1] the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] . fMatrix[1][] the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] . fMatrix[][0] the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0] . ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!).; In summary, if a specific index is not specified for a dimension, TTree::Draw will loop through all the indices along this dimension. Leaving off the last (right most) dimension of specifying then with the two characters '[]' is equivalent. For variable size arrays (and TClonesArray) the range of the first dimension is recalculated for each entry of the tree. You can also specify the index as an expression of any other variables from the tree.; TTree::Draw also now properly handling operations involving 2 or more arrays.; Let assume a second matrix fResults[5][2], here are a sample of some of the possible combinations, the number of elements they produce and the loop used:. expression element(s) Loop . fMatrix[2][1] - fResults[5][2] one no loop . fMatrix[2][] - fResults[5][2] three on 2nd dim fMatrix . fMatrix[2][] - fResults[5][] two on both 2nd dimensions . fMatrix[][2] - fResults[][1] three on both 1st dimensions . fMatrix[][2] - fResults[][] six on both 1st and 2nd dimensions of fResults . fMatrix[][2] - fResults[3][] two on 1st dim of fMatrix and 2nd of fResults (at the same time) . fMatrix[][] - fResults[][] six on 1st dim then on 2nd dim . fMatrix[][fResult[][]] 30 on 1st dim of fMatrix then on both dimensions of fResults. The value if fResults[j][k] is used as the second i",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:116495,Modifiability,variab,variables,116495,"ray. In a TTree::Draw expression you can now access fMatrix using the following syntaxes:. String passed What is used for each entry of the tree . fMatrix the 9 elements of fMatrix . fMatrix[][] the 9 elements of fMatrix . fMatrix[2][2] only the elements fMatrix[2][2] . fMatrix[1] the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] . fMatrix[1][] the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] . fMatrix[][0] the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0] . ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!).; In summary, if a specific index is not specified for a dimension, TTree::Draw will loop through all the indices along this dimension. Leaving off the last (right most) dimension of specifying then with the two characters '[]' is equivalent. For variable size arrays (and TClonesArray) the range of the first dimension is recalculated for each entry of the tree. You can also specify the index as an expression of any other variables from the tree.; TTree::Draw also now properly handling operations involving 2 or more arrays.; Let assume a second matrix fResults[5][2], here are a sample of some of the possible combinations, the number of elements they produce and the loop used:. expression element(s) Loop . fMatrix[2][1] - fResults[5][2] one no loop . fMatrix[2][] - fResults[5][2] three on 2nd dim fMatrix . fMatrix[2][] - fResults[5][] two on both 2nd dimensions . fMatrix[][2] - fResults[][1] three on both 1st dimensions . fMatrix[][2] - fResults[][] six on both 1st and 2nd dimensions of fResults . fMatrix[][2] - fResults[3][] two on 1st dim of fMatrix and 2nd of fResults (at the same time) . fMatrix[][] - fResults[][] six on 1st dim then on 2nd dim . fMatrix[][fResult[][]] 30 on 1st dim of fMatrix then on both dimensions of fResults. The value if fResults[j][k] is used as the second index of fMatrix. . In summary, TTree::Draw loops through all unspecified dimensions. To figure out the ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:117767,Modifiability,variab,variable,117767," fResults[5][2] one no loop . fMatrix[2][] - fResults[5][2] three on 2nd dim fMatrix . fMatrix[2][] - fResults[5][] two on both 2nd dimensions . fMatrix[][2] - fResults[][1] three on both 1st dimensions . fMatrix[][2] - fResults[][] six on both 1st and 2nd dimensions of fResults . fMatrix[][2] - fResults[3][] two on 1st dim of fMatrix and 2nd of fResults (at the same time) . fMatrix[][] - fResults[][] six on 1st dim then on 2nd dim . fMatrix[][fResult[][]] 30 on 1st dim of fMatrix then on both dimensions of fResults. The value if fResults[j][k] is used as the second index of fMatrix. . In summary, TTree::Draw loops through all unspecified dimensions. To figure out the range of each loop, we match each unspecified dimension from left to right (ignoring ALL dimensions for which an index has been specified), in the equivalent loop matched dimensions use the same index and are restricted to the smallest range (of only the matched dimensions). When involving variable arrays, the range can of course be different for each entry of the tree.; So the loop equivalent to ""fMatrix[][2] - fResults[3][]"" is: for (Int_t i0; i < min(3,2); i++) {; use the value of (fMatrix[i0][2] - fMatrix[3][i0]); }; So the loop equivalent to ""fMatrix[][2] - fResults[][]"" is: for (Int_t i0; i < min(3,5); i++) {; for (Int_t i1; i1 < 2; i1++) {; use the value of (fMatrix[i0][2] - fMatrix[i0][i1]); }; }; So the loop equivalent to ""fMatrix[][] - fResults[][]"" is: for (Int_t i0; i < min(3,5); i++) {; for (Int_t i1; i1 < min(3,2); i1++) {; use the value of (fMatrix[i0][i1] - fMatrix[i0][i1]); }; }; So the loop equivalent to ""fMatrix[][fResults[][]]"" is: for (Int_t i0; i0 < 3; i0++) {; for (Int_t j2; j2 < 5; j2++) {; for (Int_t j3; j3 < 2; j3++) {; i1 = fResults[j2][j3];; use the value of fMatrix[i0][i1]; }; }; ; Retrieving the result of Draw; By default a temporary histogram called htemp is created. It will be:. A TH1F* in case of a mono-dimensional distribution: Draw(""e1""),; A TH2F* in case of a bi-dimen",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:120527,Modifiability,variab,variable,120527," In the two dimensional case (Draw(""e1;e2"")), with the default drawing option, the data is filled into a TGraph named Graph. This TGraph can be retrieved by calling; auto graph = (TGraph*)gPad->GetPrimitive(""Graph"");; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; graphDefinition graph.py:1; For the three and four dimensional cases, with the default drawing option, an unnamed TPolyMarker3D is produced, and therefore cannot be retrieved.; In all cases htemp can be used to access the axes. For instance in the 2D case:; auto htemp = (TH2F*)gPad->GetPrimitive(""htemp"");; auto xaxis = htemp->GetXaxis();; When the option ""A"" is used (with TGraph painting option) to draw a 2D distribution: tree.Draw(""e1:e2"","""",""A*"");; a scatter plot is produced (with stars in that case) but the axis creation is delegated to TGraph and htemp is not created. Saving the result of Draw to a histogram; If varexp contains >>hnew (following the variable(s) name(s)), the new histogram called hnew is created and it is kept in the current directory (and also the current pad). This works for all dimensions.; Example: tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current directory. To retrieve it do: TH1F *hsqrt = (TH1F*)gDirectory->Get(""hsqrt"");; gDirectory#define gDirectoryDefinition TDirectory.h:384; The binning information is taken from the environment variables Hist.Binning.?D.?; In addition, the name of the histogram can be followed by up to 9 numbers between '(' and ')', where the numbers describe the following:. 1 - bins in x-direction; 2 - lower limit in x-direction; 3 - upper limit in x-direction; 4-6 same for y-direction; 7-9 same for z-direction. When a new binning is used the new value will become the default. Values can be skipped.; Example: tree.Draw(""sqrt(x)>>hsqrt(500,10,20)""); // plot sqrt(x) between 10 and 20 using 500 bins; tree.Draw(""sqrt(x):sin(y)>>hsqrt(100,10,60,50,.1,.5)""); // plot",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:120990,Modifiability,variab,variables,120990," an unnamed TPolyMarker3D is produced, and therefore cannot be retrieved.; In all cases htemp can be used to access the axes. For instance in the 2D case:; auto htemp = (TH2F*)gPad->GetPrimitive(""htemp"");; auto xaxis = htemp->GetXaxis();; When the option ""A"" is used (with TGraph painting option) to draw a 2D distribution: tree.Draw(""e1:e2"","""",""A*"");; a scatter plot is produced (with stars in that case) but the axis creation is delegated to TGraph and htemp is not created. Saving the result of Draw to a histogram; If varexp contains >>hnew (following the variable(s) name(s)), the new histogram called hnew is created and it is kept in the current directory (and also the current pad). This works for all dimensions.; Example: tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current directory. To retrieve it do: TH1F *hsqrt = (TH1F*)gDirectory->Get(""hsqrt"");; gDirectory#define gDirectoryDefinition TDirectory.h:384; The binning information is taken from the environment variables Hist.Binning.?D.?; In addition, the name of the histogram can be followed by up to 9 numbers between '(' and ')', where the numbers describe the following:. 1 - bins in x-direction; 2 - lower limit in x-direction; 3 - upper limit in x-direction; 4-6 same for y-direction; 7-9 same for z-direction. When a new binning is used the new value will become the default. Values can be skipped.; Example: tree.Draw(""sqrt(x)>>hsqrt(500,10,20)""); // plot sqrt(x) between 10 and 20 using 500 bins; tree.Draw(""sqrt(x):sin(y)>>hsqrt(100,10,60,50,.1,.5)""); // plot sqrt(x) against sin(y); // 100 bins in x-direction; lower limit on x-axis is 10; upper limit is 60; // 50 bins in y-direction; lower limit on y-axis is .1; upper limit is .5; By default, the specified histogram is reset. To continue to append data to an existing histogram, use ""+"" in front of the histogram name.; A '+' in front of the histogram name is ignored, when the name is followed by binning information as ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:122698,Modifiability,variab,variable,122698,"eset. To continue to append data to an existing histogram, use ""+"" in front of the histogram name.; A '+' in front of the histogram name is ignored, when the name is followed by binning information as described in the previous paragraph. tree.Draw(""sqrt(x)>>+hsqrt"",""y>0""); will not reset hsqrt, but will continue filling. This works for 1-D, 2-D and 3-D histograms. Accessing collection objects; TTree::Draw default's handling of collections is to assume that any request on a collection pertain to it content. For example, if fTracks is a collection of Track objects, the following: tree->Draw(""event.fTracks.fPx"");; will plot the value of fPx for each Track objects inside the collection. Also tree->Draw(""event.fTracks.size()"");; would plot the result of the member function Track::size() for each Track object inside the collection. To access information about the collection itself, TTree::Draw support the '@' notation. If a variable which points to a collection is prefixed or postfixed with '@', the next part of the expression will pertain to the collection object. For example: tree->Draw(""event.@fTracks.size()"");; will plot the size of the collection referred to by fTracks (i.e the number of Track objects). Drawing 'objects'; When a class has a member function named AsDouble or AsString, requesting to directly draw the object will imply a call to one of the 2 functions. If both AsDouble and AsString are present, AsDouble will be used. AsString can return either a char*, a std::string or a TString.s For example, the following tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw will call respectively TString::Data and std::string::c_str(); If the object is a TBits, the histogram will contain the index of the bit that are turned on. Retrieving information about the tree itself.; You can refer to the tree (or chain) containing the data by usi",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:124054,Modifiability,variab,variables,124054,"e object will imply a call to one of the 2 functions. If both AsDouble and AsString are present, AsDouble will be used. AsString can return either a char*, a std::string or a TString.s For example, the following tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw will call respectively TString::Data and std::string::c_str(); If the object is a TBits, the histogram will contain the index of the bit that are turned on. Retrieving information about the tree itself.; You can refer to the tree (or chain) containing the data by using the string 'This'. You can then could any TTree methods. For example: tree->Draw(""This->GetReadEntry()"");; will display the local entry numbers be read. tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; will display the name of the first 'user info' object. Special functions and variables; Entry$: A TTree::Draw formula can use the special variable Entry$ to access the entry number being read. For example to draw every other entry use: tree.Draw(""myvar"",""Entry$%2==0"");. Entry$ : return the current entry number (== TTree::GetReadEntry()); LocalEntry$ : return the current entry number in the current tree of a chain (== GetTree()->GetReadEntry()); Entries$ : return the total number of entries (== TTree::GetEntries()); LocalEntries$ : return the total number of entries in the current tree of a chain (== GetTree()->TTree::GetEntries()); Length$ : return the total number of element of this formula for this entry (==TTreeFormula::GetNdata()); Iteration$ : return the current iteration over this formula for this entry (i.e. varies from 0 to Length$).; Length$(formula ) : return the total number of element of the formula given as a parameter.; Sum$(formula ) : return the sum of the value of the elements of the formula given as a parameter. For example the mean for all the elements in one entry can be calculated with",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:124115,Modifiability,variab,variable,124115,"e object will imply a call to one of the 2 functions. If both AsDouble and AsString are present, AsDouble will be used. AsString can return either a char*, a std::string or a TString.s For example, the following tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw will call respectively TString::Data and std::string::c_str(); If the object is a TBits, the histogram will contain the index of the bit that are turned on. Retrieving information about the tree itself.; You can refer to the tree (or chain) containing the data by using the string 'This'. You can then could any TTree methods. For example: tree->Draw(""This->GetReadEntry()"");; will display the local entry numbers be read. tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; will display the name of the first 'user info' object. Special functions and variables; Entry$: A TTree::Draw formula can use the special variable Entry$ to access the entry number being read. For example to draw every other entry use: tree.Draw(""myvar"",""Entry$%2==0"");. Entry$ : return the current entry number (== TTree::GetReadEntry()); LocalEntry$ : return the current entry number in the current tree of a chain (== GetTree()->GetReadEntry()); Entries$ : return the total number of entries (== TTree::GetEntries()); LocalEntries$ : return the total number of entries in the current tree of a chain (== GetTree()->TTree::GetEntries()); Length$ : return the total number of element of this formula for this entry (==TTreeFormula::GetNdata()); Iteration$ : return the current iteration over this formula for this entry (i.e. varies from 0 to Length$).; Length$(formula ) : return the total number of element of the formula given as a parameter.; Sum$(formula ) : return the sum of the value of the elements of the formula given as a parameter. For example the mean for all the elements in one entry can be calculated with",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:126135,Modifiability,variab,variable,126135,"ts of the formula given as a parameter.; Max$(formula ) : return the maximum (within one TTree entry) of the value of the elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition) : return the minimum (maximum) (within one TTree entry) of the value of the elements of the formula given as a parameter if they match the condition. If no element matches the condition, the result is zero. To avoid the resulting peak at zero, use the pattern: tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match for the condition.; Alt$(primary,alternate) : return the value of ""primary"" if it is available for the current iteration otherwise return the value of ""alternate"". For example, with arr1[3] and arr2[2] tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0 Or with a variable size array arr3 tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1) As a comparison tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the actual_size_of_arr3 is greater or equal to 3. Note that the array in 'primary' is flattened/linearized thus using Alt$ with multi-dimensional arrays of different dimensions in unlikely to yield the expected results. To visualize a bit more what elements would be matched by TTree::Draw, TTree::Scan can be used: tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be matched by tree->Draw(""arr1-Alt$(arr2,0)"");; The ternary operator is not directly supported in TTree::Draw however, to plot the equivalent of var2<20 ? -99 : var1, you can use: tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly; If the formula contains a file name, TTree::MakeProxy will be used to load and execute this file. In particular it will",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:127381,Modifiability,variab,variable,127381,"]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the actual_size_of_arr3 is greater or equal to 3. Note that the array in 'primary' is flattened/linearized thus using Alt$ with multi-dimensional arrays of different dimensions in unlikely to yield the expected results. To visualize a bit more what elements would be matched by TTree::Draw, TTree::Scan can be used: tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be matched by tree->Draw(""arr1-Alt$(arr2,0)"");; The ternary operator is not directly supported in TTree::Draw however, to plot the equivalent of var2<20 ? -99 : var1, you can use: tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly; If the formula contains a file name, TTree::MakeProxy will be used to load and execute this file. In particular it will draw the result of a function with the same name as the file. The function will be executed in a context where the name of the branches can be used as a C++ variable.; For example draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; hsimpleDefinition hsimple.py:1; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; Drawth1 Draw(); A more complete example is available in the tutorials directory: h1analysisProxy.cxx, h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C; The main features of this facility are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bound; ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram; In case of a 2-Dim expression, one can generate a TProfile histogram instead of a TH2F histogram by specifying ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:129144,Modifiability,variab,variables,129144,"n the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram; In case of a 2-Dim expression, one can generate a TProfile histogram instead of a TH2F histogram by specifying option=prof or option=profs or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of y:x>>pf where pf is an existing TProfile histogram. Making a 2D Profile histogram; In case of a 3-Dim expression, one can generate a TProfile2D histogram instead of a TH3F histogram by specifying option=prof or option=profs. or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of z:y:x>>pf where pf is an existing TProfile2D histogram. Making a 5D plot using GL; If option GL5D is specified together with 5 variables, a 5D plot is drawn using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot; In case of a 2-Dim or more expression with the option=para, one can generate a parallel coordinates plot. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error. Making a candle sticks chart; In case of a 2-Dim or more expression with the option=candle, one can generate a candle sticks chart. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error. Normalizing the output histogram to 1; When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray; TTree::Draw can be used to fill a TEventList object (list of entry numbers) instead of histogramming one",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:129454,Modifiability,variab,variables,129454,"ption for details on the differences. The option=prof is automatically selected in case of y:x>>pf where pf is an existing TProfile histogram. Making a 2D Profile histogram; In case of a 3-Dim expression, one can generate a TProfile2D histogram instead of a TH3F histogram by specifying option=prof or option=profs. or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of z:y:x>>pf where pf is an existing TProfile2D histogram. Making a 5D plot using GL; If option GL5D is specified together with 5 variables, a 5D plot is drawn using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot; In case of a 2-Dim or more expression with the option=para, one can generate a parallel coordinates plot. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error. Making a candle sticks chart; In case of a 2-Dim or more expression with the option=candle, one can generate a candle sticks chart. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error. Normalizing the output histogram to 1; When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray; TTree::Draw can be used to fill a TEventList object (list of entry numbers) instead of histogramming one variable. If varexp0 has the form >>elist , a TEventList object named ""elist"" is created in the current directory. elist will contain the list of entry numbers satisfying the current selection. If option ""entrylist"" is used, a TEntryList object is created If the selection contains arrays, vectors or any container class and option ""entrylistarray"" is used,",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:129751,Modifiability,variab,variables,129751,"f or option=profs. or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of z:y:x>>pf where pf is an existing TProfile2D histogram. Making a 5D plot using GL; If option GL5D is specified together with 5 variables, a 5D plot is drawn using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot; In case of a 2-Dim or more expression with the option=para, one can generate a parallel coordinates plot. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error. Making a candle sticks chart; In case of a 2-Dim or more expression with the option=candle, one can generate a candle sticks chart. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error. Normalizing the output histogram to 1; When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray; TTree::Draw can be used to fill a TEventList object (list of entry numbers) instead of histogramming one variable. If varexp0 has the form >>elist , a TEventList object named ""elist"" is created in the current directory. elist will contain the list of entry numbers satisfying the current selection. If option ""entrylist"" is used, a TEntryList object is created If the selection contains arrays, vectors or any container class and option ""entrylistarray"" is used, a TEntryListArray object is created containing also the subentries satisfying the selection, i.e. the indices of the branches which hold containers classes. Example: tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory. In an interactive session, one",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:130131,Modifiability,variab,variable,130131,"xisting TProfile2D histogram. Making a 5D plot using GL; If option GL5D is specified together with 5 variables, a 5D plot is drawn using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot; In case of a 2-Dim or more expression with the option=para, one can generate a parallel coordinates plot. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error. Making a candle sticks chart; In case of a 2-Dim or more expression with the option=candle, one can generate a candle sticks chart. With that option, the number of dimensions is arbitrary. Giving more than 4 variables without the option=para or option=candle or option=goff will produce an error. Normalizing the output histogram to 1; When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray; TTree::Draw can be used to fill a TEventList object (list of entry numbers) instead of histogramming one variable. If varexp0 has the form >>elist , a TEventList object named ""elist"" is created in the current directory. elist will contain the list of entry numbers satisfying the current selection. If option ""entrylist"" is used, a TEntryList object is created If the selection contains arrays, vectors or any container class and option ""entrylistarray"" is used, a TEntryListArray object is created containing also the subentries satisfying the selection, i.e. the indices of the branches which hold containers classes. Example: tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory. In an interactive session, one can type (after TTree::Draw) yplus.Print(""all""); to print the list of entry numbers in the list. tree.Draw("">>yplus"", ""y>0"", ""entrylist""); will create a TEntryList object names ""yplus"" in the current directory tree.Draw("">>yplus"", ""y>0"", ""entrylistarray""); w",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:138253,Modifiability,variab,variable,138253," Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a cache attached to the TTree (either pre-exisiting or created as part of this call) ; Definition at line 2685 of file TTree.cxx. ◆ Fill(). Int_t TTree::Fill ; (; ). virtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a simple data type, a simple conversion to a machine independent format has to be done.; This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function re",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:138297,Modifiability,config,config,138297," Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a cache attached to the TTree (either pre-exisiting or created as part of this call) ; Definition at line 2685 of file TTree.cxx. ◆ Fill(). Int_t TTree::Fill ; (; ). virtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a simple data type, a simple conversion to a machine independent format has to be done.; This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function re",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:146123,Modifiability,config,configuration,146123,"r its friends. ; The search is done breadth first. ; Reimplemented in TProofChain, and TChain.; Definition at line 5294 of file TTree.cxx. ◆ GetBranchRef(). virtual TBranchRef * TTree::GetBranchRef ; (; ); const. inlinevirtual . Definition at line 450 of file TTree.h. ◆ GetBranchStatus(). bool TTree::GetBranchStatus ; (; const char * ; branchname); const. virtual . Return status of branch with name branchname. . 0 if branch is not activated; 1 if branch is activated . Reimplemented in TProofChain, and TChain.; Definition at line 5380 of file TTree.cxx. ◆ GetBranchStyle(). Int_t TTree::GetBranchStyle ; (; ). static . Static function returning the current branch style. . style = 0 old Branch; style = 1 new Bronch . Definition at line 5395 of file TTree.cxx. ◆ GetCacheAutoSize(). Long64_t TTree::GetCacheAutoSize ; (; bool ; withDefault = false). protected . Used for automatic sizing of the cache. ; Estimates a suitable size for the tree cache based on AutoFlush. A cache sizing factor is taken from the configuration. If this yields zero and withDefault is true the historical algorithm for default size is used. ; Definition at line 5407 of file TTree.cxx. ◆ GetCacheSize(). virtual Long64_t TTree::GetCacheSize ; (; ); const. inlinevirtual . Reimplemented in TChain.; Definition at line 453 of file TTree.h. ◆ GetChainEntryNumber(). virtual Long64_t TTree::GetChainEntryNumber ; (; Long64_t ; entry); const. inlinevirtual . Reimplemented in TChain.; Definition at line 455 of file TTree.h. ◆ GetChainOffset(). virtual Long64_t TTree::GetChainOffset ; (; ); const. inlinevirtual . Definition at line 456 of file TTree.h. ◆ GetClusterIterator(). TTree::TClusterIterator TTree::GetClusterIterator ; (; Long64_t ; firstentry). virtual . Return an iterator over the cluster of baskets starting at firstentry. ; This iterator is not yet supported for TChain object. TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; Long64_t clusterStart;; while( (clusterStart = clusterIt",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:174315,Modifiability,variab,variables,174315," > MyClass* t = new MyClass;; root > t->GetEntry(12); // Fill data members of t with entry number 12.; root > t->Show(); // Show values of entry 12.; root > t->Show(16); // Read and show values of entry 16.; root > t->Loop(); // Loop on all entries.; NOTE: Do not use the code generated for a single TTree which is part of a TChain to process that entire TChain. The maximum dimensions calculated for arrays on the basis of a single TTree from the TChain might be (will be!) too small when processing all of the TTrees in the TChain. You must use myChain.MakeClass() to generate the code, not myTree.MakeClass(...). ; Definition at line 6607 of file TTree.cxx. ◆ MakeCode(). Int_t TTree::MakeCode ; (; const char * ; filename = nullptr). virtual . Generate a skeleton function for this tree. ; The function code is written on filename. If filename is 0, filename will be called nameoftree.C; The generated code includes the following:; Identification of the original Tree and Input file name,; Opening the Tree file,; Declaration of Tree variables,; Setting of branches addresses,; A skeleton for the entry loop. To use this function:. Open your Tree file (eg: TFile f(""myfile.root"");); T->MakeCode(""MyAnalysis.C"");. where T is the name of the TTree in file myfile.root and MyAnalysis.C the name of the file created by this function.; NOTE: Since the implementation of this function, a new and better function TTree::MakeClass() has been developed. ; Definition at line 6640 of file TTree.cxx. ◆ MakeProxy(). Int_t TTree::MakeProxy ; (; const char * ; proxyClassname, . const char * ; macrofilename = nullptr, . const char * ; cutfilename = nullptr, . const char * ; option = nullptr, . Int_t ; maxUnrolling = 3 . ). virtual . Generate a skeleton analysis class for this Tree using TBranchProxy. ; TBranchProxy is the base of a class hierarchy implementing an indirect access to the content of the branches of a TTree.; ""proxyClassname"" is expected to be of the form: [path/]fileprefix; The skeleton w",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:177175,Modifiability,variab,variables,177175,"t are not split. Unrolling a class allows direct access to its data members (this emulates the behavior of TTreeFormula).; The main features of this skeleton are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bounds errors; ability to use the branch data as an object (when the user code is available). For example with Event.root, if Double_t somePx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somePx will updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; These two functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example: Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; nconst Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1anal",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:177250,Modifiability,variab,variable,177250,"branchname' as if it was a data member; protection against array out-of-bounds errors; ability to use the branch data as an object (when the user code is available). For example with Event.root, if Double_t somePx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somePx will updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; These two functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example: Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; nconst Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:178409,Modifiability,variab,variable,178409,"const Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.; The default histogram is accessible via the variable named 'htemp'.; If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed include statements and give the ability to access the object stored in the branches.; To draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C ; Definition at line 6768 of file TTree.cxx. ◆ MakeSelector(). Int_t TTree::MakeSelector ; (; const char * ; selector = nullptr, . Option_t * ; option = """" . ). virtual . Generate skeleton selector class for this tree. ; The following files are produced: selector.h and selector.C. If selector is 0, the se",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:184122,Modifiability,variab,variables,184122,"ree::OptimizeBaskets ; (; ULong64_t ; maxMemory = 10000000, . Float_t ; minComp = 1.1, . Option_t * ; option = """" . ). virtual . This function may be called after having filled some entries in a Tree. ; Using the information in the existing branch buffers, it will reassign new branch buffer sizes to optimize time and memory.; The function computes the best values for branch buffer sizes such that the total buffer sizes is less than maxMemory and nearby entries written at the same time. In case the branch compression factor for the data written so far is less than compMin, the compression is disabled.; if option =""d"" an analysis report is printed. ; Definition at line 7057 of file TTree.cxx. ◆ Principal(). TPrincipal * TTree::Principal ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = ""np"", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). Interface to the Principal Components Analysis class. ; Create an instance of TPrincipal; Fill it with the selected variables. if option ""n"" is specified, the TPrincipal object is filled with normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". see TTree::Draw for explanation of the other parameters.; The created object is named ""principal"" and a reference to it is added to the list of specials Root objects. you can retrieve a pointer to the created object via: TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");; gROOT#define gROOTDefinition TROOT.h:406; TPrincipalPrincipal Components Analysis (PCA)Definition TPrincipal.h:21; principalDefinition principal.py:1. Definition at line 7200 of file TTree.cxx. ◆ Print(). v",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:184209,Modifiability,variab,variables,184209,"= 1.1, . Option_t * ; option = """" . ). virtual . This function may be called after having filled some entries in a Tree. ; Using the information in the existing branch buffers, it will reassign new branch buffer sizes to optimize time and memory.; The function computes the best values for branch buffer sizes such that the total buffer sizes is less than maxMemory and nearby entries written at the same time. In case the branch compression factor for the data written so far is less than compMin, the compression is disabled.; if option =""d"" an analysis report is printed. ; Definition at line 7057 of file TTree.cxx. ◆ Principal(). TPrincipal * TTree::Principal ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = ""np"", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). Interface to the Principal Components Analysis class. ; Create an instance of TPrincipal; Fill it with the selected variables. if option ""n"" is specified, the TPrincipal object is filled with normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". see TTree::Draw for explanation of the other parameters.; The created object is named ""principal"" and a reference to it is added to the list of specials Root objects. you can retrieve a pointer to the created object via: TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");; gROOT#define gROOTDefinition TROOT.h:406; TPrincipalPrincipal Components Analysis (PCA)Definition TPrincipal.h:21; principalDefinition principal.py:1. Definition at line 7200 of file TTree.cxx. ◆ Print(). void TTree::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:193525,Modifiability,variab,variable,193525,"hname must match with the dimension of varexp. ; Definition at line 7498 of file TTree.cxx. ◆ Query(). TSQLResult * TTree::Query ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Loop over entries and return a TSQLResult object containing entries following selection. ; Definition at line 7513 of file TTree.cxx. ◆ ReadFile(). Long64_t TTree::ReadFile ; (; const char * ; filename, . const char * ; branchDescriptor = """", . char ; delimiter = ' ' . ). virtual . Create or simply read branches from filename. ; if branchDescriptor = """" (default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like A/D:Table[2]/F:Ntracks/I:astring/C; F#define F(x, y, z); I#define I(x, y, z); otherwise branchDescriptor must be specified with the above syntax. If the type of the first variable is not specified, it is assumed to be ""/F""; If the type of any other variable is not specified, the type of the previous variable is assumed. eg; x:y:z (all variables are assumed of type ""F""); x/D:y:z (all variables are of type ""D""); x:y/D:z (x is type ""F"", y and z of type ""D""). delimiter allows for the use of another delimiter besides whitespace. This provides support for direct import of common data file formats like csv. If delimiter != ' ' and branchDescriptor == """", then the branch description is taken from the first line in the file, but delimiter is used for the branch names tokenization rather than ':'. Note however that if the values in the first line do not use the /[type] syntax, all variables are assumed to be of type ""F"". If the filename ends with extensions .csv or .CSV and a delimiter is not specified (besides ' '), the delimiter is automatically set to ','.; Lines in the input file starting with ""#"" are ignored. Leading whitespace for each column data is skipped. Empty lines are skipped.; A TBranch object is created for e",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:193603,Modifiability,variab,variable,193603,"hname must match with the dimension of varexp. ; Definition at line 7498 of file TTree.cxx. ◆ Query(). TSQLResult * TTree::Query ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Loop over entries and return a TSQLResult object containing entries following selection. ; Definition at line 7513 of file TTree.cxx. ◆ ReadFile(). Long64_t TTree::ReadFile ; (; const char * ; filename, . const char * ; branchDescriptor = """", . char ; delimiter = ' ' . ). virtual . Create or simply read branches from filename. ; if branchDescriptor = """" (default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like A/D:Table[2]/F:Ntracks/I:astring/C; F#define F(x, y, z); I#define I(x, y, z); otherwise branchDescriptor must be specified with the above syntax. If the type of the first variable is not specified, it is assumed to be ""/F""; If the type of any other variable is not specified, the type of the previous variable is assumed. eg; x:y:z (all variables are assumed of type ""F""); x/D:y:z (all variables are of type ""D""); x:y/D:z (x is type ""F"", y and z of type ""D""). delimiter allows for the use of another delimiter besides whitespace. This provides support for direct import of common data file formats like csv. If delimiter != ' ' and branchDescriptor == """", then the branch description is taken from the first line in the file, but delimiter is used for the branch names tokenization rather than ':'. Note however that if the values in the first line do not use the /[type] syntax, all variables are assumed to be of type ""F"". If the filename ends with extensions .csv or .CSV and a delimiter is not specified (besides ' '), the delimiter is automatically set to ','.; Lines in the input file starting with ""#"" are ignored. Leading whitespace for each column data is skipped. Empty lines are skipped.; A TBranch object is created for e",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:193655,Modifiability,variab,variable,193655,"hname must match with the dimension of varexp. ; Definition at line 7498 of file TTree.cxx. ◆ Query(). TSQLResult * TTree::Query ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Loop over entries and return a TSQLResult object containing entries following selection. ; Definition at line 7513 of file TTree.cxx. ◆ ReadFile(). Long64_t TTree::ReadFile ; (; const char * ; filename, . const char * ; branchDescriptor = """", . char ; delimiter = ' ' . ). virtual . Create or simply read branches from filename. ; if branchDescriptor = """" (default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like A/D:Table[2]/F:Ntracks/I:astring/C; F#define F(x, y, z); I#define I(x, y, z); otherwise branchDescriptor must be specified with the above syntax. If the type of the first variable is not specified, it is assumed to be ""/F""; If the type of any other variable is not specified, the type of the previous variable is assumed. eg; x:y:z (all variables are assumed of type ""F""); x/D:y:z (all variables are of type ""D""); x:y/D:z (x is type ""F"", y and z of type ""D""). delimiter allows for the use of another delimiter besides whitespace. This provides support for direct import of common data file formats like csv. If delimiter != ' ' and branchDescriptor == """", then the branch description is taken from the first line in the file, but delimiter is used for the branch names tokenization rather than ':'. Note however that if the values in the first line do not use the /[type] syntax, all variables are assumed to be of type ""F"". If the filename ends with extensions .csv or .CSV and a delimiter is not specified (besides ' '), the delimiter is automatically set to ','.; Lines in the input file starting with ""#"" are ignored. Leading whitespace for each column data is skipped. Empty lines are skipped.; A TBranch object is created for e",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:193691,Modifiability,variab,variables,193691," """", . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Loop over entries and return a TSQLResult object containing entries following selection. ; Definition at line 7513 of file TTree.cxx. ◆ ReadFile(). Long64_t TTree::ReadFile ; (; const char * ; filename, . const char * ; branchDescriptor = """", . char ; delimiter = ' ' . ). virtual . Create or simply read branches from filename. ; if branchDescriptor = """" (default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like A/D:Table[2]/F:Ntracks/I:astring/C; F#define F(x, y, z); I#define I(x, y, z); otherwise branchDescriptor must be specified with the above syntax. If the type of the first variable is not specified, it is assumed to be ""/F""; If the type of any other variable is not specified, the type of the previous variable is assumed. eg; x:y:z (all variables are assumed of type ""F""); x/D:y:z (all variables are of type ""D""); x:y/D:z (x is type ""F"", y and z of type ""D""). delimiter allows for the use of another delimiter besides whitespace. This provides support for direct import of common data file formats like csv. If delimiter != ' ' and branchDescriptor == """", then the branch description is taken from the first line in the file, but delimiter is used for the branch names tokenization rather than ':'. Note however that if the values in the first line do not use the /[type] syntax, all variables are assumed to be of type ""F"". If the filename ends with extensions .csv or .CSV and a delimiter is not specified (besides ' '), the delimiter is automatically set to ','.; Lines in the input file starting with ""#"" are ignored. Leading whitespace for each column data is skipped. Empty lines are skipped.; A TBranch object is created for each variable in the expression. The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES; To fill a TTree with",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:193740,Modifiability,variab,variables,193740," """", . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Loop over entries and return a TSQLResult object containing entries following selection. ; Definition at line 7513 of file TTree.cxx. ◆ ReadFile(). Long64_t TTree::ReadFile ; (; const char * ; filename, . const char * ; branchDescriptor = """", . char ; delimiter = ' ' . ). virtual . Create or simply read branches from filename. ; if branchDescriptor = """" (default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like A/D:Table[2]/F:Ntracks/I:astring/C; F#define F(x, y, z); I#define I(x, y, z); otherwise branchDescriptor must be specified with the above syntax. If the type of the first variable is not specified, it is assumed to be ""/F""; If the type of any other variable is not specified, the type of the previous variable is assumed. eg; x:y:z (all variables are assumed of type ""F""); x/D:y:z (all variables are of type ""D""); x:y/D:z (x is type ""F"", y and z of type ""D""). delimiter allows for the use of another delimiter besides whitespace. This provides support for direct import of common data file formats like csv. If delimiter != ' ' and branchDescriptor == """", then the branch description is taken from the first line in the file, but delimiter is used for the branch names tokenization rather than ':'. Note however that if the values in the first line do not use the /[type] syntax, all variables are assumed to be of type ""F"". If the filename ends with extensions .csv or .CSV and a delimiter is not specified (besides ' '), the delimiter is automatically set to ','.; Lines in the input file starting with ""#"" are ignored. Leading whitespace for each column data is skipped. Empty lines are skipped.; A TBranch object is created for each variable in the expression. The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES; To fill a TTree with",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:194238,Modifiability,variab,variables,194238,"me. ; if branchDescriptor = """" (default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like A/D:Table[2]/F:Ntracks/I:astring/C; F#define F(x, y, z); I#define I(x, y, z); otherwise branchDescriptor must be specified with the above syntax. If the type of the first variable is not specified, it is assumed to be ""/F""; If the type of any other variable is not specified, the type of the previous variable is assumed. eg; x:y:z (all variables are assumed of type ""F""); x/D:y:z (all variables are of type ""D""); x:y/D:z (x is type ""F"", y and z of type ""D""). delimiter allows for the use of another delimiter besides whitespace. This provides support for direct import of common data file formats like csv. If delimiter != ' ' and branchDescriptor == """", then the branch description is taken from the first line in the file, but delimiter is used for the branch names tokenization rather than ':'. Note however that if the values in the first line do not use the /[type] syntax, all variables are assumed to be of type ""F"". If the filename ends with extensions .csv or .CSV and a delimiter is not specified (besides ' '), the delimiter is automatically set to ','.; Lines in the input file starting with ""#"" are ignored. Leading whitespace for each column data is skipped. Empty lines are skipped.; A TBranch object is created for each variable in the expression. The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES; To fill a TTree with multiple input text files, proceed as indicated above for the first input file and omit the second argument for subsequent calls T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. Definition at line 7564 of file TTree.cxx. ◆ ReadStream(). Long64_t TTree::ReadStream ; (; std::istream & ; inputStream, . const char * ; branchDescriptor = """", . char ; delimiter = ' ' . ). virtual . Create or simply read branches from an input stream. ; See alsorefer",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:194591,Modifiability,variab,variable,194591,"type of any other variable is not specified, the type of the previous variable is assumed. eg; x:y:z (all variables are assumed of type ""F""); x/D:y:z (all variables are of type ""D""); x:y/D:z (x is type ""F"", y and z of type ""D""). delimiter allows for the use of another delimiter besides whitespace. This provides support for direct import of common data file formats like csv. If delimiter != ' ' and branchDescriptor == """", then the branch description is taken from the first line in the file, but delimiter is used for the branch names tokenization rather than ':'. Note however that if the values in the first line do not use the /[type] syntax, all variables are assumed to be of type ""F"". If the filename ends with extensions .csv or .CSV and a delimiter is not specified (besides ' '), the delimiter is automatically set to ','.; Lines in the input file starting with ""#"" are ignored. Leading whitespace for each column data is skipped. Empty lines are skipped.; A TBranch object is created for each variable in the expression. The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES; To fill a TTree with multiple input text files, proceed as indicated above for the first input file and omit the second argument for subsequent calls T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. Definition at line 7564 of file TTree.cxx. ◆ ReadStream(). Long64_t TTree::ReadStream ; (; std::istream & ; inputStream, . const char * ; branchDescriptor = """", . char ; delimiter = ' ' . ). virtual . Create or simply read branches from an input stream. ; See alsoreference information for TTree::ReadFile ; Reimplemented in TNtuple, and TNtupleD.; Definition at line 7615 of file TTree.cxx. ◆ RecursiveRemove(). void TTree::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Make sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree. ; Reimplemented from TObject.; Definition at line 7881 of ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:198234,Modifiability,variab,variable,198234,"mented in TChain, TNtuple, and TNtupleD.; Definition at line 8065 of file TTree.cxx. ◆ ResetBranchAddresses(). void TTree::ResetBranchAddresses ; (; ). virtual . Tell all of our branches to drop their current objects and allocate new ones. ; Reimplemented in TChain, TNtuple, and TNtupleD.; Definition at line 8075 of file TTree.cxx. ◆ Scan(). Long64_t TTree::Scan ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Loop over tree entries and print entries passing selection. . If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can be made using ""var1:var2:var3"". See alsoTTreePlayer::Scan for more information ; Reimplemented in TChain.; Definition at line 8094 of file TTree.cxx. ◆ SetAlias(). bool TTree::SetAlias ; (; const char * ; aliasName, . const char * ; aliasFormula . ). virtual . Set a tree variable alias. ; Set an alias for an expression/formula based on the tree 'variables'.; The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw, TTree::Scan, TTreeViewer) and will be evaluated as the content of 'aliasFormula'.; If the content of 'aliasFormula' only contains symbol names, periods and array index specification (for example event.fTracks[3]), then the content of 'aliasName' can be used as the start of symbol.; If the alias 'aliasName' already existed, it is replaced by the new value.; When being used, the alias can be preceded by an eventual 'Friend Alias' (see TTree::GetFriendAlias); Return true if it was added properly.; For example: tree->SetAlias(""x1"",""(tdc1[1]-tdc1[0])/49"");; tree->SetAlias(""y1"",""(tdc1[3]-tdc1[2])/47"");; tree->SetAlias(""x2"",""(tdc2[1]-tdc2[0])/49"");; tree->SetAlias(""y2"",""(tdc2[3]-tdc2[2])/47"");; tree->Draw(""y2-y1:x2-x1"");; ; tree->SetAlias(""theGoodTrack"",""event.fTracks[3]"");; tree->Draw(""theGoodTrack.fPx""); // same as ""event.fTracks[3]",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:198310,Modifiability,variab,variables,198310,"on at line 8065 of file TTree.cxx. ◆ ResetBranchAddresses(). void TTree::ResetBranchAddresses ; (; ). virtual . Tell all of our branches to drop their current objects and allocate new ones. ; Reimplemented in TChain, TNtuple, and TNtupleD.; Definition at line 8075 of file TTree.cxx. ◆ Scan(). Long64_t TTree::Scan ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Loop over tree entries and print entries passing selection. . If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can be made using ""var1:var2:var3"". See alsoTTreePlayer::Scan for more information ; Reimplemented in TChain.; Definition at line 8094 of file TTree.cxx. ◆ SetAlias(). bool TTree::SetAlias ; (; const char * ; aliasName, . const char * ; aliasFormula . ). virtual . Set a tree variable alias. ; Set an alias for an expression/formula based on the tree 'variables'.; The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw, TTree::Scan, TTreeViewer) and will be evaluated as the content of 'aliasFormula'.; If the content of 'aliasFormula' only contains symbol names, periods and array index specification (for example event.fTracks[3]), then the content of 'aliasName' can be used as the start of symbol.; If the alias 'aliasName' already existed, it is replaced by the new value.; When being used, the alias can be preceded by an eventual 'Friend Alias' (see TTree::GetFriendAlias); Return true if it was added properly.; For example: tree->SetAlias(""x1"",""(tdc1[1]-tdc1[0])/49"");; tree->SetAlias(""y1"",""(tdc1[3]-tdc1[2])/47"");; tree->SetAlias(""x2"",""(tdc2[1]-tdc2[0])/49"");; tree->SetAlias(""y2"",""(tdc2[3]-tdc2[2])/47"");; tree->Draw(""y2-y1:x2-x1"");; ; tree->SetAlias(""theGoodTrack"",""event.fTracks[3]"");; tree->Draw(""theGoodTrack.fPx""); // same as ""event.fTracks[3].fPx"". Definition at line 8136 of file TTree.cxx.",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:204548,Modifiability,variab,variables,204548,"anchAddressType for the semantic of the return value.; Note: See the comments in TBranchElement::SetAddress() for the meaning of the addr parameter and the object ownership policy. ; Reimplemented in TChain.; Definition at line 8398 of file TTree.cxx. ◆ SetBranchAddressImp(). Int_t TTree::SetBranchAddressImp ; (; TBranch * ; branch, . void * ; addr, . TBranch ** ; ptr . ). protected . Change branch address, dealing with clone trees properly. ; See TTree::CheckBranchAddressType for the semantic of the return value.; Note: See the comments in TBranchElement::SetAddress() for the meaning of the addr parameter and the object ownership policy. ; Definition at line 8440 of file TTree.cxx. ◆ SetBranchStatus(). void TTree::SetBranchStatus ; (; const char * ; bname, . bool ; status = true, . UInt_t * ; found = nullptr . ). virtual . Set branch status to Process or DoNotProcess. ; When reading a Tree, by default, all branches are read. One can speed up considerably the analysis phase by activating only the branches that hold variables involved in a query.; bname is the name of a branch. if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx. see TRegexp for wildcarding options. status = 1 branch will be processed; = 0 branch will not be processed. Example:; Assume a tree T with sub-branches a,b,c,d,e,f,g,etc.. when doing T.GetEntry(i) all branches are read for entry i. to read only the branches c and e, one can do T.SetBranchStatus(""*"",0); //disable all branches; T.SetBranchStatus(""c"",1);; T.setBranchStatus(""e"",1);; T.GetEntry(i);; bname is interpreted as a wild-carded TRegexp (see TRegexp::MakeWildcard). Thus, ""a*b"" or ""a.*b"" matches branches starting with ""a"" and ending with ""b"", but not any other branch with an ""a"" followed at some point by a ""b"". For this second behavior, use ""*a*b*"". Note that TRegExp does not support '|', and so you cannot select, e.g. track and shower branches with ""track|shower"".; WARNING! WARNING! WAR",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:212010,Modifiability,variab,variable,212010,"Definition at line 8956 of file TTree.cxx. ◆ SetEntries(). Long64_t TTree::SetEntries ; (; Long64_t ; n = -1). virtual . Change number of entries in the tree. ; If n >= 0, set number of entries in the tree = n.; If n < 0, set number of entries in the tree to match the number of entries in each branch. (default for n is -1); This function should be called only when one fills each branch independently via TBranch::Fill without calling TTree::Fill. Calling TTree::SetEntries() make sense only if the number of entries in each branch is identical, a warning is issued otherwise. The function returns the number of entries. ; Reimplemented in THbookTree.; Definition at line 9001 of file TTree.cxx. ◆ SetEntryList(). void TTree::SetEntryList ; (; TEntryList * ; list, . Option_t * ; opt = """" . ). virtual . Set an EntryList. ; Reimplemented in TChain.; Definition at line 9036 of file TTree.cxx. ◆ SetEstimate(). void TTree::SetEstimate ; (; Long64_t ; n = 1000000). virtual . Set number of entries to estimate variable limits. ; If n is -1, the estimate is set to be the current maximum for the tree (i.e. GetEntries() + 1) If n is less than -1, the behavior is undefined. ; Definition at line 9100 of file TTree.cxx. ◆ SetEventList(). void TTree::SetEventList ; (; TEventList * ; evlist). virtual . This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TTree and gets deleted when the tree is deleted. ; This TEntryList can be returned by GetEntryList() function. ; Reimplemented in TProofChain, and TChain.; Definition at line 9059 of file TTree.cxx. ◆ SetFileNumber(). void TTree::SetFileNumber ; (; Int_t ; number = 0). virtual . Set fFileNumber to number. ; fFileNumber is used by TTree::Fill to set the file name for a new file to be created when the current file exceeds fgTreeMaxSize. (see TTree::ChangeFile) if fFileNumber=10, the new file name will have a suffix ""_11"", ie, fFileNumber is incremented before setting the file name ; Definition at ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:213903,Modifiability,variab,variable,213903," name will have a suffix ""_11"", ie, fFileNumber is incremented before setting the file name ; Definition at line 9143 of file TTree.cxx. ◆ SetImplicitMT(). virtual void TTree::SetImplicitMT ; (; bool ; enabled). inlinevirtual . Definition at line 621 of file TTree.h. ◆ SetIOFeatures(). ROOT::TIOFeatures TTree::SetIOFeatures ; (; const ROOT::TIOFeatures & ; features). Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ; Returns all the newly-set IO settings. ; Definition at line 9120 of file TTree.cxx. ◆ SetMakeClass(). void TTree::SetMakeClass ; (; Int_t ; make). virtual . Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode). ; For MakeClass mode 0, the TTree expects the address where the data is stored to be set by either the user or the TTree to the address of a full object through the top level branch. For MakeClass mode 1, this address is expected to point to a numerical type or C-style array (variable or not) of numerical type, representing the primitive data members. The function's primary purpose is to allow the user to access the data directly with numerical type variable rather than having to have the original set of classes (or a reproduction thereof). ; Reimplemented in TChain.; Definition at line 9167 of file TTree.cxx. ◆ SetMaxEntryLoop(). virtual void TTree::SetMaxEntryLoop ; (; Long64_t ; maxev = kMaxEntries). inlinevirtual . Definition at line 623 of file TTree.h. ◆ SetMaxTreeSize(). void TTree::SetMaxTreeSize ; (; Long64_t ; maxsize = 100000000000LL). static . Set the maximum size in bytes of a Tree file (static function). ; The default size is 100000000000LL, ie 100 Gigabytes.; In TTree::Fill, when the file has a size > fgMaxTreeSize, the function closes the current file and starts writing into a new file with a name of the style ""file_1.root"" if the original requested file name was ""file.root"". ; Definition at line 9187 of file TTree.cxx. ◆ SetMaxVirt",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:214080,Modifiability,variab,variable,214080,"licitMT ; (; bool ; enabled). inlinevirtual . Definition at line 621 of file TTree.h. ◆ SetIOFeatures(). ROOT::TIOFeatures TTree::SetIOFeatures ; (; const ROOT::TIOFeatures & ; features). Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ; Returns all the newly-set IO settings. ; Definition at line 9120 of file TTree.cxx. ◆ SetMakeClass(). void TTree::SetMakeClass ; (; Int_t ; make). virtual . Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode). ; For MakeClass mode 0, the TTree expects the address where the data is stored to be set by either the user or the TTree to the address of a full object through the top level branch. For MakeClass mode 1, this address is expected to point to a numerical type or C-style array (variable or not) of numerical type, representing the primitive data members. The function's primary purpose is to allow the user to access the data directly with numerical type variable rather than having to have the original set of classes (or a reproduction thereof). ; Reimplemented in TChain.; Definition at line 9167 of file TTree.cxx. ◆ SetMaxEntryLoop(). virtual void TTree::SetMaxEntryLoop ; (; Long64_t ; maxev = kMaxEntries). inlinevirtual . Definition at line 623 of file TTree.h. ◆ SetMaxTreeSize(). void TTree::SetMaxTreeSize ; (; Long64_t ; maxsize = 100000000000LL). static . Set the maximum size in bytes of a Tree file (static function). ; The default size is 100000000000LL, ie 100 Gigabytes.; In TTree::Fill, when the file has a size > fgMaxTreeSize, the function closes the current file and starts writing into a new file with a name of the style ""file_1.root"" if the original requested file name was ""file.root"". ; Definition at line 9187 of file TTree.cxx. ◆ SetMaxVirtualSize(). virtual void TTree::SetMaxVirtualSize ; (; Long64_t ; size = 0). inlinevirtual . Definition at line 625 of file TTree.h. ◆ SetName(). void TTree::SetName ; (; const char *",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:219578,Modifiability,variab,variable,219578,"al . Start the TTreeViewer on this tree. . ww is the width of the canvas in pixels; wh is the height of the canvas in pixels . Definition at line 9449 of file TTree.cxx. ◆ StopCacheLearningPhase(). Int_t TTree::StopCacheLearningPhase ; (; ). virtual . Stop the cache learning phase. ; Returns:; 0 learning phase stopped or not active; -1 on error . Definition at line 9464 of file TTree.cxx. ◆ Streamer(). void TTree::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 9535 of file TTree.cxx. ◆ StreamerNVirtual(). void TTree::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 659 of file TTree.h. ◆ UnbinnedFit(). Int_t TTree::UnbinnedFit ; (; const char * ; funcname, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Unbinned fit of one or more variable(s) from a tree. ; funcname is a TF1 function.; See alsoTTree::Draw for explanations of the other parameters.; Fit the variable varexp using the function funcname using the selection cuts given by selection.; The list of fit options is given in parameter option. option = ""Q"" Quiet mode (minimum printing); option = ""V"" Verbose mode (default is between Q and V); option = ""E"" Perform better Errors estimation using Minos technique; option = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters. For example, if you fit a function with 6 parameters, you can do: func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup:. Parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is f",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:219705,Modifiability,variab,variable,219705," ◆ StopCacheLearningPhase(). Int_t TTree::StopCacheLearningPhase ; (; ). virtual . Stop the cache learning phase. ; Returns:; 0 learning phase stopped or not active; -1 on error . Definition at line 9464 of file TTree.cxx. ◆ Streamer(). void TTree::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 9535 of file TTree.cxx. ◆ StreamerNVirtual(). void TTree::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 659 of file TTree.h. ◆ UnbinnedFit(). Int_t TTree::UnbinnedFit ; (; const char * ; funcname, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Unbinned fit of one or more variable(s) from a tree. ; funcname is a TF1 function.; See alsoTTree::Draw for explanations of the other parameters.; Fit the variable varexp using the function funcname using the selection cuts given by selection.; The list of fit options is given in parameter option. option = ""Q"" Quiet mode (minimum printing); option = ""V"" Verbose mode (default is between Q and V); option = ""E"" Perform better Errors estimation using Minos technique; option = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters. For example, if you fit a function with 6 parameters, you can do: func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup:. Parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized.; i.e. It must have the same integral regardless of the parameter settings. Otherwise th",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:220832,Modifiability,variab,variable,220832,"n parameter option. option = ""Q"" Quiet mode (minimum printing); option = ""V"" Verbose mode (default is between Q and V); option = ""E"" Perform better Errors estimation using Minos technique; option = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters. For example, if you fit a function with 6 parameters, you can do: func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup:. Parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized.; i.e. It must have the same integral regardless of the parameter settings. Otherwise the fit will effectively just maximize the area.; It is mandatory to have a normalization variable which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TF11-Dim function classDefinition TF1.h:233; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:670; 1, 2 and 3 Dimensional fits are supported. See also TTree::Fit; Return status:. The function return the status of the fit in the following form fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResul",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:15466,Performance,perform,performance,15466,"nition TProfile.h:32; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169. PyROOT; The TTree class has several additions for its use from Python, which are also available in its subclasses e.g. TChain and TNtuple.; First, TTree instances are iterable in Python. Therefore, assuming t is a TTree instance, we can do: for entry in t:; x = entry.branch_name; ...; At each iteration, a new entry of the tree will be read. In the code above, entry allows to access the branch values for the current entry. This can be done with the syntax entry.branch_name or, if the branch name is incompatible with Python naming rules, with e.g. ""getattr(entry, '1_branch_name')"".; Please note that iterating in Python can be slow, so only iterate over a tree as described above if performance is not an issue or when dealing with a small dataset. To read and process the entries of a tree in a much faster way, please use ROOT::RDataFrame.; Second, a couple of TTree methods have been modified to facilitate their use from Python: TTree::Branch and TTree::SetBranchAddress.; Regarding TTree::Branch, the following example shows how we can create different types of branches of a TTree. Note that Branch will just link the new branch with a given Python object, so it is still necessary to fill such object with the desired content before calling TTree::Fill. from array import array; import numpy as np; import ROOT; from ROOT import addressof; ; # Basic type branch (float) - use array of length 1; n = array('f', [ 1.5 ]); t.Branch('floatb', n, 'floatb/F'); ; # Array branch - use array of length N; N = 10; a = array('d', N*[ 0. ]); t.Branch('arrayb', a, 'arrayb[' + str(N) + ']/D'); ; # Array branch - use NumPy array of length N; npa = np.array(N*[ 0. ]); t.",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:20141,Performance,cache,cache,20141,"; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTree ();  Default constructor and I/O constructor. ;  ;  TTree (const char *name, const char *title, Int_t splitlevel=99, TDirectory *dir=(::ROOT::Internal::TDirectoryAtomicAdapter{}));  Normal tree constructor. ;  ;  TTree (const TTree &tt)=delete;  ;  ~TTree () override;  Destructor. ;  ; void AddAllocationCount (UInt_t count);  ; virtual Int_t AddBranchToCache (const char *bname, bool subbranches=false);  Add branch with name bname to the Tree cache. ;  ; virtual Int_t AddBranchToCache (TBranch *branch, bool subbranches=false);  Add branch b to the Tree cache. ;  ; void AddClone (TTree *);  Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ;  ; virtual TFriendElement * AddFriend (const char *treename, const char *filename="""");  Add a TFriendElement to the list of friends. ;  ; virtual TFriendElement * AddFriend (const char *treename, TFile *file);  Add a TFriendElement to the list of friends. ;  ; virtual TFriendElement * AddFriend (TTree *tree, const char *alias="""", bool warn=false);  Add a TFriendElement to the list of friends. ;  ; virtual void AddTotBytes (Int_t tot);  ; virtual void AddZipBytes (Int_t zip);  ; virtual Long64_t AutoSave (Option_t *option="""");  AutoSave tree header every fAutoSave bytes. ;  ; virtual Int_t Branch (const char *folder, Int_t bufsize=32000, Int_t ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:20253,Performance,cache,cache,20253,"fffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTree ();  Default constructor and I/O constructor. ;  ;  TTree (const char *name, const char *title, Int_t splitlevel=99, TDirectory *dir=(::ROOT::Internal::TDirectoryAtomicAdapter{}));  Normal tree constructor. ;  ;  TTree (const TTree &tt)=delete;  ;  ~TTree () override;  Destructor. ;  ; void AddAllocationCount (UInt_t count);  ; virtual Int_t AddBranchToCache (const char *bname, bool subbranches=false);  Add branch with name bname to the Tree cache. ;  ; virtual Int_t AddBranchToCache (TBranch *branch, bool subbranches=false);  Add branch b to the Tree cache. ;  ; void AddClone (TTree *);  Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ;  ; virtual TFriendElement * AddFriend (const char *treename, const char *filename="""");  Add a TFriendElement to the list of friends. ;  ; virtual TFriendElement * AddFriend (const char *treename, TFile *file);  Add a TFriendElement to the list of friends. ;  ; virtual TFriendElement * AddFriend (TTree *tree, const char *alias="""", bool warn=false);  Add a TFriendElement to the list of friends. ;  ; virtual void AddTotBytes (Int_t tot);  ; virtual void AddZipBytes (Int_t zip);  ; virtual Long64_t AutoSave (Option_t *option="""");  AutoSave tree header every fAutoSave bytes. ;  ; virtual Int_t Branch (const char *folder, Int_t bufsize=32000, Int_t splitlevel=99);  Create one branch for each element in the folder. ;  ; TBranch * Branch (const char *name, char *address, const char *leafli",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:25374,Performance,cache,cache,25374,"al TBasket * CreateBasket (TBranch *);  Create a basket for this tree and given branch. ;  ; Int_t Debug () const;  ; void Delete (Option_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file. ;  ; virtual Long64_t Draw (const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for entries and objects that pass a (optional) selection. ;  ; virtual Long64_t Draw (const char *varexp, const TCut &selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for specified entries. ;  ; void Draw (Option_t *opt) override;  Default Draw method for all objects. ;  ; virtual void DropBaskets ();  Remove some baskets from memory. ;  ; virtual Int_t DropBranchFromCache (const char *bname, bool subbranches=false);  Remove the branch with name 'bname' from the Tree cache. ;  ; virtual Int_t DropBranchFromCache (TBranch *branch, bool subbranches=false);  Remove the branch b from the Tree cache. ;  ; virtual void DropBuffers (Int_t nbytes);  Drop branch buffers to accommodate nbytes below MaxVirtualsize. ;  ; bool EnableCache ();  Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ;  ; virtual Int_t Fill ();  Fill all branches. ;  ; virtual TBranch * FindBranch (const char *name);  Return the branch that correspond to the path 'branchname', which can include the name of the tree or the omitted name of the parent branches. ;  ; virtual TLeaf * FindLeaf (const char *name);  Find leaf.. ;  ; virtual Int_t Fit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Option_t *goption="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Fit a projected item(s) from a tree. ;  ; virtual Int_t FlushBaske",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:25498,Performance,cache,cache,25498,"tion_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file. ;  ; virtual Long64_t Draw (const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for entries and objects that pass a (optional) selection. ;  ; virtual Long64_t Draw (const char *varexp, const TCut &selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for specified entries. ;  ; void Draw (Option_t *opt) override;  Default Draw method for all objects. ;  ; virtual void DropBaskets ();  Remove some baskets from memory. ;  ; virtual Int_t DropBranchFromCache (const char *bname, bool subbranches=false);  Remove the branch with name 'bname' from the Tree cache. ;  ; virtual Int_t DropBranchFromCache (TBranch *branch, bool subbranches=false);  Remove the branch b from the Tree cache. ;  ; virtual void DropBuffers (Int_t nbytes);  Drop branch buffers to accommodate nbytes below MaxVirtualsize. ;  ; bool EnableCache ();  Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ;  ; virtual Int_t Fill ();  Fill all branches. ;  ; virtual TBranch * FindBranch (const char *name);  Return the branch that correspond to the path 'branchname', which can include the name of the tree or the omitted name of the parent branches. ;  ; virtual TLeaf * FindLeaf (const char *name);  Find leaf.. ;  ; virtual Int_t Fit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Option_t *goption="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Fit a projected item(s) from a tree. ;  ; virtual Int_t FlushBaskets (bool create_cluster=true) const;  Write to disk all the basket that have not yet been individually written and create an event cl",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:33921,Performance,load,loading,33921,"index. ;  ; virtual Int_t MakeClass (const char *classname=nullptr, Option_t *option="""");  Generate a skeleton analysis class for this tree. ;  ; virtual Int_t MakeCode (const char *filename=nullptr);  Generate a skeleton function for this tree. ;  ; virtual Int_t MakeProxy (const char *classname, const char *macrofilename=nullptr, const char *cutfilename=nullptr, const char *option=nullptr, Int_t maxUnrolling=3);  Generate a skeleton analysis class for this Tree using TBranchProxy. ;  ; virtual Int_t MakeSelector (const char *selector=nullptr, Option_t *option="""");  Generate skeleton selector class for this tree. ;  ; bool MemoryFull (Int_t nbytes);  Check if adding nbytes to memory we are still below MaxVirtualsize. ;  ; virtual Long64_t Merge (TCollection *list, Option_t *option="""");  Merge the trees in the TList into this tree. ;  ; virtual Long64_t Merge (TCollection *list, TFileMergeInfo *info);  Merge the trees in the TList into this tree. ;  ; bool Notify () override;  Function called when loading a new class library. ;  ; TTree & operator= (const TTree &tt)=delete;  ; virtual void OptimizeBaskets (ULong64_t maxMemory=10000000, Float_t minComp=1.1, Option_t *option="""");  This function may be called after having filled some entries in a Tree. ;  ; TPrincipal * Principal (const char *varexp="""", const char *selection="""", Option_t *option=""np"", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Interface to the Principal Components Analysis class. ;  ; void Print (Option_t *option="""") const override;  Print a summary of the tree contents. ;  ; virtual void PrintCacheStats (Option_t *option="""") const;  Print statistics about the TreeCache for this tree. ;  ; virtual Long64_t Process (const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Process this tree executing the TSelector code in the specified filename. ;  ; virtual Long64_t Process (TSelector *selector, Option_t *option="""", Long64_t nentries=kMaxEntries, Lon",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:38678,Performance,cache,cache,38678,"T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr=nullptr);  Change branch address, dealing with clone trees properly. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual void SetBranchStatus (const char *bname, bool status=true, UInt_t *found=nullptr);  Set branch status to Process or DoNotProcess. ;  ; virtual Int_t SetCacheEntryRange (Long64_t first, Long64_t last);  interface to TTreeCache to set the cache entry range ;  ; virtual void SetCacheLearnEntries (Int_t n=10);  Interface to TTreeCache to set the number of entries for the learning phase. ;  ; virtual Int_t SetCacheSize (Long64_t cachesize=-1);  Set maximum size of the file cache . ;  ; virtual void SetChainOffset (Long64_t offset=0);  ; virtual void SetCircular (Long64_t maxEntries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual void SetDirectory (TDirectory *dir);  Change the tree's directory. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEntryList (TEntryList *list, Option_t *opt="""");  Set an EntryList. ;  ; virtual void SetEstimate (Long64_t nentri",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:38869,Performance,cache,cachesize,38869,"ptr);  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr=nullptr);  Change branch address, dealing with clone trees properly. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual void SetBranchStatus (const char *bname, bool status=true, UInt_t *found=nullptr);  Set branch status to Process or DoNotProcess. ;  ; virtual Int_t SetCacheEntryRange (Long64_t first, Long64_t last);  interface to TTreeCache to set the cache entry range ;  ; virtual void SetCacheLearnEntries (Int_t n=10);  Interface to TTreeCache to set the number of entries for the learning phase. ;  ; virtual Int_t SetCacheSize (Long64_t cachesize=-1);  Set maximum size of the file cache . ;  ; virtual void SetChainOffset (Long64_t offset=0);  ; virtual void SetCircular (Long64_t maxEntries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual void SetDirectory (TDirectory *dir);  Change the tree's directory. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEntryList (TEntryList *list, Option_t *opt="""");  Set an EntryList. ;  ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetEventList (TEventList *list);  This function transfroms the given TEventList into a TEntry",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:38914,Performance,cache,cache,38914,"ptr);  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr=nullptr);  Change branch address, dealing with clone trees properly. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual void SetBranchStatus (const char *bname, bool status=true, UInt_t *found=nullptr);  Set branch status to Process or DoNotProcess. ;  ; virtual Int_t SetCacheEntryRange (Long64_t first, Long64_t last);  interface to TTreeCache to set the cache entry range ;  ; virtual void SetCacheLearnEntries (Int_t n=10);  Interface to TTreeCache to set the number of entries for the learning phase. ;  ; virtual Int_t SetCacheSize (Long64_t cachesize=-1);  Set maximum size of the file cache . ;  ; virtual void SetChainOffset (Long64_t offset=0);  ; virtual void SetCircular (Long64_t maxEntries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual void SetDirectory (TDirectory *dir);  Change the tree's directory. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEntryList (TEntryList *list, Option_t *opt="""");  Set an EntryList. ;  ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetEventList (TEventList *list);  This function transfroms the given TEventList into a TEntry",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:40705,Performance,load,loaded,40705," ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetEventList (TEventList *list);  This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TTree and gets deleted when the tree is deleted. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void SetImplicitMT (bool enabled);  ; ROOT::TIOFeatures SetIOFeatures (const ROOT::TIOFeatures &);  Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ;  ; virtual void SetMakeClass (Int_t make);  Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode). ;  ; virtual void SetMaxEntryLoop (Long64_t maxev=kMaxEntries);  ; virtual void SetMaxVirtualSize (Long64_t size=0);  ; void SetName (const char *name) override;  Change the name of this tree. ;  ; virtual void SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void SetWeight (Double_t w=1, Option_t *option="""");  Set tree weight. ;  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning phase. ; ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:41630,Performance,cache,cache,41630,"id SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void SetWeight (Double_t w=1, Option_t *option="""");  Set tree weight. ;  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning phase. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t UnbinnedFit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Unbinned fit of one or more variable(s) from a tree. ;  ; void UseCurrentStyle () override;  Replace current attributes by current style. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write this object to the current directory. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:58353,Performance,cache,cache,58353,"EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited fr",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:58952,Performance,cache,cache,58952,"t_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ;  ; Long64_t fAutoSave;  Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produce",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:59192,Performance,cache,cacheSize,59192,"bed by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ;  ; Long64_t fAutoSave;  Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ;  ; TObjArray fBranches;  List of Branches. ;  ; TBranchRef * fBranchRef;  Branch supporting the TRefTable (if any) ;  ; bool fCacheDoAutoInit;  ! true if cache auto creation or resize check is needed ;  ; bool fCacheDoClusterPrefetch;  ! true if cache",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:59232,Performance,cache,cache,59232,"bed by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ;  ; Long64_t fAutoSave;  Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ;  ; TObjArray fBranches;  List of Branches. ;  ; TBranchRef * fBranchRef;  Branch supporting the TRefTable (if any) ;  ; bool fCacheDoAutoInit;  ! true if cache auto creation or resize check is needed ;  ; bool fCacheDoClusterPrefetch;  ! true if cache",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:60102,Performance,cache,cache,60102,"ns inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ;  ; Long64_t fAutoSave;  Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ;  ; TObjArray fBranches;  List of Branches. ;  ; TBranchRef * fBranchRef;  Branch supporting the TRefTable (if any) ;  ; bool fCacheDoAutoInit;  ! true if cache auto creation or resize check is needed ;  ; bool fCacheDoClusterPrefetch;  ! true if cache is prefetching whole clusters ;  ; Long64_t fCacheSize;  ! Maximum size of file buffers ;  ; bool fCacheUserSet;  ! true if the cache setting was explicitly given by user ;  ; Long64_t fChainOffset;  ! Offset of 1st entry of this Tree in a TChain ;  ; TList * fClones;  ! List of cloned trees which share our addresses ;  ; Long64_t * fClusterRangeEnd;  [fNClusterRange] Last entry of a cluster range. ;  ; Long64_t * fClusterSize;  [fNClusterRange] Number of entries in each cluster for a given range. ;  ; Int_t fDebug;  ! Debug level ;  ; Long64_t fDebugMax;  ! Last entry number to debug ;  ; Long64_t fDebugMin;  ! First entry number to debug ;  ; Int_t fDefaultEntryOffsetLen;  Initial Length of fEntryOffset table in the basket buffers. ;  ; TDirectory * fDirectory;  ! Pointer to directory holding this tree ;  ; Long64_t fEntries;  Number of entries. ;  ; TEntryList * fEntryList;  ! Pointer to event selection list (if one) ;  ; Long64_t fEstimate;  Number of entries to estimate histogram limits. ;  ; TEventList * fEventList;  ! Pointer to event selection list (if one) ;  ; TList * f",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:60194,Performance,cache,cache,60194,"ns inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ;  ; Long64_t fAutoSave;  Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ;  ; TObjArray fBranches;  List of Branches. ;  ; TBranchRef * fBranchRef;  Branch supporting the TRefTable (if any) ;  ; bool fCacheDoAutoInit;  ! true if cache auto creation or resize check is needed ;  ; bool fCacheDoClusterPrefetch;  ! true if cache is prefetching whole clusters ;  ; Long64_t fCacheSize;  ! Maximum size of file buffers ;  ; bool fCacheUserSet;  ! true if the cache setting was explicitly given by user ;  ; Long64_t fChainOffset;  ! Offset of 1st entry of this Tree in a TChain ;  ; TList * fClones;  ! List of cloned trees which share our addresses ;  ; Long64_t * fClusterRangeEnd;  [fNClusterRange] Last entry of a cluster range. ;  ; Long64_t * fClusterSize;  [fNClusterRange] Number of entries in each cluster for a given range. ;  ; Int_t fDebug;  ! Debug level ;  ; Long64_t fDebugMax;  ! Last entry number to debug ;  ; Long64_t fDebugMin;  ! First entry number to debug ;  ; Int_t fDefaultEntryOffsetLen;  Initial Length of fEntryOffset table in the basket buffers. ;  ; TDirectory * fDirectory;  ! Pointer to directory holding this tree ;  ; Long64_t fEntries;  Number of entries. ;  ; TEntryList * fEntryList;  ! Pointer to event selection list (if one) ;  ; Long64_t fEstimate;  Number of entries to estimate histogram limits. ;  ; TEventList * fEventList;  ! Pointer to event selection list (if one) ;  ; TList * f",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:60328,Performance,cache,cache,60328,"ns inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ;  ; Long64_t fAutoSave;  Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ;  ; TObjArray fBranches;  List of Branches. ;  ; TBranchRef * fBranchRef;  Branch supporting the TRefTable (if any) ;  ; bool fCacheDoAutoInit;  ! true if cache auto creation or resize check is needed ;  ; bool fCacheDoClusterPrefetch;  ! true if cache is prefetching whole clusters ;  ; Long64_t fCacheSize;  ! Maximum size of file buffers ;  ; bool fCacheUserSet;  ! true if the cache setting was explicitly given by user ;  ; Long64_t fChainOffset;  ! Offset of 1st entry of this Tree in a TChain ;  ; TList * fClones;  ! List of cloned trees which share our addresses ;  ; Long64_t * fClusterRangeEnd;  [fNClusterRange] Last entry of a cluster range. ;  ; Long64_t * fClusterSize;  [fNClusterRange] Number of entries in each cluster for a given range. ;  ; Int_t fDebug;  ! Debug level ;  ; Long64_t fDebugMax;  ! Last entry number to debug ;  ; Long64_t fDebugMin;  ! First entry number to debug ;  ; Int_t fDefaultEntryOffsetLen;  Initial Length of fEntryOffset table in the basket buffers. ;  ; TDirectory * fDirectory;  ! Pointer to directory holding this tree ;  ; Long64_t fEntries;  Number of entries. ;  ; TEntryList * fEntryList;  ! Pointer to event selection list (if one) ;  ; Long64_t fEstimate;  Number of entries to estimate histogram limits. ;  ; TEventList * fEventList;  ! Pointer to event selection list (if one) ;  ; TList * f",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:61727,Performance,multi-thread,multi-threading,61727, cluster for a given range. ;  ; Int_t fDebug;  ! Debug level ;  ; Long64_t fDebugMax;  ! Last entry number to debug ;  ; Long64_t fDebugMin;  ! First entry number to debug ;  ; Int_t fDefaultEntryOffsetLen;  Initial Length of fEntryOffset table in the basket buffers. ;  ; TDirectory * fDirectory;  ! Pointer to directory holding this tree ;  ; Long64_t fEntries;  Number of entries. ;  ; TEntryList * fEntryList;  ! Pointer to event selection list (if one) ;  ; Long64_t fEstimate;  Number of entries to estimate histogram limits. ;  ; TEventList * fEventList;  ! Pointer to event selection list (if one) ;  ; TList * fExternalFriends;  ! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned. ;  ; Int_t fFileNumber;  ! current file number (if file extensions) ;  ; Long64_t fFlushedBytes;  Number of auto-flushed bytes. ;  ; UInt_t fFriendLockStatus;  ! Record which method is locking the friend recursion ;  ; TList * fFriends;  pointer to list of friend elements ;  ; bool fIMTEnabled;  ! true if implicit multi-threading is enabled for this tree ;  ; TArrayI fIndex;  Index of sorted values. ;  ; TArrayD fIndexValues;  Sorted index values. ;  ; TIOFeatures fIOFeatures {0};  IO features to define for newly-written baskets and branches. ;  ; TObjArray fLeaves;  Direct pointers to individual branch leaves. ;  ; Int_t fMakeClass;  ! not zero when processing code generated by MakeClass ;  ; Int_t fMaxClusterRange;  ! Memory allocated for the cluster range. ;  ; Long64_t fMaxEntries;  Maximum number of entries in case of circular buffers. ;  ; Long64_t fMaxEntryLoop;  Maximum number of entries to process. ;  ; Long64_t fMaxVirtualSize;  Maximum total size of buffers kept in memory. ;  ; Int_t fNClusterRange;  Number of Cluster range in addition to the one defined by 'AutoFlush'. ;  ; UInt_t fNEntriesSinceSorting;  ! Number of entries processed since the last re-sorting of branches ;  ; Int_t fNfill;  ! Local for EntryLoop ;  ; TObject * fNotif,MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:62707,Performance,load,loading,62707,"recursion ;  ; TList * fFriends;  pointer to list of friend elements ;  ; bool fIMTEnabled;  ! true if implicit multi-threading is enabled for this tree ;  ; TArrayI fIndex;  Index of sorted values. ;  ; TArrayD fIndexValues;  Sorted index values. ;  ; TIOFeatures fIOFeatures {0};  IO features to define for newly-written baskets and branches. ;  ; TObjArray fLeaves;  Direct pointers to individual branch leaves. ;  ; Int_t fMakeClass;  ! not zero when processing code generated by MakeClass ;  ; Int_t fMaxClusterRange;  ! Memory allocated for the cluster range. ;  ; Long64_t fMaxEntries;  Maximum number of entries in case of circular buffers. ;  ; Long64_t fMaxEntryLoop;  Maximum number of entries to process. ;  ; Long64_t fMaxVirtualSize;  Maximum total size of buffers kept in memory. ;  ; Int_t fNClusterRange;  Number of Cluster range in addition to the one defined by 'AutoFlush'. ;  ; UInt_t fNEntriesSinceSorting;  ! Number of entries processed since the last re-sorting of branches ;  ; Int_t fNfill;  ! Local for EntryLoop ;  ; TObject * fNotify;  Object to be notified when loading a Tree. ;  ; Int_t fPacketSize;  ! Number of entries in one packet for parallel root ;  ; TVirtualPerfStats * fPerfStats;  ! pointer to the current perf stats object ;  ; TVirtualTreePlayer * fPlayer;  ! Pointer to current Tree player ;  ; Long64_t fReadEntry;  ! Number of the entry being processed ;  ; Long64_t fSavedBytes;  Number of autosaved bytes. ;  ; Int_t fScanField;  Number of runs before prompting in Scan. ;  ; std::vector< TBranch * > fSeqBranches;  ! Branches to be processed sequentially when IMT is on ;  ; std::vector< std::pair< Long64_t, TBranch * > > fSortedBranches;  ! Branches to be processed in parallel when IMT is on, sorted by average task time ;  ; Float_t fTargetMemoryRatio {1.1f};  ! Ratio for memory usage in uncompressed buffers versus actual occupancy. ;  ; Int_t fTimerInterval;  Timer interval in milliseconds. ;  ; std::atomic< Long64_t > fTotalBuffers;  ! Tota",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:69217,Performance,cache,cache,69217,"char * ; title, . Int_t ; splitlevel = 99, . TDirectory * ; dir = (::ROOT::Internal::TDirectoryAtomicAdapter{}) . ). Normal tree constructor. ; The tree is created in the current directory. Use the various functions Branch below to add branches to this tree.; If the first character of title is a ""/"", the function assumes a folder name. In this case, it creates automatically branches following the folder hierarchy. splitlevel may be used in this case to control the split level. ; Definition at line 817 of file TTree.cxx. ◆ ~TTree(). TTree::~TTree ; (; ). override . Destructor. ; Definition at line 920 of file TTree.cxx. ◆ TTree() [3/3]. TTree::TTree ; (; const TTree & ; tt). delete . Member Function Documentation. ◆ AddAllocationCount(). void TTree::AddAllocationCount ; (; UInt_t ; count). inline . Definition at line 337 of file TTree.h. ◆ AddBranchToCache() [1/2]. Int_t TTree::AddBranchToCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Add branch with name bname to the Tree cache. ; If bname=""*"" all branches are added to the cache. if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1059 of file TTree.cxx. ◆ AddBranchToCache() [2/2]. Int_t TTree::AddBranchToCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Add branch b to the Tree cache. ; if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:69269,Performance,cache,cache,69269,"ectory * ; dir = (::ROOT::Internal::TDirectoryAtomicAdapter{}) . ). Normal tree constructor. ; The tree is created in the current directory. Use the various functions Branch below to add branches to this tree.; If the first character of title is a ""/"", the function assumes a folder name. In this case, it creates automatically branches following the folder hierarchy. splitlevel may be used in this case to control the split level. ; Definition at line 817 of file TTree.cxx. ◆ ~TTree(). TTree::~TTree ; (; ). override . Destructor. ; Definition at line 920 of file TTree.cxx. ◆ TTree() [3/3]. TTree::TTree ; (; const TTree & ; tt). delete . Member Function Documentation. ◆ AddAllocationCount(). void TTree::AddAllocationCount ; (; UInt_t ; count). inline . Definition at line 337 of file TTree.h. ◆ AddBranchToCache() [1/2]. Int_t TTree::AddBranchToCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Add branch with name bname to the Tree cache. ; If bname=""*"" all branches are added to the cache. if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1059 of file TTree.cxx. ◆ AddBranchToCache() [2/2]. Int_t TTree::AddBranchToCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Add branch b to the Tree cache. ; if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filena",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:69355,Performance,cache,cache,69355,"ormal tree constructor. ; The tree is created in the current directory. Use the various functions Branch below to add branches to this tree.; If the first character of title is a ""/"", the function assumes a folder name. In this case, it creates automatically branches following the folder hierarchy. splitlevel may be used in this case to control the split level. ; Definition at line 817 of file TTree.cxx. ◆ ~TTree(). TTree::~TTree ; (; ). override . Destructor. ; Definition at line 920 of file TTree.cxx. ◆ TTree() [3/3]. TTree::TTree ; (; const TTree & ; tt). delete . Member Function Documentation. ◆ AddAllocationCount(). void TTree::AddAllocationCount ; (; UInt_t ; count). inline . Definition at line 337 of file TTree.h. ◆ AddBranchToCache() [1/2]. Int_t TTree::AddBranchToCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Add branch with name bname to the Tree cache. ; If bname=""*"" all branches are added to the cache. if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1059 of file TTree.cxx. ◆ AddBranchToCache() [2/2]. Int_t TTree::AddBranchToCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Add branch b to the Tree cache. ; if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (curre",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:69613,Performance,cache,cache,69613,"der hierarchy. splitlevel may be used in this case to control the split level. ; Definition at line 817 of file TTree.cxx. ◆ ~TTree(). TTree::~TTree ; (; ). override . Destructor. ; Definition at line 920 of file TTree.cxx. ◆ TTree() [3/3]. TTree::TTree ; (; const TTree & ; tt). delete . Member Function Documentation. ◆ AddAllocationCount(). void TTree::AddAllocationCount ; (; UInt_t ; count). inline . Definition at line 337 of file TTree.h. ◆ AddBranchToCache() [1/2]. Int_t TTree::AddBranchToCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Add branch with name bname to the Tree cache. ; If bname=""*"" all branches are added to the cache. if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1059 of file TTree.cxx. ◆ AddBranchToCache() [2/2]. Int_t TTree::AddBranchToCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Add branch b to the Tree cache. ; if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (current directory); adds the Tree to the list of friends see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file. When a TFriendElement TF is added to the list of friends of an existing TTree T, any variable from TF can be referenced in a query to T.; A tre",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:69701,Performance,cache,cache,69701,"l the split level. ; Definition at line 817 of file TTree.cxx. ◆ ~TTree(). TTree::~TTree ; (; ). override . Destructor. ; Definition at line 920 of file TTree.cxx. ◆ TTree() [3/3]. TTree::TTree ; (; const TTree & ; tt). delete . Member Function Documentation. ◆ AddAllocationCount(). void TTree::AddAllocationCount ; (; UInt_t ; count). inline . Definition at line 337 of file TTree.h. ◆ AddBranchToCache() [1/2]. Int_t TTree::AddBranchToCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Add branch with name bname to the Tree cache. ; If bname=""*"" all branches are added to the cache. if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1059 of file TTree.cxx. ◆ AddBranchToCache() [2/2]. Int_t TTree::AddBranchToCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Add branch b to the Tree cache. ; if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (current directory); adds the Tree to the list of friends see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file. When a TFriendElement TF is added to the list of friends of an existing TTree T, any variable from TF can be referenced in a query to T.; A tree keeps a list of friends. In the context of a tree (or a ch",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:105303,Performance,optimiz,optimize,105303,"ge stays in effect. When this tree is deleted, all the addresses of the cloned tree are reset to their default values.; If 'option' contains the word 'fast' and nentries is -1, the cloning will be done without unzipping or unstreaming the baskets (i.e., a direct copy of the raw bytes on disk).; When 'fast' is specified, 'option' can also contain a sorting order for the baskets in the output file.; There are currently 3 supported sorting order:. SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in the output file in the same order as in the original file (i.e. the baskets are sorted by their offset in the original file; Usually this also means that the baskets are sorted by the index/number of the last entry they contain); When using SortBasketsByBranch all the baskets of each individual branches are stored contiguously. This tends to optimize reading speed when reading a small number (1->5) of branches, since all their baskets will be clustered together instead of being spread across the file. However it might decrease the performance when reading more branches (or the full entry).; When using SortBasketsByEntry the baskets with the lowest starting entry are written first. (i.e. the baskets are sorted by the index/number of the first entry they contain). This means that on the file the baskets will be in the order in which they will be needed when reading the whole tree sequentially.; For examples of CloneTree, see tutorials:. copytree.C: A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1; copytree2.C: A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1 . Reimplemented in TNtuple.; Definition at line 3139 of file TTree.cxx. ◆ CopyAddresses(). ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:105496,Performance,perform,performance,105496,"ntains the word 'fast' and nentries is -1, the cloning will be done without unzipping or unstreaming the baskets (i.e., a direct copy of the raw bytes on disk).; When 'fast' is specified, 'option' can also contain a sorting order for the baskets in the output file.; There are currently 3 supported sorting order:. SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in the output file in the same order as in the original file (i.e. the baskets are sorted by their offset in the original file; Usually this also means that the baskets are sorted by the index/number of the last entry they contain); When using SortBasketsByBranch all the baskets of each individual branches are stored contiguously. This tends to optimize reading speed when reading a small number (1->5) of branches, since all their baskets will be clustered together instead of being spread across the file. However it might decrease the performance when reading more branches (or the full entry).; When using SortBasketsByEntry the baskets with the lowest starting entry are written first. (i.e. the baskets are sorted by the index/number of the first entry they contain). This means that on the file the baskets will be in the order in which they will be needed when reading the whole tree sequentially.; For examples of CloneTree, see tutorials:. copytree.C: A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1; copytree2.C: A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1 . Reimplemented in TNtuple.; Definition at line 3139 of file TTree.cxx. ◆ CopyAddresses(). void TTree::CopyAddresses ; (; TTree * ; tree, . bool ; undo = false . ). virtual . Set branch addresses of passed tree equal to ours",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:114064,Performance,perform,perform,114064,", Double_t mean=0, Double_t gamma=1)Calculates a Breit Wigner function with mean and gamma.Definition TMath.cxx:442; . [in]selectionA string containing a selection expression. In a selection all usual C++ mathematical and logical operators are allowed. The value corresponding to the selection expression is used as a weight to fill the histogram (a weight of 0 is equivalent to not filling the histogram). Examples:; ""x<y && sqrt(z)>3.2"": returns a weight = 0 or 1; ""(x+y)*(sqrt(z)>3.2)"": returns a weight = x+y if sqrt(z)>3.2, 0 otherwise. If the selection expression returns an array, it is iterated over in sync with the array returned by the varexp argument (as described below in ""Drawing expressions using arrays and array; elements""). For example, if, for a given event, varexp evaluates to {1., 2., 3.} and selection evaluates to {0, 1, 0}, the resulting histogram is filled with the value 2. For example, for each event here we perform a simple object selection: // Muon_pt is an array: fill a histogram with the array elements > 100 in each event; tree->Draw('Muon_pt', 'Muon_pt > 100'); . [in]optionThe drawing option.; When an histogram is produced it can be any histogram drawing option listed in THistPainter.; when no option is specified:; the default histogram drawing option is used if the expression is of the form ""e1"".; if the expression is of the form ""e1:e2""or ""e1:e2:e3"" a cloud of unbinned 2D or 3D points is drawn respectively.; if the expression has four fields ""e1:e2:e3:e4"" a cloud of unbinned 3D points is produced with e1 vs e2 vs e3, and e4 is mapped on the current color palette. If option COL is specified when varexp has three fields: tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the current color palette. The colors for e3 are evaluated once in linear scale before painting. Therefore changing the pad to log scale along Z as no effect on the colors.; if expression has more than four fields the option ""PARA""or ""CAN",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:127174,Performance,load,load,127174,"+0 Or with a variable size array arr3 tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1) As a comparison tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the actual_size_of_arr3 is greater or equal to 3. Note that the array in 'primary' is flattened/linearized thus using Alt$ with multi-dimensional arrays of different dimensions in unlikely to yield the expected results. To visualize a bit more what elements would be matched by TTree::Draw, TTree::Scan can be used: tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be matched by tree->Draw(""arr1-Alt$(arr2,0)"");; The ternary operator is not directly supported in TTree::Draw however, to plot the equivalent of var2<20 ? -99 : var1, you can use: tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly; If the formula contains a file name, TTree::MakeProxy will be used to load and execute this file. In particular it will draw the result of a function with the same name as the file. The function will be executed in a context where the name of the branches can be used as a C++ variable.; For example draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; hsimpleDefinition hsimple.py:1; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; Drawth1 Draw(); A more complete example is available in the tutorials directory: h1analysisProxy.cxx, h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C; The main features of this facility are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bound; ability to use the branch data as objec",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:127964,Performance,load,loading,127964,"ser function accessing the TTree data directly; If the formula contains a file name, TTree::MakeProxy will be used to load and execute this file. In particular it will draw the result of a function with the same name as the file. The function will be executed in a context where the name of the branches can be used as a C++ variable.; For example draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; hsimpleDefinition hsimple.py:1; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; Drawth1 Draw(); A more complete example is available in the tutorials directory: h1analysisProxy.cxx, h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C; The main features of this facility are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bound; ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram; In case of a 2-Dim expression, one can generate a TProfile histogram instead of a TH2F histogram by specifying option=prof or option=profs or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of y:x>>pf where pf is an existing TProfile histogram. Making a 2D Profile histogram; In case of a 3-Dim expression, one can generate a TProfile2D histogram instead of a TH3F histogram by specifying option=prof or option=profs. or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of z:y:x>>pf where pf is an existing TProf",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:132223,Performance,load,loaded,132223,"e ""+"" in front of the list name; tree.Draw("">>+yplus"",""y>0""); will not reset yplus, but will enter the selected entries at the end of the existing list. Using a TEventList, TEntryList or TEntryListArray as Input; Once a TEventList or a TEntryList object has been generated, it can be used as input for TTree::Draw. Use TTree::SetEventList or TTree::SetEntryList to set the current event list; Example 1: TEventList *elist = (TEventList*)gDirectory->Get(""yplus"");; tree->SetEventList(elist);; tree->Draw(""py"");; TEventList<div class=""legacybox""><h2>Legacy Code</h2> TEventList is a legacy interface: there will be no bug fi...Definition TEventList.h:31; Example 2: TEntryList *elist = (TEntryList*)gDirectory->Get(""yplus"");; tree->SetEntryList(elist);; tree->Draw(""py"");; TEntryListA List of entry numbers in a TTree or TChain.Definition TEntryList.h:26; If a TEventList object is used as input, a new TEntryList object is created inside the SetEventList function. In case of a TChain, all tree headers are loaded for this transformation. This new object is owned by the chain and is deleted with it, unless the user extracts it by calling GetEntryList() function. See also comments to SetEventList() function of TTree and TChain.; If arrays are used in the selection criteria and TEntryListArray is not used, all the entries that have at least one element of the array that satisfy the selection are entered in the list.; Example: tree.Draw("">>pyplus"",""fTracks.fPy>0"");; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of ALL tracks in event with at least one track with a positive fPy.; To select only the elements that did match the original selection use TEventList::SetReapplyCut or TEntryList::SetReapplyCut.; Example: tree.Draw("">>pyplus"",""fTracks.fPy>0"");; pyplus->SetReapplyCut(true);; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of only the tracks that have a positive fPy.; To draw only the elements that match a selection in case o",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:137279,Performance,cache,cache,137279,"raw ; (; const char * ; varexp, . const TCut & ; selection, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Draw expression varexp for specified entries. ; Returns-1 in case of error or number of selected events in case of success.; This function accepts TCut objects as arguments. Useful to use the string operator +; Example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Reimplemented in TChain, and TProofChain.; Definition at line 3855 of file TTree.cxx. ◆ Draw() [3/3]. void TTree::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 431 of file TTree.h. ◆ DropBaskets(). void TTree::DropBaskets ; (; ). virtual . Remove some baskets from memory. ; Definition at line 4518 of file TTree.cxx. ◆ DropBranchFromCache() [1/2]. Int_t TTree::DropBranchFromCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove the branch with name 'bname' from the Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment vari",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:137335,Performance,cache,cache,137335,"n, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Draw expression varexp for specified entries. ; Returns-1 in case of error or number of selected events in case of success.; This function accepts TCut objects as arguments. Useful to use the string operator +; Example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Reimplemented in TChain, and TProofChain.; Definition at line 3855 of file TTree.cxx. ◆ Draw() [3/3]. void TTree::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 431 of file TTree.h. ◆ DropBaskets(). void TTree::DropBaskets ; (; ). virtual . Remove some baskets from memory. ; Definition at line 4518 of file TTree.cxx. ◆ DropBranchFromCache() [1/2]. Int_t TTree::DropBranchFromCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove the branch with name 'bname' from the Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCach",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:137427,Performance,cache,cache,137427,"64_t ; firstentry = 0 . ). virtual . Draw expression varexp for specified entries. ; Returns-1 in case of error or number of selected events in case of success.; This function accepts TCut objects as arguments. Useful to use the string operator +; Example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Reimplemented in TChain, and TProofChain.; Definition at line 3855 of file TTree.cxx. ◆ Draw() [3/3]. void TTree::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 431 of file TTree.h. ◆ DropBaskets(). void TTree::DropBaskets ; (; ). virtual . Remove some baskets from memory. ; Definition at line 4518 of file TTree.cxx. ◆ DropBranchFromCache() [1/2]. Int_t TTree::DropBranchFromCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove the branch with name 'bname' from the Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:137472,Performance,cache,cache,137472,"ntries. ; Returns-1 in case of error or number of selected events in case of success.; This function accepts TCut objects as arguments. Useful to use the string operator +; Example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Reimplemented in TChain, and TProofChain.; Definition at line 3855 of file TTree.cxx. ◆ Draw() [3/3]. void TTree::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 431 of file TTree.h. ◆ DropBaskets(). void TTree::DropBaskets ; (; ). virtual . Remove some baskets from memory. ; Definition at line 4518 of file TTree.cxx. ◆ DropBranchFromCache() [1/2]. Int_t TTree::DropBranchFromCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove the branch with name 'bname' from the Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a ca",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:137698,Performance,cache,cache,137698,"plemented in TChain, and TProofChain.; Definition at line 3855 of file TTree.cxx. ◆ Draw() [3/3]. void TTree::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 431 of file TTree.h. ◆ DropBaskets(). void TTree::DropBaskets ; (; ). virtual . Remove some baskets from memory. ; Definition at line 4518 of file TTree.cxx. ◆ DropBranchFromCache() [1/2]. Int_t TTree::DropBranchFromCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove the branch with name 'bname' from the Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a cache attached to the TTree (either pre-exisiting or created as part of this call) ; Definition at line 2685 of file TTree.cxx. ◆ Fill(). Int_t TTree::Fill ; (; ). virtual . Fill all branches. ; This function loops on all t",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:137792,Performance,cache,cache,137792,"le TTree.cxx. ◆ Draw() [3/3]. void TTree::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 431 of file TTree.h. ◆ DropBaskets(). void TTree::DropBaskets ; (; ). virtual . Remove some baskets from memory. ; Definition at line 4518 of file TTree.cxx. ◆ DropBranchFromCache() [1/2]. Int_t TTree::DropBranchFromCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove the branch with name 'bname' from the Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a cache attached to the TTree (either pre-exisiting or created as part of this call) ; Definition at line 2685 of file TTree.cxx. ◆ Fill(). Int_t TTree::Fill ; (; ). virtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:137837,Performance,cache,cache,137837,"lineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Definition at line 431 of file TTree.h. ◆ DropBaskets(). void TTree::DropBaskets ; (; ). virtual . Remove some baskets from memory. ; Definition at line 4518 of file TTree.cxx. ◆ DropBranchFromCache() [1/2]. Int_t TTree::DropBranchFromCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove the branch with name 'bname' from the Tree cache. ; If bname=""*"" all branches are removed from the cache. if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a cache attached to the TTree (either pre-exisiting or created as part of this call) ; Definition at line 2685 of file TTree.cxx. ◆ Fill(). Int_t TTree::Fill ; (; ). virtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a s",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:138404,Performance,cache,cache,138404," . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a cache attached to the TTree (either pre-exisiting or created as part of this call) ; Definition at line 2685 of file TTree.cxx. ◆ Fill(). Int_t TTree::Fill ; (; ). virtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a simple data type, a simple conversion to a machine independent format has to be done.; This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:138461,Performance,cache,cache,138461," . Definition at line 1142 of file TTree.cxx. ◆ DropBranchFromCache() [2/2]. Int_t TTree::DropBranchFromCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove the branch b from the Tree cache. ; if subbranches is true all the branches of the subbranches are also removed from the cache.; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a cache attached to the TTree (either pre-exisiting or created as part of this call) ; Definition at line 2685 of file TTree.cxx. ◆ Fill(). Int_t TTree::Fill ; (; ). virtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a simple data type, a simple conversion to a machine independent format has to be done.; This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:139921,Performance,optimiz,optimize,139921,"at has to be done.; This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to flush the baskets happen, we also take this opportunity to optimize the baskets buffers. We also check if the amount of data written is greater than fAutoSave (see SetAutoSave). In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes. The decisions to FlushBaskets and Auto Save can be made based either on the number of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries written (fAutoFlush and fAutoSave positive). Note that the user can decide to call FlushBaskets and AutoSave in her event loop base on the number of events written instead of the number of bytes written.; NoteCalling TTree::FlushBaskets too often increases the IO time. Calling TTree::AutoSave too often increases the IO time and also the file size. This method calls TTree::ChangeFile when the tree reaches a size greater than TTree::fgMaxTreeSize. This doesn't happen if the tree is attached to a TMemFile or derivate. ; Reimplemented in TChain, TNt",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:146009,Performance,cache,cache,146009,"ee::GetBranch ; (; const char * ; name). virtual . Return pointer to the branch with the given name in this tree or its friends. ; The search is done breadth first. ; Reimplemented in TProofChain, and TChain.; Definition at line 5294 of file TTree.cxx. ◆ GetBranchRef(). virtual TBranchRef * TTree::GetBranchRef ; (; ); const. inlinevirtual . Definition at line 450 of file TTree.h. ◆ GetBranchStatus(). bool TTree::GetBranchStatus ; (; const char * ; branchname); const. virtual . Return status of branch with name branchname. . 0 if branch is not activated; 1 if branch is activated . Reimplemented in TProofChain, and TChain.; Definition at line 5380 of file TTree.cxx. ◆ GetBranchStyle(). Int_t TTree::GetBranchStyle ; (; ). static . Static function returning the current branch style. . style = 0 old Branch; style = 1 new Bronch . Definition at line 5395 of file TTree.cxx. ◆ GetCacheAutoSize(). Long64_t TTree::GetCacheAutoSize ; (; bool ; withDefault = false). protected . Used for automatic sizing of the cache. ; Estimates a suitable size for the tree cache based on AutoFlush. A cache sizing factor is taken from the configuration. If this yields zero and withDefault is true the historical algorithm for default size is used. ; Definition at line 5407 of file TTree.cxx. ◆ GetCacheSize(). virtual Long64_t TTree::GetCacheSize ; (; ); const. inlinevirtual . Reimplemented in TChain.; Definition at line 453 of file TTree.h. ◆ GetChainEntryNumber(). virtual Long64_t TTree::GetChainEntryNumber ; (; Long64_t ; entry); const. inlinevirtual . Reimplemented in TChain.; Definition at line 455 of file TTree.h. ◆ GetChainOffset(). virtual Long64_t TTree::GetChainOffset ; (; ); const. inlinevirtual . Definition at line 456 of file TTree.h. ◆ GetClusterIterator(). TTree::TClusterIterator TTree::GetClusterIterator ; (; Long64_t ; firstentry). virtual . Return an iterator over the cluster of baskets starting at firstentry. ; This iterator is not yet supported for TChain object. TTree::TClust",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:146057,Performance,cache,cache,146057,"turn pointer to the branch with the given name in this tree or its friends. ; The search is done breadth first. ; Reimplemented in TProofChain, and TChain.; Definition at line 5294 of file TTree.cxx. ◆ GetBranchRef(). virtual TBranchRef * TTree::GetBranchRef ; (; ); const. inlinevirtual . Definition at line 450 of file TTree.h. ◆ GetBranchStatus(). bool TTree::GetBranchStatus ; (; const char * ; branchname); const. virtual . Return status of branch with name branchname. . 0 if branch is not activated; 1 if branch is activated . Reimplemented in TProofChain, and TChain.; Definition at line 5380 of file TTree.cxx. ◆ GetBranchStyle(). Int_t TTree::GetBranchStyle ; (; ). static . Static function returning the current branch style. . style = 0 old Branch; style = 1 new Bronch . Definition at line 5395 of file TTree.cxx. ◆ GetCacheAutoSize(). Long64_t TTree::GetCacheAutoSize ; (; bool ; withDefault = false). protected . Used for automatic sizing of the cache. ; Estimates a suitable size for the tree cache based on AutoFlush. A cache sizing factor is taken from the configuration. If this yields zero and withDefault is true the historical algorithm for default size is used. ; Definition at line 5407 of file TTree.cxx. ◆ GetCacheSize(). virtual Long64_t TTree::GetCacheSize ; (; ); const. inlinevirtual . Reimplemented in TChain.; Definition at line 453 of file TTree.h. ◆ GetChainEntryNumber(). virtual Long64_t TTree::GetChainEntryNumber ; (; Long64_t ; entry); const. inlinevirtual . Reimplemented in TChain.; Definition at line 455 of file TTree.h. ◆ GetChainOffset(). virtual Long64_t TTree::GetChainOffset ; (; ); const. inlinevirtual . Definition at line 456 of file TTree.h. ◆ GetClusterIterator(). TTree::TClusterIterator TTree::GetClusterIterator ; (; Long64_t ; firstentry). virtual . Return an iterator over the cluster of baskets starting at firstentry. ; This iterator is not yet supported for TChain object. TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entr",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:146085,Performance,cache,cache,146085,"r its friends. ; The search is done breadth first. ; Reimplemented in TProofChain, and TChain.; Definition at line 5294 of file TTree.cxx. ◆ GetBranchRef(). virtual TBranchRef * TTree::GetBranchRef ; (; ); const. inlinevirtual . Definition at line 450 of file TTree.h. ◆ GetBranchStatus(). bool TTree::GetBranchStatus ; (; const char * ; branchname); const. virtual . Return status of branch with name branchname. . 0 if branch is not activated; 1 if branch is activated . Reimplemented in TProofChain, and TChain.; Definition at line 5380 of file TTree.cxx. ◆ GetBranchStyle(). Int_t TTree::GetBranchStyle ; (; ). static . Static function returning the current branch style. . style = 0 old Branch; style = 1 new Bronch . Definition at line 5395 of file TTree.cxx. ◆ GetCacheAutoSize(). Long64_t TTree::GetCacheAutoSize ; (; bool ; withDefault = false). protected . Used for automatic sizing of the cache. ; Estimates a suitable size for the tree cache based on AutoFlush. A cache sizing factor is taken from the configuration. If this yields zero and withDefault is true the historical algorithm for default size is used. ; Definition at line 5407 of file TTree.cxx. ◆ GetCacheSize(). virtual Long64_t TTree::GetCacheSize ; (; ); const. inlinevirtual . Reimplemented in TChain.; Definition at line 453 of file TTree.h. ◆ GetChainEntryNumber(). virtual Long64_t TTree::GetChainEntryNumber ; (; Long64_t ; entry); const. inlinevirtual . Reimplemented in TChain.; Definition at line 455 of file TTree.h. ◆ GetChainOffset(). virtual Long64_t TTree::GetChainOffset ; (; ); const. inlinevirtual . Definition at line 456 of file TTree.h. ◆ GetClusterIterator(). TTree::TClusterIterator TTree::GetClusterIterator ; (; Long64_t ; firstentry). virtual . Return an iterator over the cluster of baskets starting at firstentry. ; This iterator is not yet supported for TChain object. TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; Long64_t clusterStart;; while( (clusterStart = clusterIt",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:154725,Performance,perform,performs,154725," for the object ownership policy of the underlying (user) data. ; Reimplemented in THbookTree, TChain, and TTreeSQL.; Definition at line 5638 of file TTree.cxx. ◆ GetEntryList(). TEntryList * TTree::GetEntryList ; (; ). virtual . Returns the entry list assigned to this tree. ; Definition at line 5854 of file TTree.cxx. ◆ GetEntryNumber(). Long64_t TTree::GetEntryNumber ; (; Long64_t ; entry); const. virtual . Return entry number corresponding to entry. ; if no TEntryList set returns entry else returns the entry number corresponding to the list index=entry ; Reimplemented in TChain.; Definition at line 5865 of file TTree.cxx. ◆ GetEntryNumberWithBestIndex(). Long64_t TTree::GetEntryNumberWithBestIndex ; (; Long64_t ; major, . Long64_t ; minor = 0 . ); const. virtual . Return entry number corresponding to major and minor number. ; Note that this function returns only the entry number, not the data To read the data corresponding to an entry number, use TTree::GetEntryWithIndex the BuildIndex function has created a table of Long64_t* of sorted values corresponding to val = major<<31 + minor; The function performs binary search in this sorted table. If it finds a pair that matches val, it returns directly the index in the table. If an entry corresponding to major and minor is not found, the function returns the index of the major,minor pair immediately lower than the requested value, ie it will return -1 if the pair is lower than the first entry in the index.; See also GetEntryNumberWithIndex ; Definition at line 5890 of file TTree.cxx. ◆ GetEntryNumberWithIndex(). Long64_t TTree::GetEntryNumberWithIndex ; (; Long64_t ; major, . Long64_t ; minor = 0 . ); const. virtual . Return entry number corresponding to major and minor number. ; Note that this function returns only the entry number, not the data To read the data corresponding to an entry number, use TTree::GetEntryWithIndex the BuildIndex function has created a table of Long64_t* of sorted values corresponding to val",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:155642,Performance,perform,performs,155642,"the data corresponding to an entry number, use TTree::GetEntryWithIndex the BuildIndex function has created a table of Long64_t* of sorted values corresponding to val = major<<31 + minor; The function performs binary search in this sorted table. If it finds a pair that matches val, it returns directly the index in the table. If an entry corresponding to major and minor is not found, the function returns the index of the major,minor pair immediately lower than the requested value, ie it will return -1 if the pair is lower than the first entry in the index.; See also GetEntryNumberWithIndex ; Definition at line 5890 of file TTree.cxx. ◆ GetEntryNumberWithIndex(). Long64_t TTree::GetEntryNumberWithIndex ; (; Long64_t ; major, . Long64_t ; minor = 0 . ); const. virtual . Return entry number corresponding to major and minor number. ; Note that this function returns only the entry number, not the data To read the data corresponding to an entry number, use TTree::GetEntryWithIndex the BuildIndex function has created a table of Long64_t* of sorted values corresponding to val = major<<31 + minor; The function performs binary search in this sorted table. If it finds a pair that matches val, it returns directly the index in the table, otherwise it returns -1.; See also GetEntryNumberWithBestIndex ; Definition at line 5910 of file TTree.cxx. ◆ GetEntryWithIndex(). Int_t TTree::GetEntryWithIndex ; (; Int_t ; major, . Int_t ; minor = 0 . ). virtual . Read entry corresponding to major and minor number. ; The function returns the total number of bytes read. If the Tree has friend trees, the corresponding entry with the index values (major,minor) is read. Note that the master Tree and its friend may have different entry serial numbers corresponding to (major,minor). ; Reimplemented in TChain.; Definition at line 5927 of file TTree.cxx. ◆ GetEstimate(). virtual Long64_t TTree::GetEstimate ; (; ); const. inlinevirtual . Definition at line 467 of file TTree.h. ◆ GetEvent(). Int_t TTree",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:162061,Performance,cache,cache,162061,"const. inline . Definition at line 495 of file TTree.h. ◆ GetMaxEntryLoop(). virtual Long64_t TTree::GetMaxEntryLoop ; (; ); const. inlinevirtual . Definition at line 497 of file TTree.h. ◆ GetMaximum(). Double_t TTree::GetMaximum ; (; const char * ; columname). virtual . Return maximum of column with name columname. ; if the Tree has an associated TEventList or TEntryList, the maximum is computed for the entries in this list. ; Reimplemented in TChain.; Definition at line 6235 of file TTree.cxx. ◆ GetMaxTreeSize(). Long64_t TTree::GetMaxTreeSize ; (; ). static . Static function which returns the tree file size limit in bytes. ; Definition at line 6265 of file TTree.cxx. ◆ GetMaxVirtualSize(). virtual Long64_t TTree::GetMaxVirtualSize ; (; ); const. inlinevirtual . Definition at line 500 of file TTree.h. ◆ GetMedianClusterSize(). Long64_t TTree::GetMedianClusterSize ; (; ). private . Estimate the median cluster size for the TTree. ; This value provides e.g. a reasonable cache size default if other heuristics fail. Clusters with size 0 and the very last cluster range, that might not have been committed to fClusterSize yet, are ignored for the purposes of the calculation. ; Definition at line 8292 of file TTree.cxx. ◆ GetMinimum(). Double_t TTree::GetMinimum ; (; const char * ; columname). virtual . Return minimum of column with name columname. ; if the Tree has an associated TEventList or TEntryList, the minimum is computed for the entries in this list. ; Reimplemented in TChain.; Definition at line 6275 of file TTree.cxx. ◆ GetNbranches(). virtual Int_t TTree::GetNbranches ; (; ). inlinevirtual . Reimplemented in TChain.; Definition at line 502 of file TTree.h. ◆ GetNewlineValue(). char TTree::GetNewlineValue ; (; std::istream & ; inputStream). protected . Determine which newline this file is using. ; Return '\r' for Windows '\r\n' as that already terminates. ; Definition at line 7588 of file TTree.cxx. ◆ GetNotify(). TObject * TTree::GetNotify ; (; ); const. inline",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:163987,Performance,cache,cache,163987,"8 of file TTree.cxx. ◆ GetNotify(). TObject * TTree::GetNotify ; (; ); const. inline . Definition at line 503 of file TTree.h. ◆ GetPacketSize(). virtual Int_t TTree::GetPacketSize ; (; ); const. inlinevirtual . Definition at line 505 of file TTree.h. ◆ GetPerfStats(). virtual TVirtualPerfStats * TTree::GetPerfStats ; (; ); const. inlinevirtual . Definition at line 506 of file TTree.h. ◆ GetPlayer(). TVirtualTreePlayer * TTree::GetPlayer ; (; ). Load the TTreePlayer (if not already done). ; Definition at line 6305 of file TTree.cxx. ◆ GetReadCache() [1/2]. TTreeCache * TTree::GetReadCache ; (; TFile * ; file); const. Find and return the TTreeCache registered with the file and which may contain branches for us. ; Definition at line 6318 of file TTree.cxx. ◆ GetReadCache() [2/2]. TTreeCache * TTree::GetReadCache ; (; TFile * ; file, . bool ; create . ). Find and return the TTreeCache registered with the file and which may contain branches for us. ; If create is true and there is no cache a new cache is created with default size. ; Definition at line 6331 of file TTree.cxx. ◆ GetReadEntry(). virtual Long64_t TTree::GetReadEntry ; (; ); const. inlinevirtual . Reimplemented in TProofChain, and TChain.; Definition at line 509 of file TTree.h. ◆ GetReadEvent(). virtual Long64_t TTree::GetReadEvent ; (; ); const. inlinevirtual . Definition at line 510 of file TTree.h. ◆ GetScanField(). virtual Int_t TTree::GetScanField ; (; ); const. inlinevirtual . Definition at line 511 of file TTree.h. ◆ GetSelect(). TTreeFormula * TTree::GetSelect ; (; ). inline . Definition at line 512 of file TTree.h. ◆ GetSelectedRows(). virtual Long64_t TTree::GetSelectedRows ; (; ). inlinevirtual . Definition at line 513 of file TTree.h. ◆ GetTargetMemoryRatio(). Float_t TTree::GetTargetMemoryRatio ; (; ); const. inline . Definition at line 520 of file TTree.h. ◆ GetTimerInterval(). virtual Int_t TTree::GetTimerInterval ; (; ); const. inlinevirtual . Definition at line 514 of file TTree.h. ◆ GetTot",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:163999,Performance,cache,cache,163999,"8 of file TTree.cxx. ◆ GetNotify(). TObject * TTree::GetNotify ; (; ); const. inline . Definition at line 503 of file TTree.h. ◆ GetPacketSize(). virtual Int_t TTree::GetPacketSize ; (; ); const. inlinevirtual . Definition at line 505 of file TTree.h. ◆ GetPerfStats(). virtual TVirtualPerfStats * TTree::GetPerfStats ; (; ); const. inlinevirtual . Definition at line 506 of file TTree.h. ◆ GetPlayer(). TVirtualTreePlayer * TTree::GetPlayer ; (; ). Load the TTreePlayer (if not already done). ; Definition at line 6305 of file TTree.cxx. ◆ GetReadCache() [1/2]. TTreeCache * TTree::GetReadCache ; (; TFile * ; file); const. Find and return the TTreeCache registered with the file and which may contain branches for us. ; Definition at line 6318 of file TTree.cxx. ◆ GetReadCache() [2/2]. TTreeCache * TTree::GetReadCache ; (; TFile * ; file, . bool ; create . ). Find and return the TTreeCache registered with the file and which may contain branches for us. ; If create is true and there is no cache a new cache is created with default size. ; Definition at line 6331 of file TTree.cxx. ◆ GetReadEntry(). virtual Long64_t TTree::GetReadEntry ; (; ); const. inlinevirtual . Reimplemented in TProofChain, and TChain.; Definition at line 509 of file TTree.h. ◆ GetReadEvent(). virtual Long64_t TTree::GetReadEvent ; (; ); const. inlinevirtual . Definition at line 510 of file TTree.h. ◆ GetScanField(). virtual Int_t TTree::GetScanField ; (; ); const. inlinevirtual . Definition at line 511 of file TTree.h. ◆ GetSelect(). TTreeFormula * TTree::GetSelect ; (; ). inline . Definition at line 512 of file TTree.h. ◆ GetSelectedRows(). virtual Long64_t TTree::GetSelectedRows ; (; ). inlinevirtual . Definition at line 513 of file TTree.h. ◆ GetTargetMemoryRatio(). Float_t TTree::GetTargetMemoryRatio ; (; ); const. inline . Definition at line 520 of file TTree.h. ◆ GetTimerInterval(). virtual Int_t TTree::GetTimerInterval ; (; ); const. inlinevirtual . Definition at line 514 of file TTree.h. ◆ GetTot",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:170879,Performance,load,loading,170879,"2 of file TTree.cxx. ◆ IsA(). TClass * TTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 659 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 547 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:176222,Performance,load,loading,176222,"efix.h; located in the current directory or in 'path/' if it is specified. The class generated will be named 'fileprefix'; ""macrofilename"" and optionally ""cutfilename"" are expected to point to source files which will be included by the generated skeleton. Method of the same name as the file(minus the extension and path) will be called by the generated skeleton's Process method as follow: [if (cutfilename())] htemp->Fill(macrofilename());; ""option"" can be used select some of the optional features during the code generation. The possible options are:. nohist : indicates that the generated ProcessFill should not fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the system 'unroll' classes that are not split. Unrolling a class allows direct access to its data members (this emulates the behavior of TTreeFormula).; The main features of this skeleton are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bounds errors; ability to use the branch data as an object (when the user code is available). For example with Event.root, if Double_t somePx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somePx will updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; These two functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For exampl",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:177292,Performance,cache,cache,177292,"branchname' as if it was a data member; protection against array out-of-bounds errors; ability to use the branch data as an object (when the user code is available). For example with Event.root, if Double_t somePx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somePx will updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; These two functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example: Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; nconst Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:178356,Performance,load,loaded,178356,". For example: Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; nconst Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.; The default histogram is accessible via the variable named 'htemp'.; If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed include statements and give the ability to access the object stored in the branches.; To draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C ; Definition at line 6768 of file TTree.cxx. ◆ MakeSelector(). Int_t TTree::MakeSelector ; (; const char * ; selector = nullptr, . Option_t * ; option = """" . ). virtual . Generate skeleton selector class for this tre",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:178501,Performance,load,loaded,178501,"d selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.; The default histogram is accessible via the variable named 'htemp'.; If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed include statements and give the ability to access the object stored in the branches.; To draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C ; Definition at line 6768 of file TTree.cxx. ◆ MakeSelector(). Int_t TTree::MakeSelector ; (; const char * ; selector = nullptr, . Option_t * ; option = """" . ). virtual . Generate skeleton selector class for this tree. ; The following files are produced: selector.h and selector.C. If selector is 0, the selector will be called ""nameoftree"". The option can be used to specify the branches that will have a data member.; If option is ""=le",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:182616,Performance,cache,cache,182616,"le TTree.cxx. ◆ Merge() [2/2]. Long64_t TTree::Merge ; (; TCollection * ; li, . TFileMergeInfo * ; info . ). virtual . Merge the trees in the TList into this tree. ; If info->fIsFirst is true, first we clone this TTree info the directory info->fOutputDirectory and then overlay the new TTree information onto this TTree object (so that this TTree object is now the appropriate to use for further merging).; Returns the total number of entries in the merged tree. ; Reimplemented in TChain.; Definition at line 6927 of file TTree.cxx. ◆ MergeTrees(). TTree * TTree::MergeTrees ; (; TList * ; li, . Option_t * ; options = """" . ). static . Static function merging the trees in the TList into a new tree. ; Trees in the list can be memory or disk-resident trees. The new tree is created in the current directory (memory if gROOT). ; Definition at line 6851 of file TTree.cxx. ◆ MoveReadCache(). void TTree::MoveReadCache ; (; TFile * ; src, . TDirectory * ; dir . ). protected . Move a cache from a file to the current file in dir. ; if src is null no operation is done, if dir is null or there is no current file the cache is deleted. ; Definition at line 6983 of file TTree.cxx. ◆ Notify(). bool TTree::Notify ; (; ). overridevirtual . Function called when loading a new class library. ; Reimplemented from TObject.; Definition at line 7033 of file TTree.cxx. ◆ operator=(). TTree & TTree::operator= ; (; const TTree & ; tt). delete . ◆ OptimizeBaskets(). void TTree::OptimizeBaskets ; (; ULong64_t ; maxMemory = 10000000, . Float_t ; minComp = 1.1, . Option_t * ; option = """" . ). virtual . This function may be called after having filled some entries in a Tree. ; Using the information in the existing branch buffers, it will reassign new branch buffer sizes to optimize time and memory.; The function computes the best values for branch buffer sizes such that the total buffer sizes is less than maxMemory and nearby entries written at the same time. In case the branch compression factor for the dat",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:182748,Performance,cache,cache,182748," TFileMergeInfo * ; info . ). virtual . Merge the trees in the TList into this tree. ; If info->fIsFirst is true, first we clone this TTree info the directory info->fOutputDirectory and then overlay the new TTree information onto this TTree object (so that this TTree object is now the appropriate to use for further merging).; Returns the total number of entries in the merged tree. ; Reimplemented in TChain.; Definition at line 6927 of file TTree.cxx. ◆ MergeTrees(). TTree * TTree::MergeTrees ; (; TList * ; li, . Option_t * ; options = """" . ). static . Static function merging the trees in the TList into a new tree. ; Trees in the list can be memory or disk-resident trees. The new tree is created in the current directory (memory if gROOT). ; Definition at line 6851 of file TTree.cxx. ◆ MoveReadCache(). void TTree::MoveReadCache ; (; TFile * ; src, . TDirectory * ; dir . ). protected . Move a cache from a file to the current file in dir. ; if src is null no operation is done, if dir is null or there is no current file the cache is deleted. ; Definition at line 6983 of file TTree.cxx. ◆ Notify(). bool TTree::Notify ; (; ). overridevirtual . Function called when loading a new class library. ; Reimplemented from TObject.; Definition at line 7033 of file TTree.cxx. ◆ operator=(). TTree & TTree::operator= ; (; const TTree & ; tt). delete . ◆ OptimizeBaskets(). void TTree::OptimizeBaskets ; (; ULong64_t ; maxMemory = 10000000, . Float_t ; minComp = 1.1, . Option_t * ; option = """" . ). virtual . This function may be called after having filled some entries in a Tree. ; Using the information in the existing branch buffers, it will reassign new branch buffer sizes to optimize time and memory.; The function computes the best values for branch buffer sizes such that the total buffer sizes is less than maxMemory and nearby entries written at the same time. In case the branch compression factor for the data written so far is less than compMin, the compression is disabled.; if option",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:182889,Performance,load,loading,182889,"ry and then overlay the new TTree information onto this TTree object (so that this TTree object is now the appropriate to use for further merging).; Returns the total number of entries in the merged tree. ; Reimplemented in TChain.; Definition at line 6927 of file TTree.cxx. ◆ MergeTrees(). TTree * TTree::MergeTrees ; (; TList * ; li, . Option_t * ; options = """" . ). static . Static function merging the trees in the TList into a new tree. ; Trees in the list can be memory or disk-resident trees. The new tree is created in the current directory (memory if gROOT). ; Definition at line 6851 of file TTree.cxx. ◆ MoveReadCache(). void TTree::MoveReadCache ; (; TFile * ; src, . TDirectory * ; dir . ). protected . Move a cache from a file to the current file in dir. ; if src is null no operation is done, if dir is null or there is no current file the cache is deleted. ; Definition at line 6983 of file TTree.cxx. ◆ Notify(). bool TTree::Notify ; (; ). overridevirtual . Function called when loading a new class library. ; Reimplemented from TObject.; Definition at line 7033 of file TTree.cxx. ◆ operator=(). TTree & TTree::operator= ; (; const TTree & ; tt). delete . ◆ OptimizeBaskets(). void TTree::OptimizeBaskets ; (; ULong64_t ; maxMemory = 10000000, . Float_t ; minComp = 1.1, . Option_t * ; option = """" . ). virtual . This function may be called after having filled some entries in a Tree. ; Using the information in the existing branch buffers, it will reassign new branch buffer sizes to optimize time and memory.; The function computes the best values for branch buffer sizes such that the total buffer sizes is less than maxMemory and nearby entries written at the same time. In case the branch compression factor for the data written so far is less than compMin, the compression is disabled.; if option =""d"" an analysis report is printed. ; Definition at line 7057 of file TTree.cxx. ◆ Principal(). TPrincipal * TTree::Principal ; (; const char * ; varexp = """", . const char * ; se",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:183396,Performance,optimiz,optimize,183396," be memory or disk-resident trees. The new tree is created in the current directory (memory if gROOT). ; Definition at line 6851 of file TTree.cxx. ◆ MoveReadCache(). void TTree::MoveReadCache ; (; TFile * ; src, . TDirectory * ; dir . ). protected . Move a cache from a file to the current file in dir. ; if src is null no operation is done, if dir is null or there is no current file the cache is deleted. ; Definition at line 6983 of file TTree.cxx. ◆ Notify(). bool TTree::Notify ; (; ). overridevirtual . Function called when loading a new class library. ; Reimplemented from TObject.; Definition at line 7033 of file TTree.cxx. ◆ operator=(). TTree & TTree::operator= ; (; const TTree & ; tt). delete . ◆ OptimizeBaskets(). void TTree::OptimizeBaskets ; (; ULong64_t ; maxMemory = 10000000, . Float_t ; minComp = 1.1, . Option_t * ; option = """" . ). virtual . This function may be called after having filled some entries in a Tree. ; Using the information in the existing branch buffers, it will reassign new branch buffer sizes to optimize time and memory.; The function computes the best values for branch buffer sizes such that the total buffer sizes is less than maxMemory and nearby entries written at the same time. In case the branch compression factor for the data written so far is less than compMin, the compression is disabled.; if option =""d"" an analysis report is printed. ; Definition at line 7057 of file TTree.cxx. ◆ Principal(). TPrincipal * TTree::Principal ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = ""np"", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). Interface to the Principal Components Analysis class. ; Create an instance of TPrincipal; Fill it with the selected variables. if option ""n"" is specified, the TPrincipal object is filled with normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" gene",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:185963,Performance,cache,cache,185963,"principal.py:1. Definition at line 7200 of file TTree.cxx. ◆ Print(). void TTree::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print a summary of the tree contents. . If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g., T.Print(""Elec*"") will print all branches with name starting with ""Elec"". ; Reimplemented from TNamed.; Definition at line 7219 of file TTree.cxx. ◆ PrintCacheStats(). void TTree::PrintCacheStats ; (; Option_t * ; option = """"); const. virtual . Print statistics about the TreeCache for this tree. ; Like: ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245; if option = ""a"" the list of blocks in the cache is printed ; Definition at line 7370 of file TTree.cxx. ◆ Pro",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:186959,Performance,cache,cache,186959," cache: 202, total size : 6001193; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245; if option = ""a"" the list of blocks in the cache is printed ; Definition at line 7370 of file TTree.cxx. ◆ Process() [1/2]. Long64_t TTree::Process ; (; const char * ; filename, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Process this tree executing the TSelector code in the specified filename. ; The return value is -1 in case of error and TSelector::GetStatus() in in case of success.; The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector, where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts, a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the slave servers.; Process(): called for each event, in this function you decide what to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF called only on the slave servers.; ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:187393,Performance,load,loaded,187393,"tionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245; if option = ""a"" the list of blocks in the cache is printed ; Definition at line 7370 of file TTree.cxx. ◆ Process() [1/2]. Long64_t TTree::Process ; (; const char * ; filename, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Process this tree executing the TSelector code in the specified filename. ; The return value is -1 in case of error and TSelector::GetStatus() in in case of success.; The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector, where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts, a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the slave servers.; Process(): called for each event, in this function you decide what to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF called only on the slave servers.; Terminate(): called at the end of the loop on the tree, a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:188218,Performance,load,loaded,188218,"ocess this tree executing the TSelector code in the specified filename. ; The return value is -1 in case of error and TSelector::GetStatus() in in case of success.; The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector, where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts, a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the slave servers.; Process(): called for each event, in this function you decide what to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF called only on the slave servers.; Terminate(): called at the end of the loop on the tree, a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function accepting a TSelector* as argument.eg MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:188312,Performance,load,loaded,188312,"-1 in case of error and TSelector::GetStatus() in in case of success.; The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector, where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts, a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the slave servers.; Process(): called for each event, in this function you decide what to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF called only on the slave servers.; Terminate(): called at the end of the loop on the tree, a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function accepting a TSelector* as argument.eg MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char f",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:188422,Performance,load,loaded,188422,"ed, see below), filename must contain a valid class implementation derived from TSelector, where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts, a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the slave servers.; Process(): called for each event, in this function you decide what to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF called only on the slave servers.; Terminate(): called at the end of the loop on the tree, a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function accepting a TSelector* as argument.eg MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; TSelector::Processvirtual bool Process(Long64_t)The Process() function is cal",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:189626,Performance,load,loaded,189626,"name);; selector->CallSomeFunction(..);; mytree.Process(selector,..);; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; TSelector::Processvirtual bool Process(Long64_t)The Process() function is called for each entry in the tree (or possibly keyed object in the case of ...Definition TSelector.cxx:360; TSelector::GetSelectorstatic TSelector * GetSelector(const char *filename)The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid cl...Definition TSelector.cxx:142; ; NOTE2; One should not call this function twice with the same selector file in the same script. If this is required, proceed as indicated in NOTE1, by getting a pointer to the corresponding TSelector,eg. Workaround 1; void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and...Definition TSelector.h:31; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11;",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:200240,Performance,optimiz,optimize,200240,"8136 of file TTree.cxx. ◆ SetAutoFlush(). void TTree::SetAutoFlush ; (; Long64_t ; autof = -30000000). virtual . This function may be called at the start of a program to change the default value for fAutoFlush. . CASE 1 : autof > 0; autof is the number of consecutive entries after which TTree::Fill will flush all branch buffers to disk. CASE 2 : autof < 0; When filling the Tree the branch buffers will be flushed to disk when more than autof bytes have been written to the file. At the first FlushBaskets TTree::Fill will replace fAutoFlush by the current value of fEntries.; Calling this function with autof<0 is interesting when it is hard to estimate the size of one entry. This value is also independent of the Tree.; The Tree is initialized with fAutoFlush=-30000000, ie that, by default, the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0; The AutoFlush mechanism is disabled.; Flushing the buffers at regular intervals optimize the location of consecutive entries on the disk by creating clusters of baskets.; A cluster of baskets is a set of baskets that contains all the data for a (consecutive) set of entries and that is stored consecutively on the disk. When reading all the branches, this is the minimum set of baskets that the TTreeCache will read. ; Definition at line 8191 of file TTree.cxx. ◆ SetAutoSave(). void TTree::SetAutoSave ; (; Long64_t ; autos = -300000000). virtual . In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ; This function may be called before filling a TTree to specify when the branch buffers and TTree header are flushed to disk as part of TTree::Fill(). The default is -300000000, ie the TTree will write data to disk once it exceeds 300 MBytes. CASE 1: If fAutoSave is positive the watermark is reached when a multiple of fAutoSave entries have been filled. CASE 2: If fAutoSave is negative the watermark is reached when -fAutoSave bytes can be",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:207225,Performance,cache,cache,207225,"h of the sub branches.; An alternative to this function is to read directly and only the interesting branches. Example: TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);; TBranch::GetEntryvirtual Int_t GetEntry(Long64_t entry=0, Int_t getall=0)Read all leaves of entry and return total number of bytes read.Definition TBranch.cxx:1706; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an exist",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:207604,Performance,cache,cacheSize,207604,"ytes read.Definition TBranch.cxx:1706; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:207660,Performance,cache,cache,207660,"the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough.",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:207673,Performance,cache,cachesize,207673,"ar expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . D",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:207700,Performance,cache,cache,207700,"ar expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . D",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:207731,Performance,cache,cachesize,207731,"essed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:207857,Performance,cache,cache,207857,"chStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of fi",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208064,Performance,cache,cacheSize,208064,"e TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffe",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208120,Performance,cache,cache,208120,"EntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this functi",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208204,Performance,cache,cache,208204,"eeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per br",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208254,Performance,cache,cache,208254,"eeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per br",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208305,Performance,cache,cacheSize,208305,"id TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208317,Performance,cache,cacheSize,208317,"id TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208336,Performance,cache,cache,208336,"id TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208353,Performance,cache,cache,208353,"id TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208380,Performance,cache,cacheSize,208380,"id TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208416,Performance,cache,cache,208416,"id TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208483,Performance,cache,cache,208483,"er of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results of the last maxEntries events. NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before m",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208490,Performance,cache,cacheSize,208490,"tion at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results of the last maxEntries events. NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before merging circular Trees that have been saved on ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208520,Performance,cache,cache,208520,"tion at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results of the last maxEntries events. NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before merging circular Trees that have been saved on ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208532,Performance,cache,cache,208532,"cheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results of the last maxEntries events. NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before merging circular Trees that have been saved on files. NOTE 3:; SetCircular with maxEntries ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208623,Performance,cache,cache,208623," = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results of the last maxEntries events. NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before merging circular Trees that have been saved on files. NOTE 3:; SetCircular with maxEntries <= 0 is automatically called by TChain::Merge NOTE 4:; A circ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:208651,Performance,cache,cache,208651," cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results of the last maxEntries events. NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before merging circular Trees that have been saved on files. NOTE 3:; SetCircular with maxEntries <= 0 is automatically called by TChain::Merge NOTE 4:; A circular Tree can still be saved in a file. When read back, it i",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:215340,Performance,load,loaded,215340,"4_t ; maxev = kMaxEntries). inlinevirtual . Definition at line 623 of file TTree.h. ◆ SetMaxTreeSize(). void TTree::SetMaxTreeSize ; (; Long64_t ; maxsize = 100000000000LL). static . Set the maximum size in bytes of a Tree file (static function). ; The default size is 100000000000LL, ie 100 Gigabytes.; In TTree::Fill, when the file has a size > fgMaxTreeSize, the function closes the current file and starts writing into a new file with a name of the style ""file_1.root"" if the original requested file name was ""file.root"". ; Definition at line 9187 of file TTree.cxx. ◆ SetMaxVirtualSize(). virtual void TTree::SetMaxVirtualSize ; (; Long64_t ; size = 0). inlinevirtual . Definition at line 625 of file TTree.h. ◆ SetName(). void TTree::SetName ; (; const char * ; name). overridevirtual . Change the name of this tree. ; Reimplemented from TNamed.; Definition at line 9195 of file TTree.cxx. ◆ SetNotify(). void TTree::SetNotify ; (; TObject * ; obj). virtual . Sets the address of the object to be notified when the tree is loaded. ; The method TObject::Notify is called for the given object when the tree is loaded. Specifically this occurs in the TTree::LoadTree method. To remove the notification call this method with nullptr: tree->SetNotify(nullptr); ; If this is a TChain, obj is most often going to be a TNotifyLink.; Parameters. [in]objPointer to a TObject to be notified. . Definition at line 9221 of file TTree.cxx. ◆ SetObject(). void TTree::SetObject ; (; const char * ; name, . const char * ; title . ). virtual . Change the name and title of this tree. ; Definition at line 9250 of file TTree.cxx. ◆ SetParallelUnzip(). void TTree::SetParallelUnzip ; (; bool ; opt = true, . Float_t ; RelSize = -1 . ). virtual . Enable or disable parallel unzipping of Tree buffers. ; Definition at line 9281 of file TTree.cxx. ◆ SetPerfStats(). void TTree::SetPerfStats ; (; TVirtualPerfStats * ; perf). virtual . Set perf stats. ; Definition at line 9319 of file TTree.cxx. ◆ SetScanField(). vir",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:215425,Performance,load,loaded,215425,"ee.h. ◆ SetMaxTreeSize(). void TTree::SetMaxTreeSize ; (; Long64_t ; maxsize = 100000000000LL). static . Set the maximum size in bytes of a Tree file (static function). ; The default size is 100000000000LL, ie 100 Gigabytes.; In TTree::Fill, when the file has a size > fgMaxTreeSize, the function closes the current file and starts writing into a new file with a name of the style ""file_1.root"" if the original requested file name was ""file.root"". ; Definition at line 9187 of file TTree.cxx. ◆ SetMaxVirtualSize(). virtual void TTree::SetMaxVirtualSize ; (; Long64_t ; size = 0). inlinevirtual . Definition at line 625 of file TTree.h. ◆ SetName(). void TTree::SetName ; (; const char * ; name). overridevirtual . Change the name of this tree. ; Reimplemented from TNamed.; Definition at line 9195 of file TTree.cxx. ◆ SetNotify(). void TTree::SetNotify ; (; TObject * ; obj). virtual . Sets the address of the object to be notified when the tree is loaded. ; The method TObject::Notify is called for the given object when the tree is loaded. Specifically this occurs in the TTree::LoadTree method. To remove the notification call this method with nullptr: tree->SetNotify(nullptr); ; If this is a TChain, obj is most often going to be a TNotifyLink.; Parameters. [in]objPointer to a TObject to be notified. . Definition at line 9221 of file TTree.cxx. ◆ SetObject(). void TTree::SetObject ; (; const char * ; name, . const char * ; title . ). virtual . Change the name and title of this tree. ; Definition at line 9250 of file TTree.cxx. ◆ SetParallelUnzip(). void TTree::SetParallelUnzip ; (; bool ; opt = true, . Float_t ; RelSize = -1 . ). virtual . Enable or disable parallel unzipping of Tree buffers. ; Definition at line 9281 of file TTree.cxx. ◆ SetPerfStats(). void TTree::SetPerfStats ; (; TVirtualPerfStats * ; perf). virtual . Set perf stats. ; Definition at line 9319 of file TTree.cxx. ◆ SetScanField(). virtual void TTree::SetScanField ; (; Int_t ; n = 50). inlinevirtual . Definition",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:218836,Performance,cache,cache,218836,"trees in the TChain instead of the default behaviour using the weights of each tree in the chain (see TChain::SetWeight). ; Reimplemented in TChain.; Definition at line 9364 of file TTree.cxx. ◆ Show(). void TTree::Show ; (; Long64_t ; entry = -1, . Int_t ; lenmax = 20 . ). virtual . Print values of all active leaves for entry. . if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. . Definition at line 9375 of file TTree.cxx. ◆ SortBranchesByTime(). void TTree::SortBranchesByTime ; (; ). private . Sorts top-level branches by the last average task time recorded per branch. ; Definition at line 5834 of file TTree.cxx. ◆ StartViewer(). void TTree::StartViewer ; (; ). virtual . Start the TTreeViewer on this tree. . ww is the width of the canvas in pixels; wh is the height of the canvas in pixels . Definition at line 9449 of file TTree.cxx. ◆ StopCacheLearningPhase(). Int_t TTree::StopCacheLearningPhase ; (; ). virtual . Stop the cache learning phase. ; Returns:; 0 learning phase stopped or not active; -1 on error . Definition at line 9464 of file TTree.cxx. ◆ Streamer(). void TTree::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 9535 of file TTree.cxx. ◆ StreamerNVirtual(). void TTree::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 659 of file TTree.h. ◆ UnbinnedFit(). Int_t TTree::UnbinnedFit ; (; const char * ; funcname, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Unbinned fit of one or more variable(s) from a tree. ; funcname is a TF1 function.; See alsoTTree::Draw for explanations of the other parameters.; Fit the variable varexp using the function funcname using the selection cuts given by selection.; The list of fit options is given in parameter o",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:224804,Performance,cache,cache,224804,"ationCount. std::atomic<UInt_t> TTree::fAllocationCount {0}. mutableprotected . indicates basket should be resized to exact memory usage, but causes significant ; memory churn. ! Number of reallocations basket memory buffers. ; Definition at line 152 of file TTree.h. ◆ fAutoFlush. Long64_t TTree::fAutoFlush. protected . Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ; Definition at line 101 of file TTree.h. ◆ fAutoSave. Long64_t TTree::fAutoSave. protected . Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ; Definition at line 100 of file TTree.h. ◆ fBranches. TObjArray TTree::fBranches. protected . List of Branches. ; Definition at line 122 of file TTree.h. ◆ fBranchRef. TBranchRef* TTree::fBranchRef. protected . Branch supporting the TRefTable (if any) ; Definition at line 136 of file TTree.h. ◆ fCacheDoAutoInit. bool TTree::fCacheDoAutoInit. protected . ! true if cache auto creation or resize check is needed ; Definition at line 139 of file TTree.h. ◆ fCacheDoClusterPrefetch. bool TTree::fCacheDoClusterPrefetch. protected . ! true if cache is prefetching whole clusters ; Definition at line 140 of file TTree.h. ◆ fCacheSize. Long64_t TTree::fCacheSize. protected . ! Maximum size of file buffers ; Definition at line 105 of file TTree.h. ◆ fCacheUserSet. bool TTree::fCacheUserSet. protected . ! true if the cache setting was explicitly given by user ; Definition at line 141 of file TTree.h. ◆ fChainOffset. Long64_t TTree::fChainOffset. protected . ! Offset of 1st entry of this Tree in a TChain ; Definition at line 106 of file TTree.h. ◆ fClones. TList* TTree::fClones. protected . ! List of cloned trees which share our addresses ; Definition at line 135 of file TTree.h. ◆ fClusterRangeEnd. Long64_t* TTree::fClusterRangeEnd. protected . [fNClusterRange] Last entry of a cluster range. ; Definition at line 103 of file TTree.h. ◆ fClusterSize. Long64_t* TTree::fClusterSize. protected . [fN",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:224978,Performance,cache,cache,224978, churn. ! Number of reallocations basket memory buffers. ; Definition at line 152 of file TTree.h. ◆ fAutoFlush. Long64_t TTree::fAutoFlush. protected . Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ; Definition at line 101 of file TTree.h. ◆ fAutoSave. Long64_t TTree::fAutoSave. protected . Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ; Definition at line 100 of file TTree.h. ◆ fBranches. TObjArray TTree::fBranches. protected . List of Branches. ; Definition at line 122 of file TTree.h. ◆ fBranchRef. TBranchRef* TTree::fBranchRef. protected . Branch supporting the TRefTable (if any) ; Definition at line 136 of file TTree.h. ◆ fCacheDoAutoInit. bool TTree::fCacheDoAutoInit. protected . ! true if cache auto creation or resize check is needed ; Definition at line 139 of file TTree.h. ◆ fCacheDoClusterPrefetch. bool TTree::fCacheDoClusterPrefetch. protected . ! true if cache is prefetching whole clusters ; Definition at line 140 of file TTree.h. ◆ fCacheSize. Long64_t TTree::fCacheSize. protected . ! Maximum size of file buffers ; Definition at line 105 of file TTree.h. ◆ fCacheUserSet. bool TTree::fCacheUserSet. protected . ! true if the cache setting was explicitly given by user ; Definition at line 141 of file TTree.h. ◆ fChainOffset. Long64_t TTree::fChainOffset. protected . ! Offset of 1st entry of this Tree in a TChain ; Definition at line 106 of file TTree.h. ◆ fClones. TList* TTree::fClones. protected . ! List of cloned trees which share our addresses ; Definition at line 135 of file TTree.h. ◆ fClusterRangeEnd. Long64_t* TTree::fClusterRangeEnd. protected . [fNClusterRange] Last entry of a cluster range. ; Definition at line 103 of file TTree.h. ◆ fClusterSize. Long64_t* TTree::fClusterSize. protected . [fNClusterRange] Number of entries in each cluster for a given range. ; Definition at line 104 of file TTree.h. ◆ fDebug. Int_t TTree::fDebug. protected . ! Debug level ; D,MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:225253,Performance,cache,cache,225253,e TTree.h. ◆ fAutoSave. Long64_t TTree::fAutoSave. protected . Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ; Definition at line 100 of file TTree.h. ◆ fBranches. TObjArray TTree::fBranches. protected . List of Branches. ; Definition at line 122 of file TTree.h. ◆ fBranchRef. TBranchRef* TTree::fBranchRef. protected . Branch supporting the TRefTable (if any) ; Definition at line 136 of file TTree.h. ◆ fCacheDoAutoInit. bool TTree::fCacheDoAutoInit. protected . ! true if cache auto creation or resize check is needed ; Definition at line 139 of file TTree.h. ◆ fCacheDoClusterPrefetch. bool TTree::fCacheDoClusterPrefetch. protected . ! true if cache is prefetching whole clusters ; Definition at line 140 of file TTree.h. ◆ fCacheSize. Long64_t TTree::fCacheSize. protected . ! Maximum size of file buffers ; Definition at line 105 of file TTree.h. ◆ fCacheUserSet. bool TTree::fCacheUserSet. protected . ! true if the cache setting was explicitly given by user ; Definition at line 141 of file TTree.h. ◆ fChainOffset. Long64_t TTree::fChainOffset. protected . ! Offset of 1st entry of this Tree in a TChain ; Definition at line 106 of file TTree.h. ◆ fClones. TList* TTree::fClones. protected . ! List of cloned trees which share our addresses ; Definition at line 135 of file TTree.h. ◆ fClusterRangeEnd. Long64_t* TTree::fClusterRangeEnd. protected . [fNClusterRange] Last entry of a cluster range. ; Definition at line 103 of file TTree.h. ◆ fClusterSize. Long64_t* TTree::fClusterSize. protected . [fNClusterRange] Number of entries in each cluster for a given range. ; Definition at line 104 of file TTree.h. ◆ fDebug. Int_t TTree::fDebug. protected . ! Debug level ; Definition at line 111 of file TTree.h. ◆ fDebugMax. Long64_t TTree::fDebugMax. protected . ! Last entry number to debug ; Definition at line 113 of file TTree.h. ◆ fDebugMin. Long64_t TTree::fDebugMin. protected . ! First entry number to debug ; Definition at line 112 of file ,MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:228276,Performance,multi-thread,multi-threading,228276,d. ; Definition at line 131 of file TTree.h. ◆ fFileNumber. Int_t TTree::fFileNumber. protected . ! current file number (if file extensions) ; Definition at line 116 of file TTree.h. ◆ fFlushedBytes. Long64_t TTree::fFlushedBytes. protected . Number of auto-flushed bytes. ; Definition at line 89 of file TTree.h. ◆ fFriendLockStatus. UInt_t TTree::fFriendLockStatus. protected . ! Record which method is locking the friend recursion ; Definition at line 137 of file TTree.h. ◆ fFriends. TList* TTree::fFriends. protected . pointer to list of friend elements ; Definition at line 130 of file TTree.h. ◆ fgBranchStyle. Int_t TTree::fgBranchStyle = 1. staticprotected . Old/New branch style. ; Definition at line 154 of file TTree.h. ◆ fgMaxTreeSize. Long64_t TTree::fgMaxTreeSize = 100000000000LL. staticprotected . Maximum size of a file containing a Tree. ; Definition at line 155 of file TTree.h. ◆ fIMTEnabled. bool TTree::fIMTEnabled. protected . ! true if implicit multi-threading is enabled for this tree ; Definition at line 142 of file TTree.h. ◆ fIMTFlush. bool TTree::fIMTFlush {false}. mutableprivate . ! True if we are doing a multithreaded flush. ; Definition at line 159 of file TTree.h. ◆ fIMTTotBytes. std::atomic<Long64_t> TTree::fIMTTotBytes. mutableprivate . ! Total bytes for the IMT flush baskets ; Definition at line 160 of file TTree.h. ◆ fIMTZipBytes. std::atomic<Long64_t> TTree::fIMTZipBytes. mutableprivate . ! Zip bytes for the IMT flush baskets. ; Definition at line 161 of file TTree.h. ◆ fIndex. TArrayI TTree::fIndex. protected . Index of sorted values. ; Definition at line 128 of file TTree.h. ◆ fIndexValues. TArrayD TTree::fIndexValues. protected . Sorted index values. ; Definition at line 127 of file TTree.h. ◆ fIOFeatures. TIOFeatures TTree::fIOFeatures {0}. protected . IO features to define for newly-written baskets and branches. ; Definition at line 114 of file TTree.h. ◆ fLeaves. TObjArray TTree::fLeaves. protected . Direct pointers to individual branch,MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:230630,Performance,load,loading,230630,at line 96 of file TTree.h. ◆ fMaxEntries. Long64_t TTree::fMaxEntries. protected . Maximum number of entries in case of circular buffers. ; Definition at line 97 of file TTree.h. ◆ fMaxEntryLoop. Long64_t TTree::fMaxEntryLoop. protected . Maximum number of entries to process. ; Definition at line 98 of file TTree.h. ◆ fMaxVirtualSize. Long64_t TTree::fMaxVirtualSize. protected . Maximum total size of buffers kept in memory. ; Definition at line 99 of file TTree.h. ◆ fNClusterRange. Int_t TTree::fNClusterRange. protected . Number of Cluster range in addition to the one defined by 'AutoFlush'. ; Definition at line 95 of file TTree.h. ◆ fNEntriesSinceSorting. UInt_t TTree::fNEntriesSinceSorting. protected . ! Number of entries processed since the last re-sorting of branches ; Definition at line 143 of file TTree.h. ◆ fNfill. Int_t TTree::fNfill. protected . ! Local for EntryLoop ; Definition at line 110 of file TTree.h. ◆ fNotify. TObject* TTree::fNotify. protected . Object to be notified when loading a Tree. ; TTree::LoadTree() and TChain::LoadTree() will call fNotify->Notify(). Usually points to a TNotifyLink if this is a TChain. ; Definition at line 120 of file TTree.h. ◆ fPacketSize. Int_t TTree::fPacketSize. protected . ! Number of entries in one packet for parallel root ; Definition at line 109 of file TTree.h. ◆ fPerfStats. TVirtualPerfStats* TTree::fPerfStats. protected . ! pointer to the current perf stats object ; Definition at line 132 of file TTree.h. ◆ fPlayer. TVirtualTreePlayer* TTree::fPlayer. protected . ! Pointer to current Tree player ; Definition at line 134 of file TTree.h. ◆ fReadEntry. Long64_t TTree::fReadEntry. protected . ! Number of the entry being processed ; Definition at line 107 of file TTree.h. ◆ fSavedBytes. Long64_t TTree::fSavedBytes. protected . Number of autosaved bytes. ; Definition at line 88 of file TTree.h. ◆ fScanField. Int_t TTree::fScanField. protected . Number of runs before prompting in Scan. ; Definition at line 92 of file,MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:12209,Safety,detect,detector,12209,"s stored in TFiles: for example, these files might not be writeable, just readable. In addition, modifying in place a TTree causes a new TTree instance to be written and the previous one to be deleted. For this reasons, ROOT offers the concept of friends for TTree and TChain: if is good practice to rely on friend trees rather than adding a branch manually. An Example. // A simple example with histograms and a tree; //; // This program creates :; // - a one dimensional histogram; // - a two dimensional histogram; // - a profile histogram; // - a tree; //; // These objects are filled with some random numbers and saved on a file.; ; #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h""; ; //__________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");; ; // Create some histograms and a profile histogram; TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile hprof(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; ; // Define some simple structures; typedef struct {Float_t x,y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; POINT point;; EVENTN eventn;; ; // Create a ROOT Tree; TTree tree(""T"",""An example of ROOT tree with a few branches"");; tree.Branch(""point"",&point,""x:y:z"");; tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);; ; Float_t px,py,pz;; ; // Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py)",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:37514,Safety,recover,recover,37514,"askets, buffers and entries count in all branches and leaves. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Resets the state of this TTree after a merge (keep the customization but forget the data). ;  ; virtual void ResetBranchAddress (TBranch *);  Tell all of our branches to set their addresses to zero. ;  ; virtual void ResetBranchAddresses ();  Tell all of our branches to drop their current objects and allocate new ones. ;  ; virtual Long64_t Scan (const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop over tree entries and print entries passing selection. ;  ; virtual bool SetAlias (const char *aliasName, const char *aliasFormula);  Set a tree variable alias. ;  ; virtual void SetAutoFlush (Long64_t autof=-30000000);  This function may be called at the start of a program to change the default value for fAutoFlush. ;  ; virtual void SetAutoSave (Long64_t autos=-300000000);  In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ;  ; virtual void SetBasketSize (const char *bname, Int_t buffsize=16000);  Set a branch's basket size. ;  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr=nullptr);  Change branch address, dealing with clone trees properly. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual void SetBranchStatus (const char *bname, bool s",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:57220,Safety,detect,detection,57220,"utes; static constexpr Long64_t kMaxEntries = TVirtualTreePlayer::kMaxEntries;  . Protected Types; enum  ELockStatusBits { ;   kFindBranch = (1ULL << ( 0 )); , kFindLeaf = (1ULL << ( 1 )); , kGetAlias = (1ULL << ( 2 )); , kGetBranch = (1ULL << ( 3 )); , ;   kGetEntry = (1ULL << ( 4 )); , kGetEntryWithIndex = (1ULL << ( 5 )); , kGetFriend = (1ULL << ( 6 )); , kGetFriendAlias = (1ULL << ( 7 )); , ;   kGetLeaf = (1ULL << ( 8 )); , kLoadTree = (1ULL << ( 9 )); , kPrint = (1ULL << ( 10 )); , kRemoveFriend = (1ULL << ( 11 )); , ;   kSetBranchStatus = (1ULL << ( 12 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool p",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:57578,Safety,detect,detection,57578,"L << ( 4 )); , kGetEntryWithIndex = (1ULL << ( 5 )); , kGetFriend = (1ULL << ( 6 )); , kGetFriendAlias = (1ULL << ( 7 )); , ;   kGetLeaf = (1ULL << ( 8 )); , kLoadTree = (1ULL << ( 9 )); , kPrint = (1ULL << ( 10 )); , kRemoveFriend = (1ULL << ( 11 )); , ;   kSetBranchStatus = (1ULL << ( 12 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const cha",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:57791,Safety,detect,detection,57791," ( 12 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual TBranch * BranchImp (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch() with added check that addobj matches className. ;  ; virtual TBranch * BranchImp (const char *branchname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpArr (const char *branchname, EDataType datatype, std::size_t N, void *addobj, Int_t bufsize, Int_t splitlevel);  ; virtual TBranch * BranchImpRef (const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BranchImpRef (const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel);  Same as TTree::Branch but automatic detection of the class name. ;  ; virtual TBranch * BronchExec (const char *name, const char *classname, void *addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);  Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ;  ; virtual Int_t CheckBranchAddressType (TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr);  Check whether or not the address described by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends t",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:67667,Safety,safe,safety,67667,"kLoadTree ; kPrint ; kRemoveFriend ; kSetBranchStatus . Definition at line 211 of file TTree.h. ◆ ESetBranchAddressStatus. enum TTree::ESetBranchAddressStatus. EnumeratorkMissingBranch ; kInternalError ; kMissingCompiledCollectionProxy ; kMismatch ; kClassMismatch ; kMatch ; kMatchConversion ; kMatchConversionCollection ; kMakeClass ; kVoidPtr ; kNoCheck ; kNeedEnableDecomposedObj ; kNeedDisableDecomposedObj ; kDecomposedObjMask . Definition at line 232 of file TTree.h. ◆ EStatusBits. enum TTree::EStatusBits. EnumeratorkForceRead ; kCircular ; kOnlyFlushAtCluster If set, the branch's buffers will grow until an event cluster boundary is hit, guaranteeing a basket per cluster. ; This mode does not provide any guarantee on the memory bounds in the case of extremely large events. . kEntriesReshuffled If set, signals that this TTree is the output of the processing of another TTree, and the entries are reshuffled w.r.t. ; to the original TTree. As a safety measure, a TTree with this bit set cannot add friends nor can be added as a friend. If you know what you are doing, you can manually unset this bit with ResetBit(EStatusBits::kEntriesReshuffled). . Definition at line 250 of file TTree.h. Constructor & Destructor Documentation. ◆ TTree() [1/3]. TTree::TTree ; (; ). Default constructor and I/O constructor. ; Note: We do not insert ourself into the current directory. ; Definition at line 737 of file TTree.cxx. ◆ TTree() [2/3]. TTree::TTree ; (; const char * ; name, . const char * ; title, . Int_t ; splitlevel = 99, . TDirectory * ; dir = (::ROOT::Internal::TDirectoryAtomicAdapter{}) . ). Normal tree constructor. ; The tree is created in the current directory. Use the various functions Branch below to add branches to this tree.; If the first character of title is a ""/"", the function assumes a folder name. In this case, it creates automatically branches following the folder hierarchy. splitlevel may be used in this case to control the split level. ; Definition at line 817 of",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:70808,Safety,risk,risk,70808,"on at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (current directory); adds the Tree to the list of friends see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file. When a TFriendElement TF is added to the list of friends of an existing TTree T, any variable from TF can be referenced in a query to T.; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The tree in the diagram below has two friends (friend_tree1 and friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in the Draw method, use the syntax: <treeName>.<branchname>.<varname>; If the variablename is enough t",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:74526,Safety,safe,safe,74526,"const char *). This function:; reads a Tree with name treename from the file; adds the Tree to the list of friends . Reimplemented in TChain.; Definition at line 1366 of file TTree.cxx. ◆ AddFriend() [3/3]. TFriendElement * TTree::AddFriend ; (; TTree * ; tree, . const char * ; alias = """", . bool ; warn = false . ). virtual . Add a TFriendElement to the list of friends. ; The TTree is managed by the user (e.g., the user must delete the file). For a complete description see AddFriend(const char *, const char *). ; Reimplemented in TChain.; Definition at line 1397 of file TTree.cxx. ◆ AddTotBytes(). virtual void TTree::AddTotBytes ; (; Int_t ; tot). inlinevirtual . Definition at line 331 of file TTree.h. ◆ AddZipBytes(). virtual void TTree::AddZipBytes ; (; Int_t ; zip). inlinevirtual . Definition at line 332 of file TTree.h. ◆ AutoSave(). Long64_t TTree::AutoSave ; (; Option_t * ; option = """"). virtual . AutoSave tree header every fAutoSave bytes. ; When large Trees are produced, it is safe to activate the AutoSave procedure. Some branches may have buffers holding many entries. If fAutoSave is negative, AutoSave is automatically called by TTree::Fill when the number of bytes generated since the previous AutoSave is greater than -fAutoSave bytes. If fAutoSave is positive, AutoSave is automatically called by TTree::Fill every N entries. This function may also be invoked by the user. Each AutoSave generates a new key on the file. Once the key with the tree header has been written, the previous cycle (if any) is deleted.; Note that calling TTree::AutoSave too frequently (or similarly calling TTree::SetAutoSave with a small value) is an expensive operation. You should make tests for your own application to find a compromise between speed and the quantity of information you may loose in case of a job crash.; In case your program crashes before closing the file holding this tree, the file will be automatically recovered when you will connect the file in UPDATE mode. The Tre",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:75462,Safety,recover,recovered,75462,"ual . AutoSave tree header every fAutoSave bytes. ; When large Trees are produced, it is safe to activate the AutoSave procedure. Some branches may have buffers holding many entries. If fAutoSave is negative, AutoSave is automatically called by TTree::Fill when the number of bytes generated since the previous AutoSave is greater than -fAutoSave bytes. If fAutoSave is positive, AutoSave is automatically called by TTree::Fill every N entries. This function may also be invoked by the user. Each AutoSave generates a new key on the file. Once the key with the tree header has been written, the previous cycle (if any) is deleted.; Note that calling TTree::AutoSave too frequently (or similarly calling TTree::SetAutoSave with a small value) is an expensive operation. You should make tests for your own application to find a compromise between speed and the quantity of information you may loose in case of a job crash.; In case your program crashes before closing the file holding this tree, the file will be automatically recovered when you will connect the file in UPDATE mode. The Tree will be recovered at the status corresponding to the last AutoSave.; if option contains ""SaveSelf"", gDirectory->SaveSelf() is called. This allows another process to analyze the Tree while the Tree is being filled.; if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all the current basket are closed-out and written to disk individually.; By default the previous header is deleted after having written the new header. if option contains ""Overwrite"", the previous Tree header is deleted before written the new header. This option is slightly faster, but the default option is safer in case of a problem (disk quota exceeded) when writing the new header.; The function returns the number of bytes written to the file. if the number of bytes is null, an error has occurred while writing the header to the file. How to write a Tree in one process and view it from another process; The following t",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:75536,Safety,recover,recovered,75536,"procedure. Some branches may have buffers holding many entries. If fAutoSave is negative, AutoSave is automatically called by TTree::Fill when the number of bytes generated since the previous AutoSave is greater than -fAutoSave bytes. If fAutoSave is positive, AutoSave is automatically called by TTree::Fill every N entries. This function may also be invoked by the user. Each AutoSave generates a new key on the file. Once the key with the tree header has been written, the previous cycle (if any) is deleted.; Note that calling TTree::AutoSave too frequently (or similarly calling TTree::SetAutoSave with a small value) is an expensive operation. You should make tests for your own application to find a compromise between speed and the quantity of information you may loose in case of a job crash.; In case your program crashes before closing the file holding this tree, the file will be automatically recovered when you will connect the file in UPDATE mode. The Tree will be recovered at the status corresponding to the last AutoSave.; if option contains ""SaveSelf"", gDirectory->SaveSelf() is called. This allows another process to analyze the Tree while the Tree is being filled.; if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all the current basket are closed-out and written to disk individually.; By default the previous header is deleted after having written the new header. if option contains ""Overwrite"", the previous Tree header is deleted before written the new header. This option is slightly faster, but the default option is safer in case of a problem (disk quota exceeded) when writing the new header.; The function returns the number of bytes written to the file. if the number of bytes is null, an error has occurred while writing the header to the file. How to write a Tree in one process and view it from another process; The following two scripts illustrate how to do this. The script treew.C is executed by process1, treer.C by process2; script treew.C: ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:76121,Safety,safe,safer,76121,"y calling TTree::SetAutoSave with a small value) is an expensive operation. You should make tests for your own application to find a compromise between speed and the quantity of information you may loose in case of a job crash.; In case your program crashes before closing the file holding this tree, the file will be automatically recovered when you will connect the file in UPDATE mode. The Tree will be recovered at the status corresponding to the last AutoSave.; if option contains ""SaveSelf"", gDirectory->SaveSelf() is called. This allows another process to analyze the Tree while the Tree is being filled.; if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all the current basket are closed-out and written to disk individually.; By default the previous header is deleted after having written the new header. if option contains ""Overwrite"", the previous Tree header is deleted before written the new header. This option is slightly faster, but the default option is safer in case of a problem (disk quota exceeded) when writing the new header.; The function returns the number of bytes written to the file. if the number of bytes is null, an error has occurred while writing the header to the file. How to write a Tree in one process and view it from another process; The following two scripts illustrate how to do this. The script treew.C is executed by process1, treer.C by process2; script treew.C: void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TRandom::RndmDouble_t Rndm() ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:88308,Safety,avoid,avoid,88308,"tion, the entry in the collection becomes in turn top level branches, etc. The splitlevel is decreased by 1 every time a new collection is found. For example if list is a TObjArray*; if splitlevel = 1, one top level branch is created for each element of the TObjArray.; if splitlevel = 2, one top level branch is created for each array element. if, in turn, one of the array elements is a TCollection, one top level branch will be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor for TClonesArray is called. The collection itself cannot be a TClonesArray.; The function returns the total number of branches created.; If name is given, all branch names will be prefixed with name_.; IMPORTANT NOTE1: This function should not be called with splitlevel < 1.; IMPORTANT NOTE2: The branches created by this function will have names corresponding to the collection or object names. It is important to give names to collections to avoid misleading branch names or identical branch names. By default collections have a name equal to the corresponding class name, e.g. the default name for a TList is ""TList"".; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; Example: {; TTree T(""T"",""test list"");; TList *list = new TList();; ; TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; l",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:91240,Safety,detect,detection,91240,"void Add(TObject *obj) overrideDefinition TObjArray.h:68. Reimplemented in TTreeSQL.; Definition at line 1833 of file TTree.cxx. ◆ Branch() [13/13]. Int_t TTree::Branch ; (; TList * ; list, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). virtual . Deprecated function. Use next function instead. ; Reimplemented in TTreeSQL.; Definition at line 1749 of file TTree.cxx. ◆ BranchImp() [1/2]. TBranch * TTree::BranchImp ; (; const char * ; branchname, . const char * ; classname, . TClass * ; ptrClass, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch() with added check that addobj matches className. ; See alsoTTree::Branch() for other details. ; Reimplemented in TTreeSQL.; Definition at line 1554 of file TTree.cxx. ◆ BranchImp() [2/2]. TBranch * TTree::BranchImp ; (; const char * ; branchname, . TClass * ; ptrClass, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Reimplemented in TTreeSQL.; Definition at line 1602 of file TTree.cxx. ◆ BranchImpArr(). TBranch * TTree::BranchImpArr ; (; const char * ; branchname, . EDataType ; datatype, . std::size_t ; N, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Definition at line 1731 of file TTree.cxx. ◆ BranchImpRef() [1/2]. TBranch * TTree::BranchImpRef ; (; const char * ; branchname, . const char * ; classname, . TClass * ; ptrClass, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1635 of file TTree.cxx. ◆ BranchImpRef() [2/2]. TBranch * TTree::BranchImpRef ; (; const char * ; branchname, . TClass * ; ptrClass, . EDataType ; datatype, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:91890,Safety,detect,detection,91890,"hes className. ; See alsoTTree::Branch() for other details. ; Reimplemented in TTreeSQL.; Definition at line 1554 of file TTree.cxx. ◆ BranchImp() [2/2]. TBranch * TTree::BranchImp ; (; const char * ; branchname, . TClass * ; ptrClass, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Reimplemented in TTreeSQL.; Definition at line 1602 of file TTree.cxx. ◆ BranchImpArr(). TBranch * TTree::BranchImpArr ; (; const char * ; branchname, . EDataType ; datatype, . std::size_t ; N, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Definition at line 1731 of file TTree.cxx. ◆ BranchImpRef() [1/2]. TBranch * TTree::BranchImpRef ; (; const char * ; branchname, . const char * ; classname, . TClass * ; ptrClass, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1635 of file TTree.cxx. ◆ BranchImpRef() [2/2]. TBranch * TTree::BranchImpRef ; (; const char * ; branchname, . TClass * ; ptrClass, . EDataType ; datatype, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1695 of file TTree.cxx. ◆ BranchOld(). TBranch * TTree::BranchOld ; (; const char * ; name, . const char * ; classname, . void * ; addobj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 1 . ). virtual . Create a new TTree BranchObject. ; Build a TBranchObject for an object of class classname. addobj is the address of a pointer to an object of class classname. IMPORTANT: classname must derive from TObject. The class dictionary must be available (ClassDef in class header).; This option requires access to the library where the c",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:92259,Safety,detect,detection,92259,"he class name. ; See alsoTTree::Branch for other details. ; Reimplemented in TTreeSQL.; Definition at line 1602 of file TTree.cxx. ◆ BranchImpArr(). TBranch * TTree::BranchImpArr ; (; const char * ; branchname, . EDataType ; datatype, . std::size_t ; N, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Definition at line 1731 of file TTree.cxx. ◆ BranchImpRef() [1/2]. TBranch * TTree::BranchImpRef ; (; const char * ; branchname, . const char * ; classname, . TClass * ; ptrClass, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1635 of file TTree.cxx. ◆ BranchImpRef() [2/2]. TBranch * TTree::BranchImpRef ; (; const char * ; branchname, . TClass * ; ptrClass, . EDataType ; datatype, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1695 of file TTree.cxx. ◆ BranchOld(). TBranch * TTree::BranchOld ; (; const char * ; name, . const char * ; classname, . void * ; addobj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 1 . ). virtual . Create a new TTree BranchObject. ; Build a TBranchObject for an object of class classname. addobj is the address of a pointer to an object of class classname. IMPORTANT: classname must derive from TObject. The class dictionary must be available (ClassDef in class header).; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object. See the next Branch constructor for a more efficient storage in case the entry consists of arrays of identical objects.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE a",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:125655,Safety,avoid,avoid,125655,"rent iteration over this formula for this entry (i.e. varies from 0 to Length$).; Length$(formula ) : return the total number of element of the formula given as a parameter.; Sum$(formula ) : return the sum of the value of the elements of the formula given as a parameter. For example the mean for all the elements in one entry can be calculated with: Sum$(formula )/Length$(formula ); Min$(formula ) : return the minimum (within one TTree entry) of the value of the elements of the formula given as a parameter.; Max$(formula ) : return the maximum (within one TTree entry) of the value of the elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition) : return the minimum (maximum) (within one TTree entry) of the value of the elements of the formula given as a parameter if they match the condition. If no element matches the condition, the result is zero. To avoid the resulting peak at zero, use the pattern: tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match for the condition.; Alt$(primary,alternate) : return the value of ""primary"" if it is available for the current iteration otherwise return the value of ""alternate"". For example, with arr1[3] and arr2[2] tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0 Or with a variable size array arr3 tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1) As a comparison tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the actual_size_of_arr3 is greater or equal to 3. Note that the array in 'primary' is flattened/linearized thus using Alt$ with multi-dimensional arrays of different dimensions in unlikely to yield the expected results. To visualize a bit more what elements would be matched by TTree::Draw, TTree::Scan can be used: tree->Scan(""arr1:Alt$(arr2,0)"")",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:125771,Safety,avoid,avoid,125771,"rent iteration over this formula for this entry (i.e. varies from 0 to Length$).; Length$(formula ) : return the total number of element of the formula given as a parameter.; Sum$(formula ) : return the sum of the value of the elements of the formula given as a parameter. For example the mean for all the elements in one entry can be calculated with: Sum$(formula )/Length$(formula ); Min$(formula ) : return the minimum (within one TTree entry) of the value of the elements of the formula given as a parameter.; Max$(formula ) : return the maximum (within one TTree entry) of the value of the elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition) : return the minimum (maximum) (within one TTree entry) of the value of the elements of the formula given as a parameter if they match the condition. If no element matches the condition, the result is zero. To avoid the resulting peak at zero, use the pattern: tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match for the condition.; Alt$(primary,alternate) : return the value of ""primary"" if it is available for the current iteration otherwise return the value of ""alternate"". For example, with arr1[3] and arr2[2] tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0 Or with a variable size array arr3 tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1) As a comparison tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the actual_size_of_arr3 is greater or equal to 3. Note that the array in 'primary' is flattened/linearized thus using Alt$ with multi-dimensional arrays of different dimensions in unlikely to yield the expected results. To visualize a bit more what elements would be matched by TTree::Draw, TTree::Scan can be used: tree->Scan(""arr1:Alt$(arr2,0)"")",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:140104,Safety,recover,recoverable,140104,"operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to flush the baskets happen, we also take this opportunity to optimize the baskets buffers. We also check if the amount of data written is greater than fAutoSave (see SetAutoSave). In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes. The decisions to FlushBaskets and Auto Save can be made based either on the number of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries written (fAutoFlush and fAutoSave positive). Note that the user can decide to call FlushBaskets and AutoSave in her event loop base on the number of events written instead of the number of bytes written.; NoteCalling TTree::FlushBaskets too often increases the IO time. Calling TTree::AutoSave too often increases the IO time and also the file size. This method calls TTree::ChangeFile when the tree reaches a size greater than TTree::fgMaxTreeSize. This doesn't happen if the tree is attached to a TMemFile or derivate. ; Reimplemented in TChain, TNtuple, TNtupleD, and TTreeSQL.; Definition at line 4603 of file TTree.cxx. ◆ FindBranch(). TBranch * TTree::FindBranch ; (; const char * ; branchname). virtual . Return the branch that correspond to the path 'branchname', which can includ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:200761,Safety,recover,recover,200761,"skets TTree::Fill will replace fAutoFlush by the current value of fEntries.; Calling this function with autof<0 is interesting when it is hard to estimate the size of one entry. This value is also independent of the Tree.; The Tree is initialized with fAutoFlush=-30000000, ie that, by default, the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0; The AutoFlush mechanism is disabled.; Flushing the buffers at regular intervals optimize the location of consecutive entries on the disk by creating clusters of baskets.; A cluster of baskets is a set of baskets that contains all the data for a (consecutive) set of entries and that is stored consecutively on the disk. When reading all the branches, this is the minimum set of baskets that the TTreeCache will read. ; Definition at line 8191 of file TTree.cxx. ◆ SetAutoSave(). void TTree::SetAutoSave ; (; Long64_t ; autos = -300000000). virtual . In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ; This function may be called before filling a TTree to specify when the branch buffers and TTree header are flushed to disk as part of TTree::Fill(). The default is -300000000, ie the TTree will write data to disk once it exceeds 300 MBytes. CASE 1: If fAutoSave is positive the watermark is reached when a multiple of fAutoSave entries have been filled. CASE 2: If fAutoSave is negative the watermark is reached when -fAutoSave bytes can be written to the file. CASE 3: If fAutoSave is 0, AutoSave() will never be called automatically as part of TTree::Fill(). ; Definition at line 8337 of file TTree.cxx. ◆ SetBasketSize(). void TTree::SetBasketSize ; (; const char * ; bname, . Int_t ; buffsize = 16000 . ). virtual . Set a branch's basket size. ; bname is the name of a branch. if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx. see TRegexp for wildcarding options buffsize = branc ba",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:8815,Security,access,access,8815,"the one pointed to by the pointer. It should be either a parent or derived class. Note: The pointer whose address is passed to TTree::Branch must not be destroyed (i.e. go out of scope) until the TTree is deleted or TTree::ResetBranchAddress is called.; Note: The pointer p_object must be initialized before calling TTree::Branch; Do either: MyDataClass* p_object = nullptr;; tree.Branch(branchname, &p_object);. Or: auto p_object = new MyDataClass;; tree.Branch(branchname, &p_object);; Whether the pointer is set to zero or not, the ownership of the object is not taken over by the TTree. I.e. even though an object will be allocated by TTree::Branch if the pointer p_object is zero, the object will not be deleted when the TTree is deleted. Add a column holding TClonesArray instances; It is recommended to use STL containers instead of TClonesArrays*.; // clonesarray is the address of a pointer to a TClonesArray.; auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel); The TClonesArray is a direct access list of objects of the same class. For example, if the TClonesArray is an array of TTrack objects, this function will create one subbranch for each data member of the object TTrack. Fill the Tree; A TTree instance is filled with the invocation of the TTree::Fill method: tree.Fill(); Upon its invocation, a loop on all defined branches takes place that for each branch invokes the TBranch::Fill method. Add a column to an already existing Tree; You may want to add a branch to an existing tree. For example, if one variable in the tree was computed with a certain algorithm, you may want to try another algorithm and compare the results. One solution is to add a new branch, fill it, and save the tree. The code below adds a simple branch to an existing tree. Note the kOverwrite option in the Write method, it overwrites the existing tree. If it is not specified, two copies of the tree headers are saved. void tree3AddBranch() {; TFile f(""tree3.root"", ""update"");; ; Float",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:15156,Security,access,access,15156,"inition RtypesCore.h:46; TFile.h; TH1.h; TH2.h; TProfile.h; TRandom.h; TTree.h; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:621; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TProfileProfile Histogram.Definition TProfile.h:32; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169. PyROOT; The TTree class has several additions for its use from Python, which are also available in its subclasses e.g. TChain and TNtuple.; First, TTree instances are iterable in Python. Therefore, assuming t is a TTree instance, we can do: for entry in t:; x = entry.branch_name; ...; At each iteration, a new entry of the tree will be read. In the code above, entry allows to access the branch values for the current entry. This can be done with the syntax entry.branch_name or, if the branch name is incompatible with Python naming rules, with e.g. ""getattr(entry, '1_branch_name')"".; Please note that iterating in Python can be slow, so only iterate over a tree as described above if performance is not an issue or when dealing with a small dataset. To read and process the entries of a tree in a much faster way, please use ROOT::RDataFrame.; Second, a couple of TTree methods have been modified to facilitate their use from Python: TTree::Branch and TTree::SetBranchAddress.; Regarding TTree::Branch, the following example shows how we can create different types of branches of a TTree. Note that Branch will just link the new branch with a given Python object, so it is still necessary to fill such object with the desired content before calling TTree::Fill. from array import array; import numpy as np; import ROOT; from ROOT import addressof; ; # Basic type branch (float) - ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:43265,Security,hash,hash,43265,"nst char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:70699,Security,access,access,70699,"hes are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (current directory); adds the Tree to the list of friends see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file. When a TFriendElement TF is added to the list of friends of an existing TTree T, any variable from TF can be referenced in a query to T.; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The tree in the diagram below has two friends (friend_tree1 and friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:70989,Security,access,access,70989,"r when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of friends. ; This function:; opens a file if filename is specified; reads a Tree with name treename from the file (current directory); adds the Tree to the list of friends see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file. When a TFriendElement TF is added to the list of friends of an existing TTree T, any variable from TF can be referenced in a query to T.; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The tree in the diagram below has two friends (friend_tree1 and friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in the Draw method, use the syntax: <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable ""var"" in the TTree tree versus variable ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:72164,Security,access,access,72164," AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root""); If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root""); Once the tree has friends, we can use TTree::Draw as if the friend's variables were in the original tree. To specify which tree to use in the Draw method, use the syntax: <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can leave out the tree and/or branch name. For example, these commands generate a 3-d scatter plot of variable ""var"" in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; . The picture illustrates the access of the tree and its friends with a Draw command. When AddFriend is called, the ROOT file is automatically opened and the friend tree (ft1) is read into memory. The new friend (ft1) is added to the list of friends of tree. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries a warning is given and the missing entries are not included in the histogram. To retrieve the list of friends from a tree use TTree::GetListOfFriends. When the tree is written to file (TTree::Write), the friends list is saved with it. And when the tree is retrieved, the trees on the friends list are also retrieved and the friendship restored. When a tree is deleted, the elements of the friend list are also deleted. It is possible to declare a friend tree that has the same internal structure (same branches and leaves) as the original tree, and compare the same values by specifying the tree. tree.Draw(""var:ft1.var:ft2.var""). Reimplem",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:81945,Security,access,accessed,81945,"splitlevel = 99 . ). inline . Definition at line 405 of file TTree.h. ◆ Branch() [9/13]. template<class T > . TBranch * TTree::Branch ; (; const char * ; name, . T ** ; addobj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). inline . Add a new branch, and infer the data type from the array addobj being passed. ; NoteThis and the previous overload should cover most cases for creating a branch. Try to use these two whenever possible, unless e.g. type conversions are needed.; Parameters. [in]nameName of the branch to be created. ; [in]addobjArray of the objects to be added. When calling Fill(), the current value of the type/object will be saved. ; [in]bufsizehe buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc. The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes). A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode. ; [in]splitlevelIf T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 370 of file TTree.h. ◆ Branch() [10/13]. template<class T > . TBranch * TTree::Branch ; (; const char * ; name, . T * ; obj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). inline . Add a new branch, and infer the data type from the type of obj being passed. ; NoteThis and the next overload should cover most cases for creating a branch. Try to use these two whenever possible, unless e.g. type conversions are needed.; Parameters. [in]nameName of the branch to be created. ; [in]objAddress of the object to be added. Make sure to pass a pointer to the actual type/class that should be stored in the tree (no pointers to base classes). When calling Fill(), the current value of the type/object will be",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:83293,Security,access,accessed,83293,". TBranch * TTree::Branch ; (; const char * ; name, . T * ; obj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). inline . Add a new branch, and infer the data type from the type of obj being passed. ; NoteThis and the next overload should cover most cases for creating a branch. Try to use these two whenever possible, unless e.g. type conversions are needed.; Parameters. [in]nameName of the branch to be created. ; [in]objAddress of the object to be added. Make sure to pass a pointer to the actual type/class that should be stored in the tree (no pointers to base classes). When calling Fill(), the current value of the type/object will be saved. ; [in]bufsizeThe buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc. The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes). A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode. ; [in]splitlevelIf T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 353 of file TTree.h. ◆ Branch() [11/13]. TBranch * TTree::Branch ; (; const char * ; name, . void * ; address, . const char * ; leaflist, . Int_t ; bufsize = 32000 . ). virtual . Create a new TTree Branch. ; This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file. address is the address of the first item of a structure.; leaflist is the concatenation of all the variable names and types separated by a colon character : The variabl",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:86828,Security,access,access,86828,"name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]) where nelem and nelem2 are non-negative integer) then it is used as a 2 dimensional array of fixed size.; In case of the truncated floating point types (Float16_t and Double32_t) you can furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after the type character. See TStreamerElement::GetRange() for further information. Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory. On some platform, this is not always true of the member of a struct or a class, due to padding and alignment. Sorting your data member in order of decreasing sizeof usually leads to their being contiguous in memory. bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode. . Reimplemented in TTreeSQL.; Definition at line 1986 of file TTree.cxx. ◆ Branch() [12/13]. Int_t TTree::Branch ; (; TCollection * ; li, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99, . const char * ; name = """" . ). virtual . Create one branch for each element in the collection. ; Each entry in the collection becomes a top level branch if the corresponding class is not a collection. If it is a collection, the entry in the collection becomes in turn top level branches, etc. The splitlevel is decreased by 1 every time a new collection is found. For example if list is a TObjArray*; if splitlevel = 1, one top level branch is created for each element of the TObjArray.; if splitlevel = 2, one top level branch is created for each array element. if, in turn, one of the array elements is a TCollection, one top level branch will be created for each element of this collection. In case a coll",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:92853,Security,access,access,92853,"ch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1635 of file TTree.cxx. ◆ BranchImpRef() [2/2]. TBranch * TTree::BranchImpRef ; (; const char * ; branchname, . TClass * ; ptrClass, . EDataType ; datatype, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1695 of file TTree.cxx. ◆ BranchOld(). TBranch * TTree::BranchOld ; (; const char * ; name, . const char * ; classname, . void * ; addobj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 1 . ). virtual . Create a new TTree BranchObject. ; Build a TBranchObject for an object of class classname. addobj is the address of a pointer to an object of class classname. IMPORTANT: classname must derive from TObject. The class dictionary must be available (ClassDef in class header).; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object. See the next Branch constructor for a more efficient storage in case the entry consists of arrays of identical objects.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:94256,Security,access,access,94256,"ent file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode. ; Reimplemented in TTreeSQL.; Definition at line 2074 of file TTree.cxx. ◆ BranchRef(). TBranch * TTree::BranchRef ; (; ). virtual . Build the optional branch supporting the TRefTable. ; This branch will keep all the information to find the branches containing referenced objects.; At each Tree::Fill, the branch numbers containing the referenced objects are saved to the TBranchRef basket. When the Tree header is saved (via TTree::Write), the branch is saved keeping the information with the pointers to the branches having referenced objects. ; Definition at line 2328 of file TTree.cxx. ◆ Bronch(). TBranch * TTree::Bronch ; (; const char * ; name, . const char * ; classname, . void * ; addr, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). virtual . Create a new TTree BranchElement. . WARNING about this new function; This function is designed to replace the internal implementation o",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:96258,Security,access,access,96258," been moved to BranchOld).; NOTE: The 'Bronch' method supports only one possible calls signature (where the object type has to be specified explicitly and the address must be the address of a pointer). For more flexibility use 'Branch'. Use Bronch only in (rare) cases (likely to be legacy cases) where both the new and old implementation of Branch needs to be used at the same time.; This function is far more powerful than the old Branch function. It supports the full C++, including STL and has the same behaviour in split or non-split mode. classname does not have to derive from TObject. The function is based on the new TStreamerInfo.; Build a TBranchElement for an object of class classname.; addr is the address of a pointer to an object of class classname. The class dictionary must be available (ClassDef in class header).; Note: See the comments in TBranchElement::SetAddress() for a more detailed discussion of the meaning of the addr parameter.; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; bufsize is the b",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:97541,Security,access,access,97541,"ent file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode.; Use splitlevel < 0 instead of splitlevel=0 when the class has a custom Streamer; Note: if the split level is set to the default (99), TTree::Branch will not issue a warning if the class can not be split. ; Reimplemented in TTreeSQL.; Definition at line 2404 of file TTree.cxx. ◆ BronchExec(). TBranch * TTree::BronchExec ; (; const char * ; name, . const char * ; classname, . void * ; addobj, . bool ; isptrptr, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ; Definition at line 2412 of file TTree.cxx. ◆ Browse(). void TTree::Browse ; (; TBrowser * ; b). overridevirtual . Browse content of the TTree. ; Reimplemented from TObject.; Definition at line 2609 of file TTree.cxx. ◆ BuildIndex(). Int_t TTree::BuildIndex ; (; const char * ; majorname, . const char * ; minorname = ""0"" . ). virtua",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:115521,Security,access,access,115521,"cloud of unbinned 2D or 3D points is drawn respectively.; if the expression has four fields ""e1:e2:e3:e4"" a cloud of unbinned 3D points is produced with e1 vs e2 vs e3, and e4 is mapped on the current color palette. If option COL is specified when varexp has three fields: tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the current color palette. The colors for e3 are evaluated once in linear scale before painting. Therefore changing the pad to log scale along Z as no effect on the colors.; if expression has more than four fields the option ""PARA""or ""CANDLE"" can be used.; If option contains the string ""goff"", no graphics is generated. . [in]nentriesThe number of entries to process (default is all) ; [in]firstentryThe first entry to process (default is 0). Drawing expressions using arrays and array elements; Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array, or a TClonesArray. In a TTree::Draw expression you can now access fMatrix using the following syntaxes:. String passed What is used for each entry of the tree . fMatrix the 9 elements of fMatrix . fMatrix[][] the 9 elements of fMatrix . fMatrix[2][2] only the elements fMatrix[2][2] . fMatrix[1] the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] . fMatrix[1][] the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] . fMatrix[][0] the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0] . ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!).; In summary, if a specific index is not specified for a dimension, TTree::Draw will loop through all the indices along this dimension. Leaving off the last (right most) dimension of specifying then with the two characters '[]' is equivalent. For variable size arrays (and TClonesArray) the range of the first dimension is recalculated for each entry of the tree. You can also specify the index as an expression of any other variables from the tree.; TT",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:120076,Security,access,access,120076,"tion (""""), a cloud of points is drawn and the histogram htemp is not filled. For all the other drawing options htemp will be filled.; In all cases htemp can be retrieved by calling:; auto htemp = (TH1F*)gPad->GetPrimitive(""htemp""); // 1D; auto htemp = (TH2F*)gPad->GetPrimitive(""htemp""); // 2D; auto htemp = (TH3F*)gPad->GetPrimitive(""htemp""); // 3D; gPad#define gPadDefinition TVirtualPad.h:305; TH3F3-D histogram with a float per channel (see TH1 documentation)Definition TH3.h:317; In the two dimensional case (Draw(""e1;e2"")), with the default drawing option, the data is filled into a TGraph named Graph. This TGraph can be retrieved by calling; auto graph = (TGraph*)gPad->GetPrimitive(""Graph"");; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; graphDefinition graph.py:1; For the three and four dimensional cases, with the default drawing option, an unnamed TPolyMarker3D is produced, and therefore cannot be retrieved.; In all cases htemp can be used to access the axes. For instance in the 2D case:; auto htemp = (TH2F*)gPad->GetPrimitive(""htemp"");; auto xaxis = htemp->GetXaxis();; When the option ""A"" is used (with TGraph painting option) to draw a 2D distribution: tree.Draw(""e1:e2"","""",""A*"");; a scatter plot is produced (with stars in that case) but the axis creation is delegated to TGraph and htemp is not created. Saving the result of Draw to a histogram; If varexp contains >>hnew (following the variable(s) name(s)), the new histogram called hnew is created and it is kept in the current directory (and also the current pad). This works for all dimensions.; Example: tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current directory. To retrieve it do: TH1F *hsqrt = (TH1F*)gDirectory->Get(""hsqrt"");; gDirectory#define gDirectoryDefinition TDirectory.h:384; The binning information is taken from the environment variables Hist.Binning.?D.?; In addition, the name of the histogram can be f",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:122607,Security,access,access,122607,"60; // 50 bins in y-direction; lower limit on y-axis is .1; upper limit is .5; By default, the specified histogram is reset. To continue to append data to an existing histogram, use ""+"" in front of the histogram name.; A '+' in front of the histogram name is ignored, when the name is followed by binning information as described in the previous paragraph. tree.Draw(""sqrt(x)>>+hsqrt"",""y>0""); will not reset hsqrt, but will continue filling. This works for 1-D, 2-D and 3-D histograms. Accessing collection objects; TTree::Draw default's handling of collections is to assume that any request on a collection pertain to it content. For example, if fTracks is a collection of Track objects, the following: tree->Draw(""event.fTracks.fPx"");; will plot the value of fPx for each Track objects inside the collection. Also tree->Draw(""event.fTracks.size()"");; would plot the result of the member function Track::size() for each Track object inside the collection. To access information about the collection itself, TTree::Draw support the '@' notation. If a variable which points to a collection is prefixed or postfixed with '@', the next part of the expression will pertain to the collection object. For example: tree->Draw(""event.@fTracks.size()"");; will plot the size of the collection referred to by fTracks (i.e the number of Track objects). Drawing 'objects'; When a class has a member function named AsDouble or AsString, requesting to directly draw the object will imply a call to one of the 2 functions. If both AsDouble and AsString are present, AsDouble will be used. AsString can return either a char*, a std::string or a TString.s For example, the following tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw will call respectively TString::Data and std::string::c_str(); If the object is a TBits, the histogram will contain the index of the bit that are tu",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:124134,Security,access,access,124134,"e object will imply a call to one of the 2 functions. If both AsDouble and AsString are present, AsDouble will be used. AsString can return either a char*, a std::string or a TString.s For example, the following tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw will call respectively TString::Data and std::string::c_str(); If the object is a TBits, the histogram will contain the index of the bit that are turned on. Retrieving information about the tree itself.; You can refer to the tree (or chain) containing the data by using the string 'This'. You can then could any TTree methods. For example: tree->Draw(""This->GetReadEntry()"");; will display the local entry numbers be read. tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; will display the name of the first 'user info' object. Special functions and variables; Entry$: A TTree::Draw formula can use the special variable Entry$ to access the entry number being read. For example to draw every other entry use: tree.Draw(""myvar"",""Entry$%2==0"");. Entry$ : return the current entry number (== TTree::GetReadEntry()); LocalEntry$ : return the current entry number in the current tree of a chain (== GetTree()->GetReadEntry()); Entries$ : return the total number of entries (== TTree::GetEntries()); LocalEntries$ : return the total number of entries in the current tree of a chain (== GetTree()->TTree::GetEntries()); Length$ : return the total number of element of this formula for this entry (==TTreeFormula::GetNdata()); Iteration$ : return the current iteration over this formula for this entry (i.e. varies from 0 to Length$).; Length$(formula ) : return the total number of element of the formula given as a parameter.; Sum$(formula ) : return the sum of the value of the elements of the formula given as a parameter. For example the mean for all the elements in one entry can be calculated with",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:127069,Security,access,accessing,127069,"+0 Or with a variable size array arr3 tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1) As a comparison tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the actual_size_of_arr3 is greater or equal to 3. Note that the array in 'primary' is flattened/linearized thus using Alt$ with multi-dimensional arrays of different dimensions in unlikely to yield the expected results. To visualize a bit more what elements would be matched by TTree::Draw, TTree::Scan can be used: tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be matched by tree->Draw(""arr1-Alt$(arr2,0)"");; The ternary operator is not directly supported in TTree::Draw however, to plot the equivalent of var2<20 ? -99 : var1, you can use: tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly; If the formula contains a file name, TTree::MakeProxy will be used to load and execute this file. In particular it will draw the result of a function with the same name as the file. The function will be executed in a context where the name of the branches can be used as a C++ variable.; For example draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; hsimpleDefinition hsimple.py:1; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; Drawth1 Draw(); A more complete example is available in the tutorials directory: h1analysisProxy.cxx, h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C; The main features of this facility are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bound; ability to use the branch data as objec",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:133698,Security,access,access,133698,"SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of ALL tracks in event with at least one track with a positive fPy.; To select only the elements that did match the original selection use TEventList::SetReapplyCut or TEntryList::SetReapplyCut.; Example: tree.Draw("">>pyplus"",""fTracks.fPy>0"");; pyplus->SetReapplyCut(true);; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of only the tracks that have a positive fPy.; To draw only the elements that match a selection in case of arrays, you can also use TEntryListArray (faster in case of a more general selection).; Example: tree.Draw("">>pyplus"",""fTracks.fPy>0"", ""entrylistarray"");; tree->SetEntryList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of only the tracks that have a positive fPy, but without redoing the selection.; Note: Use tree->SetEventList(0) if you do not want use the list as input. How to obtain more info from TTree::Draw; Once TTree::Draw has been called, it is possible to access useful information still stored in the TTree object via the following functions:. GetSelectedRows() // return the number of values accepted by the selection expression. In case where no selection was specified, returns the number of values processed.; GetV1() // returns a pointer to the double array of V1; GetV2() // returns a pointer to the double array of V2; GetV3() // returns a pointer to the double array of V3; GetV4() // returns a pointer to the double array of V4; GetW() // returns a pointer to the double array of Weights where weight equal the result of the selection expression. where V1,V2,V3 correspond to the expressions in TTree::Draw(""V1:V2:V3:V4"",selection);; If the expression has more than 4 component use GetVal(index); Example: Root > ntuple->Draw(""py:px"",""pz>4"");; Root > TGraph *gr = new TGraph(ntuple->GetSelectedRows(),; ntuple->GetV2(), ntuple->GetV1());; Root > gr->Draw(""ap""); //draw graph in current pad; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDr",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:170973,Security,access,access,170973,"rent object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 659 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 547 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by LoadTree() when the masterTree looks for the entry number in a friend tree (us) corresponding to the passed entry nu",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:171021,Security,access,access,171021,"e.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 547 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by LoadTree() when the masterTree looks for the entry number in a friend tree (us) corresponding to the passed entry number in the masterTree.; If we have no index, our entry number and the masterTree entry number are the sa",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:175146,Security,access,access,175146,"lename will be called nameoftree.C; The generated code includes the following:; Identification of the original Tree and Input file name,; Opening the Tree file,; Declaration of Tree variables,; Setting of branches addresses,; A skeleton for the entry loop. To use this function:. Open your Tree file (eg: TFile f(""myfile.root"");); T->MakeCode(""MyAnalysis.C"");. where T is the name of the TTree in file myfile.root and MyAnalysis.C the name of the file created by this function.; NOTE: Since the implementation of this function, a new and better function TTree::MakeClass() has been developed. ; Definition at line 6640 of file TTree.cxx. ◆ MakeProxy(). Int_t TTree::MakeProxy ; (; const char * ; proxyClassname, . const char * ; macrofilename = nullptr, . const char * ; cutfilename = nullptr, . const char * ; option = nullptr, . Int_t ; maxUnrolling = 3 . ). virtual . Generate a skeleton analysis class for this Tree using TBranchProxy. ; TBranchProxy is the base of a class hierarchy implementing an indirect access to the content of the branches of a TTree.; ""proxyClassname"" is expected to be of the form: [path/]fileprefix; The skeleton will then be generated in the file: fileprefix.h; located in the current directory or in 'path/' if it is specified. The class generated will be named 'fileprefix'; ""macrofilename"" and optionally ""cutfilename"" are expected to point to source files which will be included by the generated skeleton. Method of the same name as the file(minus the extension and path) will be called by the generated skeleton's Process method as follow: [if (cutfilename())] htemp->Fill(macrofilename());; ""option"" can be used select some of the optional features during the code generation. The possible options are:. nohist : indicates that the generated ProcessFill should not fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the system 'unroll' classes that are not split. Unrolling a class allows direct access to its data members (this emul",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:176097,Security,access,access,176097,"rchy implementing an indirect access to the content of the branches of a TTree.; ""proxyClassname"" is expected to be of the form: [path/]fileprefix; The skeleton will then be generated in the file: fileprefix.h; located in the current directory or in 'path/' if it is specified. The class generated will be named 'fileprefix'; ""macrofilename"" and optionally ""cutfilename"" are expected to point to source files which will be included by the generated skeleton. Method of the same name as the file(minus the extension and path) will be called by the generated skeleton's Process method as follow: [if (cutfilename())] htemp->Fill(macrofilename());; ""option"" can be used select some of the optional features during the code generation. The possible options are:. nohist : indicates that the generated ProcessFill should not fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the system 'unroll' classes that are not split. Unrolling a class allows direct access to its data members (this emulates the behavior of TTreeFormula).; The main features of this skeleton are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bounds errors; ability to use the branch data as an object (when the user code is available). For example with Event.root, if Double_t somePx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somePx will updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; These two functions are run in a ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:178390,Security,access,accessible,178390,"const Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.; The default histogram is accessible via the variable named 'htemp'.; If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed include statements and give the ability to access the object stored in the branches.; To draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C ; Definition at line 6768 of file TTree.cxx. ◆ MakeSelector(). Int_t TTree::MakeSelector ; (; const char * ; selector = nullptr, . Option_t * ; option = """" . ). virtual . Generate skeleton selector class for this tree. ; The following files are produced: selector.h and selector.C. If selector is 0, the se",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:178585,Security,access,access,178585,"d selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.; The default histogram is accessible via the variable named 'htemp'.; If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed include statements and give the ability to access the object stored in the branches.; To draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C ; Definition at line 6768 of file TTree.cxx. ◆ MakeSelector(). Int_t TTree::MakeSelector ; (; const char * ; selector = nullptr, . Option_t * ; option = """" . ). virtual . Generate skeleton selector class for this tree. ; The following files are produced: selector.h and selector.C. If selector is 0, the selector will be called ""nameoftree"". The option can be used to specify the branches that will have a data member.; If option is ""=le",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:214035,Security,access,access,214035,"licitMT ; (; bool ; enabled). inlinevirtual . Definition at line 621 of file TTree.h. ◆ SetIOFeatures(). ROOT::TIOFeatures TTree::SetIOFeatures ; (; const ROOT::TIOFeatures & ; features). Provide the end-user with the ability to enable/disable various experimental IO features for this TTree. ; Returns all the newly-set IO settings. ; Definition at line 9120 of file TTree.cxx. ◆ SetMakeClass(). void TTree::SetMakeClass ; (; Int_t ; make). virtual . Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode). ; For MakeClass mode 0, the TTree expects the address where the data is stored to be set by either the user or the TTree to the address of a full object through the top level branch. For MakeClass mode 1, this address is expected to point to a numerical type or C-style array (variable or not) of numerical type, representing the primitive data members. The function's primary purpose is to allow the user to access the data directly with numerical type variable rather than having to have the original set of classes (or a reproduction thereof). ; Reimplemented in TChain.; Definition at line 9167 of file TTree.cxx. ◆ SetMaxEntryLoop(). virtual void TTree::SetMaxEntryLoop ; (; Long64_t ; maxev = kMaxEntries). inlinevirtual . Definition at line 623 of file TTree.h. ◆ SetMaxTreeSize(). void TTree::SetMaxTreeSize ; (; Long64_t ; maxsize = 100000000000LL). static . Set the maximum size in bytes of a Tree file (static function). ; The default size is 100000000000LL, ie 100 Gigabytes.; In TTree::Fill, when the file has a size > fgMaxTreeSize, the function closes the current file and starts writing into a new file with a name of the style ""file_1.root"" if the original requested file name was ""file.root"". ; Definition at line 9187 of file TTree.cxx. ◆ SetMaxVirtualSize(). virtual void TTree::SetMaxVirtualSize ; (; Long64_t ; size = 0). inlinevirtual . Definition at line 625 of file TTree.h. ◆ SetName(). void TTree::SetName ; (; const char *",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:75222,Testability,test,tests,75222,"Bytes ; (; Int_t ; zip). inlinevirtual . Definition at line 332 of file TTree.h. ◆ AutoSave(). Long64_t TTree::AutoSave ; (; Option_t * ; option = """"). virtual . AutoSave tree header every fAutoSave bytes. ; When large Trees are produced, it is safe to activate the AutoSave procedure. Some branches may have buffers holding many entries. If fAutoSave is negative, AutoSave is automatically called by TTree::Fill when the number of bytes generated since the previous AutoSave is greater than -fAutoSave bytes. If fAutoSave is positive, AutoSave is automatically called by TTree::Fill every N entries. This function may also be invoked by the user. Each AutoSave generates a new key on the file. Once the key with the tree header has been written, the previous cycle (if any) is deleted.; Note that calling TTree::AutoSave too frequently (or similarly calling TTree::SetAutoSave with a small value) is an expensive operation. You should make tests for your own application to find a compromise between speed and the quantity of information you may loose in case of a job crash.; In case your program crashes before closing the file holding this tree, the file will be automatically recovered when you will connect the file in UPDATE mode. The Tree will be recovered at the status corresponding to the last AutoSave.; if option contains ""SaveSelf"", gDirectory->SaveSelf() is called. This allows another process to analyze the Tree while the Tree is being filled.; if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all the current basket are closed-out and written to disk individually.; By default the previous header is deleted after having written the new header. if option contains ""Overwrite"", the previous Tree header is deleted before written the new header. This option is slightly faster, but the default option is safer in case of a problem (disk quota exceeded) when writing the new header.; The function returns the number of bytes written to the file. if the number of by",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:76582,Testability,test,test,76582,"ing to the last AutoSave.; if option contains ""SaveSelf"", gDirectory->SaveSelf() is called. This allows another process to analyze the Tree while the Tree is being filled.; if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all the current basket are closed-out and written to disk individually.; By default the previous header is deleted after having written the new header. if option contains ""Overwrite"", the previous Tree header is deleted before written the new header. This option is slightly faster, but the default option is safer in case of a problem (disk quota exceeded) when writing the new header.; The function returns the number of bytes written to the file. if the number of bytes is null, an error has occurred while writing the header to the file. How to write a Tree in one process and view it from another process; The following two scripts illustrate how to do this. The script treew.C is executed by process1, treer.C by process2; script treew.C: void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TTree::AutoSavevirtual Long64_t AutoSave(Option_t *option="""")AutoSave tree header every fAutoSave bytes.Definition TTree.cxx:1500; int; script treer.C: void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:77387,Testability,test,test,77387,"n one process and view it from another process; The following two scripts illustrate how to do this. The script treew.C is executed by process1, treer.C by process2; script treew.C: void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TTree::AutoSavevirtual Long64_t AutoSave(Option_t *option="""")AutoSave tree header every fAutoSave bytes.Definition TTree.cxx:1500; int; script treer.C: void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:555; TCanvasThe Canvas class.Definition TCanvas.h:23; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::Refreshvirtual void Refresh()Refresh contents of this tree and its branches from the current status on disk.Definition TTree.cxx:7916; c1return c1Definition legend1.C:41. Definition at line 1500 of file TTree.cxx. ◆ Branch() [1/13]. Int_t TTree::Branch ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:89213,Testability,test,test,89213,"r more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; Example: {; TTree T(""T"",""test list"");; TList *list = new TList();; ; TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);; ; TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);; ; T.Branch(list,16000,2);; T.Print();; }; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TH1S1-D histogram with a short per channel (see TH1 documentation)Definition TH1.h:498; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68. Reimplemented in TTreeSQL.; Definition at line 1833 of file TTree.cxx. ◆ Branch() [13/13]. Int_t TTree::Branch ; (; TList * ; list, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). virtual . Deprecated function. U",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:106033,Testability,test,test,106033,"he baskets are sorted by their offset in the original file; Usually this also means that the baskets are sorted by the index/number of the last entry they contain); When using SortBasketsByBranch all the baskets of each individual branches are stored contiguously. This tends to optimize reading speed when reading a small number (1->5) of branches, since all their baskets will be clustered together instead of being spread across the file. However it might decrease the performance when reading more branches (or the full entry).; When using SortBasketsByEntry the baskets with the lowest starting entry are written first. (i.e. the baskets are sorted by the index/number of the first entry they contain). This means that on the file the baskets will be in the order in which they will be needed when reading the whole tree sequentially.; For examples of CloneTree, see tutorials:. copytree.C: A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1; copytree2.C: A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1 . Reimplemented in TNtuple.; Definition at line 3139 of file TTree.cxx. ◆ CopyAddresses(). void TTree::CopyAddresses ; (; TTree * ; tree, . bool ; undo = false . ). virtual . Set branch addresses of passed tree equal to ours. ; If undo is true, reset the branch addresses instead of copying them. This ensures 'separation' of a cloned tree from its original. ; Definition at line 3299 of file TTree.cxx. ◆ CopyEntries(). Long64_t TTree::CopyEntries ; (; TTree * ; tree, . Long64_t ; nentries = -1, . Option_t * ; option = """", . bool ; needCopyAddresses = false . ). virtual . Copy nentries from given tree to this tree. ; This routines assumes that the branches that intended to be copied are already connected. The typical case is that th",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:106252,Testability,test,test,106252," each individual branches are stored contiguously. This tends to optimize reading speed when reading a small number (1->5) of branches, since all their baskets will be clustered together instead of being spread across the file. However it might decrease the performance when reading more branches (or the full entry).; When using SortBasketsByEntry the baskets with the lowest starting entry are written first. (i.e. the baskets are sorted by the index/number of the first entry they contain). This means that on the file the baskets will be in the order in which they will be needed when reading the whole tree sequentially.; For examples of CloneTree, see tutorials:. copytree.C: A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1; copytree2.C: A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1 . Reimplemented in TNtuple.; Definition at line 3139 of file TTree.cxx. ◆ CopyAddresses(). void TTree::CopyAddresses ; (; TTree * ; tree, . bool ; undo = false . ). virtual . Set branch addresses of passed tree equal to ours. ; If undo is true, reset the branch addresses instead of copying them. This ensures 'separation' of a cloned tree from its original. ; Definition at line 3299 of file TTree.cxx. ◆ CopyEntries(). Long64_t TTree::CopyEntries ; (; TTree * ; tree, . Long64_t ; nentries = -1, . Option_t * ; option = """", . bool ; needCopyAddresses = false . ). virtual . Copy nentries from given tree to this tree. ; This routines assumes that the branches that intended to be copied are already connected. The typical case is that this tree was created using tree->CloneTree(0).; By default copy all entries.; Returns number of bytes copied to this tree.; If 'option' contains the word 'fast' and nentries is -1, the cloning will be done without u",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:109132,Testability,test,test,109132,"IndexOnError : If any of the underlying TTree objects do not have a TTreeIndex, all TTreeIndex are 'ignored' and the missing piece are rebuilt. . Definition at line 3534 of file TTree.cxx. ◆ CopyTree(). TTree * TTree::CopyTree ; (; const char * ; selection, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Copy a tree with selection. . Important:; The returned copied tree stays connected with the original tree until the original tree is deleted. In particular, any changes to the branch addresses in the original tree are also made to the copied tree. Any changes made to the branch addresses of the copied tree are overridden anytime the original tree changes its branch addresses. When the original tree is deleted, all the branch addresses of the copied tree are set to zero.; For examples of CopyTree, see the tutorials:. copytree.C: Example macro to copy a subset of a tree to a new tree. The input file was generated by running the program in $ROOTSYS/test/Event in this way: ./Event 1000 1 1 1; EventDefinition collection_proxies.C:172. copytree2.C Example macro to copy a subset of a tree to a new tree. One branch of the new tree is written to a separate file. The input file was generated by running the program in $ROOTSYS/test/Event in this way: ./Event 1000 1 1 1. copytree3.C Example macro to copy a subset of a tree to a new tree. Only selected entries are copied to the new tree. NOTE that only the active branches are copied. . Definition at line 3719 of file TTree.cxx. ◆ CreateBasket(). TBasket * TTree::CreateBasket ; (; TBranch * ; branch). virtual . Create a basket for this tree and given branch. ; Reimplemented in TTreeSQL.; Definition at line 3731 of file TTree.cxx. ◆ Debug(). Int_t TTree::Debug ; (; ); const. inline . Definition at line 429 of file TTree.h. ◆ DeclFileName(). static const char * TTree::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:109408,Testability,test,test,109408,"ion = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Copy a tree with selection. . Important:; The returned copied tree stays connected with the original tree until the original tree is deleted. In particular, any changes to the branch addresses in the original tree are also made to the copied tree. Any changes made to the branch addresses of the copied tree are overridden anytime the original tree changes its branch addresses. When the original tree is deleted, all the branch addresses of the copied tree are set to zero.; For examples of CopyTree, see the tutorials:. copytree.C: Example macro to copy a subset of a tree to a new tree. The input file was generated by running the program in $ROOTSYS/test/Event in this way: ./Event 1000 1 1 1; EventDefinition collection_proxies.C:172. copytree2.C Example macro to copy a subset of a tree to a new tree. One branch of the new tree is written to a separate file. The input file was generated by running the program in $ROOTSYS/test/Event in this way: ./Event 1000 1 1 1. copytree3.C Example macro to copy a subset of a tree to a new tree. Only selected entries are copied to the new tree. NOTE that only the active branches are copied. . Definition at line 3719 of file TTree.cxx. ◆ CreateBasket(). TBasket * TTree::CreateBasket ; (; TBranch * ; branch). virtual . Create a basket for this tree and given branch. ; Reimplemented in TTreeSQL.; Definition at line 3731 of file TTree.cxx. ◆ Debug(). Int_t TTree::Debug ; (; ); const. inline . Definition at line 429 of file TTree.h. ◆ DeclFileName(). static const char * TTree::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 659 of file TTree.h. ◆ Delete(). void TTree::Delete ; (; Option_t * ; option = """"). overridevirtual . Delete this tree from memory or/and disk. . if option == ""all"" delete Tree object from memory AND from disk all baskets on disk are deleted. All keys with same name a",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:113348,Testability,log,logical,113348,"d the color number of each marker will be 2.5*E. If the color number is negative it is set to 0. If the color number is greater than the current number of colors it is set to the highest color number. The default number of colors is 50. See TStyle::SetPalette for setting a new color palette. The expressions can use all the operations and built-in functions supported by TFormula (see TFormula::Analyze()), including free functions taking numerical arguments (e.g. TMath::Bessel()). In addition, you can call member functions taking numerical arguments. For example, these are two valid expressions: TMath::BreitWigner(fPx,3,2); event.GetHistogram()->GetXaxis()->GetXmax(); TTree::GetHistogramTH1 * GetHistogram()Definition TTree.h:479; TMath::BreitWignerDouble_t BreitWigner(Double_t x, Double_t mean=0, Double_t gamma=1)Calculates a Breit Wigner function with mean and gamma.Definition TMath.cxx:442; . [in]selectionA string containing a selection expression. In a selection all usual C++ mathematical and logical operators are allowed. The value corresponding to the selection expression is used as a weight to fill the histogram (a weight of 0 is equivalent to not filling the histogram). Examples:; ""x<y && sqrt(z)>3.2"": returns a weight = 0 or 1; ""(x+y)*(sqrt(z)>3.2)"": returns a weight = x+y if sqrt(z)>3.2, 0 otherwise. If the selection expression returns an array, it is iterated over in sync with the array returned by the varexp argument (as described below in ""Drawing expressions using arrays and array; elements""). For example, if, for a given event, varexp evaluates to {1., 2., 3.} and selection evaluates to {0, 1, 0}, the resulting histogram is filled with the value 2. For example, for each event here we perform a simple object selection: // Muon_pt is an array: fill a histogram with the array elements > 100 in each event; tree->Draw('Muon_pt', 'Muon_pt > 100'); . [in]optionThe drawing option.; When an histogram is produced it can be any histogram drawing option listed in THi",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:115016,Testability,log,log,115016,"e 2. For example, for each event here we perform a simple object selection: // Muon_pt is an array: fill a histogram with the array elements > 100 in each event; tree->Draw('Muon_pt', 'Muon_pt > 100'); . [in]optionThe drawing option.; When an histogram is produced it can be any histogram drawing option listed in THistPainter.; when no option is specified:; the default histogram drawing option is used if the expression is of the form ""e1"".; if the expression is of the form ""e1:e2""or ""e1:e2:e3"" a cloud of unbinned 2D or 3D points is drawn respectively.; if the expression has four fields ""e1:e2:e3:e4"" a cloud of unbinned 3D points is produced with e1 vs e2 vs e3, and e4 is mapped on the current color palette. If option COL is specified when varexp has three fields: tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the current color palette. The colors for e3 are evaluated once in linear scale before painting. Therefore changing the pad to log scale along Z as no effect on the colors.; if expression has more than four fields the option ""PARA""or ""CANDLE"" can be used.; If option contains the string ""goff"", no graphics is generated. . [in]nentriesThe number of entries to process (default is all) ; [in]firstentryThe first entry to process (default is 0). Drawing expressions using arrays and array elements; Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array, or a TClonesArray. In a TTree::Draw expression you can now access fMatrix using the following syntaxes:. String passed What is used for each entry of the tree . fMatrix the 9 elements of fMatrix . fMatrix[][] the 9 elements of fMatrix . fMatrix[2][2] only the elements fMatrix[2][2] . fMatrix[1] the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] . fMatrix[1][] the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] . fMatrix[][0] the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0] . ""fEvent.fMatrix...."" same as ""fMatrix..."" (unle",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:151041,Testability,test,test,151041,"if you have a Tree with several hundred branches, and you are interested only by branches named ""a"" and ""b"", do mytree.SetBranchStatus(""*"",0); //disable all branches; mytree.SetBranchStatus(""a"",1);; mytree.SetBranchStatus(""b"",1);; when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read.; WARNING!! If your Tree has been created in split mode with a parent branch ""parent."", mytree.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do: mytree.SetBranchStatus(""parent*"",1);; Without the trailing dot in the branch creation you have no choice but to call SetBranchStatus explicitly for each of the sub branches.; An alternative is to call directly brancha.GetEntry(i); branchb.GetEntry(i);; ; IMPORTANT NOTE; By default, GetEntry reuses the space allocated by the previous object for each branch. You can force the previous object to be automatically deleted if you call mybranch.SetAutoDelete(true) (default is false).; Example:; Consider the example in $ROOTSYS/test/Event.h The top level branch in the tree T is declared with: Event *event = 0; //event must be null or point to a valid object; //it must be initialized; T.SetBranchAddress(""event"",&event);; When reading the Tree, one can choose one of these 3 options:. OPTION 1; for (Long64_t i=0;i<nentries;i++) {; T.GetEntry(i);; // the object event has been filled at this point; }; The default (recommended). At the first entry an object of the class Event will be created and pointed by event. At the following entries, event will be overwritten by the new data. All internal members that are TObject* are automatically deleted. It is important that these members be in a valid state when GetEntry is called. Pointers must be correctly initialized. However these internal members will not be deleted if the characters ""->"" are specified as the first characters in the comment field of the data member declaration.; If ""->"" is specified, the pointer member is read via pointer->Streamer(bu",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:2003,Usability,simpl,simple,2003," if the file compression attribute is set (default). Branches may be written to different files (see TBranch::SetFile).; The ROOT user can decide to make one single branch and serialize one object into one single I/O buffer or to make several branches. Making several branches is particularly interesting in the data analysis phase, when it is desirable to have a high reading rate and not all columns are equally interesting. Create a TTree to store columnar data. Construct a TTree; Add a column of Fundamental Types and Arrays thereof; Add a column of a STL Collection instances; Add a column holding an object; Add a column holding a TObjectArray; Fill the tree; Add a column to an already existing Tree; An Example. Construct a TTree; TTree tree(name, title); namechar name[80]Definition TGX11.cxx:110; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Creates a Tree with name and title.; Various kinds of branches can be added to a tree:; Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran structures.; Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures. It is strongly recommended to persistify those as objects rather than lists of leaves.; auto branch = tree.Branch(branchname, address, leaflist, bufsize). address is the address of the first item of a structure; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type must be 1 character. (Characters after the first are legal and will be appended to the visible name of the leaf, but have no effect.) If no type is given, the type of the variable is assumed to be the sa",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:2379,Usability,simpl,simple,2379,"and not all columns are equally interesting. Create a TTree to store columnar data. Construct a TTree; Add a column of Fundamental Types and Arrays thereof; Add a column of a STL Collection instances; Add a column holding an object; Add a column holding a TObjectArray; Fill the tree; Add a column to an already existing Tree; An Example. Construct a TTree; TTree tree(name, title); namechar name[80]Definition TGX11.cxx:110; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Creates a Tree with name and title.; Various kinds of branches can be added to a tree:; Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran structures.; Any C++ object or collection, provided by the STL or ROOT. In the following, the details about the creation of different types of branches are given. Add a column (""branch"") holding fundamental types and arrays thereof; This strategy works also for lists of variables, e.g. to describe simple structures. It is strongly recommended to persistify those as objects rather than lists of leaves.; auto branch = tree.Branch(branchname, address, leaflist, bufsize). address is the address of the first item of a structure; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type must be 1 character. (Characters after the first are legal and will be appended to the visible name of the leaf, but have no effect.) If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:9547,Usability,simpl,simple,9547,"olding TClonesArray instances; It is recommended to use STL containers instead of TClonesArrays*.; // clonesarray is the address of a pointer to a TClonesArray.; auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel); The TClonesArray is a direct access list of objects of the same class. For example, if the TClonesArray is an array of TTrack objects, this function will create one subbranch for each data member of the object TTrack. Fill the Tree; A TTree instance is filled with the invocation of the TTree::Fill method: tree.Fill(); Upon its invocation, a loop on all defined branches takes place that for each branch invokes the TBranch::Fill method. Add a column to an already existing Tree; You may want to add a branch to an existing tree. For example, if one variable in the tree was computed with a certain algorithm, you may want to try another algorithm and compare the results. One solution is to add a new branch, fill it, and save the tree. The code below adds a simple branch to an existing tree. Note the kOverwrite option in the Write method, it overwrites the existing tree. If it is not specified, two copies of the tree headers are saved. void tree3AddBranch() {; TFile f(""tree3.root"", ""update"");; ; Float_t new_v;; auto t3 = f->Get<TTree>(""t3"");; auto newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");; ; Long64_t nentries = t3->GetEntries(); // read the number of entries in the t3; ; for (Long64_t i = 0; i < nentries; i++) {; new_v = gRandom->Gaus(0, 1);; newBranch->Fill();; }; ; t3->Write("""", TObject::kOverwrite); // save only the new version of the tree; }; f#define f(i)Definition RSha256.hxx:104; Float_tfloat Float_tDefinition RtypesCore.h:57; Long64_tlong long Long64_tDefinition RtypesCore.h:80; nentriesint nentriesDefinition THbookFile.cxx:91; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TObject::kO",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:11549,Usability,simpl,simple,11549,"uble_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TTree::Fillvirtual Int_t Fill()Fill all branches.Definition TTree.cxx:4603; TTree::BranchTBranch * Branch(const char *name, T *obj, Int_t bufsize=32000, Int_t splitlevel=99)Add a new branch, and infer the data type from the type of obj being passed.Definition TTree.h:353; It is not always possible to add branches to existing datasets stored in TFiles: for example, these files might not be writeable, just readable. In addition, modifying in place a TTree causes a new TTree instance to be written and the previous one to be deleted. For this reasons, ROOT offers the concept of friends for TTree and TChain: if is good practice to rely on friend trees rather than adding a branch manually. An Example. // A simple example with histograms and a tree; //; // This program creates :; // - a one dimensional histogram; // - a two dimensional histogram; // - a profile histogram; // - a tree; //; // These objects are filled with some random numbers and saved on a file.; ; #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h""; ; //__________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");; ; // Create some histograms and a profile histogram; TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile hprof(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; ; // Define some simple structures; typedef struct {Float_t x,y,",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:12628,Usability,simpl,simple,12628,"eates :; // - a one dimensional histogram; // - a two dimensional histogram; // - a profile histogram; // - a tree; //; // These objects are filled with some random numbers and saved on a file.; ; #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h""; ; //__________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");; ; // Create some histograms and a profile histogram; TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile hprof(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; ; // Define some simple structures; typedef struct {Float_t x,y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; POINT point;; EVENTN eventn;; ; // Create a ROOT Tree; TTree tree(""T"",""An example of ROOT tree with a few branches"");; tree.Branch(""point"",&point,""x:y:z"");; tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);; ; Float_t px,py,pz;; ; // Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; const auto random = gRandom->::Rndm(1);; ; // Fill histograms; hpx.Fill(px);; hpxpy.Fill(px,py,1);; hprof.Fill(px,pz,1);; ; // Fill structures; point.x = 10*(random-1);; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;; ; // Fill the tree. For each event, save ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:13658,Usability,simpl,simple,13658,"y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; POINT point;; EVENTN eventn;; ; // Create a ROOT Tree; TTree tree(""T"",""An example of ROOT tree with a few branches"");; tree.Branch(""point"",&point,""x:y:z"");; tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);; ; Float_t px,py,pz;; ; // Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; const auto random = gRandom->::Rndm(1);; ; // Fill histograms; hpx.Fill(px);; hpxpy.Fill(px,py,1);; hprof.Fill(px,pz,1);; ; // Fill structures; point.x = 10*(random-1);; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;; ; // Fill the tree. For each event, save the 2 structures and 3 objects; // In this simple example, the objects hpx, hprof and hpxpy are slightly; // different from event to event. We expect a big compression factor!; tree->Fill();; }; // End of the loop; ; tree.Print();; ; // Save all objects in this file; hfile.Write();; ; // Close the file. Note that this is automatically done when you leave; // the application upon file destruction.; hfile.Close();; ; return 0;; }; mainint main()Definition Prototype.cxx:12; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; TFile.h; TH1.h; TH2.h; TProfile.h; TRandom.h; TTree.h; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:621; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TProfileProfile Histogram.Definition TProfile.h:32; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; yDouble_t y[n]Definition legend1.C:17; xDoubl",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:23908,Usability,undo,undo,23908,"e, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=1);  Create a new TTree BranchObject. ;  ; virtual TBranch * BranchRef ();  Build the optional branch supporting the TRefTable. ;  ; virtual TBranch * Bronch (const char *name, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=99);  Create a new TTree BranchElement. ;  ; void Browse (TBrowser *) override;  Browse content of the TTree. ;  ; virtual Int_t BuildIndex (const char *majorname, const char *minorname=""0"");  Build a Tree Index (default is TTreeIndex). ;  ; TStreamerInfo * BuildStreamerInfo (TClass *cl, void *pointer=nullptr, bool canOptimize=true);  Build StreamerInfo for class cl. ;  ; virtual TFile * ChangeFile (TFile *file);  Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize. ;  ; virtual TTree * CloneTree (Long64_t nentries=-1, Option_t *option="""");  Create a clone of this tree and copy nentries. ;  ; virtual void CopyAddresses (TTree *, bool undo=false);  Set branch addresses of passed tree equal to ours. ;  ; virtual Long64_t CopyEntries (TTree *tree, Long64_t nentries=-1, Option_t *option="""", bool needCopyAddresses=false);  Copy nentries from given tree to this tree. ;  ; virtual TTree * CopyTree (const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Copy a tree with selection. ;  ; virtual TBasket * CreateBasket (TBranch *);  Create a basket for this tree and given branch. ;  ; Int_t Debug () const;  ; void Delete (Option_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file. ;  ; virtual Long64_t Draw (const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for entries and objects that pass a (optional) selection. ;  ; virtual Long6",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:35581,Usability,simpl,simply,35581,"const;  Print statistics about the TreeCache for this tree. ;  ; virtual Long64_t Process (const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Process this tree executing the TSelector code in the specified filename. ;  ; virtual Long64_t Process (TSelector *selector, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Process this tree executing the code in the specified selector. ;  ; virtual Long64_t Project (const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Make a projection of a tree using selections. ;  ; virtual TSQLResult * Query (const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop over entries and return a TSQLResult object containing entries following selection. ;  ; virtual Long64_t ReadFile (const char *filename, const char *branchDescriptor="""", char delimiter=' ');  Create or simply read branches from filename. ;  ; virtual Long64_t ReadStream (std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ');  Create or simply read branches from an input stream. ;  ; void RecursiveRemove (TObject *obj) override;  Make sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree. ;  ; virtual void Refresh ();  Refresh contents of this tree and its branches from the current status on disk. ;  ; virtual void RegisterExternalFriend (TFriendElement *);  Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual void RemoveFriend (TTree *);  Remove a friend from the list of friends. ;  ; virtual void Reset (Option_t *option="""");  Reset baskets, buffers and entries count in all branches an",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:35743,Usability,simpl,simply,35743,"s, Long64_t firstentry=0);  Process this tree executing the TSelector code in the specified filename. ;  ; virtual Long64_t Process (TSelector *selector, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Process this tree executing the code in the specified selector. ;  ; virtual Long64_t Project (const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Make a projection of a tree using selections. ;  ; virtual TSQLResult * Query (const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop over entries and return a TSQLResult object containing entries following selection. ;  ; virtual Long64_t ReadFile (const char *filename, const char *branchDescriptor="""", char delimiter=' ');  Create or simply read branches from filename. ;  ; virtual Long64_t ReadStream (std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ');  Create or simply read branches from an input stream. ;  ; void RecursiveRemove (TObject *obj) override;  Make sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree. ;  ; virtual void Refresh ();  Refresh contents of this tree and its branches from the current status on disk. ;  ; virtual void RegisterExternalFriend (TFriendElement *);  Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual void RemoveFriend (TTree *);  Remove a friend from the list of friends. ;  ; virtual void Reset (Option_t *option="""");  Reset baskets, buffers and entries count in all branches and leaves. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Resets the state of this TTree after a merge (keep the customization but forget the data). ;  ; v",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:38811,Usability,learn,learning,38811,"T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr=nullptr);  Change branch address, dealing with clone trees properly. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual void SetBranchStatus (const char *bname, bool status=true, UInt_t *found=nullptr);  Set branch status to Process or DoNotProcess. ;  ; virtual Int_t SetCacheEntryRange (Long64_t first, Long64_t last);  interface to TTreeCache to set the cache entry range ;  ; virtual void SetCacheLearnEntries (Int_t n=10);  Interface to TTreeCache to set the number of entries for the learning phase. ;  ; virtual Int_t SetCacheSize (Long64_t cachesize=-1);  Set maximum size of the file cache . ;  ; virtual void SetChainOffset (Long64_t offset=0);  ; virtual void SetCircular (Long64_t maxEntries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual void SetDirectory (TDirectory *dir);  Change the tree's directory. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEntryList (TEntryList *list, Option_t *opt="""");  Set an EntryList. ;  ; virtual void SetEstimate (Long64_t nentri",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:41636,Usability,learn,learning,41636,"id SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void SetWeight (Double_t w=1, Option_t *option="""");  Set tree weight. ;  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning phase. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t UnbinnedFit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Unbinned fit of one or more variable(s) from a tree. ;  ; void UseCurrentStyle () override;  Replace current attributes by current style. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write this object to the current directory. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:76913,Usability,simpl,simple,76913,"Tree::FlushBaskets is called and all the current basket are closed-out and written to disk individually.; By default the previous header is deleted after having written the new header. if option contains ""Overwrite"", the previous Tree header is deleted before written the new header. This option is slightly faster, but the default option is safer in case of a problem (disk quota exceeded) when writing the new header.; The function returns the number of bytes written to the file. if the number of bytes is null, an error has occurred while writing the header to the file. How to write a Tree in one process and view it from another process; The following two scripts illustrate how to do this. The script treew.C is executed by process1, treer.C by process2; script treew.C: void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TTree::AutoSavevirtual Long64_t AutoSave(Option_t *option="""")AutoSave tree header every fAutoSave bytes.Definition TTree.cxx:1500; int; script treer.C: void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:555",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:81772,Usability,simpl,simple,81772,"le TTree.h. ◆ Branch() [8/13]. template<typename T , std::size_t N> . TBranch * TTree::Branch ; (; const char * ; name, . std::array< T, N > * ; obj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). inline . Definition at line 405 of file TTree.h. ◆ Branch() [9/13]. template<class T > . TBranch * TTree::Branch ; (; const char * ; name, . T ** ; addobj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). inline . Add a new branch, and infer the data type from the array addobj being passed. ; NoteThis and the previous overload should cover most cases for creating a branch. Try to use these two whenever possible, unless e.g. type conversions are needed.; Parameters. [in]nameName of the branch to be created. ; [in]addobjArray of the objects to be added. When calling Fill(), the current value of the type/object will be saved. ; [in]bufsizehe buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc. The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes). A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode. ; [in]splitlevelIf T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 370 of file TTree.h. ◆ Branch() [10/13]. template<class T > . TBranch * TTree::Branch ; (; const char * ; name, . T * ; obj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). inline . Add a new branch, and infer the data type from the type of obj being passed. ; NoteThis and the next overload should cover most cases for creating a branch. Try to use these two whenever possible, unless e.g. type conversions are needed.; Parameters. [in]nameName of the branch to be created. ; [in]objAddress of the object to be adde",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:83120,Usability,simpl,simple,83120," as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 370 of file TTree.h. ◆ Branch() [10/13]. template<class T > . TBranch * TTree::Branch ; (; const char * ; name, . T * ; obj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). inline . Add a new branch, and infer the data type from the type of obj being passed. ; NoteThis and the next overload should cover most cases for creating a branch. Try to use these two whenever possible, unless e.g. type conversions are needed.; Parameters. [in]nameName of the branch to be created. ; [in]objAddress of the object to be added. Make sure to pass a pointer to the actual type/class that should be stored in the tree (no pointers to base classes). When calling Fill(), the current value of the type/object will be saved. ; [in]bufsizeThe buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc. The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes). A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode. ; [in]splitlevelIf T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 353 of file TTree.h. ◆ Branch() [11/13]. TBranch * TTree::Branch ; (; const char * ; name, . void * ; address, . const char * ; leaflist, . Int_t ; bufsize = 32000 . ). virtual . Create a new TTree Branch. ; This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:83892,Usability,simpl,simple,83892,"ll(), the current value of the type/object will be saved. ; [in]bufsizeThe buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc. The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes). A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode. ; [in]splitlevelIf T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches. . ReturnsPointer to the TBranch that was created. The branch is owned by the tree. ; Definition at line 353 of file TTree.h. ◆ Branch() [11/13]. TBranch * TTree::Branch ; (; const char * ; name, . void * ; address, . const char * ; leaflist, . Int_t ; bufsize = 32000 . ). virtual . Create a new TTree Branch. ; This Branch constructor is provided to support non-objects in a Tree. The variables described in leaflist may be simple variables or structures. // See the two following constructors for writing objects in a Tree.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file. address is the address of the first item of a structure.; leaflist is the concatenation of all the variable names and types separated by a colon character : The variable name and the variable type are separated by a slash (/). The variable type may be 0,1 or 2 characters. If no type is given, the type of the variable is assumed to be the same as the previous variable. If the first variable does not have a type, it is assumed of type F by default. The list of currently supported types is given below:; C : a character string terminated by the 0 character; B : an 8 bit signed integer (Char_t); Treated as a character when in an array.; b : an 8 bit unsigned integer (UChar_t); S : a 16 bit signed integer (Short_t); s : a 16 bit unsigned integer (UShort_t); I : a 32 ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:88743,Usability,simpl,simply,88743," created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor for TClonesArray is called. The collection itself cannot be a TClonesArray.; The function returns the total number of branches created.; If name is given, all branch names will be prefixed with name_.; IMPORTANT NOTE1: This function should not be called with splitlevel < 1.; IMPORTANT NOTE2: The branches created by this function will have names corresponding to the collection or object names. It is important to give names to collections to avoid misleading branch names or identical branch names. By default collections have a name equal to the corresponding class name, e.g. the default name for a TList is ""TList"".; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; Example: {; TTree T(""T"",""test list"");; TList *list = new TList();; ; TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);; ; TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""h",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:93532,Usability,simpl,simply,93532,"litlevel = 1 . ). virtual . Create a new TTree BranchObject. ; Build a TBranchObject for an object of class classname. addobj is the address of a pointer to an object of class classname. IMPORTANT: classname must derive from TObject. The class dictionary must be available (ClassDef in class header).; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object. See the next Branch constructor for a more efficient storage in case the entry consists of arrays of identical objects.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode. ; Reimplemented in TTreeSQL.; Definition at line 2074 of file TTree.cxx. ◆ BranchRef(). TBranch * TTree::BranchRef ; (; ). virtual . Build the optional branch supporting the TRefTable. ; This branch wil",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:96817,Usability,simpl,simply,96817,"t mode. classname does not have to derive from TObject. The function is based on the new TStreamerInfo.; Build a TBranchElement for an object of class classname.; addr is the address of a pointer to an object of class classname. The class dictionary must be available (ClassDef in class header).; Note: See the comments in TBranchElement::SetAddress() for a more detailed discussion of the meaning of the addr parameter.; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode.; Use splitlevel < 0 instead of splitlevel=0 when the class has a custom Streamer; Note: if the split level is set to the default (99), TTree::Branch will not issue a warning if the class can not be spli",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:102856,Usability,usab,usable,102856,"t of the branch. ; If a Data Model Evolution conversion is involved, reset the fInfo of the branch. The return values are:; kMissingBranch (-5) : Missing branch; kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. In addition this can be multiplexed with the two bits:; kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode. This bits can be masked out by using kDecomposedObjMask . Definition at line 2867 of file TTree.cxx. ◆ Class(). static TClass * TTree::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTree::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTree::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 659 of file TTree.h. ◆ CloneTree(). TTree * TTree::CloneTree ; (; Long64_t ; nentries = -1, . Option_t * ; option = """" . ). virtual . Create a clone of this tree and copy nentries. ; By default copy all entries. The compression level of the cloned tree is set to the destination file's compression level.; NOTE:",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:102998,Usability,usab,usable,102998,"Error (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. In addition this can be multiplexed with the two bits:; kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode. This bits can be masked out by using kDecomposedObjMask . Definition at line 2867 of file TTree.cxx. ◆ Class(). static TClass * TTree::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTree::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTree::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 659 of file TTree.h. ◆ CloneTree(). TTree * TTree::CloneTree ; (; Long64_t ; nentries = -1, . Option_t * ; option = """" . ). virtual . Create a clone of this tree and copy nentries. ; By default copy all entries. The compression level of the cloned tree is set to the destination file's compression level.; NOTE: Only active branches are copied. See TTree::SetBranchStatus for more information and usage regarding the (de)activation of branches. More examples are provided in the tut",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:106433,Usability,undo,undo,106433,"being spread across the file. However it might decrease the performance when reading more branches (or the full entry).; When using SortBasketsByEntry the baskets with the lowest starting entry are written first. (i.e. the baskets are sorted by the index/number of the first entry they contain). This means that on the file the baskets will be in the order in which they will be needed when reading the whole tree sequentially.; For examples of CloneTree, see tutorials:. copytree.C: A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1; copytree2.C: A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1 . Reimplemented in TNtuple.; Definition at line 3139 of file TTree.cxx. ◆ CopyAddresses(). void TTree::CopyAddresses ; (; TTree * ; tree, . bool ; undo = false . ). virtual . Set branch addresses of passed tree equal to ours. ; If undo is true, reset the branch addresses instead of copying them. This ensures 'separation' of a cloned tree from its original. ; Definition at line 3299 of file TTree.cxx. ◆ CopyEntries(). Long64_t TTree::CopyEntries ; (; TTree * ; tree, . Long64_t ; nentries = -1, . Option_t * ; option = """", . bool ; needCopyAddresses = false . ). virtual . Copy nentries from given tree to this tree. ; This routines assumes that the branches that intended to be copied are already connected. The typical case is that this tree was created using tree->CloneTree(0).; By default copy all entries.; Returns number of bytes copied to this tree.; If 'option' contains the word 'fast' and nentries is -1, the cloning will be done without unzipping or unstreaming the baskets (i.e., a direct copy of the raw bytes on disk).; When 'fast' is specified, 'option' can also contains a sorting order for the baskets in the output file.; There ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:106517,Usability,undo,undo,106517,"l entry).; When using SortBasketsByEntry the baskets with the lowest starting entry are written first. (i.e. the baskets are sorted by the index/number of the first entry they contain). This means that on the file the baskets will be in the order in which they will be needed when reading the whole tree sequentially.; For examples of CloneTree, see tutorials:. copytree.C: A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1; copytree2.C: A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in $ROOTSYS/test/Event with: Event 1000 1 1 1 . Reimplemented in TNtuple.; Definition at line 3139 of file TTree.cxx. ◆ CopyAddresses(). void TTree::CopyAddresses ; (; TTree * ; tree, . bool ; undo = false . ). virtual . Set branch addresses of passed tree equal to ours. ; If undo is true, reset the branch addresses instead of copying them. This ensures 'separation' of a cloned tree from its original. ; Definition at line 3299 of file TTree.cxx. ◆ CopyEntries(). Long64_t TTree::CopyEntries ; (; TTree * ; tree, . Long64_t ; nentries = -1, . Option_t * ; option = """", . bool ; needCopyAddresses = false . ). virtual . Copy nentries from given tree to this tree. ; This routines assumes that the branches that intended to be copied are already connected. The typical case is that this tree was created using tree->CloneTree(0).; By default copy all entries.; Returns number of bytes copied to this tree.; If 'option' contains the word 'fast' and nentries is -1, the cloning will be done without unzipping or unstreaming the baskets (i.e., a direct copy of the raw bytes on disk).; When 'fast' is specified, 'option' can also contains a sorting order for the baskets in the output file.; There are currently 3 supported sorting order:. SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsBy",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:112058,Usability,simpl,simplest,112058,". [in]varexpA string that takes one of these general forms:; ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1"" on the y-axis versus ""e2"" on the x-axis; ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1"" vs ""e2"" vs ""e3"" on the z-, y-, x-axis, respectively; ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1"" vs ""e2"" vs ""e3"" and ""e4"" mapped on the current color palette. (to create histograms in the 2, 3, and 4 dimensional case, see section ""Saving the result of Draw to an histogram""); ""e1:e2:e3:e4:e5"" with option ""GL5D"" produces a 5D plot using OpenGL. gStyle->SetCanvasPreferGL(true) is needed.; Any number of variables no fewer than two can be used with the options ""CANDLE"" and ""PARA""; An arbitrary number of variables can be used with the option ""GOFF"". Examples:; ""x"": the simplest case, it draws a 1-Dim histogram of column x; ""sqrt(x)"", ""x*y/z"": draw histogram with the values of the specified numerical expression across TTree events; ""y:sqrt(x)"": 2-Dim histogram of y versus sqrt(x); ""px:py:pz:2.5*E"": produces a 3-d scatter-plot of px vs py ps pz and the color number of each marker will be 2.5*E. If the color number is negative it is set to 0. If the color number is greater than the current number of colors it is set to the highest color number. The default number of colors is 50. See TStyle::SetPalette for setting a new color palette. The expressions can use all the operations and built-in functions supported by TFormula (see TFormula::Analyze()), including free functions taking numerical arguments (e.g. TMath::Bessel()). In addition, you can call member functions taking numerical arguments. For example, these are two valid expressions: TMath::BreitWigner(fPx,3,2); event.GetHistogram()->GetXaxis()->GetXmax(); TTree::GetHistogramTH1 * GetHistogram()Definition TTree.h:479; TMath::BreitWignerDouble_t BreitWigner(Double_t x, Double_t mean=0, Double_t gamma=1",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:114074,Usability,simpl,simple,114074,", Double_t mean=0, Double_t gamma=1)Calculates a Breit Wigner function with mean and gamma.Definition TMath.cxx:442; . [in]selectionA string containing a selection expression. In a selection all usual C++ mathematical and logical operators are allowed. The value corresponding to the selection expression is used as a weight to fill the histogram (a weight of 0 is equivalent to not filling the histogram). Examples:; ""x<y && sqrt(z)>3.2"": returns a weight = 0 or 1; ""(x+y)*(sqrt(z)>3.2)"": returns a weight = x+y if sqrt(z)>3.2, 0 otherwise. If the selection expression returns an array, it is iterated over in sync with the array returned by the varexp argument (as described below in ""Drawing expressions using arrays and array; elements""). For example, if, for a given event, varexp evaluates to {1., 2., 3.} and selection evaluates to {0, 1, 0}, the resulting histogram is filled with the value 2. For example, for each event here we perform a simple object selection: // Muon_pt is an array: fill a histogram with the array elements > 100 in each event; tree->Draw('Muon_pt', 'Muon_pt > 100'); . [in]optionThe drawing option.; When an histogram is produced it can be any histogram drawing option listed in THistPainter.; when no option is specified:; the default histogram drawing option is used if the expression is of the form ""e1"".; if the expression is of the form ""e1:e2""or ""e1:e2:e3"" a cloud of unbinned 2D or 3D points is drawn respectively.; if the expression has four fields ""e1:e2:e3:e4"" a cloud of unbinned 3D points is produced with e1 vs e2 vs e3, and e4 is mapped on the current color palette. If option COL is specified when varexp has three fields: tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the current color palette. The colors for e3 are evaluated once in linear scale before painting. Therefore changing the pad to log scale along Z as no effect on the colors.; if expression has more than four fields the option ""PARA""or ""CAN",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:138827,Usability,simpl,simple,138827,"inition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a cache attached to the TTree (either pre-exisiting or created as part of this call) ; Definition at line 2685 of file TTree.cxx. ◆ Fill(). Int_t TTree::Fill ; (; ). virtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a simple data type, a simple conversion to a machine independent format has to be done.; This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:138847,Usability,simpl,simple,138847,"inition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a cache attached to the TTree (either pre-exisiting or created as part of this call) ; Definition at line 2685 of file TTree.cxx. ◆ Fill(). Int_t TTree::Fill ; (; ). virtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a simple data type, a simple conversion to a machine independent format has to be done.; This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:193183,Usability,simpl,simply,193183,"const char * ; hname, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Make a projection of a tree using selections. ; Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc., projection of the tree will be filled in histogram hname. Note that the dimension of hname must match with the dimension of varexp. ; Definition at line 7498 of file TTree.cxx. ◆ Query(). TSQLResult * TTree::Query ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Loop over entries and return a TSQLResult object containing entries following selection. ; Definition at line 7513 of file TTree.cxx. ◆ ReadFile(). Long64_t TTree::ReadFile ; (; const char * ; filename, . const char * ; branchDescriptor = """", . char ; delimiter = ' ' . ). virtual . Create or simply read branches from filename. ; if branchDescriptor = """" (default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like A/D:Table[2]/F:Ntracks/I:astring/C; F#define F(x, y, z); I#define I(x, y, z); otherwise branchDescriptor must be specified with the above syntax. If the type of the first variable is not specified, it is assumed to be ""/F""; If the type of any other variable is not specified, the type of the previous variable is assumed. eg; x:y:z (all variables are assumed of type ""F""); x/D:y:z (all variables are of type ""D""); x:y/D:z (x is type ""F"", y and z of type ""D""). delimiter allows for the use of another delimiter besides whitespace. This provides support for direct import of common data file formats like csv. If delimiter != ' ' and branchDescriptor == """", then the branch description is taken from the first line in the file, but delimiter is used for the branch names tokenization rather than ':'. Note however that if the values in the fir",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:195157,Usability,simpl,simply,195157,"f the values in the first line do not use the /[type] syntax, all variables are assumed to be of type ""F"". If the filename ends with extensions .csv or .CSV and a delimiter is not specified (besides ' '), the delimiter is automatically set to ','.; Lines in the input file starting with ""#"" are ignored. Leading whitespace for each column data is skipped. Empty lines are skipped.; A TBranch object is created for each variable in the expression. The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES; To fill a TTree with multiple input text files, proceed as indicated above for the first input file and omit the second argument for subsequent calls T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. Definition at line 7564 of file TTree.cxx. ◆ ReadStream(). Long64_t TTree::ReadStream ; (; std::istream & ; inputStream, . const char * ; branchDescriptor = """", . char ; delimiter = ' ' . ). virtual . Create or simply read branches from an input stream. ; See alsoreference information for TTree::ReadFile ; Reimplemented in TNtuple, and TNtupleD.; Definition at line 7615 of file TTree.cxx. ◆ RecursiveRemove(). void TTree::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Make sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree. ; Reimplemented from TObject.; Definition at line 7881 of file TTree.cxx. ◆ Refresh(). void TTree::Refresh ; (; ). virtual . Refresh contents of this tree and its branches from the current status on disk. ; One can call this function in case the tree file is being updated by another process. ; Reimplemented in TTreeSQL.; Definition at line 7916 of file TTree.cxx. ◆ RegisterExternalFriend(). void TTree::RegisterExternalFriend ; (; TFriendElement * ; fe). virtual . Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ; Definition at line 7957 ",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:207483,Usability,learn,learning,207483,"i);; TBranch::GetEntryvirtual Int_t GetEntry(Long64_t entry=0, Int_t getall=0)Read all leaves of entry and return total number of bytes read.Definition TBranch.cxx:1706; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: th",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:218842,Usability,learn,learning,218842,"trees in the TChain instead of the default behaviour using the weights of each tree in the chain (see TChain::SetWeight). ; Reimplemented in TChain.; Definition at line 9364 of file TTree.cxx. ◆ Show(). void TTree::Show ; (; Long64_t ; entry = -1, . Int_t ; lenmax = 20 . ). virtual . Print values of all active leaves for entry. . if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. . Definition at line 9375 of file TTree.cxx. ◆ SortBranchesByTime(). void TTree::SortBranchesByTime ; (; ). private . Sorts top-level branches by the last average task time recorded per branch. ; Definition at line 5834 of file TTree.cxx. ◆ StartViewer(). void TTree::StartViewer ; (; ). virtual . Start the TTreeViewer on this tree. . ww is the width of the canvas in pixels; wh is the height of the canvas in pixels . Definition at line 9449 of file TTree.cxx. ◆ StopCacheLearningPhase(). Int_t TTree::StopCacheLearningPhase ; (; ). virtual . Stop the cache learning phase. ; Returns:; 0 learning phase stopped or not active; -1 on error . Definition at line 9464 of file TTree.cxx. ◆ Streamer(). void TTree::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 9535 of file TTree.cxx. ◆ StreamerNVirtual(). void TTree::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 659 of file TTree.h. ◆ UnbinnedFit(). Int_t TTree::UnbinnedFit ; (; const char * ; funcname, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Unbinned fit of one or more variable(s) from a tree. ; funcname is a TF1 function.; See alsoTTree::Draw for explanations of the other parameters.; Fit the variable varexp using the function funcname using the selection cuts given by selection.; The list of fit options is given in parameter o",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTree.html:218872,Usability,learn,learning,218872,"our using the weights of each tree in the chain (see TChain::SetWeight). ; Reimplemented in TChain.; Definition at line 9364 of file TTree.cxx. ◆ Show(). void TTree::Show ; (; Long64_t ; entry = -1, . Int_t ; lenmax = 20 . ). virtual . Print values of all active leaves for entry. . if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. . Definition at line 9375 of file TTree.cxx. ◆ SortBranchesByTime(). void TTree::SortBranchesByTime ; (; ). private . Sorts top-level branches by the last average task time recorded per branch. ; Definition at line 5834 of file TTree.cxx. ◆ StartViewer(). void TTree::StartViewer ; (; ). virtual . Start the TTreeViewer on this tree. . ww is the width of the canvas in pixels; wh is the height of the canvas in pixels . Definition at line 9449 of file TTree.cxx. ◆ StopCacheLearningPhase(). Int_t TTree::StopCacheLearningPhase ; (; ). virtual . Stop the cache learning phase. ; Returns:; 0 learning phase stopped or not active; -1 on error . Definition at line 9464 of file TTree.cxx. ◆ Streamer(). void TTree::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 9535 of file TTree.cxx. ◆ StreamerNVirtual(). void TTree::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 659 of file TTree.h. ◆ UnbinnedFit(). Int_t TTree::UnbinnedFit ; (; const char * ; funcname, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Unbinned fit of one or more variable(s) from a tree. ; funcname is a TF1 function.; See alsoTTree::Draw for explanations of the other parameters.; Fit the variable varexp using the function funcname using the selection cuts given by selection.; The list of fit options is given in parameter option. option = ""Q"" Quiet mode (minimum printing",MatchSource.WIKI,doc/v632/classTTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTree.html
https://root.cern/doc/v632/classTTreeCache.html:1175,Availability,avail,available,1175,"; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; List of all members ; TTreeCache Class ReferenceTree Library. ; A cache to speed-up the reading of ROOT datasets. . A cache to speed-up the reading of ROOT datasets. Table of Contents. Motivation; General Description; Changes in behaviour; Self-optimization; Examples of usage; Check performance and stats. Motivation: why having a cache is needed?; When writing a TTree, the branch buffers are kept in memory. A typical branch buffersize (before compression) is typically 32 KBytes. After compression, the zipped buffer may be just a few Kbytes. The branch buffers cannot be much larger in case of TTrees with several hundred or thousand branches.; When writing, this does not generate a performance problem because branch buffers are always written sequentially and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache i",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:14503,Availability,error,error,14503,"  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:20401,Availability,error,error,20401,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:20490,Availability,error,error,20490,"ar *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns strin",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:20645,Availability,error,error,20645,";  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title o",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:20942,Availability,error,error,20942,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:25385,Availability,error,error,25385,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetLearnEntries ();  Static function returning the number of entries used to train the cache see SetLearnEntries. ;  ; static void SetL",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:35217,Availability,error,error,35217,"efault Constructor. ; Definition at line 313 of file TTreeCache.cxx. ◆ TTreeCache() [3/3]. TTreeCache::TTreeCache ; (; TTree * ; tree, . Int_t ; buffersize = 0 . ). Constructor. ; Definition at line 320 of file TTreeCache.cxx. ◆ ~TTreeCache(). TTreeCache::~TTreeCache ; (; ). override . Destructor. (in general called by the TFile destructor) ; Definition at line 332 of file TTreeCache.cxx. Member Function Documentation. ◆ AddBranch() [1/2]. Int_t TTreeCache::AddBranch ; (; const char * ; bname, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 446 of file TTreeCache.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCache::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ; The branch is added even if we are outside of the training phase. Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 376 of file TTreeCache.cxx. ◆ CalculateMissCache(). bool TTreeCache::CalculateMissCache ; (; ). private . Calculate the appropriate miss cache to fetch; helper function for FillMissCache. . ◆ CalculateMissEntries(). TBranch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:35712,Availability,error,error,35712,"al . Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 446 of file TTreeCache.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCache::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ; The branch is added even if we are outside of the training phase. Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 376 of file TTreeCache.cxx. ◆ CalculateMissCache(). bool TTreeCache::CalculateMissCache ; (; ). private . Calculate the appropriate miss cache to fetch; helper function for FillMissCache. . ◆ CalculateMissEntries(). TBranch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file read, try to determine the corresponding branch. ; Given a particular IO description (offset / length) representing a 'miss' of the TTreeCache's primary cache, calculate all the corresponding IO that should be performed.; all indicates that this function should search the set of all branches in this TTree. When set to false, we only search through branches that have previously incurred a miss.; Returns:; TBranch pointer corresponding to the basket that will be retrieved by this IO operation.; If no corresponding branch could be found (or ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:36692,Availability,error,error,36692," or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 376 of file TTreeCache.cxx. ◆ CalculateMissCache(). bool TTreeCache::CalculateMissCache ; (; ). private . Calculate the appropriate miss cache to fetch; helper function for FillMissCache. . ◆ CalculateMissEntries(). TBranch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file read, try to determine the corresponding branch. ; Given a particular IO description (offset / length) representing a 'miss' of the TTreeCache's primary cache, calculate all the corresponding IO that should be performed.; all indicates that this function should search the set of all branches in this TTree. When set to false, we only search through branches that have previously incurred a miss.; Returns:; TBranch pointer corresponding to the basket that will be retrieved by this IO operation.; If no corresponding branch could be found (or an error occurs), this returns nullptr. . Definition at line 790 of file TTreeCache.cxx. ◆ CheckMissCache(). bool TTreeCache::CheckMissCache ; (; char * ; buf, . Long64_t ; pos, . int ; len . ). private . Check the miss cache for a particular buffer, fetching if deemed necessary. ; Given an IO operation (pos, len) that was a cache miss in the primary TTC, try the operation again with the miss cache.; Returns true if the IO operation was successful and the contents of buf were populated with the requested data. ; Definition at line 921 of file TTreeCache.cxx. ◆ Class(). static TClass * TTreeCache::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCache::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCache::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 175 of file TTreeCache.h. ◆ DeclFileName(). static const char * TTreeCach",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:38589,Availability,error,error,38589,"Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 175 of file TTreeCache.h. ◆ DeclFileName(). static const char * TTreeCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 175 of file TTreeCache.h. ◆ Disable(). virtual void TTreeCache::Disable ; (; ). inlinevirtual . Definition at line 136 of file TTreeCache.h. ◆ DropBranch() [1/2]. Int_t TTreeCache::DropBranch ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:38924,Availability,error,error,38924,"inition at line 136 of file TTreeCache.h. ◆ DropBranch() [1/2]. Int_t TTreeCache::DropBranch ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b, . Long64_t ; entry . ). private . Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ; For the event currently being fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IOPos describing the IO operation necessary for the basket on this branch; On failure, I",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:39891,Availability,failure,failure,39891,"Branch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b, . Long64_t ; entry . ). private . Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ; For the event currently being fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IOPos describing the IO operation necessary for the basket on this branch; On failure, IOPos.length will be set to 0. . Definition at line 716 of file TTreeCache.cxx. ◆ GetCachedBranches(). const TObjArray * TTreeCache::GetCachedBranches ; (; ); const. inline . Definition at line 139 of file TTreeCache.h. ◆ GetConfiguredPrefillType(). TTreeCache::EPrefillType TTreeCache::GetConfiguredPrefillType ; (; ); const. Return the desired prefill type from the environment or resource variable. . 0 - No prefill; 1 - All branches . Definition at line 1802 of file TTreeCache.cxx. ◆ GetEfficiency(). Double_t TTreeCache::GetEfficiency ; (; ); const. Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ; the number of blocks prefetched ( it could be more than 1 if we read the same block from the cache more than once ); Note: This should eb used at the end of the processing or we will get incomplete stats ; Definition at line 1825 of file TTreeCache.cxx. ◆ GetEfficiencyRel(). Double_t TTreeCa",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:43373,Availability,error,error,43373,"at line 138 of file TTreeCache.h. ◆ GetTree(). TTree * TTreeCache::GetTree ; (; ); const. inline . Definition at line 149 of file TTreeCache.h. ◆ IsA(). TClass * TTreeCache::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 175 of file TTreeCache.h. ◆ IsAutoCreated(). bool TTreeCache::IsAutoCreated ; (; ); const. inline . Definition at line 150 of file TTreeCache.h. ◆ IsEnabled(). virtual bool TTreeCache::IsEnabled ; (; ); const. inlinevirtual . Definition at line 151 of file TTreeCache.h. ◆ IsLearning(). bool TTreeCache::IsLearning ; (; ); const. inlineoverridevirtual . Reimplemented from TFileCacheRead.; Definition at line 152 of file TTreeCache.h. ◆ LearnBranch(). Int_t TTreeCache::LearnBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ; Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2250 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Read",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:43434,Availability,error,error,43434,"TTreeCache.h. ◆ IsA(). TClass * TTreeCache::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 175 of file TTreeCache.h. ◆ IsAutoCreated(). bool TTreeCache::IsAutoCreated ; (; ); const. inline . Definition at line 150 of file TTreeCache.h. ◆ IsEnabled(). virtual bool TTreeCache::IsEnabled ; (; ); const. inlinevirtual . Definition at line 151 of file TTreeCache.h. ◆ IsLearning(). bool TTreeCache::IsLearning ; (; ); const. inlineoverridevirtual . Reimplemented from TFileCacheRead.; Definition at line 152 of file TTreeCache.h. ◆ LearnBranch(). Int_t TTreeCache::LearnBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ; Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2250 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:46768,Availability,failure,failure,46768," Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:48468,Availability,avail,available,48468,"ven if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to b",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:48551,Availability,error,error,48551,"ven if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to b",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:50358,Energy Efficiency,allocate,allocated,50358,"eeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2169 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TO",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:5875,Integrability,interface,interfaces,5875,"ample scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:20407,Integrability,message,message,20407,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:20948,Integrability,message,message,20948,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:22150,Integrability,message,message,22150,"ived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this metho",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:25391,Integrability,message,message,25391,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetLearnEntries ();  Static function returning the number of entries used to train the cache see SetLearnEntries. ;  ; static void SetL",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:25764,Integrability,message,message,25764," Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetLearnEntries ();  Static function returning the number of entries used to train the cache see SetLearnEntries. ;  ; static void SetLearnEntries (Int_t n=10);  Static function to set the number of entries to be used in learning mode The default value for n is 10. ;  ;  Static Public Member Functions inherited from TFileCacheRead; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:3139,Modifiability,variab,variable,3139,"ple, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCach",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:11303,Modifiability,inherit,inherited,11303,"These branches will be put in the cache; // if they have been used in the first 10 entries; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... Here the entry is processed; }. How can the usage and performance of TTreeCache be verified?; Once the event loop terminated, the number of effective system reads for a given file can be checked with a code like the following: printf(""Reading %lld bytes in %d transactions\n"",myTFilePtr->GetBytesRead(), f->GetReadCalls());; Another handy command is: myTreeOrChain.GetTree()->PrintCacheStats();. Definition at line 32 of file TTreeCache.h. Classes; struct  IOPos;  ; struct  MissCache;  . Public Types; enum  EPrefillType { kNoPrefill; , kAllBranches; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:13260,Modifiability,variab,variable,13260,"anch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; Int_t AddBranch (TBranch *b, bool subgbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:16581,Modifiability,inherit,inherited,16581,"timize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches used by the underlying implementation. ;  ; virtual Int_t GetBufferSize () const;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; TFile * GetFile () const;  ; virtual Long64_t GetNoCacheBytesRead () const;  ; virtual Int_t GetNoCacheReadCalls () const;  ; Int_t GetNseek () const;  ; Int_t GetNtot () const;  ; Long64_t GetPrefetchedBlocks () const;  ; virtual TFilePrefetch * GetPrefetchObj ();  ; virtual Int_t GetReadCalls () const;  ; virtual Int_t GetUnzipBuffer (char **, Long64_t, Int_t, Bool_t *);  ; virtual Bool_t IsAsyncReading",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:18640,Modifiability,inherit,inherited,18640,"g () const;  ; virtual Bool_t IsEnablePrefetching () const;  ; virtual void Prefetch (Long64_t pos, Int_t len);  Add block of length len at position pos in the list of blocks to be prefetched. ;  ; virtual Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc);  ; virtual Int_t ReadBufferExtNormal (char *buf, Long64_t pos, Int_t len, Int_t &loc);  Base function for ReadBuffer. ;  ; virtual Int_t ReadBufferExtPrefetch (char *buf, Long64_t pos, Int_t len, Int_t &loc);  prefetch the first block ;  ; virtual void SecondPrefetch (Long64_t, Int_t);  ; virtual void SecondSort ();  Sort buffers to be prefetched in increasing order of positions. ;  ; virtual void SetEnablePrefetching (Bool_t setPrefetching=kFALSE);  Set the prefetching mode of this file. ;  ; virtual void SetSkipZip (Bool_t=kTRUE);  ; virtual void Sort ();  Sort buffers to be prefetched in increasing order of positions. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void WaitFinishPrefetch ();  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (co",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:20037,Modifiability,inherit,inheritance,20037,"pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in de",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:22248,Modifiability,inherit,inherits,22248,"ed by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:22365,Modifiability,inherit,inherits,22365,"ame of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its p",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:26549,Modifiability,inherit,inherited,26549,"ning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetLearnEntries ();  Static function returning the number of entries used to train the cache see SetLearnEntries. ;  ; static void SetLearnEntries (Int_t n=10);  Static function to set the number of entries to be used in learning mode The default value for n is 10. ;  ;  Static Public Member Functions inherited from TFileCacheRead; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:26767,Modifiability,inherit,inherited,26767,"ning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetLearnEntries ();  Static function returning the number of entries used to train the cache see SetLearnEntries. ;  ; static void SetLearnEntries (Int_t n=10);  Static function to set the number of entries to be used in learning mode The default value for n is 10. ;  ;  Static Public Member Functions inherited from TFileCacheRead; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:29826,Modifiability,inherit,inherited,29826,"imary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocated size of fBuffer (at a given time) ;  ; Int_t fBufferSizeMin;  Original size of fBuffer. ;  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ; ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:33144,Modifiability,inherit,inherited,33144,"delete;  this class cannot be copied ;  ; bool CalculateMissCache ();  Calculate the appropriate miss cache to fetch; helper function for FillMissCache. ;  ; TBranch * CalculateMissEntries (Long64_t, int, bool);  Given an file read, try to determine the corresponding branch. ;  ; bool CheckMissCache (char *buf, Long64_t pos, int len);  Check the miss cache for a particular buffer, fetching if deemed necessary. ;  ; bool FillMissCache ();  Fill the miss cache from the current set of active branches. ;  ; IOPos FindBranchBasketPos (TBranch &, Long64_t entry);  Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ;  ; TTreeCache & operator= (const TTreeCache &)=delete;  ; bool ProcessMiss (Long64_t pos, int len);  ! Given a file read not in the miss cache, handle (possibly) loading the data. ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TFileCacheRead; void SetEnablePrefetchingImpl (Bool_t setPrefetching=kFALSE);  TFileCacheRead implementation of SetEnablePrefetching. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TTreeCache.h>. Inheritance diagram for TTreeCache:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EPrefillType. enum TTreeCache::EPrefillType. EnumeratorkNoPrefill ; kAllBranches . Definition at line 35 of file TTreeCache.h. Constructor & Destructor Documentation. ◆ TTreeCache() [1/3]. TTreeCache::TTreeCache ; (; const TTreeCache & ; ). privatedelete . this class cannot be copied . ◆ TTreeCache() [2/3]. TTreeCache::TTreeCache ; (; ). Default Constructor. ; Definition at line 313 of file TTreeCache.cxx. ◆ TTreeCache() [3/3]. TTreeCache",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:33243,Modifiability,inherit,inherited,33243,"delete;  this class cannot be copied ;  ; bool CalculateMissCache ();  Calculate the appropriate miss cache to fetch; helper function for FillMissCache. ;  ; TBranch * CalculateMissEntries (Long64_t, int, bool);  Given an file read, try to determine the corresponding branch. ;  ; bool CheckMissCache (char *buf, Long64_t pos, int len);  Check the miss cache for a particular buffer, fetching if deemed necessary. ;  ; bool FillMissCache ();  Fill the miss cache from the current set of active branches. ;  ; IOPos FindBranchBasketPos (TBranch &, Long64_t entry);  Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ;  ; TTreeCache & operator= (const TTreeCache &)=delete;  ; bool ProcessMiss (Long64_t pos, int len);  ! Given a file read not in the miss cache, handle (possibly) loading the data. ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TFileCacheRead; void SetEnablePrefetchingImpl (Bool_t setPrefetching=kFALSE);  TFileCacheRead implementation of SetEnablePrefetching. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TTreeCache.h>. Inheritance diagram for TTreeCache:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EPrefillType. enum TTreeCache::EPrefillType. EnumeratorkNoPrefill ; kAllBranches . Definition at line 35 of file TTreeCache.h. Constructor & Destructor Documentation. ◆ TTreeCache() [1/3]. TTreeCache::TTreeCache ; (; const TTreeCache & ; ). privatedelete . this class cannot be copied . ◆ TTreeCache() [2/3]. TTreeCache::TTreeCache ; (; ). Default Constructor. ; Definition at line 313 of file TTreeCache.cxx. ◆ TTreeCache() [3/3]. TTreeCache",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:33425,Modifiability,inherit,inherited,33425,"termine the corresponding branch. ;  ; bool CheckMissCache (char *buf, Long64_t pos, int len);  Check the miss cache for a particular buffer, fetching if deemed necessary. ;  ; bool FillMissCache ();  Fill the miss cache from the current set of active branches. ;  ; IOPos FindBranchBasketPos (TBranch &, Long64_t entry);  Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ;  ; TTreeCache & operator= (const TTreeCache &)=delete;  ; bool ProcessMiss (Long64_t pos, int len);  ! Given a file read not in the miss cache, handle (possibly) loading the data. ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TFileCacheRead; void SetEnablePrefetchingImpl (Bool_t setPrefetching=kFALSE);  TFileCacheRead implementation of SetEnablePrefetching. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TTreeCache.h>. Inheritance diagram for TTreeCache:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EPrefillType. enum TTreeCache::EPrefillType. EnumeratorkNoPrefill ; kAllBranches . Definition at line 35 of file TTreeCache.h. Constructor & Destructor Documentation. ◆ TTreeCache() [1/3]. TTreeCache::TTreeCache ; (; const TTreeCache & ; ). privatedelete . this class cannot be copied . ◆ TTreeCache() [2/3]. TTreeCache::TTreeCache ; (; ). Default Constructor. ; Definition at line 313 of file TTreeCache.cxx. ◆ TTreeCache() [3/3]. TTreeCache::TTreeCache ; (; TTree * ; tree, . Int_t ; buffersize = 0 . ). Constructor. ; Definition at line 320 of file TTreeCache.cxx. ◆ ~TTreeCache(). TTreeCache::~TTreeCache ; (; ). override . Destructor. (in general called by the TFile destructor)",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:40292,Modifiability,variab,variable,40292," 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b, . Long64_t ; entry . ). private . Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ; For the event currently being fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IOPos describing the IO operation necessary for the basket on this branch; On failure, IOPos.length will be set to 0. . Definition at line 716 of file TTreeCache.cxx. ◆ GetCachedBranches(). const TObjArray * TTreeCache::GetCachedBranches ; (; ); const. inline . Definition at line 139 of file TTreeCache.h. ◆ GetConfiguredPrefillType(). TTreeCache::EPrefillType TTreeCache::GetConfiguredPrefillType ; (; ); const. Return the desired prefill type from the environment or resource variable. . 0 - No prefill; 1 - All branches . Definition at line 1802 of file TTreeCache.cxx. ◆ GetEfficiency(). Double_t TTreeCache::GetEfficiency ; (; ); const. Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ; the number of blocks prefetched ( it could be more than 1 if we read the same block from the cache more than once ); Note: This should eb used at the end of the processing or we will get incomplete stats ; Definition at line 1825 of file TTreeCache.cxx. ◆ GetEfficiencyRel(). Double_t TTreeCache::GetEfficiencyRel ; (; ); const. This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ; Definition at line 1849 of file TTreeCache.cxx. ◆ GetEntryMax(). virtual Int_t TTreeCache::GetEntryMax ; (; ); const. inlinevirtual . Definition at line 144 of file TTreeCache.h. ◆ GetEntryMin(). virtual Int_t TTreeCache::GetEntryMin ; (; ); const.",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:50029,Modifiability,variab,variable,50029,"File(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2169 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to Fi",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:376,Performance,cache,cache,376,". ROOT: TTreeCache Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; List of all members ; TTreeCache Class ReferenceTree Library. ; A cache to speed-up the reading of ROOT datasets. . A cache to speed-up the reading of ROOT datasets. Table of Contents. Motivation; General Description; Changes in behaviour; Self-optimization; Examples of usage; Check performance and stats. Motivation: why having a cache is needed?; When writing a TTree, the branch buffers are kept in memory. A typical branch buffersize (before compression) is typically 32 KBytes. After compression, the zipped buffer may be just a few Kbytes. The branch buffers cannot be much larger in case of TTrees with several hundred or thousand branches.; When writing, this does not generate a performance problem because branch buffers are always written sequentially and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:428,Performance,cache,cache,428,". ROOT: TTreeCache Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; List of all members ; TTreeCache Class ReferenceTree Library. ; A cache to speed-up the reading of ROOT datasets. . A cache to speed-up the reading of ROOT datasets. Table of Contents. Motivation; General Description; Changes in behaviour; Self-optimization; Examples of usage; Check performance and stats. Motivation: why having a cache is needed?; When writing a TTree, the branch buffers are kept in memory. A typical branch buffersize (before compression) is typically 32 KBytes. After compression, the zipped buffer may be just a few Kbytes. The branch buffers cannot be much larger in case of TTrees with several hundred or thousand branches.; When writing, this does not generate a performance problem because branch buffers are always written sequentially and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:555,Performance,optimiz,optimization,555,". ROOT: TTreeCache Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; List of all members ; TTreeCache Class ReferenceTree Library. ; A cache to speed-up the reading of ROOT datasets. . A cache to speed-up the reading of ROOT datasets. Table of Contents. Motivation; General Description; Changes in behaviour; Self-optimization; Examples of usage; Check performance and stats. Motivation: why having a cache is needed?; When writing a TTree, the branch buffers are kept in memory. A typical branch buffersize (before compression) is typically 32 KBytes. After compression, the zipped buffer may be just a few Kbytes. The branch buffers cannot be much larger in case of TTrees with several hundred or thousand branches.; When writing, this does not generate a performance problem because branch buffers are always written sequentially and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:594,Performance,perform,performance,594,". ROOT: TTreeCache Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; List of all members ; TTreeCache Class ReferenceTree Library. ; A cache to speed-up the reading of ROOT datasets. . A cache to speed-up the reading of ROOT datasets. Table of Contents. Motivation; General Description; Changes in behaviour; Self-optimization; Examples of usage; Check performance and stats. Motivation: why having a cache is needed?; When writing a TTree, the branch buffers are kept in memory. A typical branch buffersize (before compression) is typically 32 KBytes. After compression, the zipped buffer may be just a few Kbytes. The branch buffers cannot be much larger in case of TTrees with several hundred or thousand branches.; When writing, this does not generate a performance problem because branch buffers are always written sequentially and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:642,Performance,cache,cache,642,". ROOT: TTreeCache Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; List of all members ; TTreeCache Class ReferenceTree Library. ; A cache to speed-up the reading of ROOT datasets. . A cache to speed-up the reading of ROOT datasets. Table of Contents. Motivation; General Description; Changes in behaviour; Self-optimization; Examples of usage; Check performance and stats. Motivation: why having a cache is needed?; When writing a TTree, the branch buffers are kept in memory. A typical branch buffersize (before compression) is typically 32 KBytes. After compression, the zipped buffer may be just a few Kbytes. The branch buffers cannot be much larger in case of TTrees with several hundred or thousand branches.; When writing, this does not generate a performance problem because branch buffers are always written sequentially and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:999,Performance,perform,performance,999,"; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; List of all members ; TTreeCache Class ReferenceTree Library. ; A cache to speed-up the reading of ROOT datasets. . A cache to speed-up the reading of ROOT datasets. Table of Contents. Motivation; General Description; Changes in behaviour; Self-optimization; Examples of usage; Check performance and stats. Motivation: why having a cache is needed?; When writing a TTree, the branch buffers are kept in memory. A typical branch buffersize (before compression) is typically 32 KBytes. After compression, the zipped buffer may be just a few Kbytes. The branch buffers cannot be much larger in case of TTrees with several hundred or thousand branches.; When writing, this does not generate a performance problem because branch buffers are always written sequentially and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache i",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:1231,Performance,perform,performance,1231,"tected Attributes |; Static Protected Attributes |; Private Member Functions |; List of all members ; TTreeCache Class ReferenceTree Library. ; A cache to speed-up the reading of ROOT datasets. . A cache to speed-up the reading of ROOT datasets. Table of Contents. Motivation; General Description; Changes in behaviour; Self-optimization; Examples of usage; Check performance and stats. Motivation: why having a cache is needed?; When writing a TTree, the branch buffers are kept in memory. A typical branch buffersize (before compression) is typically 32 KBytes. After compression, the zipped buffer may be just a few Kbytes. The branch buffers cannot be much larger in case of TTrees with several hundred or thousand branches.; When writing, this does not generate a performance problem because branch buffers are always written sequentially and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are re",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:1328,Performance,latency,latency,1328,"speed-up the reading of ROOT datasets. . A cache to speed-up the reading of ROOT datasets. Table of Contents. Motivation; General Description; Changes in behaviour; Self-optimization; Examples of usage; Check performance and stats. Motivation: why having a cache is needed?; When writing a TTree, the branch buffers are kept in memory. A typical branch buffersize (before compression) is typically 32 KBytes. After compression, the zipped buffer may be just a few Kbytes. The branch buffers cannot be much larger in case of TTrees with several hundred or thousand branches.; When writing, this does not generate a performance problem because branch buffers are always written sequentially and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:1384,Performance,cache,cache,1384,"speed-up the reading of ROOT datasets. . A cache to speed-up the reading of ROOT datasets. Table of Contents. Motivation; General Description; Changes in behaviour; Self-optimization; Examples of usage; Check performance and stats. Motivation: why having a cache is needed?; When writing a TTree, the branch buffers are kept in memory. A typical branch buffersize (before compression) is typically 32 KBytes. After compression, the zipped buffer may be just a few Kbytes. The branch buffers cannot be much larger in case of TTrees with several hundred or thousand branches.; When writing, this does not generate a performance problem because branch buffers are always written sequentially and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:1948,Performance,cache,cache,1948,"er in case of TTrees with several hundred or thousand branches.; When writing, this does not generate a performance problem because branch buffers are always written sequentially and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is a",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:2090,Performance,perform,performance,2090," and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:2281,Performance,cache,cache,2281,"each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TE",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:2672,Performance,perform,performance,2672,"cks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache.",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:2798,Performance,latency,latency,2798,"or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCache",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:3006,Performance,cache,cache,3006,"ere cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:3230,Performance,cache,cache,3230,"cription; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is fr",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:3420,Performance,cache,cache,3420," via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-op",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:3526,Performance,cache,cache,3526,"learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:3690,Performance,cache,cache,3690,"ache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache mis",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:3777,Performance,cache,cache,3777,"cular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observati",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:3842,Performance,cache,cache,3842,"TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior i",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:4309,Performance,cache,cached,4309,"in and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct ba",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:4358,Performance,optimiz,optimization,4358,"ehaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., th",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:4386,Performance,cache,cache,4386,"ehaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., th",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:4419,Performance,optimiz,optimize,4419,"ehaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., th",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:4446,Performance,cache,cache,4446,"ehaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., th",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:4468,Performance,optimiz,optimization,4468," kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases ar",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:4600,Performance,cache,cache,4600," kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases ar",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:4621,Performance,cache,cache,4621,"erenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:4705,Performance,optimiz,optimization,4705,"automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these ca",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:5037,Performance,optimiz,optimizing,5037,"nd prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during th",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:5052,Performance,cache,cache,5052,"nd prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during th",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:5121,Performance,cache,cache,5121,"nd prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during th",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:5179,Performance,cache,cache,5179,"nd prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during th",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:5299,Performance,cache,cache,5299,"efault to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and T",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:5407,Performance,latency,latency,5407,"he can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the u",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:5446,Performance,cache,cache,5446,"ss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:5555,Performance,cache,cache,5555,"a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache.",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:6351,Performance,cache,cache,6351,"sket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSh",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:6593,Performance,cache,cache,6593,"d below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branc",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:6713,Performance,cache,cache,6713," is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=20",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:6757,Performance,cache,cache,6757," is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=20",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:7017,Performance,cache,cachesize,7017,"atically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Pr",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:7070,Performance,cache,cachesize,7070,"atically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Pr",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:7151,Performance,cache,cache,7151,"atically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Pr",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:7611,Performance,cache,cache,7611,"ecify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Process we read only 2 branches; auto b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; auto b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... Here the entry is processed; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2144; ; Custom event loop; Always using the same two branches; In this example, exactly two branches are always used: those need to be prefetched. TTree *T;; f->GetObject(T, ""mytree"");; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; //10 MByte",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:7782,Performance,cache,cachesize,7782,"ecify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Process we read only 2 branches; auto b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; auto b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... Here the entry is processed; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2144; ; Custom event loop; Always using the same two branches; In this example, exactly two branches are always used: those need to be prefetched. TTree *T;; f->GetObject(T, ""mytree"");; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; //10 MByte",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:7913,Performance,cache,cachesize,7913,"ecify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Process we read only 2 branches; auto b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; auto b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... Here the entry is processed; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2144; ; Custom event loop; Always using the same two branches; In this example, exactly two branches are always used: those need to be prefetched. TTree *T;; f->GetObject(T, ""mytree"");; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; //10 MByte",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:8741,Performance,cache,cachesize,8741,"etCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Process we read only 2 branches; auto b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; auto b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... Here the entry is processed; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2144; ; Custom event loop; Always using the same two branches; In this example, exactly two branches are always used: those need to be prefetched. TTree *T;; f->GetObject(T, ""mytree"");; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1, true); //<<< add branch1 and branch2 to the cache; T->AddBranchToCache(b2, true); //<<<; T->StopCacheLearningPhase(); //<<< we do not need the system to guess anything; for (auto i : TSeqL(nentries)) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; ... Here the entry is processed; }; Always using at least the same two branches; In this example, two branches are always used: in addition, some analysis functions are invoked and those may trigger the reading of other branches which are a priori not known. There is no point in prefetching branches that will be used very rarely: we can rely on the system to cache the right branches. TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000; //10 MBytes; T->",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:8793,Performance,cache,cachesize,8793,"etCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Process we read only 2 branches; auto b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; auto b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... Here the entry is processed; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2144; ; Custom event loop; Always using the same two branches; In this example, exactly two branches are always used: those need to be prefetched. TTree *T;; f->GetObject(T, ""mytree"");; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1, true); //<<< add branch1 and branch2 to the cache; T->AddBranchToCache(b2, true); //<<<; T->StopCacheLearningPhase(); //<<< we do not need the system to guess anything; for (auto i : TSeqL(nentries)) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; ... Here the entry is processed; }; Always using at least the same two branches; In this example, two branches are always used: in addition, some analysis functions are invoked and those may trigger the reading of other branches which are a priori not known. There is no point in prefetching branches that will be used very rarely: we can rely on the system to cache the right branches. TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000; //10 MBytes; T->",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:8880,Performance,cache,cache,8880,"etCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Process we read only 2 branches; auto b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; auto b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... Here the entry is processed; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2144; ; Custom event loop; Always using the same two branches; In this example, exactly two branches are always used: those need to be prefetched. TTree *T;; f->GetObject(T, ""mytree"");; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1, true); //<<< add branch1 and branch2 to the cache; T->AddBranchToCache(b2, true); //<<<; T->StopCacheLearningPhase(); //<<< we do not need the system to guess anything; for (auto i : TSeqL(nentries)) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; ... Here the entry is processed; }; Always using at least the same two branches; In this example, two branches are always used: in addition, some analysis functions are invoked and those may trigger the reading of other branches which are a priori not known. There is no point in prefetching branches that will be used very rarely: we can rely on the system to cache the right branches. TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000; //10 MBytes; T->",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:9795,Performance,cache,cache,9795,"00000U; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1, true); //<<< add branch1 and branch2 to the cache; T->AddBranchToCache(b2, true); //<<<; T->StopCacheLearningPhase(); //<<< we do not need the system to guess anything; for (auto i : TSeqL(nentries)) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; ... Here the entry is processed; }; Always using at least the same two branches; In this example, two branches are always used: in addition, some analysis functions are invoked and those may trigger the reading of other branches which are a priori not known. There is no point in prefetching branches that will be used very rarely: we can rely on the system to cache the right branches. TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; for (auto i : TSeqL(nentries)) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; // At this point we may call a user function where a few more branches; // will be read conditionally. These branches will be put in the cache; // if they have been used in the first 10 entries; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... Here the entry is process",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:9899,Performance,cache,cachesize,9899,"alling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; ... Here the entry is processed; }; Always using at least the same two branches; In this example, two branches are always used: in addition, some analysis functions are invoked and those may trigger the reading of other branches which are a priori not known. There is no point in prefetching branches that will be used very rarely: we can rely on the system to cache the right branches. TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; for (auto i : TSeqL(nentries)) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; // At this point we may call a user function where a few more branches; // will be read conditionally. These branches will be put in the cache; // if they have been used in the first 10 entries; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... Here the entry is processed; }. How can the usage and performance of TTreeCache be verified?; Once the event loop terminated, the number of effective system reads for a given file can be checked with a code like the following: printf(""Reading %lld bytes in %d transactions\n"",myTFilePtr->GetBytesRead(), f->GetReadCalls());; Another handy command is: m",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:9950,Performance,cache,cachesize,9950,"alling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; ... Here the entry is processed; }; Always using at least the same two branches; In this example, two branches are always used: in addition, some analysis functions are invoked and those may trigger the reading of other branches which are a priori not known. There is no point in prefetching branches that will be used very rarely: we can rely on the system to cache the right branches. TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; for (auto i : TSeqL(nentries)) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; // At this point we may call a user function where a few more branches; // will be read conditionally. These branches will be put in the cache; // if they have been used in the first 10 entries; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... Here the entry is processed; }. How can the usage and performance of TTreeCache be verified?; Once the event loop terminated, the number of effective system reads for a given file can be checked with a code like the following: printf(""Reading %lld bytes in %d transactions\n"",myTFilePtr->GetBytesRead(), f->GetReadCalls());; Another handy command is: m",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:10380,Performance,cache,cache,10380,"Here the entry is processed; }; Always using at least the same two branches; In this example, two branches are always used: in addition, some analysis functions are invoked and those may trigger the reading of other branches which are a priori not known. There is no point in prefetching branches that will be used very rarely: we can rely on the system to cache the right branches. TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; for (auto i : TSeqL(nentries)) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; // At this point we may call a user function where a few more branches; // will be read conditionally. These branches will be put in the cache; // if they have been used in the first 10 entries; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... Here the entry is processed; }. How can the usage and performance of TTreeCache be verified?; Once the event loop terminated, the number of effective system reads for a given file can be checked with a code like the following: printf(""Reading %lld bytes in %d transactions\n"",myTFilePtr->GetBytesRead(), f->GetReadCalls());; Another handy command is: myTreeOrChain.GetTree()->PrintCacheStats();. Definition at line 32 of file TTreeCache.h. Classes; struct  IOPos;  ; struct  MissCache;  . Public Types; enum  EPrefillType { kNoPrefill; , kAllBranches; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x0800",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:10785,Performance,perform,performance,10785,"tes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; for (auto i : TSeqL(nentries)) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; // At this point we may call a user function where a few more branches; // will be read conditionally. These branches will be put in the cache; // if they have been used in the first 10 entries; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... Here the entry is processed; }. How can the usage and performance of TTreeCache be verified?; Once the event loop terminated, the number of effective system reads for a given file can be checked with a code like the following: printf(""Reading %lld bytes in %d transactions\n"",myTFilePtr->GetBytesRead(), f->GetReadCalls());; Another handy command is: myTreeOrChain.GetTree()->PrintCacheStats();. Definition at line 32 of file TTreeCache.h. Classes; struct  IOPos;  ; struct  MissCache;  . Public Types; enum  EPrefillType { kNoPrefill; , kAllBranches; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Pu",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:12278,Performance,cache,cache,12278," Types; enum  EPrefillType { kNoPrefill; , kAllBranches; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; Int_t AddBranch (TBranch *b, bool subgbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:12482,Performance,cache,cache,12482,"itMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; Int_t AddBranch (TBranch *b, bool subgbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:12718,Performance,cache,cache,12718,"ts { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; Int_t AddBranch (TBranch *b, bool subgbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPre",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:12924,Performance,cache,cache,12924," kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; Int_t AddBranch (TBranch *b, bool subgbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:13047,Performance,cache,cache,13047,"size=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; Int_t AddBranch (TBranch *b, bool subgbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far.",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:13085,Performance,cache,cache,13085,"size=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; Int_t AddBranch (TBranch *b, bool subgbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far.",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:13350,Performance,cache,cache,13350,"thats why we pass the name of the branch). ;  ; Int_t AddBranch (TBranch *b, bool subgbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:13403,Performance,cache,cache,13403,"*b, bool subgbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be st",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:13541,Performance,cache,cache,13541,"nchToCache. ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill (",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:13783,Performance,cache,cache,13783,"is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache stat",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:13836,Performance,cache,cache,13836,"is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache stat",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:13961,Performance,cache,cache,13961,"TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long6",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:13998,Performance,cache,cache,13998,"TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long6",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:14397,Performance,cache,cache,14397,"  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:14719,Performance,cache,cache,14719,"l () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFi",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:15241,Performance,cache,cache,15241,"IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of St",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:15297,Performance,cache,cache,15297,"ol subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ;",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:15444,Performance,cache,cache,15444,"e stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:15599,Performance,optimiz,optimize,15599,"al prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Publi",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:15795,Performance,cache,cached,15795,"  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Create",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:15938,Performance,cache,cache,15938,"from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void A",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:16053,Performance,cache,cache,16053,"n of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches us",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:16544,Performance,cache,cache,16544,";  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches used by the underlying implementation. ;  ; virtual Int_t GetBufferSize () const;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; TFile * GetFile () const;  ; virtual Long64_t GetNoCacheBytesRead () const;  ; virtual Int_t GetNoCacheReadCalls () const;  ; Int_t GetNseek () const;  ; Int_t GetNtot () const;  ; Long64_t GetPrefetchedBlocks () const;  ; virtual TFilePrefetch * GetPrefetc",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:26333,Performance,cache,cache,26333,"et the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetLearnEntries ();  Static function returning the number of entries used to train the cache see SetLearnEntries. ;  ; static void SetLearnEntries (Int_t n=10);  Static function to set the number of entries to be used in learning mode The default value for n is 10. ;  ;  Static Public Member Functions inherited from TFileCacheRead; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:27313,Performance,cache,cache,27313,ublic Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of bran,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:27423,Performance,cache,cache,27423,ublic Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of bran,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:27493,Performance,cache,cache,27493,ublic Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of bran,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:27638,Performance,cache,cache,27638,ublic Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of bran,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:27656,Performance,cache,cached,27656,ublic Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of bran,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:27743,Performance,cache,cache,27743,ublic Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of bran,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:27799,Performance,cache,cache,27799,ublic Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of bran,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:27856,Performance,cache,cache,27856,ublic Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of bran,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:27920,Performance,cache,cache,27920,ublic Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of bran,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:28358,Performance,cache,cache,28358,"  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:28424,Performance,cache,cache,28424,"  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:28756,Performance,cache,cache,28756,"he cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:28946,Performance,cache,cache,28946,"he cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:29031,Performance,cache,cache,29031,"uffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Lon",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:29065,Performance,cache,cache,29065,"uffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Lon",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:29154,Performance,cache,cache,29154,"tEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:29232,Performance,cache,cache,29232,"set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:29304,Performance,cache,cache,29304,"the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:29492,Performance,optimiz,optimize,29492,"Phase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocat",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:29501,Performance,cache,cache,29501,"Phase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocat",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:30594,Performance,cache,cache,30594,g is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocated size of fBuffer (at a given time) ;  ; Int_t fBufferSizeMin;  Original size of fBuffer. ;  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ;  ; Long64_t fNoCacheBytesRead;  Number of bytes read by basket to fill cached tree. ;  ; Int_t fNoCacheReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache.,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:31096,Performance,cache,cached,31096,eek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocated size of fBuffer (at a given time) ;  ; Int_t fBufferSizeMin;  Original size of fBuffer. ;  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ;  ; Long64_t fNoCacheBytesRead;  Number of bytes read by basket to fill cached tree. ;  ; Int_t fNoCacheReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorte,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:31179,Performance,cache,cached,31179,t_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocated size of fBuffer (at a given time) ;  ; Int_t fBufferSizeMin;  Original size of fBuffer. ;  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ;  ; Long64_t fNoCacheBytesRead;  Number of bytes read by basket to fill cached tree. ;  ; Int_t fNoCacheReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static Int_t fgLearnEntries = 100;  number of en,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:31562,Performance,cache,cache,31562,";  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ;  ; Long64_t fNoCacheBytesRead;  Number of bytes read by basket to fill cached tree. ;  ; Int_t fNoCacheReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCache (const TTreeCache &)=delete;  this class cannot be copied ;  ; bool CalculateMissCache ();  Calculate the appropriate miss cache to fetch; helper function for FillMissCache. ;  ; TBranch * CalculateMissEntries (Long64_t, int, bool);  Given an file read, try to determine the corresponding branch. ;  ; bool CheckMiss",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:32345,Performance,cache,cache,32345,"d blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCache (const TTreeCache &)=delete;  this class cannot be copied ;  ; bool CalculateMissCache ();  Calculate the appropriate miss cache to fetch; helper function for FillMissCache. ;  ; TBranch * CalculateMissEntries (Long64_t, int, bool);  Given an file read, try to determine the corresponding branch. ;  ; bool CheckMissCache (char *buf, Long64_t pos, int len);  Check the miss cache for a particular buffer, fetching if deemed necessary. ;  ; bool FillMissCache ();  Fill the miss cache from the current set of active branches. ;  ; IOPos FindBranchBasketPos (TBranch &, Long64_t entry);  Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ;  ; TTreeCache & operator= (const TTreeCache &)=delete;  ; bool ProcessMiss (Long64_t pos, int len);  ! Given a file read not in the miss cache, handle (possibly) loading the data. ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TFileCacheRead; void SetEnableP",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:32596,Performance,cache,cache,32596,"eek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCache (const TTreeCache &)=delete;  this class cannot be copied ;  ; bool CalculateMissCache ();  Calculate the appropriate miss cache to fetch; helper function for FillMissCache. ;  ; TBranch * CalculateMissEntries (Long64_t, int, bool);  Given an file read, try to determine the corresponding branch. ;  ; bool CheckMissCache (char *buf, Long64_t pos, int len);  Check the miss cache for a particular buffer, fetching if deemed necessary. ;  ; bool FillMissCache ();  Fill the miss cache from the current set of active branches. ;  ; IOPos FindBranchBasketPos (TBranch &, Long64_t entry);  Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ;  ; TTreeCache & operator= (const TTreeCache &)=delete;  ; bool ProcessMiss (Long64_t pos, int len);  ! Given a file read not in the miss cache, handle (possibly) loading the data. ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TFileCacheRead; void SetEnablePrefetchingImpl (Bool_t setPrefetching=kFALSE);  TFileCacheRead implementation of SetEnablePrefetching. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; vo",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:32700,Performance,cache,cache,32700,"of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCache (const TTreeCache &)=delete;  this class cannot be copied ;  ; bool CalculateMissCache ();  Calculate the appropriate miss cache to fetch; helper function for FillMissCache. ;  ; TBranch * CalculateMissEntries (Long64_t, int, bool);  Given an file read, try to determine the corresponding branch. ;  ; bool CheckMissCache (char *buf, Long64_t pos, int len);  Check the miss cache for a particular buffer, fetching if deemed necessary. ;  ; bool FillMissCache ();  Fill the miss cache from the current set of active branches. ;  ; IOPos FindBranchBasketPos (TBranch &, Long64_t entry);  Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ;  ; TTreeCache & operator= (const TTreeCache &)=delete;  ; bool ProcessMiss (Long64_t pos, int len);  ! Given a file read not in the miss cache, handle (possibly) loading the data. ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TFileCacheRead; void SetEnablePrefetchingImpl (Bool_t setPrefetching=kFALSE);  TFileCacheRead implementation of SetEnablePrefetching. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TTreeCache.h>. Inheritance diagram for TTreeCache:. This browser is not able to sho",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:33049,Performance,cache,cache,33049,"fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCache (const TTreeCache &)=delete;  this class cannot be copied ;  ; bool CalculateMissCache ();  Calculate the appropriate miss cache to fetch; helper function for FillMissCache. ;  ; TBranch * CalculateMissEntries (Long64_t, int, bool);  Given an file read, try to determine the corresponding branch. ;  ; bool CheckMissCache (char *buf, Long64_t pos, int len);  Check the miss cache for a particular buffer, fetching if deemed necessary. ;  ; bool FillMissCache ();  Fill the miss cache from the current set of active branches. ;  ; IOPos FindBranchBasketPos (TBranch &, Long64_t entry);  Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ;  ; TTreeCache & operator= (const TTreeCache &)=delete;  ; bool ProcessMiss (Long64_t pos, int len);  ! Given a file read not in the miss cache, handle (possibly) loading the data. ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TFileCacheRead; void SetEnablePrefetchingImpl (Bool_t setPrefetching=kFALSE);  TFileCacheRead implementation of SetEnablePrefetching. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TTreeCache.h>. Inheritance diagram for TTreeCache:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EPrefillType. enum TTreeCache::EPrefillType. EnumeratorkNoPrefill ; kAllBranches . Definition at line 35 of file TTreeCache.h. Constructor & Destructor Documentation. ◆ TTreeCache() [1/3]. TTreeCach",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:33074,Performance,load,loading,33074,"fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCache (const TTreeCache &)=delete;  this class cannot be copied ;  ; bool CalculateMissCache ();  Calculate the appropriate miss cache to fetch; helper function for FillMissCache. ;  ; TBranch * CalculateMissEntries (Long64_t, int, bool);  Given an file read, try to determine the corresponding branch. ;  ; bool CheckMissCache (char *buf, Long64_t pos, int len);  Check the miss cache for a particular buffer, fetching if deemed necessary. ;  ; bool FillMissCache ();  Fill the miss cache from the current set of active branches. ;  ; IOPos FindBranchBasketPos (TBranch &, Long64_t entry);  Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ;  ; TTreeCache & operator= (const TTreeCache &)=delete;  ; bool ProcessMiss (Long64_t pos, int len);  ! Given a file read not in the miss cache, handle (possibly) loading the data. ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TFileCacheRead; void SetEnablePrefetchingImpl (Bool_t setPrefetching=kFALSE);  TFileCacheRead implementation of SetEnablePrefetching. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TTreeCache.h>. Inheritance diagram for TTreeCache:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EPrefillType. enum TTreeCache::EPrefillType. EnumeratorkNoPrefill ; kAllBranches . Definition at line 35 of file TTreeCache.h. Constructor & Destructor Documentation. ◆ TTreeCache() [1/3]. TTreeCach",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:34751,Performance,cache,cache,34751,"end]; Member Enumeration Documentation. ◆ EPrefillType. enum TTreeCache::EPrefillType. EnumeratorkNoPrefill ; kAllBranches . Definition at line 35 of file TTreeCache.h. Constructor & Destructor Documentation. ◆ TTreeCache() [1/3]. TTreeCache::TTreeCache ; (; const TTreeCache & ; ). privatedelete . this class cannot be copied . ◆ TTreeCache() [2/3]. TTreeCache::TTreeCache ; (; ). Default Constructor. ; Definition at line 313 of file TTreeCache.cxx. ◆ TTreeCache() [3/3]. TTreeCache::TTreeCache ; (; TTree * ; tree, . Int_t ; buffersize = 0 . ). Constructor. ; Definition at line 320 of file TTreeCache.cxx. ◆ ~TTreeCache(). TTreeCache::~TTreeCache ; (; ). override . Destructor. (in general called by the TFile destructor) ; Definition at line 332 of file TTreeCache.cxx. Member Function Documentation. ◆ AddBranch() [1/2]. Int_t TTreeCache::AddBranch ; (; const char * ; bname, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 446 of file TTreeCache.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCache::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ; The branch is added even if we are outside of the training phase. Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reim",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:35128,Performance,cache,cache,35128,"efault Constructor. ; Definition at line 313 of file TTreeCache.cxx. ◆ TTreeCache() [3/3]. TTreeCache::TTreeCache ; (; TTree * ; tree, . Int_t ; buffersize = 0 . ). Constructor. ; Definition at line 320 of file TTreeCache.cxx. ◆ ~TTreeCache(). TTreeCache::~TTreeCache ; (; ). override . Destructor. (in general called by the TFile destructor) ; Definition at line 332 of file TTreeCache.cxx. Member Function Documentation. ◆ AddBranch() [1/2]. Int_t TTreeCache::AddBranch ; (; const char * ; bname, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 446 of file TTreeCache.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCache::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ; The branch is added even if we are outside of the training phase. Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 376 of file TTreeCache.cxx. ◆ CalculateMissCache(). bool TTreeCache::CalculateMissCache ; (; ). private . Calculate the appropriate miss cache to fetch; helper function for FillMissCache. . ◆ CalculateMissEntries(). TBranch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:35521,Performance,cache,cache,35521,"he.cxx. Member Function Documentation. ◆ AddBranch() [1/2]. Int_t TTreeCache::AddBranch ; (; const char * ; bname, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 446 of file TTreeCache.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCache::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ; The branch is added even if we are outside of the training phase. Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 376 of file TTreeCache.cxx. ◆ CalculateMissCache(). bool TTreeCache::CalculateMissCache ; (; ). private . Calculate the appropriate miss cache to fetch; helper function for FillMissCache. . ◆ CalculateMissEntries(). TBranch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file read, try to determine the corresponding branch. ; Given a particular IO description (offset / length) representing a 'miss' of the TTreeCache's primary cache, calculate all the corresponding IO that should be performed.; all indicates that this function should search the set of all branches in this TTree. When set to false, we only search through branches that have previously in",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:35947,Performance,cache,cache,35947,"f bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 446 of file TTreeCache.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCache::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ; The branch is added even if we are outside of the training phase. Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 376 of file TTreeCache.cxx. ◆ CalculateMissCache(). bool TTreeCache::CalculateMissCache ; (; ). private . Calculate the appropriate miss cache to fetch; helper function for FillMissCache. . ◆ CalculateMissEntries(). TBranch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file read, try to determine the corresponding branch. ; Given a particular IO description (offset / length) representing a 'miss' of the TTreeCache's primary cache, calculate all the corresponding IO that should be performed.; all indicates that this function should search the set of all branches in this TTree. When set to false, we only search through branches that have previously incurred a miss.; Returns:; TBranch pointer corresponding to the basket that will be retrieved by this IO operation.; If no corresponding branch could be found (or an error occurs), this returns nullptr. . Definition at line 790 of file TTreeCache.cxx. ◆ CheckMissCache(). bool TTreeCache::CheckMissCache ; (; char * ; buf, . Long64_t ; pos, . int ; len . ). private . Check the miss cache for a particular buffer, fetching if deem",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:36298,Performance,cache,cache,36298,"TreeCacheUnzip.; Definition at line 446 of file TTreeCache.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCache::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ; The branch is added even if we are outside of the training phase. Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 376 of file TTreeCache.cxx. ◆ CalculateMissCache(). bool TTreeCache::CalculateMissCache ; (; ). private . Calculate the appropriate miss cache to fetch; helper function for FillMissCache. . ◆ CalculateMissEntries(). TBranch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file read, try to determine the corresponding branch. ; Given a particular IO description (offset / length) representing a 'miss' of the TTreeCache's primary cache, calculate all the corresponding IO that should be performed.; all indicates that this function should search the set of all branches in this TTree. When set to false, we only search through branches that have previously incurred a miss.; Returns:; TBranch pointer corresponding to the basket that will be retrieved by this IO operation.; If no corresponding branch could be found (or an error occurs), this returns nullptr. . Definition at line 790 of file TTreeCache.cxx. ◆ CheckMissCache(). bool TTreeCache::CheckMissCache ; (; char * ; buf, . Long64_t ; pos, . int ; len . ). private . Check the miss cache for a particular buffer, fetching if deemed necessary. ; Given an IO operation (pos, len) that was a cache miss in the primary TTC, try the operation again with the miss cache.; Returns true if the IO operation was successful and the contents of buf were populated with the requested data. ; Definition at line 921 of file TTreeCache.cxx. ◆ Class(). static TClass ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:36355,Performance,perform,performed,36355,"TreeCacheUnzip.; Definition at line 446 of file TTreeCache.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCache::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ; The branch is added even if we are outside of the training phase. Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 376 of file TTreeCache.cxx. ◆ CalculateMissCache(). bool TTreeCache::CalculateMissCache ; (; ). private . Calculate the appropriate miss cache to fetch; helper function for FillMissCache. . ◆ CalculateMissEntries(). TBranch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file read, try to determine the corresponding branch. ; Given a particular IO description (offset / length) representing a 'miss' of the TTreeCache's primary cache, calculate all the corresponding IO that should be performed.; all indicates that this function should search the set of all branches in this TTree. When set to false, we only search through branches that have previously incurred a miss.; Returns:; TBranch pointer corresponding to the basket that will be retrieved by this IO operation.; If no corresponding branch could be found (or an error occurs), this returns nullptr. . Definition at line 790 of file TTreeCache.cxx. ◆ CheckMissCache(). bool TTreeCache::CheckMissCache ; (; char * ; buf, . Long64_t ; pos, . int ; len . ). private . Check the miss cache for a particular buffer, fetching if deemed necessary. ; Given an IO operation (pos, len) that was a cache miss in the primary TTC, try the operation again with the miss cache.; Returns true if the IO operation was successful and the contents of buf were populated with the requested data. ; Definition at line 921 of file TTreeCache.cxx. ◆ Class(). static TClass ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:36909,Performance,cache,cache,36909,"ppropriate miss cache to fetch; helper function for FillMissCache. . ◆ CalculateMissEntries(). TBranch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file read, try to determine the corresponding branch. ; Given a particular IO description (offset / length) representing a 'miss' of the TTreeCache's primary cache, calculate all the corresponding IO that should be performed.; all indicates that this function should search the set of all branches in this TTree. When set to false, we only search through branches that have previously incurred a miss.; Returns:; TBranch pointer corresponding to the basket that will be retrieved by this IO operation.; If no corresponding branch could be found (or an error occurs), this returns nullptr. . Definition at line 790 of file TTreeCache.cxx. ◆ CheckMissCache(). bool TTreeCache::CheckMissCache ; (; char * ; buf, . Long64_t ; pos, . int ; len . ). private . Check the miss cache for a particular buffer, fetching if deemed necessary. ; Given an IO operation (pos, len) that was a cache miss in the primary TTC, try the operation again with the miss cache.; Returns true if the IO operation was successful and the contents of buf were populated with the requested data. ; Definition at line 921 of file TTreeCache.cxx. ◆ Class(). static TClass * TTreeCache::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCache::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCache::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 175 of file TTreeCache.h. ◆ DeclFileName(). static const char * TTreeCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 175 of file TTreeCache.h. ◆ Disable(). virtual void TTreeCache::Disable ; (; ). inlinevirtual . Definition at line 136 of file TT",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:37016,Performance,cache,cache,37016,"nch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file read, try to determine the corresponding branch. ; Given a particular IO description (offset / length) representing a 'miss' of the TTreeCache's primary cache, calculate all the corresponding IO that should be performed.; all indicates that this function should search the set of all branches in this TTree. When set to false, we only search through branches that have previously incurred a miss.; Returns:; TBranch pointer corresponding to the basket that will be retrieved by this IO operation.; If no corresponding branch could be found (or an error occurs), this returns nullptr. . Definition at line 790 of file TTreeCache.cxx. ◆ CheckMissCache(). bool TTreeCache::CheckMissCache ; (; char * ; buf, . Long64_t ; pos, . int ; len . ). private . Check the miss cache for a particular buffer, fetching if deemed necessary. ; Given an IO operation (pos, len) that was a cache miss in the primary TTC, try the operation again with the miss cache.; Returns true if the IO operation was successful and the contents of buf were populated with the requested data. ; Definition at line 921 of file TTreeCache.cxx. ◆ Class(). static TClass * TTreeCache::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCache::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCache::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 175 of file TTreeCache.h. ◆ DeclFileName(). static const char * TTreeCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 175 of file TTreeCache.h. ◆ Disable(). virtual void TTreeCache::Disable ; (; ). inlinevirtual . Definition at line 136 of file TTreeCache.h. ◆ DropBranch() [1/2]. Int_t TTreeCache::DropBranch ; (; const char * ; bname, . bool ; ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:37085,Performance,cache,cache,37085,"nch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file read, try to determine the corresponding branch. ; Given a particular IO description (offset / length) representing a 'miss' of the TTreeCache's primary cache, calculate all the corresponding IO that should be performed.; all indicates that this function should search the set of all branches in this TTree. When set to false, we only search through branches that have previously incurred a miss.; Returns:; TBranch pointer corresponding to the basket that will be retrieved by this IO operation.; If no corresponding branch could be found (or an error occurs), this returns nullptr. . Definition at line 790 of file TTreeCache.cxx. ◆ CheckMissCache(). bool TTreeCache::CheckMissCache ; (; char * ; buf, . Long64_t ; pos, . int ; len . ). private . Check the miss cache for a particular buffer, fetching if deemed necessary. ; Given an IO operation (pos, len) that was a cache miss in the primary TTC, try the operation again with the miss cache.; Returns true if the IO operation was successful and the contents of buf were populated with the requested data. ; Definition at line 921 of file TTreeCache.cxx. ◆ Class(). static TClass * TTreeCache::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCache::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCache::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 175 of file TTreeCache.h. ◆ DeclFileName(). static const char * TTreeCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 175 of file TTreeCache.h. ◆ Disable(). virtual void TTreeCache::Disable ; (; ). inlinevirtual . Definition at line 136 of file TTreeCache.h. ◆ DropBranch() [1/2]. Int_t TTreeCache::DropBranch ; (; const char * ; bname, . bool ; ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:38125,Performance,cache,cache,38125,"ccessful and the contents of buf were populated with the requested data. ; Definition at line 921 of file TTreeCache.cxx. ◆ Class(). static TClass * TTreeCache::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCache::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCache::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 175 of file TTreeCache.h. ◆ DeclFileName(). static const char * TTreeCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 175 of file TTreeCache.h. ◆ Disable(). virtual void TTreeCache::Disable ; (; ). inlinevirtual . Definition at line 136 of file TTreeCache.h. ◆ DropBranch() [1/2]. Int_t TTreeCache::DropBranch ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuff",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:38502,Performance,cache,cache,38502,"Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 175 of file TTreeCache.h. ◆ DeclFileName(). static const char * TTreeCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 175 of file TTreeCache.h. ◆ Disable(). virtual void TTreeCache::Disable ; (; ). inlinevirtual . Definition at line 136 of file TTreeCache.h. ◆ DropBranch() [1/2]. Int_t TTreeCache::DropBranch ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:38576,Performance,cache,cache,38576,"Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 175 of file TTreeCache.h. ◆ DeclFileName(). static const char * TTreeCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 175 of file TTreeCache.h. ◆ Disable(). virtual void TTreeCache::Disable ; (; ). inlinevirtual . Definition at line 136 of file TTreeCache.h. ◆ DropBranch() [1/2]. Int_t TTreeCache::DropBranch ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:38819,Performance,cache,cache,38819,"TTreeCache.h. ◆ Disable(). virtual void TTreeCache::Disable ; (; ). inlinevirtual . Definition at line 136 of file TTreeCache.h. ◆ DropBranch() [1/2]. Int_t TTreeCache::DropBranch ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b, . Long64_t ; entry . ). private . Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ; For the event currently being fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IO",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:38911,Performance,cache,cache,38911,"inition at line 136 of file TTreeCache.h. ◆ DropBranch() [1/2]. Int_t TTreeCache::DropBranch ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b, . Long64_t ; entry . ). private . Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ; For the event currently being fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IOPos describing the IO operation necessary for the basket on this branch; On failure, I",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:39163,Performance,cache,cache,39163," name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b, . Long64_t ; entry . ). private . Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ; For the event currently being fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IOPos describing the IO operation necessary for the basket on this branch; On failure, IOPos.length will be set to 0. . Definition at line 716 of file TTreeCache.cxx. ◆ GetCachedBranches(). const TObjArray * TTreeCache::GetCachedBranches ; (; ); const. inline . Definition at line 139 of file TTreeCache.h. ◆ GetConfiguredPrefillType(). TTreeCache::EPrefillType TTree",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:39201,Performance,cache,cache,39201," name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b, . Long64_t ; entry . ). private . Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ; For the event currently being fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IOPos describing the IO operation necessary for the basket on this branch; On failure, IOPos.length will be set to 0. . Definition at line 716 of file TTreeCache.cxx. ◆ GetCachedBranches(). const TObjArray * TTreeCache::GetCachedBranches ; (; ); const. inline . Definition at line 139 of file TTreeCache.h. ◆ GetConfiguredPrefillType(). TTreeCache::EPrefillType TTree",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:39375,Performance,cache,cache,39375,"h respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b, . Long64_t ; entry . ). private . Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ; For the event currently being fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IOPos describing the IO operation necessary for the basket on this branch; On failure, IOPos.length will be set to 0. . Definition at line 716 of file TTreeCache.cxx. ◆ GetCachedBranches(). const TObjArray * TTreeCache::GetCachedBranches ; (; ); const. inline . Definition at line 139 of file TTreeCache.h. ◆ GetConfiguredPrefillType(). TTreeCache::EPrefillType TTreeCache::GetConfiguredPrefillType ; (; ); const. Return the desired prefill type from the environment or resource variable. . 0 - No prefill; 1 - All branches . Definition at line 1802 of file TTreeCache.cxx. ◆ Ge",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:39709,Performance,cache,cache,39709,"branches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b, . Long64_t ; entry . ). private . Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ; For the event currently being fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IOPos describing the IO operation necessary for the basket on this branch; On failure, IOPos.length will be set to 0. . Definition at line 716 of file TTreeCache.cxx. ◆ GetCachedBranches(). const TObjArray * TTreeCache::GetCachedBranches ; (; ); const. inline . Definition at line 139 of file TTreeCache.h. ◆ GetConfiguredPrefillType(). TTreeCache::EPrefillType TTreeCache::GetConfiguredPrefillType ; (; ); const. Return the desired prefill type from the environment or resource variable. . 0 - No prefill; 1 - All branches . Definition at line 1802 of file TTreeCache.cxx. ◆ GetEfficiency(). Double_t TTreeCache::GetEfficiency ; (; ); const. Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ; the number of blocks prefetched ( it could be more than 1 if we read the same block from the cache more than once ); Note: This should eb used at the end of the proce",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:40497,Performance,cache,cache,40497,"FindBranchBasketPos ; (; TBranch & ; b, . Long64_t ; entry . ). private . Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ; For the event currently being fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IOPos describing the IO operation necessary for the basket on this branch; On failure, IOPos.length will be set to 0. . Definition at line 716 of file TTreeCache.cxx. ◆ GetCachedBranches(). const TObjArray * TTreeCache::GetCachedBranches ; (; ); const. inline . Definition at line 139 of file TTreeCache.h. ◆ GetConfiguredPrefillType(). TTreeCache::EPrefillType TTreeCache::GetConfiguredPrefillType ; (; ); const. Return the desired prefill type from the environment or resource variable. . 0 - No prefill; 1 - All branches . Definition at line 1802 of file TTreeCache.cxx. ◆ GetEfficiency(). Double_t TTreeCache::GetEfficiency ; (; ); const. Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ; the number of blocks prefetched ( it could be more than 1 if we read the same block from the cache more than once ); Note: This should eb used at the end of the processing or we will get incomplete stats ; Definition at line 1825 of file TTreeCache.cxx. ◆ GetEfficiencyRel(). Double_t TTreeCache::GetEfficiencyRel ; (; ); const. This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ; Definition at line 1849 of file TTreeCache.cxx. ◆ GetEntryMax(). virtual Int_t TTreeCache::GetEntryMax ; (; ); const. inlinevirtual . Definition at line 144 of file TTreeCache.h. ◆ GetEntryMin(). virtual Int_t TTreeCache::GetEntryMin ; (; ); const. inlinevirtual . Definition at line 143 of file TTreeCache.h. ◆ GetLearnEntries(). Int_t TTreeCache::GetLearnEntries ; (; ). static . Static function returning the number of entries used to train the cache see SetLe",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:40550,Performance,cache,cache,40550,"entry . ). private . Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ; For the event currently being fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IOPos describing the IO operation necessary for the basket on this branch; On failure, IOPos.length will be set to 0. . Definition at line 716 of file TTreeCache.cxx. ◆ GetCachedBranches(). const TObjArray * TTreeCache::GetCachedBranches ; (; ); const. inline . Definition at line 139 of file TTreeCache.h. ◆ GetConfiguredPrefillType(). TTreeCache::EPrefillType TTreeCache::GetConfiguredPrefillType ; (; ); const. Return the desired prefill type from the environment or resource variable. . 0 - No prefill; 1 - All branches . Definition at line 1802 of file TTreeCache.cxx. ◆ GetEfficiency(). Double_t TTreeCache::GetEfficiency ; (; ); const. Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ; the number of blocks prefetched ( it could be more than 1 if we read the same block from the cache more than once ); Note: This should eb used at the end of the processing or we will get incomplete stats ; Definition at line 1825 of file TTreeCache.cxx. ◆ GetEfficiencyRel(). Double_t TTreeCache::GetEfficiencyRel ; (; ); const. This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ; Definition at line 1849 of file TTreeCache.cxx. ◆ GetEntryMax(). virtual Int_t TTreeCache::GetEntryMax ; (; ); const. inlinevirtual . Definition at line 144 of file TTreeCache.h. ◆ GetEntryMin(). virtual Int_t TTreeCache::GetEntryMin ; (; ); const. inlinevirtual . Definition at line 143 of file TTreeCache.h. ◆ GetLearnEntries(). Int_t TTreeCache::GetLearnEntries ; (; ). static . Static function returning the number of entries used to train the cache see SetLearnEntries. ; Definition at line 1874 of file TTreeCa",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:40655,Performance,cache,cache,40655,"g fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IOPos describing the IO operation necessary for the basket on this branch; On failure, IOPos.length will be set to 0. . Definition at line 716 of file TTreeCache.cxx. ◆ GetCachedBranches(). const TObjArray * TTreeCache::GetCachedBranches ; (; ); const. inline . Definition at line 139 of file TTreeCache.h. ◆ GetConfiguredPrefillType(). TTreeCache::EPrefillType TTreeCache::GetConfiguredPrefillType ; (; ); const. Return the desired prefill type from the environment or resource variable. . 0 - No prefill; 1 - All branches . Definition at line 1802 of file TTreeCache.cxx. ◆ GetEfficiency(). Double_t TTreeCache::GetEfficiency ; (; ); const. Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ; the number of blocks prefetched ( it could be more than 1 if we read the same block from the cache more than once ); Note: This should eb used at the end of the processing or we will get incomplete stats ; Definition at line 1825 of file TTreeCache.cxx. ◆ GetEfficiencyRel(). Double_t TTreeCache::GetEfficiencyRel ; (; ); const. This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ; Definition at line 1849 of file TTreeCache.cxx. ◆ GetEntryMax(). virtual Int_t TTreeCache::GetEntryMax ; (; ); const. inlinevirtual . Definition at line 144 of file TTreeCache.h. ◆ GetEntryMin(). virtual Int_t TTreeCache::GetEntryMin ; (; ); const. inlinevirtual . Definition at line 143 of file TTreeCache.h. ◆ GetLearnEntries(). Int_t TTreeCache::GetLearnEntries ; (; ). static . Static function returning the number of entries used to train the cache see SetLearnEntries. ; Definition at line 1874 of file TTreeCache.cxx. ◆ GetLearnPrefill(). virtual EPrefillType TTreeCache::GetLearnPrefill ; (; ); const. inlinevirtual . Definition at line 146 of file TTreeCache.h",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:40977,Performance,cache,cache,40977,x. ◆ GetCachedBranches(). const TObjArray * TTreeCache::GetCachedBranches ; (; ); const. inline . Definition at line 139 of file TTreeCache.h. ◆ GetConfiguredPrefillType(). TTreeCache::EPrefillType TTreeCache::GetConfiguredPrefillType ; (; ); const. Return the desired prefill type from the environment or resource variable. . 0 - No prefill; 1 - All branches . Definition at line 1802 of file TTreeCache.cxx. ◆ GetEfficiency(). Double_t TTreeCache::GetEfficiency ; (; ); const. Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ; the number of blocks prefetched ( it could be more than 1 if we read the same block from the cache more than once ); Note: This should eb used at the end of the processing or we will get incomplete stats ; Definition at line 1825 of file TTreeCache.cxx. ◆ GetEfficiencyRel(). Double_t TTreeCache::GetEfficiencyRel ; (; ); const. This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ; Definition at line 1849 of file TTreeCache.cxx. ◆ GetEntryMax(). virtual Int_t TTreeCache::GetEntryMax ; (; ); const. inlinevirtual . Definition at line 144 of file TTreeCache.h. ◆ GetEntryMin(). virtual Int_t TTreeCache::GetEntryMin ; (; ); const. inlinevirtual . Definition at line 143 of file TTreeCache.h. ◆ GetLearnEntries(). Int_t TTreeCache::GetLearnEntries ; (; ). static . Static function returning the number of entries used to train the cache see SetLearnEntries. ; Definition at line 1874 of file TTreeCache.cxx. ◆ GetLearnPrefill(). virtual EPrefillType TTreeCache::GetLearnPrefill ; (; ); const. inlinevirtual . Definition at line 146 of file TTreeCache.h. ◆ GetMissEfficiency(). Double_t TTreeCache::GetMissEfficiency ; (; ); const. The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ; Definition at line 1837 of file TTreeCache.cxx. ◆ GetMissEfficiencyRel(). Doubl,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:41464,Performance,cache,cache,41464,(; ); const. Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ; the number of blocks prefetched ( it could be more than 1 if we read the same block from the cache more than once ); Note: This should eb used at the end of the processing or we will get incomplete stats ; Definition at line 1825 of file TTreeCache.cxx. ◆ GetEfficiencyRel(). Double_t TTreeCache::GetEfficiencyRel ; (; ); const. This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ; Definition at line 1849 of file TTreeCache.cxx. ◆ GetEntryMax(). virtual Int_t TTreeCache::GetEntryMax ; (; ); const. inlinevirtual . Definition at line 144 of file TTreeCache.h. ◆ GetEntryMin(). virtual Int_t TTreeCache::GetEntryMin ; (; ); const. inlinevirtual . Definition at line 143 of file TTreeCache.h. ◆ GetLearnEntries(). Int_t TTreeCache::GetLearnEntries ; (; ). static . Static function returning the number of entries used to train the cache see SetLearnEntries. ; Definition at line 1874 of file TTreeCache.cxx. ◆ GetLearnPrefill(). virtual EPrefillType TTreeCache::GetLearnPrefill ; (; ); const. inlinevirtual . Definition at line 146 of file TTreeCache.h. ◆ GetMissEfficiency(). Double_t TTreeCache::GetMissEfficiency ; (; ); const. The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ; Definition at line 1837 of file TTreeCache.cxx. ◆ GetMissEfficiencyRel(). Double_t TTreeCache::GetMissEfficiencyRel ; (; ); const. Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ; Definition at line 1861 of file TTreeCache.cxx. ◆ GetOptimizeMisses(). bool TTreeCache::GetOptimizeMisses ; (; ); const. inline . Definition at line 138 of file TTreeCache.h. ◆ GetTree(). TTree * TTreeCache::GetTree ; (; ); const. inline . Definition at line 149 of file TTreeCache.h. ◆ IsA(). TClass * TT,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:41798,Performance,cache,cache,41798,cyRel(). Double_t TTreeCache::GetEfficiencyRel ; (; ); const. This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ; Definition at line 1849 of file TTreeCache.cxx. ◆ GetEntryMax(). virtual Int_t TTreeCache::GetEntryMax ; (; ); const. inlinevirtual . Definition at line 144 of file TTreeCache.h. ◆ GetEntryMin(). virtual Int_t TTreeCache::GetEntryMin ; (; ); const. inlinevirtual . Definition at line 143 of file TTreeCache.h. ◆ GetLearnEntries(). Int_t TTreeCache::GetLearnEntries ; (; ). static . Static function returning the number of entries used to train the cache see SetLearnEntries. ; Definition at line 1874 of file TTreeCache.cxx. ◆ GetLearnPrefill(). virtual EPrefillType TTreeCache::GetLearnPrefill ; (; ); const. inlinevirtual . Definition at line 146 of file TTreeCache.h. ◆ GetMissEfficiency(). Double_t TTreeCache::GetMissEfficiency ; (; ); const. The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ; Definition at line 1837 of file TTreeCache.cxx. ◆ GetMissEfficiencyRel(). Double_t TTreeCache::GetMissEfficiencyRel ; (; ); const. Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ; Definition at line 1861 of file TTreeCache.cxx. ◆ GetOptimizeMisses(). bool TTreeCache::GetOptimizeMisses ; (; ); const. inline . Definition at line 138 of file TTreeCache.h. ◆ GetTree(). TTree * TTreeCache::GetTree ; (; ); const. inline . Definition at line 149 of file TTreeCache.h. ◆ IsA(). TClass * TTreeCache::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 175 of file TTreeCache.h. ◆ IsAutoCreated(). bool TTreeCache::IsAutoCreated ; (; ); const. inline . Definition at line 150 of file TTreeCache.h. ◆ IsEnabled(). virtual bool TTreeCache::IsEnabled ; (; ),MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:41851,Performance,cache,cache,41851,cyRel(). Double_t TTreeCache::GetEfficiencyRel ; (; ); const. This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ; Definition at line 1849 of file TTreeCache.cxx. ◆ GetEntryMax(). virtual Int_t TTreeCache::GetEntryMax ; (; ); const. inlinevirtual . Definition at line 144 of file TTreeCache.h. ◆ GetEntryMin(). virtual Int_t TTreeCache::GetEntryMin ; (; ); const. inlinevirtual . Definition at line 143 of file TTreeCache.h. ◆ GetLearnEntries(). Int_t TTreeCache::GetLearnEntries ; (; ). static . Static function returning the number of entries used to train the cache see SetLearnEntries. ; Definition at line 1874 of file TTreeCache.cxx. ◆ GetLearnPrefill(). virtual EPrefillType TTreeCache::GetLearnPrefill ; (; ); const. inlinevirtual . Definition at line 146 of file TTreeCache.h. ◆ GetMissEfficiency(). Double_t TTreeCache::GetMissEfficiency ; (; ); const. The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ; Definition at line 1837 of file TTreeCache.cxx. ◆ GetMissEfficiencyRel(). Double_t TTreeCache::GetMissEfficiencyRel ; (; ); const. Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ; Definition at line 1861 of file TTreeCache.cxx. ◆ GetOptimizeMisses(). bool TTreeCache::GetOptimizeMisses ; (; ); const. inline . Definition at line 138 of file TTreeCache.h. ◆ GetTree(). TTree * TTreeCache::GetTree ; (; ); const. inline . Definition at line 149 of file TTreeCache.h. ◆ IsA(). TClass * TTreeCache::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 175 of file TTreeCache.h. ◆ IsAutoCreated(). bool TTreeCache::IsAutoCreated ; (; ); const. inline . Definition at line 150 of file TTreeCache.h. ◆ IsEnabled(). virtual bool TTreeCache::IsEnabled ; (; ),MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:42063,Performance,cache,cache,42063,irtual Int_t TTreeCache::GetEntryMax ; (; ); const. inlinevirtual . Definition at line 144 of file TTreeCache.h. ◆ GetEntryMin(). virtual Int_t TTreeCache::GetEntryMin ; (; ); const. inlinevirtual . Definition at line 143 of file TTreeCache.h. ◆ GetLearnEntries(). Int_t TTreeCache::GetLearnEntries ; (; ). static . Static function returning the number of entries used to train the cache see SetLearnEntries. ; Definition at line 1874 of file TTreeCache.cxx. ◆ GetLearnPrefill(). virtual EPrefillType TTreeCache::GetLearnPrefill ; (; ); const. inlinevirtual . Definition at line 146 of file TTreeCache.h. ◆ GetMissEfficiency(). Double_t TTreeCache::GetMissEfficiency ; (; ); const. The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ; Definition at line 1837 of file TTreeCache.cxx. ◆ GetMissEfficiencyRel(). Double_t TTreeCache::GetMissEfficiencyRel ; (; ); const. Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ; Definition at line 1861 of file TTreeCache.cxx. ◆ GetOptimizeMisses(). bool TTreeCache::GetOptimizeMisses ; (; ); const. inline . Definition at line 138 of file TTreeCache.h. ◆ GetTree(). TTree * TTreeCache::GetTree ; (; ); const. inline . Definition at line 149 of file TTreeCache.h. ◆ IsA(). TClass * TTreeCache::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 175 of file TTreeCache.h. ◆ IsAutoCreated(). bool TTreeCache::IsAutoCreated ; (; ); const. inline . Definition at line 150 of file TTreeCache.h. ◆ IsEnabled(). virtual bool TTreeCache::IsEnabled ; (; ); const. inlinevirtual . Definition at line 151 of file TTreeCache.h. ◆ IsLearning(). bool TTreeCache::IsLearning ; (; ); const. inlineoverridevirtual . Reimplemented from TFileCacheRead.; Definition at line 152 of file TTreeCache.h. ◆ LearnBranch(). In,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:42100,Performance,cache,cache,42100,irtual Int_t TTreeCache::GetEntryMax ; (; ); const. inlinevirtual . Definition at line 144 of file TTreeCache.h. ◆ GetEntryMin(). virtual Int_t TTreeCache::GetEntryMin ; (; ); const. inlinevirtual . Definition at line 143 of file TTreeCache.h. ◆ GetLearnEntries(). Int_t TTreeCache::GetLearnEntries ; (; ). static . Static function returning the number of entries used to train the cache see SetLearnEntries. ; Definition at line 1874 of file TTreeCache.cxx. ◆ GetLearnPrefill(). virtual EPrefillType TTreeCache::GetLearnPrefill ; (; ); const. inlinevirtual . Definition at line 146 of file TTreeCache.h. ◆ GetMissEfficiency(). Double_t TTreeCache::GetMissEfficiency ; (; ); const. The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ; Definition at line 1837 of file TTreeCache.cxx. ◆ GetMissEfficiencyRel(). Double_t TTreeCache::GetMissEfficiencyRel ; (; ); const. Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ; Definition at line 1861 of file TTreeCache.cxx. ◆ GetOptimizeMisses(). bool TTreeCache::GetOptimizeMisses ; (; ); const. inline . Definition at line 138 of file TTreeCache.h. ◆ GetTree(). TTree * TTreeCache::GetTree ; (; ); const. inline . Definition at line 149 of file TTreeCache.h. ◆ IsA(). TClass * TTreeCache::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 175 of file TTreeCache.h. ◆ IsAutoCreated(). bool TTreeCache::IsAutoCreated ; (; ); const. inline . Definition at line 150 of file TTreeCache.h. ◆ IsEnabled(). virtual bool TTreeCache::IsEnabled ; (; ); const. inlinevirtual . Definition at line 151 of file TTreeCache.h. ◆ IsLearning(). bool TTreeCache::IsLearning ; (; ); const. inlineoverridevirtual . Reimplemented from TFileCacheRead.; Definition at line 152 of file TTreeCache.h. ◆ LearnBranch(). In,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:43267,Performance,cache,cache,43267,"at line 138 of file TTreeCache.h. ◆ GetTree(). TTree * TTreeCache::GetTree ; (; ); const. inline . Definition at line 149 of file TTreeCache.h. ◆ IsA(). TClass * TTreeCache::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 175 of file TTreeCache.h. ◆ IsAutoCreated(). bool TTreeCache::IsAutoCreated ; (; ); const. inline . Definition at line 150 of file TTreeCache.h. ◆ IsEnabled(). virtual bool TTreeCache::IsEnabled ; (; ); const. inlinevirtual . Definition at line 151 of file TTreeCache.h. ◆ IsLearning(). bool TTreeCache::IsLearning ; (; ); const. inlineoverridevirtual . Reimplemented from TFileCacheRead.; Definition at line 152 of file TTreeCache.h. ◆ LearnBranch(). Int_t TTreeCache::LearnBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ; Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2250 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Read",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:43945,Performance,cache,cache,43945,"; const. inlineoverridevirtual . Reimplemented from TFileCacheRead.; Definition at line 152 of file TTreeCache.h. ◆ LearnBranch(). Int_t TTreeCache::LearnBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ; Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2250 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwne",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:44053,Performance,cache,cache,44053," 152 of file TTreeCache.h. ◆ LearnBranch(). Int_t TTreeCache::LearnBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ; Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2250 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid win",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:44438,Performance,cache,cache,44438,"ncluded; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2250 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:45435,Performance,cache,cache,45435," cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 1899 of file TTreeCache.cxx. ◆ ProcessMiss(). bool TTreeCache::ProcessMiss ; (; Long64_t ; pos, . int ; len . ). private . ! Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TT",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:45504,Performance,cache,cachedbranches,45504,"size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 1899 of file TTreeCache.cxx. ◆ ProcessMiss(). bool TTreeCache::ProcessMiss ; (; Long64_t ; pos, . int ; len . ). private . ! Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevi",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:45548,Performance,cache,cached,45548,"size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 1899 of file TTreeCache.cxx. ◆ ProcessMiss(). bool TTreeCache::ProcessMiss ; (; Long64_t ; pos, . int ; len . ). private . ! Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevi",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:45818,Performance,cache,cache,45818,"loat_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 1899 of file TTreeCache.cxx. ◆ ProcessMiss(). bool TTreeCache::ProcessMiss ; (; Long64_t ; pos, . int ; len . ). private . ! Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read fro",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:45843,Performance,load,loading,45843,"loat_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 1899 of file TTreeCache.cxx. ◆ ProcessMiss(). bool TTreeCache::ProcessMiss ; (; Long64_t ; pos, . int ; len . ). private . ! Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read fro",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:45873,Performance,cache,cache,45873,"nt_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 1899 of file TTreeCache.cxx. ◆ ProcessMiss(). bool TTreeCache::ProcessMiss ; (; Long64_t ; pos, . int ; len . ). private . ! Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reim",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:46357,Performance,cache,cache,46357,"t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 1899 of file TTreeCache.cxx. ◆ ProcessMiss(). bool TTreeCache::ProcessMiss ; (; Long64_t ; pos, . int ; len . ). private . ! Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). vi",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:46658,Performance,cache,cache,46658,"cxx. ◆ ProcessMiss(). bool TTreeCache::ProcessMiss ; (; Long64_t ; pos, . int ; len . ). private . ! Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clea",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:46795,Performance,cache,cache,46795," Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:46823,Performance,cache,cache,46823," Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:47429,Performance,cache,cache,47429,"; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still av",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:47690,Performance,cache,cache,47690,"f selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:47861,Performance,cache,cache,47861,"eCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information he",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:47904,Performance,cache,cache,47904," Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetchin",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:48273,Performance,cache,cache,48273,"dBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:48315,Performance,cache,cache,48315,"ven if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to b",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:48382,Performance,cache,cache,48382,"ven if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to b",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:48866,Performance,optimiz,optimize,48866,"cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTre",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:49191,Performance,cache,cached,49191,"fferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; boo",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:49725,Performance,cache,cache,49725,"::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition a",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:49892,Performance,cache,cache,49892,"ormation helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2169 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart o",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:50219,Performance,cache,cache,50219,"lemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2169 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ S",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:50254,Performance,cache,cache,50254,"ition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2169 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:50650,Performance,cache,cache,50650,"ual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2169 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerNVirtual(). void TTreeCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file TTreeCache.h. ◆ UpdateBranches(). void TTreeCache::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:51711,Performance,cache,cache,51711,he new learning phase. ; Definition at line 2169 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerNVirtual(). void TTreeCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file TTreeCache.h. ◆ UpdateBranches(). void TTreeCache::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to current Tree and recompute pointers to the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2210 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoCreated {false}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurre,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:51907,Performance,cache,cache,51907,user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerNVirtual(). void TTreeCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file TTreeCache.h. ◆ UpdateBranches(). void TTreeCache::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to current Tree and recompute pointers to the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2210 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoCreated {false}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:52093,Performance,cache,cache,52093,e specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerNVirtual(). void TTreeCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file TTreeCache.h. ◆ UpdateBranches(). void TTreeCache::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to current Tree and recompute pointers to the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2210 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoCreated {false}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext ,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:52238,Performance,cache,cache,52238,; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerNVirtual(). void TTreeCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file TTreeCache.h. ◆ UpdateBranches(). void TTreeCache::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to current Tree and recompute pointers to the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2210 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoCreated {false}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillT,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:52547,Performance,cache,cache,52547,he::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to current Tree and recompute pointers to the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2210 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoCreated {false}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protecte,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:52565,Performance,cache,cached,52565,he::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to current Tree and recompute pointers to the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2210 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoCreated {false}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protecte,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:52733,Performance,cache,cache,52733,TreeCacheUnzip.; Definition at line 2210 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoCreated {false}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:52866,Performance,cache,cache,52866,se}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set to the event # of the first miss. ; Definition at line 73 of file TTreeCache.h. ◆ fFirstTime. bool TTreeCache::fFirstTime {true}. protected ,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:53000,Performance,cache,cache,53000,eCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set to the event # of the first miss. ; Definition at line 73 of file TTreeCache.h. ◆ fFirstTime. bool TTreeCache::fFirstTime {true}. protected . ! save the fact that we processes the first entry ; Definition at line 60 of file TTreeCache.h. ◆ fgLearnEntries. Int_t TTreeCache::,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:53142,Performance,cache,cache,53142,st* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set to the event # of the first miss. ; Definition at line 73 of file TTreeCache.h. ◆ fFirstTime. bool TTreeCache::fFirstTime {true}. protected . ! save the fact that we processes the first entry ; Definition at line 60 of file TTreeCache.h. ◆ fgLearnEntries. Int_t TTreeCache::fgLearnEntries = 100. staticprotected . number of entries used for learning mode ; Definition at line 65 of file TTreeCache.h. ◆ fIsLearning. bool ,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:54215,Performance,cache,cache,54215,llTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set to the event # of the first miss. ; Definition at line 73 of file TTreeCache.h. ◆ fFirstTime. bool TTreeCache::fFirstTime {true}. protected . ! save the fact that we processes the first entry ; Definition at line 60 of file TTreeCache.h. ◆ fgLearnEntries. Int_t TTreeCache::fgLearnEntries = 100. staticprotected . number of entries used for learning mode ; Definition at line 65 of file TTreeCache.h. ◆ fIsLearning. bool TTreeCache::fIsLearning {true}. protected . ! true if cache is in learning mode ; Definition at line 54 of file TTreeCache.h. ◆ fIsManual. bool TTreeCache::fIsManual {false}. protected . ! true if cache is StopLearningPhase was used ; Definition at line 55 of file TTreeCache.h. ◆ fLastMiss. Long64_t TTreeCache::fLastMiss {-1}. protected . ! set to the event # of the last miss. ; Definition at line 74 of file TTreeCache.h. ◆ fLearnPrefilling. bool TTreeCache::fLearnPrefilling {false}. protected . ! true if we are in the process of executing LearnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCach,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:54358,Performance,cache,cache,54358,he::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set to the event # of the first miss. ; Definition at line 73 of file TTreeCache.h. ◆ fFirstTime. bool TTreeCache::fFirstTime {true}. protected . ! save the fact that we processes the first entry ; Definition at line 60 of file TTreeCache.h. ◆ fgLearnEntries. Int_t TTreeCache::fgLearnEntries = 100. staticprotected . number of entries used for learning mode ; Definition at line 65 of file TTreeCache.h. ◆ fIsLearning. bool TTreeCache::fIsLearning {true}. protected . ! true if cache is in learning mode ; Definition at line 54 of file TTreeCache.h. ◆ fIsManual. bool TTreeCache::fIsManual {false}. protected . ! true if cache is StopLearningPhase was used ; Definition at line 55 of file TTreeCache.h. ◆ fLastMiss. Long64_t TTreeCache::fLastMiss {-1}. protected . ! set to the event # of the last miss. ; Definition at line 74 of file TTreeCache.h. ◆ fLearnPrefilling. bool TTreeCache::fLearnPrefilling {false}. protected . ! true if we are in the process of executing LearnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCache.h. ◆ fNMissReadMiss. Int_t TTreeCache::fNMissReadMiss {0}. protected . Number of blocks read and not found in either cache. ; Definition at line 4,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:55006,Performance,cache,cache,55006,"LearnEntries = 100. staticprotected . number of entries used for learning mode ; Definition at line 65 of file TTreeCache.h. ◆ fIsLearning. bool TTreeCache::fIsLearning {true}. protected . ! true if cache is in learning mode ; Definition at line 54 of file TTreeCache.h. ◆ fIsManual. bool TTreeCache::fIsManual {false}. protected . ! true if cache is StopLearningPhase was used ; Definition at line 55 of file TTreeCache.h. ◆ fLastMiss. Long64_t TTreeCache::fLastMiss {-1}. protected . ! set to the event # of the last miss. ; Definition at line 74 of file TTreeCache.h. ◆ fLearnPrefilling. bool TTreeCache::fLearnPrefilling {false}. protected . ! true if we are in the process of executing LearnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCache.h. ◆ fNMissReadMiss. Int_t TTreeCache::fNMissReadMiss {0}. protected . Number of blocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks r",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:55363,Performance,cache,cache,55363,"ted . ! true if cache is StopLearningPhase was used ; Definition at line 55 of file TTreeCache.h. ◆ fLastMiss. Long64_t TTreeCache::fLastMiss {-1}. protected . ! set to the event # of the last miss. ; Definition at line 74 of file TTreeCache.h. ◆ fLearnPrefilling. bool TTreeCache::fLearnPrefilling {false}. protected . ! true if we are in the process of executing LearnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCache.h. ◆ fNMissReadMiss. Int_t TTreeCache::fNMissReadMiss {0}. protected . Number of blocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:55528,Performance,cache,cache,55528,"of the last miss. ; Definition at line 74 of file TTreeCache.h. ◆ fLearnPrefilling. bool TTreeCache::fLearnPrefilling {false}. protected . ! true if we are in the process of executing LearnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCache.h. ◆ fNMissReadMiss. Int_t TTreeCache::fNMissReadMiss {0}. protected . Number of blocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCa",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:55562,Performance,cache,cache,55562,"of the last miss. ; Definition at line 74 of file TTreeCache.h. ◆ fLearnPrefilling. bool TTreeCache::fLearnPrefilling {false}. protected . ! true if we are in the process of executing LearnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCache.h. ◆ fNMissReadMiss. Int_t TTreeCache::fNMissReadMiss {0}. protected . Number of blocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCa",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:55733,Performance,cache,cache,55733,"rnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCache.h. ◆ fNMissReadMiss. Int_t TTreeCache::fNMissReadMiss {0}. protected . Number of blocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ f",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:55889,Performance,cache,cache,55889," ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCache.h. ◆ fNMissReadMiss. Int_t TTreeCache::fNMissReadMiss {0}. protected . Number of blocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ fReadDirectionSet. bool TTreeCache::fReadDirectionSet {false}. protected . ! read direction established ; Definition at line 62 of file TTreeCache.h. ◆ fReverse",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:56037,Performance,cache,cache,56037,"tion at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCache.h. ◆ fNMissReadMiss. Int_t TTreeCache::fNMissReadMiss {0}. protected . Number of blocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ fReadDirectionSet. bool TTreeCache::fReadDirectionSet {false}. protected . ! read direction established ; Definition at line 62 of file TTreeCache.h. ◆ fReverseRead. bool TTreeCache::fReverseRead {false}. protected . ! reading in reverse mode ; Definition at line 58 of file TTreeCache.h. ◆ fTree. TTree* TTree",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:56462,Performance,optimiz,optimize,56462,"◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ fReadDirectionSet. bool TTreeCache::fReadDirectionSet {false}. protected . ! read direction established ; Definition at line 62 of file TTreeCache.h. ◆ fReverseRead. bool TTreeCache::fReverseRead {false}. protected . ! reading in reverse mode ; Definition at line 58 of file TTreeCache.h. ◆ fTree. TTree* TTreeCache::fTree {nullptr}. protected . ! pointer to the current Tree ; Definition at line 53 of file TTreeCache.h. Libraries for TTreeCache:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TTreeCache.h; tree/tree/src/TTreeCache.cxx. TTreeCache. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:13 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:56471,Performance,cache,cache,56471,"◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ fReadDirectionSet. bool TTreeCache::fReadDirectionSet {false}. protected . ! read direction established ; Definition at line 62 of file TTreeCache.h. ◆ fReverseRead. bool TTreeCache::fReverseRead {false}. protected . ! reading in reverse mode ; Definition at line 58 of file TTreeCache.h. ◆ fTree. TTree* TTreeCache::fTree {nullptr}. protected . ! pointer to the current Tree ; Definition at line 53 of file TTreeCache.h. Libraries for TTreeCache:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TTreeCache.h; tree/tree/src/TTreeCache.cxx. TTreeCache. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:13 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:5938,Safety,predict,predicting,5938,"h a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTr",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:6892,Safety,avoid,avoid,6892,"TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<<",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:2763,Security,access,accessed,2763,"cks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache.",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:4761,Security,access,accessed,4761,"automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these ca",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:4789,Security,access,accessed,4789,"automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these ca",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:21879,Security,hash,hash,21879," Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:2495,Usability,learn,learning,2495,"each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TE",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:2515,Usability,learn,learning,2515,"selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache i",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:3701,Usability,learn,learning,3701,"cular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observati",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:3961,Usability,learn,learning,3961,"ge the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a tri",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:4065,Usability,learn,learning,4065,"led with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:4192,Usability,learn,learning,4192,"is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:4226,Usability,learn,learning,4226,"is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:4570,Usability,learn,learning,4570," kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases ar",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:6097,Usability,learn,learning,6097,"he misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:8373,Usability,learn,learning,8373,"inition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Process we read only 2 branches; auto b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; auto b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... Here the entry is processed; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2144; ; Custom event loop; Always using the same two branches; In this example, exactly two branches are always used: those need to be prefetched. TTree *T;; f->GetObject(T, ""mytree"");; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1, true); //<<< add branch1 and branch2 to the cache; T->AddBranchToCache(b2, true); //<<<; T->StopCacheLearningPhase(); //<<< we do not need the system to guess anything; for (auto i : TSeqL(nentries)) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:14609,Usability,learn,learning,14609,"virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this infor",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:15224,Usability,simpl,simply,15224,"IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of St",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:15231,Usability,clear,clear,15231,"IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of St",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:15886,Usability,learn,learning,15886,"from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void A",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:16260,Usability,learn,learning,16260," ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches used by the underlying implementation. ;  ; virtual Int_t GetBufferSize () const;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; TFile * GetFile",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:26467,Usability,learn,learning,26467,"t (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetLearnEntries ();  Static function returning the number of entries used to train the cache see SetLearnEntries. ;  ; static void SetLearnEntries (Int_t n=10);  Static function to set the number of entries to be used in learning mode The default value for n is 10. ;  ;  Static Public Member Functions inherited from TFileCacheRead; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; T",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:28370,Usability,learn,learning,28370,"  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:29421,Usability,learn,learning,29421,"Phase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocat",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:32165,Usability,learn,learning,32165,"eReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCache (const TTreeCache &)=delete;  this class cannot be copied ;  ; bool CalculateMissCache ();  Calculate the appropriate miss cache to fetch; helper function for FillMissCache. ;  ; TBranch * CalculateMissEntries (Long64_t, int, bool);  Given an file read, try to determine the corresponding branch. ;  ; bool CheckMissCache (char *buf, Long64_t pos, int len);  Check the miss cache for a particular buffer, fetching if deemed necessary. ;  ; bool FillMissCache ();  Fill the miss cache from the current set of active branches. ;  ; IOPos FindBranchBasketPos (TBranch &, Long64_t entry);  Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ;  ; TTreeCache & operator= (const TTreeCache &)=delete;  ; bool ProcessMiss (Long64_t pos, int len);  ! Given a file read not in the miss cache, handle (possibly) loading the data. ;  . Additional Inherited Members;  ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:35142,Usability,learn,learning,35142,"efault Constructor. ; Definition at line 313 of file TTreeCache.cxx. ◆ TTreeCache() [3/3]. TTreeCache::TTreeCache ; (; TTree * ; tree, . Int_t ; buffersize = 0 . ). Constructor. ; Definition at line 320 of file TTreeCache.cxx. ◆ ~TTreeCache(). TTreeCache::~TTreeCache ; (; ). override . Destructor. (in general called by the TFile destructor) ; Definition at line 332 of file TTreeCache.cxx. Member Function Documentation. ◆ AddBranch() [1/2]. Int_t TTreeCache::AddBranch ; (; const char * ; bname, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 446 of file TTreeCache.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCache::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ; The branch is added even if we are outside of the training phase. Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 376 of file TTreeCache.cxx. ◆ CalculateMissCache(). bool TTreeCache::CalculateMissCache ; (; ). private . Calculate the appropriate miss cache to fetch; helper function for FillMissCache. . ◆ CalculateMissEntries(). TBranch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:38516,Usability,learn,learning,38516,"Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 175 of file TTreeCache.h. ◆ DeclFileName(). static const char * TTreeCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 175 of file TTreeCache.h. ◆ Disable(). virtual void TTreeCache::Disable ; (; ). inlinevirtual . Definition at line 136 of file TTreeCache.h. ◆ DropBranch() [1/2]. Int_t TTreeCache::DropBranch ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:43654,Usability,learn,learning,43654,"Cache.h. ◆ IsAutoCreated(). bool TTreeCache::IsAutoCreated ; (; ); const. inline . Definition at line 150 of file TTreeCache.h. ◆ IsEnabled(). virtual bool TTreeCache::IsEnabled ; (; ); const. inlinevirtual . Definition at line 151 of file TTreeCache.h. ◆ IsLearning(). bool TTreeCache::IsLearning ; (; ); const. inlineoverridevirtual . Reimplemented from TFileCacheRead.; Definition at line 152 of file TTreeCache.h. ◆ LearnBranch(). Int_t TTreeCache::LearnBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ; Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2250 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPo",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:47673,Usability,simpl,simply,47673,"f selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:47680,Usability,clear,clear,47680,"f selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:49429,Usability,learn,learning,49429,"ead Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the fu",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:49673,Usability,learn,learning,49673,"::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition a",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:50403,Usability,simpl,simply,50403,"of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2169 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerN",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:50682,Usability,learn,learning,50682,"ual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2169 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerNVirtual(). void TTreeCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file TTreeCache.h. ◆ UpdateBranches(). void TTreeCache::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to ",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:50900,Usability,learn,learning,50900,":kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2169 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerNVirtual(). void TTreeCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file TTreeCache.h. ◆ UpdateBranches(). void TTreeCache::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to current Tree and recompute pointers to the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2210 of file TTreeCache.cxx. Member Data Documentation. ◆ fAutoCreated. bool TTreeCache::fAutoC",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:54081,Usability,learn,learning,54081,xt {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set to the event # of the first miss. ; Definition at line 73 of file TTreeCache.h. ◆ fFirstTime. bool TTreeCache::fFirstTime {true}. protected . ! save the fact that we processes the first entry ; Definition at line 60 of file TTreeCache.h. ◆ fgLearnEntries. Int_t TTreeCache::fgLearnEntries = 100. staticprotected . number of entries used for learning mode ; Definition at line 65 of file TTreeCache.h. ◆ fIsLearning. bool TTreeCache::fIsLearning {true}. protected . ! true if cache is in learning mode ; Definition at line 54 of file TTreeCache.h. ◆ fIsManual. bool TTreeCache::fIsManual {false}. protected . ! true if cache is StopLearningPhase was used ; Definition at line 55 of file TTreeCache.h. ◆ fLastMiss. Long64_t TTreeCache::fLastMiss {-1}. protected . ! set to the event # of the last miss. ; Definition at line 74 of file TTreeCache.h. ◆ fLearnPrefilling. bool TTreeCache::fLearnPrefilling {false}. protected . ! true if we are in the process of executing LearnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCac,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:54227,Usability,learn,learning,54227,llTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set to the event # of the first miss. ; Definition at line 73 of file TTreeCache.h. ◆ fFirstTime. bool TTreeCache::fFirstTime {true}. protected . ! save the fact that we processes the first entry ; Definition at line 60 of file TTreeCache.h. ◆ fgLearnEntries. Int_t TTreeCache::fgLearnEntries = 100. staticprotected . number of entries used for learning mode ; Definition at line 65 of file TTreeCache.h. ◆ fIsLearning. bool TTreeCache::fIsLearning {true}. protected . ! true if cache is in learning mode ; Definition at line 54 of file TTreeCache.h. ◆ fIsManual. bool TTreeCache::fIsManual {false}. protected . ! true if cache is StopLearningPhase was used ; Definition at line 55 of file TTreeCache.h. ◆ fLastMiss. Long64_t TTreeCache::fLastMiss {-1}. protected . ! set to the event # of the last miss. ; Definition at line 74 of file TTreeCache.h. ◆ fLearnPrefilling. bool TTreeCache::fLearnPrefilling {false}. protected . ! true if we are in the process of executing LearnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCach,MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCache.html:56308,Usability,learn,learning,56308,"ocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ fReadDirectionSet. bool TTreeCache::fReadDirectionSet {false}. protected . ! read direction established ; Definition at line 62 of file TTreeCache.h. ◆ fReverseRead. bool TTreeCache::fReverseRead {false}. protected . ! reading in reverse mode ; Definition at line 58 of file TTreeCache.h. ◆ fTree. TTree* TTreeCache::fTree {nullptr}. protected . ! pointer to the current Tree ; Definition at line 53 of file TTreeCache.h. Libraries for TTreeCache:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TTreeCache.h; tree/tree/src/TTreeCache.cxx. TTreeCache. ROOT v6-32 - Refe",MatchSource.WIKI,doc/v632/classTTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:2653,Availability,failure,failure,2653," (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t AddBranch (TBranch *b, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t CreateTasks ();  We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ;  ; bool FillBuffer () override;  Fill the cache buffer with the branches in the cache. ;  ; Int_t GetNFound ();  ; Int_t GetNMissed ();  ; Int_t GetNUnzip ();  ; Int_t GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache.",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:6378,Availability,error,error,6378,"ource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:11308,Availability,error,error,11308,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:11397,Availability,error,error,11397,"ar *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns strin",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:11552,Availability,error,error,11552,";  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title o",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:11849,Availability,error,error,11849,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:16292,Availability,error,error,16292,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static EParUnzipMode GetParallelUnzip ();  Static function that returns the parallel option (to indicate an additional thread) ;  ; static bool IsPa",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:27504,Availability,error,error,27504,"nished . Definition at line 43 of file TTreeCacheUnzip.h. Constructor & Destructor Documentation. ◆ TTreeCacheUnzip() [1/3]. TTreeCacheUnzip::TTreeCacheUnzip ; (; const TTreeCacheUnzip & ; ). privatedelete . ◆ TTreeCacheUnzip() [2/3]. TTreeCacheUnzip::TTreeCacheUnzip ; (; ). Definition at line 159 of file TTreeCacheUnzip.cxx. ◆ TTreeCacheUnzip() [3/3]. TTreeCacheUnzip::TTreeCacheUnzip ; (; TTree * ; tree, . Int_t ; buffersize = 0 . ). Constructor. ; Definition at line 178 of file TTreeCacheUnzip.cxx. ◆ ~TTreeCacheUnzip(). TTreeCacheUnzip::~TTreeCacheUnzip ; (; ). override . Destructor. (in general called by the TFile destructor) ; Definition at line 235 of file TTreeCacheUnzip.cxx. Member Function Documentation. ◆ AddBranch() [1/2]. Int_t TTreeCacheUnzip::AddBranch ; (; const char * ; branch, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 260 of file TTreeCacheUnzip.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCacheUnzip::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 248 of file TTreeCacheUnzip.cxx. ◆ Class(). static TClass * TTreeCacheUnzip::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_t TTreeCacheUnzip::CreateTasks ; (; ). We create a TTaskGroup and asynchronously maps",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:27884,Availability,error,error,27884,"heUnzip ; (; TTree * ; tree, . Int_t ; buffersize = 0 . ). Constructor. ; Definition at line 178 of file TTreeCacheUnzip.cxx. ◆ ~TTreeCacheUnzip(). TTreeCacheUnzip::~TTreeCacheUnzip ; (; ). override . Destructor. (in general called by the TFile destructor) ; Definition at line 235 of file TTreeCacheUnzip.cxx. Member Function Documentation. ◆ AddBranch() [1/2]. Int_t TTreeCacheUnzip::AddBranch ; (; const char * ; branch, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 260 of file TTreeCacheUnzip.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCacheUnzip::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 248 of file TTreeCacheUnzip.cxx. ◆ Class(). static TClass * TTreeCacheUnzip::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_t TTreeCacheUnzip::CreateTasks ; (; ). We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ; In TTaskGroup, we use TThreadExecutor to do the actually work of unzipping a group of basket. The purpose of creating TTaskGroup is to avoid competing with main thread. ; Definition at line 613 of file TTreeCacheUnzip.cxx. ◆ DeclFileName(). static const char * TTreeCacheUnzip::DeclFileName ; (; ). inlinestatic . ReturnsName",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:30769,Availability,failure,failure,30769,"ordHeader(). Int_t TTreeCacheUnzip::GetRecordHeader ; (; char * ; buf, . Int_t ; maxbytes, . Int_t & ; nbytes, . Int_t & ; objlen, . Int_t & ; keylen . ). Read the logical record header from the buffer buf. ; That must be the pointer tho the header part not the object by itself and must contain data of at least maxbytes Returns nread;; In output arguments:. nbytes : number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header. Note that the arguments objlen and keylen are returned only if maxbytes >=16 Note: This was adapted from TFile... so some things dont apply ; Definition at line 469 of file TTreeCacheUnzip.cxx. ◆ GetUnzipBuffer(). Int_t TTreeCacheUnzip::GetUnzipBuffer ; (; char ** ; buf, . Long64_t ; pos, . Int_t ; len, . bool * ; free . ). overridevirtual . We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ; pos and len are the original values as were passed to ReadBuffer but instead we will return the inflated buffer. Note!! : If *buf == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer ; Reimplemented from TFileCacheRead.; Definition at line 668 of file TTreeCacheUnzip.cxx. ◆ GetUnzipGroupSize(). Int_t TTreeCacheUnzip::GetUnzipGroupSize ; (; ). inline . Definition at line 142 of file TTreeCacheUnzip.h. ◆ Init(). void TTreeCacheUnzip::Init ; (; ). private . Initialization procedure common to all the constructors. ; Definition at line 196 of file TTreeCacheUnzip.cxx. ◆ IsA(). TClass * TTreeCacheUnzip::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TTreeCache.; Definition at line 159 of file TTreeCacheUnzip.h. ◆ IsParallelUnzip(). bool TTree",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:34880,Availability,avail,available,34880,"eCacheUnzip::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). overridevirtual . Reimplemented from TFileCacheRead.; Definition at line 961 of file TTreeCacheUnzip.cxx. ◆ ResetCache(). void TTreeCacheUnzip::ResetCache ; (; ). overridevirtual . This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 501 of file TTreeCacheUnzip.cxx. ◆ SetBufferSize(). Int_t TTreeCacheUnzip::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TTreeCache.; Definition at line 359 of file TTreeCacheUnzip.cxx. ◆ SetEntryRange(). void TTreeCacheUnzip::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). overridevirtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 375 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::SetParallelUnzip ; (; TTreeCacheUnzip::EParUnzipMode ; option = TTreeCacheUnzip::kEnable). static . Static function that (de)activates multithreading unzipping. ; The possible options are:; kEnable Enable it, which causes an automatic detection and launches the additional thread if the number of cores in the machine is greater than one; kDisable Disable will not activate the additional thread.; kForce Force will start the additional th",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:34963,Availability,error,error,34963,"eCacheUnzip::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). overridevirtual . Reimplemented from TFileCacheRead.; Definition at line 961 of file TTreeCacheUnzip.cxx. ◆ ResetCache(). void TTreeCacheUnzip::ResetCache ; (; ). overridevirtual . This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 501 of file TTreeCacheUnzip.cxx. ◆ SetBufferSize(). Int_t TTreeCacheUnzip::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TTreeCache.; Definition at line 359 of file TTreeCacheUnzip.cxx. ◆ SetEntryRange(). void TTreeCacheUnzip::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). overridevirtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 375 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::SetParallelUnzip ; (; TTreeCacheUnzip::EParUnzipMode ; option = TTreeCacheUnzip::kEnable). static . Static function that (de)activates multithreading unzipping. ; The possible options are:; kEnable Enable it, which causes an automatic detection and launches the additional thread if the number of cores in the machine is greater than one; kDisable Disable will not activate the additional thread.; kForce Force will start the additional th",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:36003,Availability,error,error,36003,"e.; Definition at line 359 of file TTreeCacheUnzip.cxx. ◆ SetEntryRange(). void TTreeCacheUnzip::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). overridevirtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 375 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::SetParallelUnzip ; (; TTreeCacheUnzip::EParUnzipMode ; option = TTreeCacheUnzip::kEnable). static . Static function that (de)activates multithreading unzipping. ; The possible options are:; kEnable Enable it, which causes an automatic detection and launches the additional thread if the number of cores in the machine is greater than one; kDisable Disable will not activate the additional thread.; kForce Force will start the additional thread even if there is only one core. the default will be taken as kEnable. Returns 0 if there was an error, 1 otherwise. ; Definition at line 436 of file TTreeCacheUnzip.cxx. ◆ SetUnzipBufferSize(). void TTreeCacheUnzip::SetUnzipBufferSize ; (; Long64_t ; bufferSize). Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ; Definition at line 839 of file TTreeCacheUnzip.cxx. ◆ SetUnzipGroupSize(). void TTreeCacheUnzip::SetUnzipGroupSize ; (; Int_t ; groupSize). inline . Definition at line 146 of file TTreeCacheUnzip.h. ◆ SetUnzipRelBufferSize(). void TTreeCacheUnzip::SetUnzipRelBufferSize ; (; Float_t ; relbufferSize). static . static function: Sets the unzip relative buffer size ; Definition at line 830 of file TTreeCacheUnzip.cxx. ◆ StopLearningPhase(). void TTreeCacheUnzip::StopLearningPhase ; (; ). overridevirtual . It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ; Reimplemented from TTreeCache.; Definition at line 384 of file TTreeCacheUnzip.cxx. ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:37538,Availability,error,error,37538,"lbufferSize). static . static function: Sets the unzip relative buffer size ; Definition at line 830 of file TTreeCacheUnzip.cxx. ◆ StopLearningPhase(). void TTreeCacheUnzip::StopLearningPhase ; (; ). overridevirtual . It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ; Reimplemented from TTreeCache.; Definition at line 384 of file TTreeCacheUnzip.cxx. ◆ Streamer(). void TTreeCacheUnzip::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TTreeCache. ◆ StreamerNVirtual(). void TTreeCacheUnzip::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 159 of file TTreeCacheUnzip.h. ◆ UnzipBuffer(). Int_t TTreeCacheUnzip::UnzipBuffer ; (; char ** ; dest, . char * ; src . ). Unzips a ROOT specific buffer... by reading the header at the beginning. ; returns the size of the inflated buffer or -1 if error Note!! : If *dest == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer src is the original buffer with the record (header+compressed data) *dest is the inflated buffer (including the header) ; Definition at line 853 of file TTreeCacheUnzip.cxx. ◆ UnzipCache(). Int_t TTreeCacheUnzip::UnzipCache ; (; Int_t ; index). This inflates a basket in the cache. ; . passing the data to a new buffer that will only wait there to be read... This function is responsible to update corresponding elements in fUnzipStatus, fUnzipChunks and fUnzipLen. Since we use atomic variables in fUnzipStatus to exclusively unzip the basket, we must update fUnzipStatus after fUnzipChunks and fUnzipLen and make sure fUnzipChunks and fUnzipLen are ready before main thread fetch the data. ; Definition at line 526 of file TTreeCacheUnzip.cxx. ◆ UpdateBranches(). void TTreeCacheUnzip::UpdateBranches ; (; TTree * ; tree). overridevirtual . update p",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:4219,Deployability,update,update,4219,"x) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as th",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:38110,Deployability,update,update,38110,"mented from TTreeCache. ◆ StreamerNVirtual(). void TTreeCacheUnzip::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 159 of file TTreeCacheUnzip.h. ◆ UnzipBuffer(). Int_t TTreeCacheUnzip::UnzipBuffer ; (; char ** ; dest, . char * ; src . ). Unzips a ROOT specific buffer... by reading the header at the beginning. ; returns the size of the inflated buffer or -1 if error Note!! : If *dest == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer src is the original buffer with the record (header+compressed data) *dest is the inflated buffer (including the header) ; Definition at line 853 of file TTreeCacheUnzip.cxx. ◆ UnzipCache(). Int_t TTreeCacheUnzip::UnzipCache ; (; Int_t ; index). This inflates a basket in the cache. ; . passing the data to a new buffer that will only wait there to be read... This function is responsible to update corresponding elements in fUnzipStatus, fUnzipChunks and fUnzipLen. Since we use atomic variables in fUnzipStatus to exclusively unzip the basket, we must update fUnzipStatus after fUnzipChunks and fUnzipLen and make sure fUnzipChunks and fUnzipLen are ready before main thread fetch the data. ; Definition at line 526 of file TTreeCacheUnzip.cxx. ◆ UpdateBranches(). void TTreeCacheUnzip::UpdateBranches ; (; TTree * ; tree). overridevirtual . update pointer to current Tree and recompute pointers to the branches in the cache ; Reimplemented from TTreeCache.; Definition at line 392 of file TTreeCacheUnzip.cxx. Member Data Documentation. ◆ fAsyncReading. bool TTreeCacheUnzip::fAsyncReading. protected . Definition at line 81 of file TTreeCacheUnzip.h. ◆ fCompBuffer. char* TTreeCacheUnzip::fCompBuffer. private . Definition at line 112 of file TTreeCacheUnzip.h. ◆ fCompBufferSize. Int_t TTreeCacheUnzip::fCompBufferSize. private . Definition at line 113 of file TTreeCacheUnzip.h. ◆ fCycle. Int_t TTreeCacheUn",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:38272,Deployability,update,update,38272,"file TTreeCacheUnzip.h. ◆ UnzipBuffer(). Int_t TTreeCacheUnzip::UnzipBuffer ; (; char ** ; dest, . char * ; src . ). Unzips a ROOT specific buffer... by reading the header at the beginning. ; returns the size of the inflated buffer or -1 if error Note!! : If *dest == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer src is the original buffer with the record (header+compressed data) *dest is the inflated buffer (including the header) ; Definition at line 853 of file TTreeCacheUnzip.cxx. ◆ UnzipCache(). Int_t TTreeCacheUnzip::UnzipCache ; (; Int_t ; index). This inflates a basket in the cache. ; . passing the data to a new buffer that will only wait there to be read... This function is responsible to update corresponding elements in fUnzipStatus, fUnzipChunks and fUnzipLen. Since we use atomic variables in fUnzipStatus to exclusively unzip the basket, we must update fUnzipStatus after fUnzipChunks and fUnzipLen and make sure fUnzipChunks and fUnzipLen are ready before main thread fetch the data. ; Definition at line 526 of file TTreeCacheUnzip.cxx. ◆ UpdateBranches(). void TTreeCacheUnzip::UpdateBranches ; (; TTree * ; tree). overridevirtual . update pointer to current Tree and recompute pointers to the branches in the cache ; Reimplemented from TTreeCache.; Definition at line 392 of file TTreeCacheUnzip.cxx. Member Data Documentation. ◆ fAsyncReading. bool TTreeCacheUnzip::fAsyncReading. protected . Definition at line 81 of file TTreeCacheUnzip.h. ◆ fCompBuffer. char* TTreeCacheUnzip::fCompBuffer. private . Definition at line 112 of file TTreeCacheUnzip.h. ◆ fCompBufferSize. Int_t TTreeCacheUnzip::fCompBufferSize. private . Definition at line 113 of file TTreeCacheUnzip.h. ◆ fCycle. Int_t TTreeCacheUnzip::fCycle. protected . Definition at line 83 of file TTreeCacheUnzip.h. ◆ fEmpty. bool TTreeCacheUnzip::fEmpty. protected . Definition at line 82 of file TTreeCache",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:38562,Deployability,update,update,38562,"nsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer src is the original buffer with the record (header+compressed data) *dest is the inflated buffer (including the header) ; Definition at line 853 of file TTreeCacheUnzip.cxx. ◆ UnzipCache(). Int_t TTreeCacheUnzip::UnzipCache ; (; Int_t ; index). This inflates a basket in the cache. ; . passing the data to a new buffer that will only wait there to be read... This function is responsible to update corresponding elements in fUnzipStatus, fUnzipChunks and fUnzipLen. Since we use atomic variables in fUnzipStatus to exclusively unzip the basket, we must update fUnzipStatus after fUnzipChunks and fUnzipLen and make sure fUnzipChunks and fUnzipLen are ready before main thread fetch the data. ; Definition at line 526 of file TTreeCacheUnzip.cxx. ◆ UpdateBranches(). void TTreeCacheUnzip::UpdateBranches ; (; TTree * ; tree). overridevirtual . update pointer to current Tree and recompute pointers to the branches in the cache ; Reimplemented from TTreeCache.; Definition at line 392 of file TTreeCacheUnzip.cxx. Member Data Documentation. ◆ fAsyncReading. bool TTreeCacheUnzip::fAsyncReading. protected . Definition at line 81 of file TTreeCacheUnzip.h. ◆ fCompBuffer. char* TTreeCacheUnzip::fCompBuffer. private . Definition at line 112 of file TTreeCacheUnzip.h. ◆ fCompBufferSize. Int_t TTreeCacheUnzip::fCompBufferSize. private . Definition at line 113 of file TTreeCacheUnzip.h. ◆ fCycle. Int_t TTreeCacheUnzip::fCycle. protected . Definition at line 83 of file TTreeCacheUnzip.h. ◆ fEmpty. bool TTreeCacheUnzip::fEmpty. protected . Definition at line 82 of file TTreeCacheUnzip.h. ◆ fgParallel. TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::fgParallel = TTreeCacheUnzip::kDisable. staticprotected . Indicate if we want to activate the parallelism. ; Definition at line 88 of file TTreeCacheUnzip.h. ◆ fgRelBuffSize. Double_t TTreeCacheUnzip::fgRelBuffSize = .5. staticprotected . This is the ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:30435,Energy Efficiency,adapt,adapted,30435,"acheUnzip.h. ◆ GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. ◆ GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel option (to indicate an additional thread) ; Definition at line 407 of file TTreeCacheUnzip.cxx. ◆ GetRecordHeader(). Int_t TTreeCacheUnzip::GetRecordHeader ; (; char * ; buf, . Int_t ; maxbytes, . Int_t & ; nbytes, . Int_t & ; objlen, . Int_t & ; keylen . ). Read the logical record header from the buffer buf. ; That must be the pointer tho the header part not the object by itself and must contain data of at least maxbytes Returns nread;; In output arguments:. nbytes : number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header. Note that the arguments objlen and keylen are returned only if maxbytes >=16 Note: This was adapted from TFile... so some things dont apply ; Definition at line 469 of file TTreeCacheUnzip.cxx. ◆ GetUnzipBuffer(). Int_t TTreeCacheUnzip::GetUnzipBuffer ; (; char ** ; buf, . Long64_t ; pos, . Int_t ; len, . bool * ; free . ). overridevirtual . We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ; pos and len are the original values as were passed to ReadBuffer but instead we will return the inflated buffer. Note!! : If *buf == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer ; Reimplemented from TFileCacheRead.; Definition at line 668 of file TTreeCacheUnzip.cxx. ◆ GetUnzipGroupSize(). Int_t TTreeCacheUnzip::GetUnzipGroupSize ; (; ). inline . Definition at line 142 of file TTreeCacheUnzip.h. ◆ Init(). void TTree",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:31013,Energy Efficiency,allocate,allocate,31013," object by itself and must contain data of at least maxbytes Returns nread;; In output arguments:. nbytes : number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header. Note that the arguments objlen and keylen are returned only if maxbytes >=16 Note: This was adapted from TFile... so some things dont apply ; Definition at line 469 of file TTreeCacheUnzip.cxx. ◆ GetUnzipBuffer(). Int_t TTreeCacheUnzip::GetUnzipBuffer ; (; char ** ; buf, . Long64_t ; pos, . Int_t ; len, . bool * ; free . ). overridevirtual . We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ; pos and len are the original values as were passed to ReadBuffer but instead we will return the inflated buffer. Note!! : If *buf == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer ; Reimplemented from TFileCacheRead.; Definition at line 668 of file TTreeCacheUnzip.cxx. ◆ GetUnzipGroupSize(). Int_t TTreeCacheUnzip::GetUnzipGroupSize ; (; ). inline . Definition at line 142 of file TTreeCacheUnzip.h. ◆ Init(). void TTreeCacheUnzip::Init ; (; ). private . Initialization procedure common to all the constructors. ; Definition at line 196 of file TTreeCacheUnzip.cxx. ◆ IsA(). TClass * TTreeCacheUnzip::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TTreeCache.; Definition at line 159 of file TTreeCacheUnzip.h. ◆ IsParallelUnzip(). bool TTreeCacheUnzip::IsParallelUnzip ; (; ). static . Static function that tells wether the multithreading unzipping is activated. ; Definition at line 415 of file TTreeCacheUnzip.cxx. ◆ operator=(). TTreeCacheUnzip & TTreeCacheUnzip::operator= ; (; const TTreeCacheUnz",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:37575,Energy Efficiency,allocate,allocate,37575,"lbufferSize). static . static function: Sets the unzip relative buffer size ; Definition at line 830 of file TTreeCacheUnzip.cxx. ◆ StopLearningPhase(). void TTreeCacheUnzip::StopLearningPhase ; (; ). overridevirtual . It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ; Reimplemented from TTreeCache.; Definition at line 384 of file TTreeCacheUnzip.cxx. ◆ Streamer(). void TTreeCacheUnzip::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TTreeCache. ◆ StreamerNVirtual(). void TTreeCacheUnzip::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 159 of file TTreeCacheUnzip.h. ◆ UnzipBuffer(). Int_t TTreeCacheUnzip::UnzipBuffer ; (; char ** ; dest, . char * ; src . ). Unzips a ROOT specific buffer... by reading the header at the beginning. ; returns the size of the inflated buffer or -1 if error Note!! : If *dest == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer src is the original buffer with the record (header+compressed data) *dest is the inflated buffer (including the header) ; Definition at line 853 of file TTreeCacheUnzip.cxx. ◆ UnzipCache(). Int_t TTreeCacheUnzip::UnzipCache ; (; Int_t ; index). This inflates a basket in the cache. ; . passing the data to a new buffer that will only wait there to be read... This function is responsible to update corresponding elements in fUnzipStatus, fUnzipChunks and fUnzipLen. Since we use atomic variables in fUnzipStatus to exclusively unzip the basket, we must update fUnzipStatus after fUnzipChunks and fUnzipLen and make sure fUnzipChunks and fUnzipLen are ready before main thread fetch the data. ; Definition at line 526 of file TTreeCacheUnzip.cxx. ◆ UpdateBranches(). void TTreeCacheUnzip::UpdateBranches ; (; TTree * ; tree). overridevirtual . update p",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:11314,Integrability,message,message,11314,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:11855,Integrability,message,message,11855,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:13057,Integrability,message,message,13057,"ived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this metho",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:16298,Integrability,message,message,16298,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static EParUnzipMode GetParallelUnzip ();  Static function that returns the parallel option (to indicate an additional thread) ;  ; static bool IsPa",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:16671,Integrability,message,message,16671," Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static EParUnzipMode GetParallelUnzip ();  Static function that returns the parallel option (to indicate an additional thread) ;  ; static bool IsParallelUnzip ();  Static function that tells wether the multithreading unzipping is activated. ;  ; static Int_t SetParallelUnzip (TTreeCacheUnzip::EParUnzipMode option=TTreeCacheUnzip::kEnable);  Static function that (de)activates multithreading unzipping. ;  ; static void SetUnzipRelBufferSize (Float_t relbufferSize);  static function: Sets the unzip relative buffer size ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:734,Modifiability,inherit,inherited,734,". ROOT: TTreeCacheUnzip Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Types |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; Private Attributes |; List of all members ; TTreeCacheUnzip Class ReferenceTree Library. ; A TTreeCache which exploits parallelized decompression of its own content. ; Definition at line 35 of file TTreeCacheUnzip.h. Classes; struct  UnzipState;  . Public Types; enum  EParUnzipMode { kEnable; , kDisable; , kForce; };  ; enum  EUnzipState { kUntouched; , kProgress; , kFinished; };  ;  Public Types inherited from TTreeCache; enum  EPrefillType { kNoPrefill; , kAllBranches; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTreeCacheUnzip ();  ;  TTreeCacheUnzip (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCacheUnzip () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t AddBranch (TBranch *b, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this functio",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:830,Modifiability,inherit,inherited,830,". ROOT: TTreeCacheUnzip Class Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Types |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; Private Attributes |; List of all members ; TTreeCacheUnzip Class ReferenceTree Library. ; A TTreeCache which exploits parallelized decompression of its own content. ; Definition at line 35 of file TTreeCacheUnzip.h. Classes; struct  UnzipState;  . Public Types; enum  EParUnzipMode { kEnable; , kDisable; , kForce; };  ; enum  EUnzipState { kUntouched; , kProgress; , kFinished; };  ;  Public Types inherited from TTreeCache; enum  EPrefillType { kNoPrefill; , kAllBranches; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTreeCacheUnzip ();  ;  TTreeCacheUnzip (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCacheUnzip () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t AddBranch (TBranch *b, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this functio",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:4332,Modifiability,inherit,inherited,4332,"x) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as th",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:5170,Modifiability,variab,variable,5170,"at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () cons",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:7639,Modifiability,inherit,inherited,7639,"pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches used by the underlying implementation. ;  ; virtual Int_t GetBufferSize () const;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; TFile * GetFile () const;  ; virtual Long64_t GetNoCacheBytesRead () const;  ; virtual Int_t GetNoCacheReadCalls () const;  ; Int_t GetNseek () const;  ; Int_t GetNtot () const;  ; Long64_t GetPrefetchedBlocks () const;  ; virtual TFilePrefetch * GetPrefetchObj ();  ; virtual Int_t GetReadCalls () const;  ; virtual Bool_t IsAsyncReading () const;  ; virtual Bool_t IsEnable",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:9547,Modifiability,inherit,inherited,9547,"chObj ();  ; virtual Int_t GetReadCalls () const;  ; virtual Bool_t IsAsyncReading () const;  ; virtual Bool_t IsEnablePrefetching () const;  ; virtual void Prefetch (Long64_t pos, Int_t len);  Add block of length len at position pos in the list of blocks to be prefetched. ;  ; virtual Int_t ReadBufferExtNormal (char *buf, Long64_t pos, Int_t len, Int_t &loc);  Base function for ReadBuffer. ;  ; virtual Int_t ReadBufferExtPrefetch (char *buf, Long64_t pos, Int_t len, Int_t &loc);  prefetch the first block ;  ; virtual void SecondPrefetch (Long64_t, Int_t);  ; virtual void SecondSort ();  Sort buffers to be prefetched in increasing order of positions. ;  ; virtual void SetEnablePrefetching (Bool_t setPrefetching=kFALSE);  Set the prefetching mode of this file. ;  ; virtual void SetSkipZip (Bool_t=kTRUE);  ; virtual void Sort ();  Sort buffers to be prefetched in increasing order of positions. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void WaitFinishPrefetch ();  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (co",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:10944,Modifiability,inherit,inheritance,10944,"pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in de",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:13155,Modifiability,inherit,inherits,13155,"ed by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:13272,Modifiability,inherit,inherits,13272,"ame of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its p",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:17700,Modifiability,inherit,inherited,17700,"s object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static EParUnzipMode GetParallelUnzip ();  Static function that returns the parallel option (to indicate an additional thread) ;  ; static bool IsParallelUnzip ();  Static function that tells wether the multithreading unzipping is activated. ;  ; static Int_t SetParallelUnzip (TTreeCacheUnzip::EParUnzipMode option=TTreeCacheUnzip::kEnable);  Static function that (de)activates multithreading unzipping. ;  ; static void SetUnzipRelBufferSize (Float_t relbufferSize);  static function: Sets the unzip relative buffer size ;  ;  Static Public Member Functions inherited from TTreeCache; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetLearnEntries ();  Static function returning the number of entries used to train the cache see SetLearnEntries. ;  ; static void SetLearnEntries (Int_t n=10);  Static function to set the number of entries to be used in learning mode The default value for n is 10. ;  ;  Static Public Member Functions inherited from TFileCacheRead; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set d",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:18198,Modifiability,inherit,inherited,18198,lelUnzip (TTreeCacheUnzip::EParUnzipMode option=TTreeCacheUnzip::kEnable);  Static function that (de)activates multithreading unzipping. ;  ; static void SetUnzipRelBufferSize (Float_t relbufferSize);  static function: Sets the unzip relative buffer size ;  ;  Static Public Member Functions inherited from TTreeCache; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetLearnEntries ();  Static function returning the number of entries used to train the cache see SetLearnEntries. ;  ; static void SetLearnEntries (Int_t n=10);  Static function to set the number of entries to be used in learning mode The default value for n is 10. ;  ;  Static Public Member Functions inherited from TFileCacheRead; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; typedef struct UnzipState UnzipState_t;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t ,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:18416,Modifiability,inherit,inherited,18416,lelUnzip (TTreeCacheUnzip::EParUnzipMode option=TTreeCacheUnzip::kEnable);  Static function that (de)activates multithreading unzipping. ;  ; static void SetUnzipRelBufferSize (Float_t relbufferSize);  static function: Sets the unzip relative buffer size ;  ;  Static Public Member Functions inherited from TTreeCache; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetLearnEntries ();  Static function returning the number of entries used to train the cache see SetLearnEntries. ;  ; static void SetLearnEntries (Int_t n=10);  Static function to set the number of entries to be used in learning mode The default value for n is 10. ;  ;  Static Public Member Functions inherited from TFileCacheRead; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; typedef struct UnzipState UnzipState_t;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t ,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:18979,Modifiability,inherit,inherited,18979,in the cache see SetLearnEntries. ;  ; static void SetLearnEntries (Int_t n=10);  Static function to set the number of entries to be used in learning mode The default value for n is 10. ;  ;  Static Public Member Functions inherited from TFileCacheRead; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; typedef struct UnzipState UnzipState_t;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t fNStalls;  ! number of hits which caused a stall ;  ; Int_t fNUnzip;  ! number of blocks that were unzipped ;  ; bool fParallel;  Indicate if we want to activate the parallelism (for this instance) ;  ; Long64_t fUnzipBufferSize;  ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ;  ; Int_t fUnzipGroupSize;  ! Min accumulated size of a group of baskets ready to be unzipped by a IMT task ;  ; UnzipState_t fUnzipState;  ; std::unique_ptr< ROOT::Experimental::TTaskGroup > fUnzipTaskGroup;  ;  Protected Attributes inherited from TTreeCache; bool ,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:19943,Modifiability,inherit,inherited,19943,rom TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t fNStalls;  ! number of hits which caused a stall ;  ; Int_t fNUnzip;  ! number of blocks that were unzipped ;  ; bool fParallel;  Indicate if we want to activate the parallelism (for this instance) ;  ; Long64_t fUnzipBufferSize;  ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ;  ; Int_t fUnzipGroupSize;  ! Min accumulated size of a group of baskets ready to be unzipped by a IMT task ;  ; UnzipState_t fUnzipState;  ; std::unique_ptr< ROOT::Experimental::TTaskGroup > fUnzipTaskGroup;  ;  Protected Attributes inherited from TTreeCache; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we proc,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:22521,Modifiability,inherit,inherited,22521,"imary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocated size of fBuffer (at a given time) ;  ; Int_t fBufferSizeMin;  Original size of fBuffer. ;  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ; ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:25066,Modifiability,inherit,inherited,25066,"synchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static TTreeCacheUnzip::EParUnzipMode fgParallel = TTreeCacheUnzip::kDisable;  Indicate if we want to activate the parallelism. ;  ; static Double_t fgRelBuffSize = .5;  This is the percentage of the TTreeCacheUnzip that will be used. ;  ;  Static Protected Attributes inherited from TTreeCache; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCacheUnzip (const TTreeCacheUnzip &)=delete;  ; void Init ();  Initialization procedure common to all the constructors. ;  ; TTreeCacheUnzip & operator= (const TTreeCacheUnzip &)=delete;  . Private Attributes; char * fCompBuffer;  ; Int_t fCompBufferSize;  . Additional Inherited Members;  Protected Member Functions inherited from TFileCacheRead; void SetEnablePrefetchingImpl (Bool_t setPrefetching=kFALSE);  TFileCacheRead implementation of SetEnablePrefetching. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TTreeCacheUnzip.h>. Inheritance diagram for TTreeCacheUnzip:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ UnzipState_t. ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:25524,Modifiability,inherit,inherited,25524,"located size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static TTreeCacheUnzip::EParUnzipMode fgParallel = TTreeCacheUnzip::kDisable;  Indicate if we want to activate the parallelism. ;  ; static Double_t fgRelBuffSize = .5;  This is the percentage of the TTreeCacheUnzip that will be used. ;  ;  Static Protected Attributes inherited from TTreeCache; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCacheUnzip (const TTreeCacheUnzip &)=delete;  ; void Init ();  Initialization procedure common to all the constructors. ;  ; TTreeCacheUnzip & operator= (const TTreeCacheUnzip &)=delete;  . Private Attributes; char * fCompBuffer;  ; Int_t fCompBufferSize;  . Additional Inherited Members;  Protected Member Functions inherited from TFileCacheRead; void SetEnablePrefetchingImpl (Bool_t setPrefetching=kFALSE);  TFileCacheRead implementation of SetEnablePrefetching. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TTreeCacheUnzip.h>. Inheritance diagram for TTreeCacheUnzip:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ UnzipState_t. typedef struct UnzipState TTreeCacheUnzip::UnzipState_t. protected . Definition at line 77 of file TTreeCacheUnzip.h. Member Enumeration Documentation. ◆ EParUnzipMode. enum TTreeCacheUnzip::EParUnzipMode. EnumeratorkEnable ; kDisable ; kForce . Definition at line 40 of file TTreeCacheUnzip.h. ◆ EUnzipState. enum TTreeCacheUnzip::EUnzipState. EnumeratorkUntouched ; kProgress ; kFinished . Definition at line 43 of file TTreeCacheUnzip.h. Constructor & Destructor ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:25706,Modifiability,inherit,inherited,25706,". Static Protected Attributes; static TTreeCacheUnzip::EParUnzipMode fgParallel = TTreeCacheUnzip::kDisable;  Indicate if we want to activate the parallelism. ;  ; static Double_t fgRelBuffSize = .5;  This is the percentage of the TTreeCacheUnzip that will be used. ;  ;  Static Protected Attributes inherited from TTreeCache; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCacheUnzip (const TTreeCacheUnzip &)=delete;  ; void Init ();  Initialization procedure common to all the constructors. ;  ; TTreeCacheUnzip & operator= (const TTreeCacheUnzip &)=delete;  . Private Attributes; char * fCompBuffer;  ; Int_t fCompBufferSize;  . Additional Inherited Members;  Protected Member Functions inherited from TFileCacheRead; void SetEnablePrefetchingImpl (Bool_t setPrefetching=kFALSE);  TFileCacheRead implementation of SetEnablePrefetching. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TTreeCacheUnzip.h>. Inheritance diagram for TTreeCacheUnzip:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ UnzipState_t. typedef struct UnzipState TTreeCacheUnzip::UnzipState_t. protected . Definition at line 77 of file TTreeCacheUnzip.h. Member Enumeration Documentation. ◆ EParUnzipMode. enum TTreeCacheUnzip::EParUnzipMode. EnumeratorkEnable ; kDisable ; kForce . Definition at line 40 of file TTreeCacheUnzip.h. ◆ EUnzipState. enum TTreeCacheUnzip::EUnzipState. EnumeratorkUntouched ; kProgress ; kFinished . Definition at line 43 of file TTreeCacheUnzip.h. Constructor & Destructor Documentation. ◆ TTreeCacheUnzip() [1/3]. TTreeCacheUnzip::TTreeCacheUnzip ; (; const TTreeCacheUnzip & ; ). privatedelete . ◆ TTreeCacheUnzip() [2/3]. TTreeCacheUnzip::TTreeCacheUnzip ; (; ). Defi",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:30435,Modifiability,adapt,adapted,30435,"acheUnzip.h. ◆ GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. ◆ GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel option (to indicate an additional thread) ; Definition at line 407 of file TTreeCacheUnzip.cxx. ◆ GetRecordHeader(). Int_t TTreeCacheUnzip::GetRecordHeader ; (; char * ; buf, . Int_t ; maxbytes, . Int_t & ; nbytes, . Int_t & ; objlen, . Int_t & ; keylen . ). Read the logical record header from the buffer buf. ; That must be the pointer tho the header part not the object by itself and must contain data of at least maxbytes Returns nread;; In output arguments:. nbytes : number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header. Note that the arguments objlen and keylen are returned only if maxbytes >=16 Note: This was adapted from TFile... so some things dont apply ; Definition at line 469 of file TTreeCacheUnzip.cxx. ◆ GetUnzipBuffer(). Int_t TTreeCacheUnzip::GetUnzipBuffer ; (; char ** ; buf, . Long64_t ; pos, . Int_t ; len, . bool * ; free . ). overridevirtual . We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ; pos and len are the original values as were passed to ReadBuffer but instead we will return the inflated buffer. Note!! : If *buf == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer ; Reimplemented from TFileCacheRead.; Definition at line 668 of file TTreeCacheUnzip.cxx. ◆ GetUnzipGroupSize(). Int_t TTreeCacheUnzip::GetUnzipGroupSize ; (; ). inline . Definition at line 142 of file TTreeCacheUnzip.h. ◆ Init(). void TTree",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:38205,Modifiability,variab,variables,38205,"file TTreeCacheUnzip.h. ◆ UnzipBuffer(). Int_t TTreeCacheUnzip::UnzipBuffer ; (; char ** ; dest, . char * ; src . ). Unzips a ROOT specific buffer... by reading the header at the beginning. ; returns the size of the inflated buffer or -1 if error Note!! : If *dest == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer src is the original buffer with the record (header+compressed data) *dest is the inflated buffer (including the header) ; Definition at line 853 of file TTreeCacheUnzip.cxx. ◆ UnzipCache(). Int_t TTreeCacheUnzip::UnzipCache ; (; Int_t ; index). This inflates a basket in the cache. ; . passing the data to a new buffer that will only wait there to be read... This function is responsible to update corresponding elements in fUnzipStatus, fUnzipChunks and fUnzipLen. Since we use atomic variables in fUnzipStatus to exclusively unzip the basket, we must update fUnzipStatus after fUnzipChunks and fUnzipLen and make sure fUnzipChunks and fUnzipLen are ready before main thread fetch the data. ; Definition at line 526 of file TTreeCacheUnzip.cxx. ◆ UpdateBranches(). void TTreeCacheUnzip::UpdateBranches ; (; TTree * ; tree). overridevirtual . update pointer to current Tree and recompute pointers to the branches in the cache ; Reimplemented from TTreeCache.; Definition at line 392 of file TTreeCacheUnzip.cxx. Member Data Documentation. ◆ fAsyncReading. bool TTreeCacheUnzip::fAsyncReading. protected . Definition at line 81 of file TTreeCacheUnzip.h. ◆ fCompBuffer. char* TTreeCacheUnzip::fCompBuffer. private . Definition at line 112 of file TTreeCacheUnzip.h. ◆ fCompBufferSize. Int_t TTreeCacheUnzip::fCompBufferSize. private . Definition at line 113 of file TTreeCacheUnzip.h. ◆ fCycle. Int_t TTreeCacheUnzip::fCycle. protected . Definition at line 83 of file TTreeCacheUnzip.h. ◆ fEmpty. bool TTreeCacheUnzip::fEmpty. protected . Definition at line 82 of file TTreeCache",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:1796,Performance,cache,cache,1796,"NotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTreeCacheUnzip ();  ;  TTreeCacheUnzip (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCacheUnzip () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t AddBranch (TBranch *b, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t CreateTasks ();  We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ;  ; bool FillBuffer () override;  Fill the cache buffer with the branches in the cache. ;  ; Int_t GetNFound ();  ; Int_t GetNMissed ();  ; Int_t GetNUnzip ();  ; Int_t GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistic",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:1983,Performance,cache,cache,1983,"NotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTreeCacheUnzip ();  ;  TTreeCacheUnzip (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCacheUnzip () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t AddBranch (TBranch *b, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t CreateTasks ();  We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ;  ; bool FillBuffer () override;  Fill the cache buffer with the branches in the cache. ;  ; Int_t GetNFound ();  ; Int_t GetNMissed ();  ; Int_t GetNUnzip ();  ; Int_t GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistic",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:2215,Performance,cache,cache,2215,"elete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTreeCacheUnzip ();  ;  TTreeCacheUnzip (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCacheUnzip () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t AddBranch (TBranch *b, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t CreateTasks ();  We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ;  ; bool FillBuffer () override;  Fill the cache buffer with the branches in the cache. ;  ; Int_t GetNFound ();  ; Int_t GetNMissed ();  ; Int_t GetNUnzip ();  ; Int_t GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:2253,Performance,cache,cache,2253,"elete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTreeCacheUnzip ();  ;  TTreeCacheUnzip (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCacheUnzip () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t AddBranch (TBranch *b, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t CreateTasks ();  We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ;  ; bool FillBuffer () override;  Fill the cache buffer with the branches in the cache. ;  ; Int_t GetNFound ();  ; Int_t GetNMissed ();  ; Int_t GetNUnzip ();  ; Int_t GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:2688,Performance,cache,cache,2688," (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t AddBranch (TBranch *b, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t CreateTasks ();  We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ;  ; bool FillBuffer () override;  Fill the cache buffer with the branches in the cache. ;  ; Int_t GetNFound ();  ; Int_t GetNMissed ();  ; Int_t GetNUnzip ();  ; Int_t GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache.",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:2720,Performance,cache,cache,2720," (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t AddBranch (TBranch *b, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t CreateTasks ();  We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ;  ; bool FillBuffer () override;  Fill the cache buffer with the branches in the cache. ;  ; Int_t GetNFound ();  ; Int_t GetNMissed ();  ; Int_t GetNUnzip ();  ; Int_t GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache.",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:2879,Performance,cache,cache,2879,"ed by TBranch::GetBasket Returns: ;  ; Int_t AddBranch (TBranch *b, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t CreateTasks ();  We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ;  ; bool FillBuffer () override;  Fill the cache buffer with the branches in the cache. ;  ; Int_t GetNFound ();  ; Int_t GetNMissed ();  ; Int_t GetNUnzip ();  ; Int_t GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buff",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:3077,Performance,cache,cache,3077,"d by TBranch::GetBasket Returns: ;  ; Int_t CreateTasks ();  We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ;  ; bool FillBuffer () override;  Fill the cache buffer with the branches in the cache. ;  ; Int_t GetNFound ();  ; Int_t GetNMissed ();  ; Int_t GetNUnzip ();  ; Int_t GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, cha",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:3120,Performance,cache,cache,3120,"d by TBranch::GetBasket Returns: ;  ; Int_t CreateTasks ();  We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ;  ; bool FillBuffer () override;  Fill the cache buffer with the branches in the cache. ;  ; Int_t GetNFound ();  ; Int_t GetNMissed ();  ; Int_t GetNUnzip ();  ; Int_t GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, cha",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:3223,Performance,cache,cache,3223,"ool FillBuffer () override;  Fill the cache buffer with the branches in the cache. ;  ; Int_t GetNFound ();  ; Int_t GetNMissed ();  ; Int_t GetNUnzip ();  ; Int_t GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:3379,Performance,optimiz,optimize,3379,"GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:3540,Performance,cache,cache,3540,"zipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destr",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:3611,Performance,cache,cache,3611,"ead a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ;",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:4162,Performance,cache,cache,4162,"; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:4296,Performance,cache,cache,4296,"x) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as th",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:4716,Performance,cache,cache,4716,"t_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency (",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:4922,Performance,cache,cache,4922,"ject of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, char *src);  Unzips a ROOT specific buffer... by reading the header at the beginning. ;  ; Int_t UnzipCache (Int_t index);  This inflates a basket in the cache. ;  ; void UpdateBranches (TTree *tree) override;  update pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - rat",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:5260,Performance,cache,cache,5260,"ate pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual u",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:5313,Performance,cache,cache,5313," cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:5451,Performance,cache,cache,5451,"onstructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, at",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:5693,Performance,cache,cache,5693,"ranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the r",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:5746,Performance,cache,cache,5746,"ranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the r",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:5871,Performance,cache,cache,5871,"e a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t Read",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:5908,Performance,cache,cache,5908,"e a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t Read",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:6272,Performance,cache,cache,6272,"ource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:7025,Performance,cache,cache,7025,"nst;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (O",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:7196,Performance,cache,cached,7196,"Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches used by the underlying implementation. ;  ; vi",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:7339,Performance,cache,cache,7339,"is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches used by the underlying implementation. ;  ; virtual Int_t GetBufferSize () const;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; TFile * GetFile () const;  ; virtual Long",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:7454,Performance,cache,cache,7454,"Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches used by the underlying implementation. ;  ; virtual Int_t GetBufferSize () const;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; TFile * GetFile () const;  ; virtual Long64_t GetNoCacheBytesRead () const;  ; virtual Int_t GetNoCacheReadCalls () const;  ; Int_t GetNseek () const;  ; Int_t GetNtot (",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:17982,Performance,cache,cache,17982,"s object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static EParUnzipMode GetParallelUnzip ();  Static function that returns the parallel option (to indicate an additional thread) ;  ; static bool IsParallelUnzip ();  Static function that tells wether the multithreading unzipping is activated. ;  ; static Int_t SetParallelUnzip (TTreeCacheUnzip::EParUnzipMode option=TTreeCacheUnzip::kEnable);  Static function that (de)activates multithreading unzipping. ;  ; static void SetUnzipRelBufferSize (Float_t relbufferSize);  static function: Sets the unzip relative buffer size ;  ;  Static Public Member Functions inherited from TTreeCache; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetLearnEntries ();  Static function returning the number of entries used to train the cache see SetLearnEntries. ;  ; static void SetLearnEntries (Int_t n=10);  Static function to set the number of entries to be used in learning mode The default value for n is 10. ;  ;  Static Public Member Functions inherited from TFileCacheRead; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set d",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:19225,Performance,cache,cache,19225,rom TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t fNStalls;  ! number of hits which caused a stall ;  ; Int_t fNUnzip;  ! number of blocks that were unzipped ;  ; bool fParallel;  Indicate if we want to activate the parallelism (for this instance) ;  ; Long64_t fUnzipBufferSize;  ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ;  ; Int_t fUnzipGroupSize;  ! Min accumulated size of a group of baskets ready to be unzipped by a IMT task ;  ; UnzipState_t fUnzipState;  ; std::unique_ptr< ROOT::Experimental::TTaskGroup > fUnzipTaskGroup;  ;  Protected Attributes inherited from TTreeCache; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we proc,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:19299,Performance,cache,cache,19299,rom TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t fNStalls;  ! number of hits which caused a stall ;  ; Int_t fNUnzip;  ! number of blocks that were unzipped ;  ; bool fParallel;  Indicate if we want to activate the parallelism (for this instance) ;  ; Long64_t fUnzipBufferSize;  ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ;  ; Int_t fUnzipGroupSize;  ! Min accumulated size of a group of baskets ready to be unzipped by a IMT task ;  ; UnzipState_t fUnzipState;  ; std::unique_ptr< ROOT::Experimental::TTaskGroup > fUnzipTaskGroup;  ;  Protected Attributes inherited from TTreeCache; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we proc,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:20008,Performance,cache,cache,20008,rom TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t fNStalls;  ! number of hits which caused a stall ;  ; Int_t fNUnzip;  ! number of blocks that were unzipped ;  ; bool fParallel;  Indicate if we want to activate the parallelism (for this instance) ;  ; Long64_t fUnzipBufferSize;  ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ;  ; Int_t fUnzipGroupSize;  ! Min accumulated size of a group of baskets ready to be unzipped by a IMT task ;  ; UnzipState_t fUnzipState;  ; std::unique_ptr< ROOT::Experimental::TTaskGroup > fUnzipTaskGroup;  ;  Protected Attributes inherited from TTreeCache; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we proc,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:20118,Performance,cache,cache,20118,rom TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t fNStalls;  ! number of hits which caused a stall ;  ; Int_t fNUnzip;  ! number of blocks that were unzipped ;  ; bool fParallel;  Indicate if we want to activate the parallelism (for this instance) ;  ; Long64_t fUnzipBufferSize;  ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ;  ; Int_t fUnzipGroupSize;  ! Min accumulated size of a group of baskets ready to be unzipped by a IMT task ;  ; UnzipState_t fUnzipState;  ; std::unique_ptr< ROOT::Experimental::TTaskGroup > fUnzipTaskGroup;  ;  Protected Attributes inherited from TTreeCache; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we proc,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:20188,Performance,cache,cache,20188,rom TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t fNStalls;  ! number of hits which caused a stall ;  ; Int_t fNUnzip;  ! number of blocks that were unzipped ;  ; bool fParallel;  Indicate if we want to activate the parallelism (for this instance) ;  ; Long64_t fUnzipBufferSize;  ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ;  ; Int_t fUnzipGroupSize;  ! Min accumulated size of a group of baskets ready to be unzipped by a IMT task ;  ; UnzipState_t fUnzipState;  ; std::unique_ptr< ROOT::Experimental::TTaskGroup > fUnzipTaskGroup;  ;  Protected Attributes inherited from TTreeCache; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we proc,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:20333,Performance,cache,cache,20333,rom TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t fNStalls;  ! number of hits which caused a stall ;  ; Int_t fNUnzip;  ! number of blocks that were unzipped ;  ; bool fParallel;  Indicate if we want to activate the parallelism (for this instance) ;  ; Long64_t fUnzipBufferSize;  ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ;  ; Int_t fUnzipGroupSize;  ! Min accumulated size of a group of baskets ready to be unzipped by a IMT task ;  ; UnzipState_t fUnzipState;  ; std::unique_ptr< ROOT::Experimental::TTaskGroup > fUnzipTaskGroup;  ;  Protected Attributes inherited from TTreeCache; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we proc,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:20351,Performance,cache,cached,20351,rom TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t fNStalls;  ! number of hits which caused a stall ;  ; Int_t fNUnzip;  ! number of blocks that were unzipped ;  ; bool fParallel;  Indicate if we want to activate the parallelism (for this instance) ;  ; Long64_t fUnzipBufferSize;  ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ;  ; Int_t fUnzipGroupSize;  ! Min accumulated size of a group of baskets ready to be unzipped by a IMT task ;  ; UnzipState_t fUnzipState;  ; std::unique_ptr< ROOT::Experimental::TTaskGroup > fUnzipTaskGroup;  ;  Protected Attributes inherited from TTreeCache; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we proc,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:20438,Performance,cache,cache,20438,rom TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t fNStalls;  ! number of hits which caused a stall ;  ; Int_t fNUnzip;  ! number of blocks that were unzipped ;  ; bool fParallel;  Indicate if we want to activate the parallelism (for this instance) ;  ; Long64_t fUnzipBufferSize;  ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ;  ; Int_t fUnzipGroupSize;  ! Min accumulated size of a group of baskets ready to be unzipped by a IMT task ;  ; UnzipState_t fUnzipState;  ; std::unique_ptr< ROOT::Experimental::TTaskGroup > fUnzipTaskGroup;  ;  Protected Attributes inherited from TTreeCache; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we proc,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:20494,Performance,cache,cache,20494,rom TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t fNStalls;  ! number of hits which caused a stall ;  ; Int_t fNUnzip;  ! number of blocks that were unzipped ;  ; bool fParallel;  Indicate if we want to activate the parallelism (for this instance) ;  ; Long64_t fUnzipBufferSize;  ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ;  ; Int_t fUnzipGroupSize;  ! Min accumulated size of a group of baskets ready to be unzipped by a IMT task ;  ; UnzipState_t fUnzipState;  ; std::unique_ptr< ROOT::Experimental::TTaskGroup > fUnzipTaskGroup;  ;  Protected Attributes inherited from TTreeCache; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we proc,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:20551,Performance,cache,cache,20551,rom TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t fNStalls;  ! number of hits which caused a stall ;  ; Int_t fNUnzip;  ! number of blocks that were unzipped ;  ; bool fParallel;  Indicate if we want to activate the parallelism (for this instance) ;  ; Long64_t fUnzipBufferSize;  ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ;  ; Int_t fUnzipGroupSize;  ! Min accumulated size of a group of baskets ready to be unzipped by a IMT task ;  ; UnzipState_t fUnzipState;  ; std::unique_ptr< ROOT::Experimental::TTaskGroup > fUnzipTaskGroup;  ;  Protected Attributes inherited from TTreeCache; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we proc,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:20615,Performance,cache,cache,20615,rom TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t fNStalls;  ! number of hits which caused a stall ;  ; Int_t fNUnzip;  ! number of blocks that were unzipped ;  ; bool fParallel;  Indicate if we want to activate the parallelism (for this instance) ;  ; Long64_t fUnzipBufferSize;  ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ;  ; Int_t fUnzipGroupSize;  ! Min accumulated size of a group of baskets ready to be unzipped by a IMT task ;  ; UnzipState_t fUnzipState;  ; std::unique_ptr< ROOT::Experimental::TTaskGroup > fUnzipTaskGroup;  ;  Protected Attributes inherited from TTreeCache; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we proc,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:21053,Performance,cache,cache,21053,"  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:21119,Performance,cache,cache,21119,"  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:21451,Performance,cache,cache,21451,"he cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:21641,Performance,cache,cache,21641,"he cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:21726,Performance,cache,cache,21726,"uffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Lon",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:21760,Performance,cache,cache,21760,"uffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Lon",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:21849,Performance,cache,cache,21849,"tEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:21927,Performance,cache,cache,21927,"set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:21999,Performance,cache,cache,21999,"the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:22187,Performance,optimiz,optimize,22187,"Phase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocat",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:22196,Performance,cache,cache,22196,"Phase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocat",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:23289,Performance,cache,cache,23289,g is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocated size of fBuffer (at a given time) ;  ; Int_t fBufferSizeMin;  Original size of fBuffer. ;  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ;  ; Long64_t fNoCacheBytesRead;  Number of bytes read by basket to fill cached tree. ;  ; Int_t fNoCacheReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache.,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:23791,Performance,cache,cached,23791,eek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocated size of fBuffer (at a given time) ;  ; Int_t fBufferSizeMin;  Original size of fBuffer. ;  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ;  ; Long64_t fNoCacheBytesRead;  Number of bytes read by basket to fill cached tree. ;  ; Int_t fNoCacheReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorte,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:23874,Performance,cache,cached,23874,t_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocated size of fBuffer (at a given time) ;  ; Int_t fBufferSizeMin;  Original size of fBuffer. ;  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ;  ; Long64_t fNoCacheBytesRead;  Number of bytes read by basket to fill cached tree. ;  ; Int_t fNoCacheReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static TTreeCacheUnzip::EParUnzipMode fgParallel,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:24257,Performance,cache,cache,24257,;  ; Long64_t fBytesRead;  Number of bytes read for this cache. ;  ; Long64_t fBytesReadExtra;  Number of extra bytes (overhead) read by the readahead buffer. ;  ; Bool_t fEnablePrefetching;  reading by prefetching asynchronously ;  ; TFile * fFile;  Pointer to file. ;  ; Bool_t fIsSorted;  True if fSeek array is sorted. ;  ; Bool_t fIsTransferred;  True when fBuffer contains something valid. ;  ; Int_t * fLen;  [fNb] Length of long buffers ;  ; Int_t fNb;  Number of long buffers. ;  ; Long64_t fNoCacheBytesRead;  Number of bytes read by basket to fill cached tree. ;  ; Int_t fNoCacheReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static TTreeCacheUnzip::EParUnzipMode fgParallel = TTreeCacheUnzip::kDisable;  Indicate if we want to activate the parallelism. ;  ; static Double_t fgRelBuffSize = .5;  This is the percentage of the TTreeCacheUnzip that will be used. ;  ;  Static Protected Attributes inherited from TTreeCache; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCacheUnzip (const TTreeCac,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:27399,Performance,cache,cache,27399,"UnzipState. enum TTreeCacheUnzip::EUnzipState. EnumeratorkUntouched ; kProgress ; kFinished . Definition at line 43 of file TTreeCacheUnzip.h. Constructor & Destructor Documentation. ◆ TTreeCacheUnzip() [1/3]. TTreeCacheUnzip::TTreeCacheUnzip ; (; const TTreeCacheUnzip & ; ). privatedelete . ◆ TTreeCacheUnzip() [2/3]. TTreeCacheUnzip::TTreeCacheUnzip ; (; ). Definition at line 159 of file TTreeCacheUnzip.cxx. ◆ TTreeCacheUnzip() [3/3]. TTreeCacheUnzip::TTreeCacheUnzip ; (; TTree * ; tree, . Int_t ; buffersize = 0 . ). Constructor. ; Definition at line 178 of file TTreeCacheUnzip.cxx. ◆ ~TTreeCacheUnzip(). TTreeCacheUnzip::~TTreeCacheUnzip ; (; ). override . Destructor. (in general called by the TFile destructor) ; Definition at line 235 of file TTreeCacheUnzip.cxx. Member Function Documentation. ◆ AddBranch() [1/2]. Int_t TTreeCacheUnzip::AddBranch ; (; const char * ; branch, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 260 of file TTreeCacheUnzip.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCacheUnzip::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 248 of file TTreeCacheUnzip.cxx. ◆ Class(). static TClass * TTreeCacheUnzip::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:27779,Performance,cache,cache,27779,"159 of file TTreeCacheUnzip.cxx. ◆ TTreeCacheUnzip() [3/3]. TTreeCacheUnzip::TTreeCacheUnzip ; (; TTree * ; tree, . Int_t ; buffersize = 0 . ). Constructor. ; Definition at line 178 of file TTreeCacheUnzip.cxx. ◆ ~TTreeCacheUnzip(). TTreeCacheUnzip::~TTreeCacheUnzip ; (; ). override . Destructor. (in general called by the TFile destructor) ; Definition at line 235 of file TTreeCacheUnzip.cxx. Member Function Documentation. ◆ AddBranch() [1/2]. Int_t TTreeCacheUnzip::AddBranch ; (; const char * ; branch, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 260 of file TTreeCacheUnzip.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCacheUnzip::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 248 of file TTreeCacheUnzip.cxx. ◆ Class(). static TClass * TTreeCacheUnzip::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_t TTreeCacheUnzip::CreateTasks ; (; ). We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ; In TTaskGroup, we use TThreadExecutor to do the actually work of unzipping a group of basket. The purpose of creating TTaskGroup is to avoid competing with main thread. ; Definition at line 613 of file TTreeCacheUnzip.cxx. ◆ DeclFileName().",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:29048,Performance,cache,cache,29048,"ng this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_t TTreeCacheUnzip::CreateTasks ; (; ). We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ; In TTaskGroup, we use TThreadExecutor to do the actually work of unzipping a group of basket. The purpose of creating TTaskGroup is to avoid competing with main thread. ; Definition at line 613 of file TTreeCacheUnzip.cxx. ◆ DeclFileName(). static const char * TTreeCacheUnzip::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ FillBuffer(). bool TTreeCacheUnzip::FillBuffer ; (; ). overridevirtual . Fill the cache buffer with the branches in the cache. ; Reimplemented from TTreeCache.; Definition at line 267 of file TTreeCacheUnzip.cxx. ◆ GetNFound(). Int_t TTreeCacheUnzip::GetNFound ; (; ). inline . Definition at line 154 of file TTreeCacheUnzip.h. ◆ GetNMissed(). Int_t TTreeCacheUnzip::GetNMissed ; (; ). inline . Definition at line 153 of file TTreeCacheUnzip.h. ◆ GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. ◆ GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel option (to indicate an additional thread) ; Definition at line 407 of file TTreeCacheUnzip.cxx. ◆ GetRecordHeader(). Int_t TTreeCacheUnzip::GetRecordHeader ; (; char * ; buf, . Int_t ; maxbytes, . Int_t & ; nbytes, . Int_t & ; objlen, . Int_t & ; keylen . ). Read the logical record header from the buffer buf. ; That must be the pointer tho the header part not the object by itself and must c",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:29086,Performance,cache,cache,29086,"ng this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_t TTreeCacheUnzip::CreateTasks ; (; ). We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ; In TTaskGroup, we use TThreadExecutor to do the actually work of unzipping a group of basket. The purpose of creating TTaskGroup is to avoid competing with main thread. ; Definition at line 613 of file TTreeCacheUnzip.cxx. ◆ DeclFileName(). static const char * TTreeCacheUnzip::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ FillBuffer(). bool TTreeCacheUnzip::FillBuffer ; (; ). overridevirtual . Fill the cache buffer with the branches in the cache. ; Reimplemented from TTreeCache.; Definition at line 267 of file TTreeCacheUnzip.cxx. ◆ GetNFound(). Int_t TTreeCacheUnzip::GetNFound ; (; ). inline . Definition at line 154 of file TTreeCacheUnzip.h. ◆ GetNMissed(). Int_t TTreeCacheUnzip::GetNMissed ; (; ). inline . Definition at line 153 of file TTreeCacheUnzip.h. ◆ GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. ◆ GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel option (to indicate an additional thread) ; Definition at line 407 of file TTreeCacheUnzip.cxx. ◆ GetRecordHeader(). Int_t TTreeCacheUnzip::GetRecordHeader ; (; char * ; buf, . Int_t ; maxbytes, . Int_t & ; nbytes, . Int_t & ; objlen, . Int_t & ; keylen . ). Read the logical record header from the buffer buf. ; That must be the pointer tho the header part not the object by itself and must c",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:30804,Performance,cache,cache,30804,"ordHeader(). Int_t TTreeCacheUnzip::GetRecordHeader ; (; char * ; buf, . Int_t ; maxbytes, . Int_t & ; nbytes, . Int_t & ; objlen, . Int_t & ; keylen . ). Read the logical record header from the buffer buf. ; That must be the pointer tho the header part not the object by itself and must contain data of at least maxbytes Returns nread;; In output arguments:. nbytes : number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header. Note that the arguments objlen and keylen are returned only if maxbytes >=16 Note: This was adapted from TFile... so some things dont apply ; Definition at line 469 of file TTreeCacheUnzip.cxx. ◆ GetUnzipBuffer(). Int_t TTreeCacheUnzip::GetUnzipBuffer ; (; char ** ; buf, . Long64_t ; pos, . Int_t ; len, . bool * ; free . ). overridevirtual . We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ; pos and len are the original values as were passed to ReadBuffer but instead we will return the inflated buffer. Note!! : If *buf == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer ; Reimplemented from TFileCacheRead.; Definition at line 668 of file TTreeCacheUnzip.cxx. ◆ GetUnzipGroupSize(). Int_t TTreeCacheUnzip::GetUnzipGroupSize ; (; ). inline . Definition at line 142 of file TTreeCacheUnzip.h. ◆ Init(). void TTreeCacheUnzip::Init ; (; ). private . Initialization procedure common to all the constructors. ; Definition at line 196 of file TTreeCacheUnzip.cxx. ◆ IsA(). TClass * TTreeCacheUnzip::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TTreeCache.; Definition at line 159 of file TTreeCacheUnzip.h. ◆ IsParallelUnzip(). bool TTree",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:30836,Performance,cache,cache,30836,"ordHeader(). Int_t TTreeCacheUnzip::GetRecordHeader ; (; char * ; buf, . Int_t ; maxbytes, . Int_t & ; nbytes, . Int_t & ; objlen, . Int_t & ; keylen . ). Read the logical record header from the buffer buf. ; That must be the pointer tho the header part not the object by itself and must contain data of at least maxbytes Returns nread;; In output arguments:. nbytes : number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header. Note that the arguments objlen and keylen are returned only if maxbytes >=16 Note: This was adapted from TFile... so some things dont apply ; Definition at line 469 of file TTreeCacheUnzip.cxx. ◆ GetUnzipBuffer(). Int_t TTreeCacheUnzip::GetUnzipBuffer ; (; char ** ; buf, . Long64_t ; pos, . Int_t ; len, . bool * ; free . ). overridevirtual . We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ; pos and len are the original values as were passed to ReadBuffer but instead we will return the inflated buffer. Note!! : If *buf == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer ; Reimplemented from TFileCacheRead.; Definition at line 668 of file TTreeCacheUnzip.cxx. ◆ GetUnzipGroupSize(). Int_t TTreeCacheUnzip::GetUnzipGroupSize ; (; ). inline . Definition at line 142 of file TTreeCacheUnzip.h. ◆ Init(). void TTreeCacheUnzip::Init ; (; ). private . Initialization procedure common to all the constructors. ; Definition at line 196 of file TTreeCacheUnzip.cxx. ◆ IsA(). TClass * TTreeCacheUnzip::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TTreeCache.; Definition at line 159 of file TTreeCacheUnzip.h. ◆ IsParallelUnzip(). bool TTree",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:32165,Performance,cache,cache,32165,"ed from TFileCacheRead.; Definition at line 668 of file TTreeCacheUnzip.cxx. ◆ GetUnzipGroupSize(). Int_t TTreeCacheUnzip::GetUnzipGroupSize ; (; ). inline . Definition at line 142 of file TTreeCacheUnzip.h. ◆ Init(). void TTreeCacheUnzip::Init ; (; ). private . Initialization procedure common to all the constructors. ; Definition at line 196 of file TTreeCacheUnzip.cxx. ◆ IsA(). TClass * TTreeCacheUnzip::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TTreeCache.; Definition at line 159 of file TTreeCacheUnzip.h. ◆ IsParallelUnzip(). bool TTreeCacheUnzip::IsParallelUnzip ; (; ). static . Static function that tells wether the multithreading unzipping is activated. ; Definition at line 415 of file TTreeCacheUnzip.cxx. ◆ operator=(). TTreeCacheUnzip & TTreeCacheUnzip::operator= ; (; const TTreeCacheUnzip & ; ). privatedelete . ◆ Print(). void TTreeCacheUnzip::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwne",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:32273,Performance,cache,cache,32273,"GroupSize(). Int_t TTreeCacheUnzip::GetUnzipGroupSize ; (; ). inline . Definition at line 142 of file TTreeCacheUnzip.h. ◆ Init(). void TTreeCacheUnzip::Init ; (; ). private . Initialization procedure common to all the constructors. ; Definition at line 196 of file TTreeCacheUnzip.cxx. ◆ IsA(). TClass * TTreeCacheUnzip::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TTreeCache.; Definition at line 159 of file TTreeCacheUnzip.h. ◆ IsParallelUnzip(). bool TTreeCacheUnzip::IsParallelUnzip ; (; ). static . Static function that tells wether the multithreading unzipping is activated. ; Definition at line 415 of file TTreeCacheUnzip.cxx. ◆ operator=(). TTreeCacheUnzip & TTreeCacheUnzip::operator= ; (; const TTreeCacheUnzip & ; ). privatedelete . ◆ Print(). void TTreeCacheUnzip::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid win",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:32658,Performance,cache,cache,32658,"cribing current object ; Reimplemented from TTreeCache.; Definition at line 159 of file TTreeCacheUnzip.h. ◆ IsParallelUnzip(). bool TTreeCacheUnzip::IsParallelUnzip ; (; ). static . Static function that tells wether the multithreading unzipping is activated. ; Definition at line 415 of file TTreeCacheUnzip.cxx. ◆ operator=(). TTreeCacheUnzip & TTreeCacheUnzip::operator= ; (; const TTreeCacheUnzip & ; ). privatedelete . ◆ Print(). void TTreeCacheUnzip::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:33655,Performance,cache,cache,33655," cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TTreeCache.; Definition at line 947 of file TTreeCacheUnzip.cxx. ◆ ReadBufferExt(). Int_t TTreeCacheUnzip::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). overridevirtual . Reimplemented from TFileCacheRead.; Definition at line 961 of file TTreeCacheUnzip.cxx. ◆ ResetCache(). void TTreeCacheUnzip::ResetCache ; (; ). overridevirtual . This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 501",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:33724,Performance,cache,cachedbranches,33724,"size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TTreeCache.; Definition at line 947 of file TTreeCacheUnzip.cxx. ◆ ReadBufferExt(). Int_t TTreeCacheUnzip::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). overridevirtual . Reimplemented from TFileCacheRead.; Definition at line 961 of file TTreeCacheUnzip.cxx. ◆ ResetCache(). void TTreeCacheUnzip::ResetCache ; (; ). overridevirtual . This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 501 of file TTreeCacheUnzip.cxx. ◆ SetBufferSize(). Int_t TTreeCacheUnzip::SetBufferSize ;",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:33768,Performance,cache,cached,33768,"size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TTreeCache.; Definition at line 947 of file TTreeCacheUnzip.cxx. ◆ ReadBufferExt(). Int_t TTreeCacheUnzip::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). overridevirtual . Reimplemented from TFileCacheRead.; Definition at line 961 of file TTreeCacheUnzip.cxx. ◆ ResetCache(). void TTreeCacheUnzip::ResetCache ; (; ). overridevirtual . This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 501 of file TTreeCacheUnzip.cxx. ◆ SetBufferSize(). Int_t TTreeCacheUnzip::SetBufferSize ;",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:34246,Performance,cache,cache,34246,"har dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TTreeCache.; Definition at line 947 of file TTreeCacheUnzip.cxx. ◆ ReadBufferExt(). Int_t TTreeCacheUnzip::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). overridevirtual . Reimplemented from TFileCacheRead.; Definition at line 961 of file TTreeCacheUnzip.cxx. ◆ ResetCache(). void TTreeCacheUnzip::ResetCache ; (; ). overridevirtual . This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 501 of file TTreeCacheUnzip.cxx. ◆ SetBufferSize(). Int_t TTreeCacheUnzip::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TTreeCache.; Definition at line 359 of file TTreeCacheUnzip.cxx. ◆ SetEntryRange(). void TTreeCacheUnzip::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). overridevirtual . Set the minimum and maximum entry number to be processed this info",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:34289,Performance,cache,cache,34289,"har dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TTreeCache.; Definition at line 947 of file TTreeCacheUnzip.cxx. ◆ ReadBufferExt(). Int_t TTreeCacheUnzip::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). overridevirtual . Reimplemented from TFileCacheRead.; Definition at line 961 of file TTreeCacheUnzip.cxx. ◆ ResetCache(). void TTreeCacheUnzip::ResetCache ; (; ). overridevirtual . This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 501 of file TTreeCacheUnzip.cxx. ◆ SetBufferSize(). Int_t TTreeCacheUnzip::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TTreeCache.; Definition at line 359 of file TTreeCacheUnzip.cxx. ◆ SetEntryRange(). void TTreeCacheUnzip::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). overridevirtual . Set the minimum and maximum entry number to be processed this info",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:34363,Performance,cache,cache,34363,"ictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TTreeCache.; Definition at line 947 of file TTreeCacheUnzip.cxx. ◆ ReadBufferExt(). Int_t TTreeCacheUnzip::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). overridevirtual . Reimplemented from TFileCacheRead.; Definition at line 961 of file TTreeCacheUnzip.cxx. ◆ ResetCache(). void TTreeCacheUnzip::ResetCache ; (; ). overridevirtual . This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 501 of file TTreeCacheUnzip.cxx. ◆ SetBufferSize(). Int_t TTreeCacheUnzip::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TTreeCache.; Definition at line 359 of file TTreeCacheUnzip.cxx. ◆ SetEntryRange(). void TTreeCacheUnzip::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). overridevirtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 375 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::S",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:34828,Performance,cache,cache,34828,"reeCache.; Definition at line 947 of file TTreeCacheUnzip.cxx. ◆ ReadBufferExt(). Int_t TTreeCacheUnzip::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). overridevirtual . Reimplemented from TFileCacheRead.; Definition at line 961 of file TTreeCacheUnzip.cxx. ◆ ResetCache(). void TTreeCacheUnzip::ResetCache ; (; ). overridevirtual . This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 501 of file TTreeCacheUnzip.cxx. ◆ SetBufferSize(). Int_t TTreeCacheUnzip::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TTreeCache.; Definition at line 359 of file TTreeCacheUnzip.cxx. ◆ SetEntryRange(). void TTreeCacheUnzip::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). overridevirtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 375 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::SetParallelUnzip ; (; TTreeCacheUnzip::EParUnzipMode ; option = TTreeCacheUnzip::kEnable). static . Static function that (de)activates multithreading unzipping. ; The possible options are:; kEnable Enable it, which causes an automatic detection and launches the additional thread if the number of cores in the machine is greater than one; kDisable",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:35256,Performance,optimiz,optimize,35256," and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 501 of file TTreeCacheUnzip.cxx. ◆ SetBufferSize(). Int_t TTreeCacheUnzip::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TTreeCache.; Definition at line 359 of file TTreeCacheUnzip.cxx. ◆ SetEntryRange(). void TTreeCacheUnzip::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). overridevirtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 375 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::SetParallelUnzip ; (; TTreeCacheUnzip::EParUnzipMode ; option = TTreeCacheUnzip::kEnable). static . Static function that (de)activates multithreading unzipping. ; The possible options are:; kEnable Enable it, which causes an automatic detection and launches the additional thread if the number of cores in the machine is greater than one; kDisable Disable will not activate the additional thread.; kForce Force will start the additional thread even if there is only one core. the default will be taken as kEnable. Returns 0 if there was an error, 1 otherwise. ; Definition at line 436 of file TTreeCacheUnzip.cxx. ◆ SetUnzipBufferSize(). void TTreeCacheUnzip::SetUnzipBufferSize ; (; Long64_t ; bufferSize). Sets the size for the unzipping cache... by default it should be two times the si",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:36203,Performance,cache,cache,36203,"and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 375 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::SetParallelUnzip ; (; TTreeCacheUnzip::EParUnzipMode ; option = TTreeCacheUnzip::kEnable). static . Static function that (de)activates multithreading unzipping. ; The possible options are:; kEnable Enable it, which causes an automatic detection and launches the additional thread if the number of cores in the machine is greater than one; kDisable Disable will not activate the additional thread.; kForce Force will start the additional thread even if there is only one core. the default will be taken as kEnable. Returns 0 if there was an error, 1 otherwise. ; Definition at line 436 of file TTreeCacheUnzip.cxx. ◆ SetUnzipBufferSize(). void TTreeCacheUnzip::SetUnzipBufferSize ; (; Long64_t ; bufferSize). Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ; Definition at line 839 of file TTreeCacheUnzip.cxx. ◆ SetUnzipGroupSize(). void TTreeCacheUnzip::SetUnzipGroupSize ; (; Int_t ; groupSize). inline . Definition at line 146 of file TTreeCacheUnzip.h. ◆ SetUnzipRelBufferSize(). void TTreeCacheUnzip::SetUnzipRelBufferSize ; (; Float_t ; relbufferSize). static . static function: Sets the unzip relative buffer size ; Definition at line 830 of file TTreeCacheUnzip.cxx. ◆ StopLearningPhase(). void TTreeCacheUnzip::StopLearningPhase ; (; ). overridevirtual . It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ; Reimplemented from TTreeCache.; Definition at line 384 of file TTreeCacheUnzip.cxx. ◆ Streamer(). void TTreeCacheUnzip::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TTreeCache. ◆ StreamerNVirtual(). void TTreeCach",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:36274,Performance,cache,cache,36274,"n helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 375 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::SetParallelUnzip ; (; TTreeCacheUnzip::EParUnzipMode ; option = TTreeCacheUnzip::kEnable). static . Static function that (de)activates multithreading unzipping. ; The possible options are:; kEnable Enable it, which causes an automatic detection and launches the additional thread if the number of cores in the machine is greater than one; kDisable Disable will not activate the additional thread.; kForce Force will start the additional thread even if there is only one core. the default will be taken as kEnable. Returns 0 if there was an error, 1 otherwise. ; Definition at line 436 of file TTreeCacheUnzip.cxx. ◆ SetUnzipBufferSize(). void TTreeCacheUnzip::SetUnzipBufferSize ; (; Long64_t ; bufferSize). Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ; Definition at line 839 of file TTreeCacheUnzip.cxx. ◆ SetUnzipGroupSize(). void TTreeCacheUnzip::SetUnzipGroupSize ; (; Int_t ; groupSize). inline . Definition at line 146 of file TTreeCacheUnzip.h. ◆ SetUnzipRelBufferSize(). void TTreeCacheUnzip::SetUnzipRelBufferSize ; (; Float_t ; relbufferSize). static . static function: Sets the unzip relative buffer size ; Definition at line 830 of file TTreeCacheUnzip.cxx. ◆ StopLearningPhase(). void TTreeCacheUnzip::StopLearningPhase ; (; ). overridevirtual . It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ; Reimplemented from TTreeCache.; Definition at line 384 of file TTreeCacheUnzip.cxx. ◆ Streamer(). void TTreeCacheUnzip::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TTreeCache. ◆ StreamerNVirtual(). void TTreeCacheUnzip::StreamerNVirtual ; (; TBuffer & ; ClassDef_Strea",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:37994,Performance,cache,cache,37994,"eeCacheUnzip.cxx. ◆ Streamer(). void TTreeCacheUnzip::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TTreeCache. ◆ StreamerNVirtual(). void TTreeCacheUnzip::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 159 of file TTreeCacheUnzip.h. ◆ UnzipBuffer(). Int_t TTreeCacheUnzip::UnzipBuffer ; (; char ** ; dest, . char * ; src . ). Unzips a ROOT specific buffer... by reading the header at the beginning. ; returns the size of the inflated buffer or -1 if error Note!! : If *dest == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer src is the original buffer with the record (header+compressed data) *dest is the inflated buffer (including the header) ; Definition at line 853 of file TTreeCacheUnzip.cxx. ◆ UnzipCache(). Int_t TTreeCacheUnzip::UnzipCache ; (; Int_t ; index). This inflates a basket in the cache. ; . passing the data to a new buffer that will only wait there to be read... This function is responsible to update corresponding elements in fUnzipStatus, fUnzipChunks and fUnzipLen. Since we use atomic variables in fUnzipStatus to exclusively unzip the basket, we must update fUnzipStatus after fUnzipChunks and fUnzipLen and make sure fUnzipChunks and fUnzipLen are ready before main thread fetch the data. ; Definition at line 526 of file TTreeCacheUnzip.cxx. ◆ UpdateBranches(). void TTreeCacheUnzip::UpdateBranches ; (; TTree * ; tree). overridevirtual . update pointer to current Tree and recompute pointers to the branches in the cache ; Reimplemented from TTreeCache.; Definition at line 392 of file TTreeCacheUnzip.cxx. Member Data Documentation. ◆ fAsyncReading. bool TTreeCacheUnzip::fAsyncReading. protected . Definition at line 81 of file TTreeCacheUnzip.h. ◆ fCompBuffer. char* TTreeCacheUnzip::fCompBuffer. private . Definition at line 112 of file TTreeCacheUnzip.h",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:38639,Performance,cache,cache,38639,"nsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer src is the original buffer with the record (header+compressed data) *dest is the inflated buffer (including the header) ; Definition at line 853 of file TTreeCacheUnzip.cxx. ◆ UnzipCache(). Int_t TTreeCacheUnzip::UnzipCache ; (; Int_t ; index). This inflates a basket in the cache. ; . passing the data to a new buffer that will only wait there to be read... This function is responsible to update corresponding elements in fUnzipStatus, fUnzipChunks and fUnzipLen. Since we use atomic variables in fUnzipStatus to exclusively unzip the basket, we must update fUnzipStatus after fUnzipChunks and fUnzipLen and make sure fUnzipChunks and fUnzipLen are ready before main thread fetch the data. ; Definition at line 526 of file TTreeCacheUnzip.cxx. ◆ UpdateBranches(). void TTreeCacheUnzip::UpdateBranches ; (; TTree * ; tree). overridevirtual . update pointer to current Tree and recompute pointers to the branches in the cache ; Reimplemented from TTreeCache.; Definition at line 392 of file TTreeCacheUnzip.cxx. Member Data Documentation. ◆ fAsyncReading. bool TTreeCacheUnzip::fAsyncReading. protected . Definition at line 81 of file TTreeCacheUnzip.h. ◆ fCompBuffer. char* TTreeCacheUnzip::fCompBuffer. private . Definition at line 112 of file TTreeCacheUnzip.h. ◆ fCompBufferSize. Int_t TTreeCacheUnzip::fCompBufferSize. private . Definition at line 113 of file TTreeCacheUnzip.h. ◆ fCycle. Int_t TTreeCacheUnzip::fCycle. protected . Definition at line 83 of file TTreeCacheUnzip.h. ◆ fEmpty. bool TTreeCacheUnzip::fEmpty. protected . Definition at line 82 of file TTreeCacheUnzip.h. ◆ fgParallel. TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::fgParallel = TTreeCacheUnzip::kDisable. staticprotected . Indicate if we want to activate the parallelism. ; Definition at line 88 of file TTreeCacheUnzip.h. ◆ fgRelBuffSize. Double_t TTreeCacheUnzip::fgRelBuffSize = .5. staticprotected . This is the ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:39945,Performance,cache,cache,39945,e 112 of file TTreeCacheUnzip.h. ◆ fCompBufferSize. Int_t TTreeCacheUnzip::fCompBufferSize. private . Definition at line 113 of file TTreeCacheUnzip.h. ◆ fCycle. Int_t TTreeCacheUnzip::fCycle. protected . Definition at line 83 of file TTreeCacheUnzip.h. ◆ fEmpty. bool TTreeCacheUnzip::fEmpty. protected . Definition at line 82 of file TTreeCacheUnzip.h. ◆ fgParallel. TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::fgParallel = TTreeCacheUnzip::kDisable. staticprotected . Indicate if we want to activate the parallelism. ; Definition at line 88 of file TTreeCacheUnzip.h. ◆ fgRelBuffSize. Double_t TTreeCacheUnzip::fgRelBuffSize = .5. staticprotected . This is the percentage of the TTreeCacheUnzip that will be used. ; Definition at line 100 of file TTreeCacheUnzip.h. ◆ fIOMutex. std::unique_ptr<TMutex> TTreeCacheUnzip::fIOMutex. protected . Definition at line 86 of file TTreeCacheUnzip.h. ◆ fNFound. Int_t TTreeCacheUnzip::fNFound. protected . ! number of blocks that were found in the cache ; Definition at line 103 of file TTreeCacheUnzip.h. ◆ fNMissed. Int_t TTreeCacheUnzip::fNMissed. protected . ! number of blocks that were not found in the cache and were unzipped ; Definition at line 104 of file TTreeCacheUnzip.h. ◆ fNseekMax. Int_t TTreeCacheUnzip::fNseekMax. protected . ! fNseek can change so we need to know its max size ; Definition at line 96 of file TTreeCacheUnzip.h. ◆ fNStalls. Int_t TTreeCacheUnzip::fNStalls. protected . ! number of hits which caused a stall ; Definition at line 105 of file TTreeCacheUnzip.h. ◆ fNUnzip. Int_t TTreeCacheUnzip::fNUnzip. protected . ! number of blocks that were unzipped ; Definition at line 106 of file TTreeCacheUnzip.h. ◆ fParallel. bool TTreeCacheUnzip::fParallel. protected . Indicate if we want to activate the parallelism (for this instance) ; Definition at line 84 of file TTreeCacheUnzip.h. ◆ fUnzipBufferSize. Long64_t TTreeCacheUnzip::fUnzipBufferSize. protected . ! Max Size for the ready unzipped blocks (default is 2*fBuffer,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:40106,Performance,cache,cache,40106,TTreeCacheUnzip::fCycle. protected . Definition at line 83 of file TTreeCacheUnzip.h. ◆ fEmpty. bool TTreeCacheUnzip::fEmpty. protected . Definition at line 82 of file TTreeCacheUnzip.h. ◆ fgParallel. TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::fgParallel = TTreeCacheUnzip::kDisable. staticprotected . Indicate if we want to activate the parallelism. ; Definition at line 88 of file TTreeCacheUnzip.h. ◆ fgRelBuffSize. Double_t TTreeCacheUnzip::fgRelBuffSize = .5. staticprotected . This is the percentage of the TTreeCacheUnzip that will be used. ; Definition at line 100 of file TTreeCacheUnzip.h. ◆ fIOMutex. std::unique_ptr<TMutex> TTreeCacheUnzip::fIOMutex. protected . Definition at line 86 of file TTreeCacheUnzip.h. ◆ fNFound. Int_t TTreeCacheUnzip::fNFound. protected . ! number of blocks that were found in the cache ; Definition at line 103 of file TTreeCacheUnzip.h. ◆ fNMissed. Int_t TTreeCacheUnzip::fNMissed. protected . ! number of blocks that were not found in the cache and were unzipped ; Definition at line 104 of file TTreeCacheUnzip.h. ◆ fNseekMax. Int_t TTreeCacheUnzip::fNseekMax. protected . ! fNseek can change so we need to know its max size ; Definition at line 96 of file TTreeCacheUnzip.h. ◆ fNStalls. Int_t TTreeCacheUnzip::fNStalls. protected . ! number of hits which caused a stall ; Definition at line 105 of file TTreeCacheUnzip.h. ◆ fNUnzip. Int_t TTreeCacheUnzip::fNUnzip. protected . ! number of blocks that were unzipped ; Definition at line 106 of file TTreeCacheUnzip.h. ◆ fParallel. bool TTreeCacheUnzip::fParallel. protected . Indicate if we want to activate the parallelism (for this instance) ; Definition at line 84 of file TTreeCacheUnzip.h. ◆ fUnzipBufferSize. Long64_t TTreeCacheUnzip::fUnzipBufferSize. protected . ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ; Definition at line 98 of file TTreeCacheUnzip.h. ◆ fUnzipGroupSize. Int_t TTreeCacheUnzip::fUnzipGroupSize. protected . ! Min accumulated size of a group of bas,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:28676,Safety,avoid,avoid,28676," bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: . 0 branch added or already included; -1 on error . Reimplemented from TTreeCache.; Definition at line 248 of file TTreeCacheUnzip.cxx. ◆ Class(). static TClass * TTreeCacheUnzip::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCacheUnzip::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCacheUnzip::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ CreateTasks(). Int_t TTreeCacheUnzip::CreateTasks ; (; ). We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ; In TTaskGroup, we use TThreadExecutor to do the actually work of unzipping a group of basket. The purpose of creating TTaskGroup is to avoid competing with main thread. ; Definition at line 613 of file TTreeCacheUnzip.cxx. ◆ DeclFileName(). static const char * TTreeCacheUnzip::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 159 of file TTreeCacheUnzip.h. ◆ FillBuffer(). bool TTreeCacheUnzip::FillBuffer ; (; ). overridevirtual . Fill the cache buffer with the branches in the cache. ; Reimplemented from TTreeCache.; Definition at line 267 of file TTreeCacheUnzip.cxx. ◆ GetNFound(). Int_t TTreeCacheUnzip::GetNFound ; (; ). inline . Definition at line 154 of file TTreeCacheUnzip.h. ◆ GetNMissed(). Int_t TTreeCacheUnzip::GetNMissed ; (; ). inline . Definition at line 153 of file TTreeCacheUnzip.h. ◆ GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. ◆ GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:35698,Safety,detect,detection,35698,"e ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TTreeCache.; Definition at line 359 of file TTreeCacheUnzip.cxx. ◆ SetEntryRange(). void TTreeCacheUnzip::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). overridevirtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 375 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::SetParallelUnzip ; (; TTreeCacheUnzip::EParUnzipMode ; option = TTreeCacheUnzip::kEnable). static . Static function that (de)activates multithreading unzipping. ; The possible options are:; kEnable Enable it, which causes an automatic detection and launches the additional thread if the number of cores in the machine is greater than one; kDisable Disable will not activate the additional thread.; kForce Force will start the additional thread even if there is only one core. the default will be taken as kEnable. Returns 0 if there was an error, 1 otherwise. ; Definition at line 436 of file TTreeCacheUnzip.cxx. ◆ SetUnzipBufferSize(). void TTreeCacheUnzip::SetUnzipBufferSize ; (; Long64_t ; bufferSize). Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ; Definition at line 839 of file TTreeCacheUnzip.cxx. ◆ SetUnzipGroupSize(). void TTreeCacheUnzip::SetUnzipGroupSize ; (; Int_t ; groupSize). inline . Definition at line 146 of file TTreeCacheUnzip.h. ◆ SetUnzipRelBufferSize(). void TTreeCacheUnzip::SetUnzipRelBufferSize ; (; Float_t ; relbufferSize). static . static function: Sets the unzip relative buffer size ; Definition at line 830 of file TTreeCacheUnzip.cxx. ◆ StopLearningPhase(). void TTreeCacheUnz",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:12786,Security,hash,hash,12786," Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:2441,Testability,log,logical,2441,")); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TTreeCacheUnzip ();  ;  TTreeCacheUnzip (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCacheUnzip () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t AddBranch (TBranch *b, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket Returns: ;  ; Int_t CreateTasks ();  We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ;  ; bool FillBuffer () override;  Fill the cache buffer with the branches in the cache. ;  ; Int_t GetNFound ();  ; Int_t GetNMissed ();  ; Int_t GetNUnzip ();  ; Int_t GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information h",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:29940,Testability,log,logical,29940,"nzip.h. ◆ FillBuffer(). bool TTreeCacheUnzip::FillBuffer ; (; ). overridevirtual . Fill the cache buffer with the branches in the cache. ; Reimplemented from TTreeCache.; Definition at line 267 of file TTreeCacheUnzip.cxx. ◆ GetNFound(). Int_t TTreeCacheUnzip::GetNFound ; (; ). inline . Definition at line 154 of file TTreeCacheUnzip.h. ◆ GetNMissed(). Int_t TTreeCacheUnzip::GetNMissed ; (; ). inline . Definition at line 153 of file TTreeCacheUnzip.h. ◆ GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. ◆ GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel option (to indicate an additional thread) ; Definition at line 407 of file TTreeCacheUnzip.cxx. ◆ GetRecordHeader(). Int_t TTreeCacheUnzip::GetRecordHeader ; (; char * ; buf, . Int_t ; maxbytes, . Int_t & ; nbytes, . Int_t & ; objlen, . Int_t & ; keylen . ). Read the logical record header from the buffer buf. ; That must be the pointer tho the header part not the object by itself and must contain data of at least maxbytes Returns nread;; In output arguments:. nbytes : number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header. Note that the arguments objlen and keylen are returned only if maxbytes >=16 Note: This was adapted from TFile... so some things dont apply ; Definition at line 469 of file TTreeCacheUnzip.cxx. ◆ GetUnzipBuffer(). Int_t TTreeCacheUnzip::GetUnzipBuffer ; (; char ** ; buf, . Long64_t ; pos, . Int_t ; len, . bool * ; free . ). overridevirtual . We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ; pos and len are the original values as were passed to ReadBuffer but instead we will r",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:30320,Testability,log,logical,30320,"ine . Definition at line 154 of file TTreeCacheUnzip.h. ◆ GetNMissed(). Int_t TTreeCacheUnzip::GetNMissed ; (; ). inline . Definition at line 153 of file TTreeCacheUnzip.h. ◆ GetNUnzip(). Int_t TTreeCacheUnzip::GetNUnzip ; (; ). inline . Definition at line 152 of file TTreeCacheUnzip.h. ◆ GetParallelUnzip(). TTreeCacheUnzip::EParUnzipMode TTreeCacheUnzip::GetParallelUnzip ; (; ). static . Static function that returns the parallel option (to indicate an additional thread) ; Definition at line 407 of file TTreeCacheUnzip.cxx. ◆ GetRecordHeader(). Int_t TTreeCacheUnzip::GetRecordHeader ; (; char * ; buf, . Int_t ; maxbytes, . Int_t & ; nbytes, . Int_t & ; objlen, . Int_t & ; keylen . ). Read the logical record header from the buffer buf. ; That must be the pointer tho the header part not the object by itself and must contain data of at least maxbytes Returns nread;; In output arguments:. nbytes : number of bytes in record if negative, this is a deleted record if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header. Note that the arguments objlen and keylen are returned only if maxbytes >=16 Note: This was adapted from TFile... so some things dont apply ; Definition at line 469 of file TTreeCacheUnzip.cxx. ◆ GetUnzipBuffer(). Int_t TTreeCacheUnzip::GetUnzipBuffer ; (; char ** ; buf, . Long64_t ; pos, . Int_t ; len, . bool * ; free . ). overridevirtual . We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ; pos and len are the original values as were passed to ReadBuffer but instead we will return the inflated buffer. Note!! : If *buf == 0 we will allocate the buffer and it will be the responsibility of the caller to free it... it is useful for example to pass it to the creator of TBuffer ; Reimplemented from TFileCacheRead.; Definition at line 668 of file TTreeCacheUnz",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:6484,Usability,learn,learning,6484,"o the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cach",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:7287,Usability,learn,learning,7287,"is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches used by the underlying implementation. ;  ; virtual Int_t GetBufferSize () const;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; TFile * GetFile () const;  ; virtual Long",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:18116,Usability,learn,learning,18116,_Version ();  ; static const char * DeclFileName ();  ; static EParUnzipMode GetParallelUnzip ();  Static function that returns the parallel option (to indicate an additional thread) ;  ; static bool IsParallelUnzip ();  Static function that tells wether the multithreading unzipping is activated. ;  ; static Int_t SetParallelUnzip (TTreeCacheUnzip::EParUnzipMode option=TTreeCacheUnzip::kEnable);  Static function that (de)activates multithreading unzipping. ;  ; static void SetUnzipRelBufferSize (Float_t relbufferSize);  static function: Sets the unzip relative buffer size ;  ;  Static Public Member Functions inherited from TTreeCache; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetLearnEntries ();  Static function returning the number of entries used to train the cache see SetLearnEntries. ;  ; static void SetLearnEntries (Int_t n=10);  Static function to set the number of entries to be used in learning mode The default value for n is 10. ;  ;  Static Public Member Functions inherited from TFileCacheRead; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; typedef struct UnzipState UnzipState_t;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncR,MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:21065,Usability,learn,learning,21065,"  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:22116,Usability,learn,learning,22116,"Phase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;  ; Long64_t * fBSeekSort;  [fBNseek] ;  ; Int_t * fBSeekSortLen;  [fBNseek] ;  ; char * fBuffer;  [fBufferSize] buffer of contiguous prefetched blocks ;  ; Int_t fBufferLen;  Current buffer length (<= fBufferSize) ;  ; Int_t fBufferSize;  Allocat",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/classTTreeCacheUnzip.html:25156,Usability,learn,learning,25156,"synchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static TTreeCacheUnzip::EParUnzipMode fgParallel = TTreeCacheUnzip::kDisable;  Indicate if we want to activate the parallelism. ;  ; static Double_t fgRelBuffSize = .5;  This is the percentage of the TTreeCacheUnzip that will be used. ;  ;  Static Protected Attributes inherited from TTreeCache; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCacheUnzip (const TTreeCacheUnzip &)=delete;  ; void Init ();  Initialization procedure common to all the constructors. ;  ; TTreeCacheUnzip & operator= (const TTreeCacheUnzip &)=delete;  . Private Attributes; char * fCompBuffer;  ; Int_t fCompBufferSize;  . Additional Inherited Members;  Protected Member Functions inherited from TFileCacheRead; void SetEnablePrefetchingImpl (Bool_t setPrefetching=kFALSE);  TFileCacheRead implementation of SetEnablePrefetching. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TTreeCacheUnzip.h>. Inheritance diagram for TTreeCacheUnzip:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ UnzipState_t. ",MatchSource.WIKI,doc/v632/classTTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html
https://root.cern/doc/v632/Compression_8h_source.html:1139,Availability,avail,available,1139,"; No Matches. Compression.h. Go to the documentation of this file. 1// @(#)root/zip:$Id$; 2// Author: David Dagenhart May 2011; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_Compression; 13#define ROOT_Compression; 14 ; 15#include ""RtypesCore.h""; 16 ; 17#include <string>; 18 ; 19namespace ROOT {; 20 ; 21/// The global settings depend on a global variable named R__ZipMode which can be; 22/// modified by a global function named R__SetZipMode. Both are defined in Bits.h.; 23///; 24/// - The default is to use the global setting and the default of the global; 25/// setting is to use the ZLIB compression algorithm.; 26/// - The LZMA algorithm (from the XZ package) is also available. The LZMA; 27/// compression usually results in greater compression factors, but takes; 28/// more CPU time and memory when compressing. LZMA memory usage is particularly; 29/// high for compression levels 8 and 9.; 30/// - Finally, the LZ4 package results in worse compression ratios; 31/// than ZLIB but achieves much faster decompression rates.; 32///; 33/// The current algorithms support level 1 to 9. The higher the level the greater; 34/// the compression and more CPU time and memory resources used during compression.; 35/// Level 0 means no compression.; 36///; 37/// Recommendation for the compression algorithm's levels:; 38/// - ZLIB is recommended to be used with compression level 1 [101]; 39/// - LZMA is recommended to be used with compression level 7-8 (higher is better,; 40/// since in the case of LZMA we don't care about compression/decompression speed); 41/// [207 - 208]; 42/// - LZ4 is recommended to be used with compression level 4 [404]; ",MatchSource.WIKI,doc/v632/Compression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/Compression_8h_source.html
https://root.cern/doc/v632/Compression_8h_source.html:793,Integrability,depend,depend,793,". ROOT: core/zip/inc/Compression.h Source File. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. Compression.h. Go to the documentation of this file. 1// @(#)root/zip:$Id$; 2// Author: David Dagenhart May 2011; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_Compression; 13#define ROOT_Compression; 14 ; 15#include ""RtypesCore.h""; 16 ; 17#include <string>; 18 ; 19namespace ROOT {; 20 ; 21/// The global settings depend on a global variable named R__ZipMode which can be; 22/// modified by a global function named R__SetZipMode. Both are defined in Bits.h.; 23///; 24/// - The default is to use the global setting and the default of the global; 25/// setting is to use the ZLIB compression algorithm.; 26/// - The LZMA algorithm (from the XZ package) is also available. The LZMA; 27/// compression usually results in greater compression factors, but takes; 28/// more CPU time and memory when compressing. LZMA memory usage is particularly; 29/// high for compression levels 8 and 9.; 30/// - Finally, the LZ4 package results in worse compression ratios; 31/// than ZLIB but achieves much faster decompression rates.; 32///; 33/// The current algorithms support level 1 to 9. The higher the level the greater; 34/// the compression and more CPU time and memory resources used during compression.; 35/// Level 0 means no compression.; 36///; 37/// Recommendation for the compression algorithm's levels:; 38/// - ZLIB is recommended to be used with compression level 1 [101]; 39/// - LZMA is recommended to be used with compression level 7-8 (higher is better,; 40/// since in the case of LZMA we don't care about compressi",MatchSource.WIKI,doc/v632/Compression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/Compression_8h_source.html
https://root.cern/doc/v632/Compression_8h_source.html:11303,Integrability,depend,depend,11303,"nition Compression.h:61; ROOT::RCompressionSetting::ELevel::EValuesEValuesNote: this is only temporarily a struct and will become a enum class hence the name convention used.Definition Compression.h:63; ROOT::RCompressionSetting::ELevel::kInherit@ kInheritSome objects use this value to denote that the compression algorithm should be inherited from the par...Definition Compression.h:66; ROOT::RCompressionSetting::ELevel::kUseMin@ kUseMinCompression level reserved when we are not sure what to use (1 is for the fastest compression)Definition Compression.h:70; ROOT::RCompressionSetting::ELevel::kDefaultOld@ kDefaultOldCompression level reserved for old ROOT compression algorithm.Definition Compression.h:78; ROOT::RCompressionSetting::ELevel::kUncompressed@ kUncompressedCompression level reserved for ""uncompressed state"".Definition Compression.h:68; ROOT::RCompressionSetting::ELevel::kDefaultLZMA@ kDefaultLZMACompression level reserved for LZMA compression algorithm (slowest compression with smallest files)Definition Compression.h:80; ROOT::RCompressionSetting::ELevel::kDefaultZSTD@ kDefaultZSTDCompression level reserved for ZSTD compression algorithm (trade-off between file ratio/decompression...Definition Compression.h:76; ROOT::RCompressionSetting::ELevel::kDefaultZLIB@ kDefaultZLIBCompression level reserved for ZLIB compression algorithm (fastest compression)Definition Compression.h:72; ROOT::RCompressionSetting::ELevel::kDefaultLZ4@ kDefaultLZ4Compression level reserved for LZ4 compression algorithm (trade-off between file ratio/decompression ...Definition Compression.h:74; ROOT::RCompressionSettingThe global settings depend on a global variable named R__ZipMode which can be modified by a global fu...Definition Compression.h:45; ROOT::RCompressionSetting::AlgorithmToStringstatic std::string AlgorithmToString(EAlgorithm::EValues algorithm). corezipincCompression.h. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:07:08 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/v632/Compression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/Compression_8h_source.html
https://root.cern/doc/v632/Compression_8h_source.html:812,Modifiability,variab,variable,812,". ROOT: core/zip/inc/Compression.h Source File. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. Compression.h. Go to the documentation of this file. 1// @(#)root/zip:$Id$; 2// Author: David Dagenhart May 2011; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_Compression; 13#define ROOT_Compression; 14 ; 15#include ""RtypesCore.h""; 16 ; 17#include <string>; 18 ; 19namespace ROOT {; 20 ; 21/// The global settings depend on a global variable named R__ZipMode which can be; 22/// modified by a global function named R__SetZipMode. Both are defined in Bits.h.; 23///; 24/// - The default is to use the global setting and the default of the global; 25/// setting is to use the ZLIB compression algorithm.; 26/// - The LZMA algorithm (from the XZ package) is also available. The LZMA; 27/// compression usually results in greater compression factors, but takes; 28/// more CPU time and memory when compressing. LZMA memory usage is particularly; 29/// high for compression levels 8 and 9.; 30/// - Finally, the LZ4 package results in worse compression ratios; 31/// than ZLIB but achieves much faster decompression rates.; 32///; 33/// The current algorithms support level 1 to 9. The higher the level the greater; 34/// the compression and more CPU time and memory resources used during compression.; 35/// Level 0 means no compression.; 36///; 37/// Recommendation for the compression algorithm's levels:; 38/// - ZLIB is recommended to be used with compression level 1 [101]; 39/// - LZMA is recommended to be used with compression level 7-8 (higher is better,; 40/// since in the case of LZMA we don't care about compressi",MatchSource.WIKI,doc/v632/Compression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/Compression_8h_source.html
https://root.cern/doc/v632/Compression_8h_source.html:3193,Modifiability,inherit,inherited,3193,"o; 54 kUseAnalysis = 404,; 55 /// Use the new recommended general-purpose setting; it is a best trade-off between compression ratio/decompression speed; 56 kUseGeneralPurpose = 505,; 57 /// Use the setting that results in the smallest files; very slow read and write; 58 kUseSmallest = 207,; 59 };; 60 };; 61 struct ELevel { /// Note: this is only temporarily a struct and will become a enum class hence the name convention; 62 /// used.; 63 enum EValues {; 64 /// Some objects use this value to denote that the compression algorithm; 65 /// should be inherited from the parent object; 66 kInherit = -1,; 67 /// Compression level reserved for ""uncompressed state""; 68 kUncompressed = 0,; 69 /// Compression level reserved when we are not sure what to use (1 is for the fastest compression); 70 kUseMin = 1,; 71 /// Compression level reserved for ZLIB compression algorithm (fastest compression); 72 kDefaultZLIB = 1,; 73 /// Compression level reserved for LZ4 compression algorithm (trade-off between file ratio/decompression speed); 74 kDefaultLZ4 = 4,; 75 /// Compression level reserved for ZSTD compression algorithm (trade-off between file ratio/decompression speed); 76 kDefaultZSTD = 5,; 77 /// Compression level reserved for old ROOT compression algorithm; 78 kDefaultOld = 6,; 79 /// Compression level reserved for LZMA compression algorithm (slowest compression with smallest files); 80 kDefaultLZMA = 7; 81 };; 82 };; 83 struct EAlgorithm { /// Note: this is only temporarily a struct and will become a enum class hence the name; 84 /// convention used.; 85 enum EValues {; 86 /// Some objects use this value to denote that the compression algorithm; 87 /// should be inherited from the parent object (e.g., TBranch should get the algorithm from the TTree); 88 kInherit = -1,; 89 /// Use the global compression algorithm; 90 kUseGlobal = 0,; 91 /// Use ZLIB compression; 92 kZLIB,; 93 /// Use LZMA compression; 94 kLZMA,; 95 /// Use the old compression algorithm; 96 kOldCompressionAlgo,; 9",MatchSource.WIKI,doc/v632/Compression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/Compression_8h_source.html
https://root.cern/doc/v632/Compression_8h_source.html:4319,Modifiability,inherit,inherited,4319," for ""uncompressed state""; 68 kUncompressed = 0,; 69 /// Compression level reserved when we are not sure what to use (1 is for the fastest compression); 70 kUseMin = 1,; 71 /// Compression level reserved for ZLIB compression algorithm (fastest compression); 72 kDefaultZLIB = 1,; 73 /// Compression level reserved for LZ4 compression algorithm (trade-off between file ratio/decompression speed); 74 kDefaultLZ4 = 4,; 75 /// Compression level reserved for ZSTD compression algorithm (trade-off between file ratio/decompression speed); 76 kDefaultZSTD = 5,; 77 /// Compression level reserved for old ROOT compression algorithm; 78 kDefaultOld = 6,; 79 /// Compression level reserved for LZMA compression algorithm (slowest compression with smallest files); 80 kDefaultLZMA = 7; 81 };; 82 };; 83 struct EAlgorithm { /// Note: this is only temporarily a struct and will become a enum class hence the name; 84 /// convention used.; 85 enum EValues {; 86 /// Some objects use this value to denote that the compression algorithm; 87 /// should be inherited from the parent object (e.g., TBranch should get the algorithm from the TTree); 88 kInherit = -1,; 89 /// Use the global compression algorithm; 90 kUseGlobal = 0,; 91 /// Use ZLIB compression; 92 kZLIB,; 93 /// Use LZMA compression; 94 kLZMA,; 95 /// Use the old compression algorithm; 96 kOldCompressionAlgo,; 97 /// Use LZ4 compression; 98 kLZ4,; 99 /// Use ZSTD compression; 100 kZSTD,; 101 /// Undefined compression algorithm (must be kept the last of the list in case a new algorithm is added).; 102 kUndefined; 103 };; 104 };; 105 ; 106 static std::string AlgorithmToString(EAlgorithm::EValues algorithm);; 107};; 108 ; 109enum ECompressionAlgorithm {; 110 /// Deprecated name, do *not* use:; 111 kUseGlobalCompressionSetting = RCompressionSetting::EAlgorithm::kUseGlobal,; 112 /// Deprecated name, do *not* use:; 113 kUseGlobalSetting = RCompressionSetting::EAlgorithm::kUseGlobal,; 114 /// Deprecated name, do *not* use:; 115 kZLIB = RCompress",MatchSource.WIKI,doc/v632/Compression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/Compression_8h_source.html
https://root.cern/doc/v632/Compression_8h_source.html:8260,Modifiability,inherit,inherited,8260,"orithm, int compressionLevel); ROOT::RCompressionSetting::EAlgorithmDefinition Compression.h:83; ROOT::RCompressionSetting::EAlgorithm::EValuesEValuesNote: this is only temporarily a struct and will become a enum class hence the name.Definition Compression.h:85; ROOT::RCompressionSetting::EAlgorithm::kUseGlobal@ kUseGlobalUse the global compression algorithm.Definition Compression.h:90; ROOT::RCompressionSetting::EAlgorithm::kLZ4@ kLZ4Use LZ4 compression.Definition Compression.h:98; ROOT::RCompressionSetting::EAlgorithm::kOldCompressionAlgo@ kOldCompressionAlgoUse the old compression algorithm.Definition Compression.h:96; ROOT::RCompressionSetting::EAlgorithm::kZSTD@ kZSTDUse ZSTD compression.Definition Compression.h:100; ROOT::RCompressionSetting::EAlgorithm::kUndefined@ kUndefinedUndefined compression algorithm (must be kept the last of the list in case a new algorithm is added).Definition Compression.h:102; ROOT::RCompressionSetting::EAlgorithm::kInherit@ kInheritSome objects use this value to denote that the compression algorithm should be inherited from the par...Definition Compression.h:88; ROOT::RCompressionSetting::EAlgorithm::kZLIB@ kZLIBUse ZLIB compression.Definition Compression.h:92; ROOT::RCompressionSetting::EAlgorithm::kLZMA@ kLZMAUse LZMA compression.Definition Compression.h:94; ROOT::RCompressionSetting::EDefaultsDefinition Compression.h:46; ROOT::RCompressionSetting::EDefaults::EValuesEValuesNote: this is only temporarily a struct and will become a enum class hence the name convention used.Definition Compression.h:48; ROOT::RCompressionSetting::EDefaults::kUseAnalysis@ kUseAnalysisUse the default analysis setting; fast reading but poor compression ratio.Definition Compression.h:54; ROOT::RCompressionSetting::EDefaults::kUseGlobal@ kUseGlobalUse the global compression setting for this process; may be affected by rootrc.Definition Compression.h:50; ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault@ kUseCompiledDefaultUse the compile-time defa",MatchSource.WIKI,doc/v632/Compression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/Compression_8h_source.html
https://root.cern/doc/v632/Compression_8h_source.html:9992,Modifiability,inherit,inherited,9992,":RCompressionSetting::EDefaults::kUseGlobal@ kUseGlobalUse the global compression setting for this process; may be affected by rootrc.Definition Compression.h:50; ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault@ kUseCompiledDefaultUse the compile-time default setting.Definition Compression.h:52; ROOT::RCompressionSetting::EDefaults::kUseSmallest@ kUseSmallestUse the setting that results in the smallest files; very slow read and write.Definition Compression.h:58; ROOT::RCompressionSetting::EDefaults::kUseGeneralPurpose@ kUseGeneralPurposeUse the new recommended general-purpose setting; it is a best trade-off between compression ratio/dec...Definition Compression.h:56; ROOT::RCompressionSetting::ELevelDefinition Compression.h:61; ROOT::RCompressionSetting::ELevel::EValuesEValuesNote: this is only temporarily a struct and will become a enum class hence the name convention used.Definition Compression.h:63; ROOT::RCompressionSetting::ELevel::kInherit@ kInheritSome objects use this value to denote that the compression algorithm should be inherited from the par...Definition Compression.h:66; ROOT::RCompressionSetting::ELevel::kUseMin@ kUseMinCompression level reserved when we are not sure what to use (1 is for the fastest compression)Definition Compression.h:70; ROOT::RCompressionSetting::ELevel::kDefaultOld@ kDefaultOldCompression level reserved for old ROOT compression algorithm.Definition Compression.h:78; ROOT::RCompressionSetting::ELevel::kUncompressed@ kUncompressedCompression level reserved for ""uncompressed state"".Definition Compression.h:68; ROOT::RCompressionSetting::ELevel::kDefaultLZMA@ kDefaultLZMACompression level reserved for LZMA compression algorithm (slowest compression with smallest files)Definition Compression.h:80; ROOT::RCompressionSetting::ELevel::kDefaultZSTD@ kDefaultZSTDCompression level reserved for ZSTD compression algorithm (trade-off between file ratio/decompression...Definition Compression.h:76; ROOT::RCompressionSetting::ELevel::kDe",MatchSource.WIKI,doc/v632/Compression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/Compression_8h_source.html
https://root.cern/doc/v632/Compression_8h_source.html:11322,Modifiability,variab,variable,11322,"nition Compression.h:61; ROOT::RCompressionSetting::ELevel::EValuesEValuesNote: this is only temporarily a struct and will become a enum class hence the name convention used.Definition Compression.h:63; ROOT::RCompressionSetting::ELevel::kInherit@ kInheritSome objects use this value to denote that the compression algorithm should be inherited from the par...Definition Compression.h:66; ROOT::RCompressionSetting::ELevel::kUseMin@ kUseMinCompression level reserved when we are not sure what to use (1 is for the fastest compression)Definition Compression.h:70; ROOT::RCompressionSetting::ELevel::kDefaultOld@ kDefaultOldCompression level reserved for old ROOT compression algorithm.Definition Compression.h:78; ROOT::RCompressionSetting::ELevel::kUncompressed@ kUncompressedCompression level reserved for ""uncompressed state"".Definition Compression.h:68; ROOT::RCompressionSetting::ELevel::kDefaultLZMA@ kDefaultLZMACompression level reserved for LZMA compression algorithm (slowest compression with smallest files)Definition Compression.h:80; ROOT::RCompressionSetting::ELevel::kDefaultZSTD@ kDefaultZSTDCompression level reserved for ZSTD compression algorithm (trade-off between file ratio/decompression...Definition Compression.h:76; ROOT::RCompressionSetting::ELevel::kDefaultZLIB@ kDefaultZLIBCompression level reserved for ZLIB compression algorithm (fastest compression)Definition Compression.h:72; ROOT::RCompressionSetting::ELevel::kDefaultLZ4@ kDefaultLZ4Compression level reserved for LZ4 compression algorithm (trade-off between file ratio/decompression ...Definition Compression.h:74; ROOT::RCompressionSettingThe global settings depend on a global variable named R__ZipMode which can be modified by a global fu...Definition Compression.h:45; ROOT::RCompressionSetting::AlgorithmToStringstatic std::string AlgorithmToString(EAlgorithm::EValues algorithm). corezipincCompression.h. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:07:08 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/v632/Compression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/Compression_8h_source.html
https://root.cern/doc/v632/ESTLType_8h_source.html:1635,Integrability,interface,interface,1635,"; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// ROOT::ESTLType //; 19// //; 20// Enum describing STL collections and some std classes //; 21// This is used in TClassEdit, TStreamerInfo, TClassEdit //; 22// and TStreamerElement. //; 23// //; 24//////////////////////////////////////////////////////////////////////////; 25 ; 26namespace ROOT {; 27 ; 28 enum ESTLType {; 29 kNotSTL = 0,; 30 kSTLvector = 1,; 31 kSTLlist = 2,; 32 kSTLdeque = 3,; 33 kSTLmap = 4,; 34 kSTLmultimap = 5,; 35 kSTLset = 6,; 36 kSTLmultiset = 7,; 37 kSTLbitset = 8,; 38 // Here the c++11 containers start. Order counts. For example,; 39 // tstreamerelements in written rootfiles carry a value and we cannot; 40 // introduce shifts.; 41 kSTLforwardlist = 9,; 42 kSTLunorderedset = 10,; 43 kSTLunorderedmultiset = 11,; 44 kSTLunorderedmap = 12,; 45 kSTLunorderedmultimap = 13,; 46 kROOTRVec = 14, /* ROOT type with STL container interface */; 47 kSTLend = 15,; 48 kSTLany = 300 /* TVirtualStreamerInfo::kSTL */,; 49 kSTLstring = 365 /* TVirtualStreamerInfo::kSTLstring */,; 50 };; 51 ; 52}; 53 ; 54#endif; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::ESTLTypeESTLTypeDefinition ESTLType.h:28; ROOT::kSTLbitset@ kSTLbitsetDefinition ESTLType.h:37; ROOT::kSTLmap@ kSTLmapDefinition ESTLType.h:33; ROOT::kSTLunorderedmultiset@ kSTLunorderedmultisetDefinition ESTLType.h:43; ROOT::kROOTRVec@ kROOTRVecDefinition ESTLType.h:46; ROOT::kSTLend@ kSTLendDefinition ESTLType.h:47; ROOT::kSTLstring@ kSTLstringDefinition ESTLType.h:49; ROOT::kSTLset@ kSTLsetDefinition ESTLType.h:35; ROOT::kSTLmultiset@ kSTLmultisetDefinition ESTLType.h:36; ROOT::kSTLdeque@ kSTLdequeDefinition ESTLType.h:32; ROOT::kSTLvector@ kSTLvectorDefinition ESTLType.h:30; ROOT::kSTLany@ kSTLanyDefinition ESTLType.h:48; ROOT::kSTLunorderedmultimap@ kSTLunorderedmultimapDefinition ESTLType.h:45; ROOT::kS",MatchSource.WIKI,doc/v632/ESTLType_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/ESTLType_8h_source.html
https://root.cern/doc/v632/group__Math.html:4062,Availability,avail,available,4062,"n and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp Optimization library with linear and quadratic programming methods. It is based on the Matrix package. Further information is available at the following links:. The Math page in the manual; The Linear Algebra section in the manual; The Fitting histograms page in the manual; [Inventory of Math functions and algorithms] (http://project-mathlibs.web.cern.ch/project-mathlibs/mathTable.html) . Modules;  Physics Vectors;  Vector classes (2D, 3D and 4D / Lorentz vector) and their transformations. ;  ;  MathCore;  The Core Mathematical Library of ROOT. ;  ;  MathMore;  The Mathematical library providing some advanced functionality and based on GSL. ;  ;  Matrix Linear Algebra;  The ROOT Matrix Linear Algebra package. ;  ;  TMinuit;  The Minuit Minimization package. ;  ;  Minuit2 Minimization Library;  New Object-oriented implementation of the MINUIT minimization package. ;  ;  Legacy Physics Classes;  Legacy physics classes. ;  ;  SMatrix Package;  ;  Unuran;  Universal Non Uniform Random number generator for generating non uniform pseudo-random numbers. ;  . ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:10:",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:586,Deployability,integrat,integration,586,". ROOT: Math. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; Math. ; The ROOT Mathematical Libraries. ; They consist of the following components:. MathCore: a self-consistent minimal set of tools required for the basic numerical computing. It provides the major mathematical functions in the namespaces ROOT::Math and TMath, classes for random number generators, TRandom, class for complex numbers, TComplex, common interfaces for function evaluation and numerical algorithms. Basic implementations of some of the numerical algorithms such as integration or derivation, are also provided by MathCore. together with the core classes needed to fit any generic data set.; MathMore: a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linea",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:3415,Deployability,continuous,continuous,3415," algorithm (class TFumili). Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp Optimization library with linear and quadratic programming methods. It is based on the Matrix package. Further information is available at the following links:. The Math page in the manual; The Linear Algebra section in the manual; The Fitting histograms page in the manual; [Inventory of Math functions and algorithms] (http://project-mathlibs.web.cern.ch/project-mathlibs/mathTable.html) . Modules;  Physics Vectors;  Vector classes (2D, 3D and 4D / L",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:3553,Deployability,integrat,integrator,3553,"ses:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp Optimization library with linear and quadratic programming methods. It is based on the Matrix package. Further information is available at the following links:. The Math page in the manual; The Linear Algebra section in the manual; The Fitting histograms page in the manual; [Inventory of Math functions and algorithms] (http://project-mathlibs.web.cern.ch/project-mathlibs/mathTable.html) . Modules;  Physics Vectors;  Vector classes (2D, 3D and 4D / Lorentz vector) and their transformations. ;  ;  MathCore;  The Core Mathematical Library of ROOT. ;  ;  MathMore;  The Mathematical l",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:3790,Deployability,install,installation,3790,"ge optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp Optimization library with linear and quadratic programming methods. It is based on the Matrix package. Further information is available at the following links:. The Math page in the manual; The Linear Algebra section in the manual; The Fitting histograms page in the manual; [Inventory of Math functions and algorithms] (http://project-mathlibs.web.cern.ch/project-mathlibs/mathTable.html) . Modules;  Physics Vectors;  Vector classes (2D, 3D and 4D / Lorentz vector) and their transformations. ;  ;  MathCore;  The Core Mathematical Library of ROOT. ;  ;  MathMore;  The Mathematical library providing some advanced functionality and based on GSL. ;  ;  Matrix Linear Algebra;  The ROOT Matrix Linear Algebra package. ;  ;  TMinuit;  The Minuit Minimization package. ;  ;  Minuit2 Minimization Library;  New Object-oriented implementation of the MINUIT",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:459,Integrability,interface,interfaces,459,". ROOT: Math. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; Math. ; The ROOT Mathematical Libraries. ; They consist of the following components:. MathCore: a self-consistent minimal set of tools required for the basic numerical computing. It provides the major mathematical functions in the namespaces ROOT::Math and TMath, classes for random number generators, TRandom, class for complex numbers, TComplex, common interfaces for function evaluation and numerical algorithms. Basic implementations of some of the numerical algorithms such as integration or derivation, are also provided by MathCore. together with the core classes needed to fit any generic data set.; MathMore: a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linea",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:586,Integrability,integrat,integration,586,". ROOT: Math. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; Math. ; The ROOT Mathematical Libraries. ; They consist of the following components:. MathCore: a self-consistent minimal set of tools required for the basic numerical computing. It provides the major mathematical functions in the namespaces ROOT::Math and TMath, classes for random number generators, TRandom, class for complex numbers, TComplex, common interfaces for function evaluation and numerical algorithms. Basic implementations of some of the numerical algorithms such as integration or derivation, are also provided by MathCore. together with the core classes needed to fit any generic data set.; MathMore: a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linea",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:783,Integrability,depend,dependent,783,". ROOT: Math. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; Math. ; The ROOT Mathematical Libraries. ; They consist of the following components:. MathCore: a self-consistent minimal set of tools required for the basic numerical computing. It provides the major mathematical functions in the namespaces ROOT::Math and TMath, classes for random number generators, TRandom, class for complex numbers, TComplex, common interfaces for function evaluation and numerical algorithms. Basic implementations of some of the numerical algorithms such as integration or derivation, are also provided by MathCore. together with the core classes needed to fit any generic data set.; MathMore: a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linea",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:1006,Integrability,interface,interfaces,1006,". ROOT: Math. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; Math. ; The ROOT Mathematical Libraries. ; They consist of the following components:. MathCore: a self-consistent minimal set of tools required for the basic numerical computing. It provides the major mathematical functions in the namespaces ROOT::Math and TMath, classes for random number generators, TRandom, class for complex numbers, TComplex, common interfaces for function evaluation and numerical algorithms. Basic implementations of some of the numerical algorithms such as integration or derivation, are also provided by MathCore. together with the core classes needed to fit any generic data set.; MathMore: a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linea",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:1301,Integrability,interface,interface,1301," TMath, classes for random number generators, TRandom, class for complex numbers, TComplex, common interfaces for function evaluation and numerical algorithms. Basic implementations of some of the numerical algorithms such as integration or derivation, are also provided by MathCore. together with the core classes needed to fit any generic data set.; MathMore: a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of ",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:1636,Integrability,interface,interface,1636,"e numerical algorithms such as integration or derivation, are also provided by MathCore. together with the core classes needed to fit any generic data set.; MathMore: a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of the original Fumili fitting algorithm (class TFumili). Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:; Matrix: general matrix pack",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:1755,Integrability,interface,interface,1755,"ty and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of the original Fumili fitting algorithm (class TFumili). Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMa",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:3553,Integrability,integrat,integrator,3553,"ses:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp Optimization library with linear and quadratic programming methods. It is based on the Matrix package. Further information is available at the following links:. The Math page in the manual; The Linear Algebra section in the manual; The Fitting histograms page in the manual; [Inventory of Math functions and algorithms] (http://project-mathlibs.web.cern.ch/project-mathlibs/mathTable.html) . Modules;  Physics Vectors;  Vector classes (2D, 3D and 4D / Lorentz vector) and their transformations. ;  ;  MathCore;  The Core Mathematical Library of ROOT. ;  ;  MathMore;  The Mathematical l",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:2683,Performance,perform,perform,2683,"imization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of the original Fumili fitting algorithm (class TFumili). Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vector",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:2791,Performance,optimiz,optimized,2791,"implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of the original Fumili fitting algorithm (class TFumili). Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library ",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:2810,Performance,perform,performances,2810,"implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of the original Fumili fitting algorithm (class TFumili). Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library ",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__Math.html:2940,Performance,optimiz,optimization,2940,"s also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of the original Fumili fitting algorithm (class TFumili). Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlp",MatchSource.WIKI,doc/v632/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__Math.html
https://root.cern/doc/v632/group__MathCore.html:596,Availability,error,error,596,". ROOT: MathCore. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Files |; Classes ; MathCoreMath. ; The Core Mathematical Library of ROOT. ; MathCore provides a collection of functions and C++ classes for HEP numerical computing. This library provides only the basic mathematical functions and algorithms and not all the functionality required by the HEP community. More advanced mathematical functionalities is provided by the MathMore. The current set includes classes and functions for:. Basic special functions used in HEP like the gamma, beta and error function;; Statistical functions : mathematical functions used in statistics, such as the probability density functions and the cumulative distributions functions (lower and upper integral of the pdf's) for continuous and discrete distributions.;; Function Classes and Interfaces :; Generic Function Evaluation Interfaces, including helper class to wrap free (static) and non-static member functions; Parametric Function Evaluation Interfaces. Numerical algorithms: user classes with (in some cases) basic implementations for:; Numerical Integration; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization and Multi-dimensional Minimization. Fitting and Parameter Estimation :classes for fitting and parameter estimation from a given data set. Note that in this latest release the GenVector (physics and geometry vectors for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree",MatchSource.WIKI,doc/v632/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__MathCore.html
https://root.cern/doc/v632/group__MathCore.html:809,Deployability,continuous,continuous,809,". ROOT: MathCore. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Files |; Classes ; MathCoreMath. ; The Core Mathematical Library of ROOT. ; MathCore provides a collection of functions and C++ classes for HEP numerical computing. This library provides only the basic mathematical functions and algorithms and not all the functionality required by the HEP community. More advanced mathematical functionalities is provided by the MathMore. The current set includes classes and functions for:. Basic special functions used in HEP like the gamma, beta and error function;; Statistical functions : mathematical functions used in statistics, such as the probability density functions and the cumulative distributions functions (lower and upper integral of the pdf's) for continuous and discrete distributions.;; Function Classes and Interfaces :; Generic Function Evaluation Interfaces, including helper class to wrap free (static) and non-static member functions; Parametric Function Evaluation Interfaces. Numerical algorithms: user classes with (in some cases) basic implementations for:; Numerical Integration; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization and Multi-dimensional Minimization. Fitting and Parameter Estimation :classes for fitting and parameter estimation from a given data set. Note that in this latest release the GenVector (physics and geometry vectors for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree",MatchSource.WIKI,doc/v632/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__MathCore.html
https://root.cern/doc/v632/group__MathCore.html:1402,Deployability,release,release,1402,"hMore. The current set includes classes and functions for:. Basic special functions used in HEP like the gamma, beta and error function;; Statistical functions : mathematical functions used in statistics, such as the probability density functions and the cumulative distributions functions (lower and upper integral of the pdf's) for continuous and discrete distributions.;; Function Classes and Interfaces :; Generic Function Evaluation Interfaces, including helper class to wrap free (static) and non-static member functions; Parametric Function Evaluation Interfaces. Numerical algorithms: user classes with (in some cases) basic implementations for:; Numerical Integration; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization and Multi-dimensional Minimization. Fitting and Parameter Estimation :classes for fitting and parameter estimation from a given data set. Note that in this latest release the GenVector (physics and geometry vectors for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree and TKDTreeBinning for binning data using a kdTree; ROOT::Math::GoFTest for goodness of fit tests . Modules;  Fitting and Parameter Estimation;  Classes used for fitting (regression analysis) and estimation of parameter values given a data sample. ;  ;  Interface classes for Random number generation;  Pseudo-random numbers generator classes and for generation of random number distributions. ;  ;  Goodness of Fit Tests;  Classical one-dimensional goodness of git tests fo",MatchSource.WIKI,doc/v632/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__MathCore.html
https://root.cern/doc/v632/group__MathCore.html:2925,Deployability,continuous,continuous,2925,"2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree and TKDTreeBinning for binning data using a kdTree; ROOT::Math::GoFTest for goodness of fit tests . Modules;  Fitting and Parameter Estimation;  Classes used for fitting (regression analysis) and estimation of parameter values given a data sample. ;  ;  Interface classes for Random number generation;  Pseudo-random numbers generator classes and for generation of random number distributions. ;  ;  Goodness of Fit Tests;  Classical one-dimensional goodness of git tests for unbinned data. ;  ;  Function Classes and Interfaces;  Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ;  ;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  . Files; file  RFit.hxx;  . Classes; class  ROOT::Math::Delaunay2D;  Class to generate a Delaunay triangulation of a 2D set of points. More...;  ; class  TKDTreeBinning;  <- TKDTreeBinning - A class providing multidimensional binning -> More...;  ; class  TStatistic;  Statistical variable, defined by its mean and variance (RMS). More...;  . ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:10:08 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/v632/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__MathCore.html
https://root.cern/doc/v632/group__MathCore.html:951,Integrability,wrap,wrap,951,". ROOT: MathCore. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Files |; Classes ; MathCoreMath. ; The Core Mathematical Library of ROOT. ; MathCore provides a collection of functions and C++ classes for HEP numerical computing. This library provides only the basic mathematical functions and algorithms and not all the functionality required by the HEP community. More advanced mathematical functionalities is provided by the MathMore. The current set includes classes and functions for:. Basic special functions used in HEP like the gamma, beta and error function;; Statistical functions : mathematical functions used in statistics, such as the probability density functions and the cumulative distributions functions (lower and upper integral of the pdf's) for continuous and discrete distributions.;; Function Classes and Interfaces :; Generic Function Evaluation Interfaces, including helper class to wrap free (static) and non-static member functions; Parametric Function Evaluation Interfaces. Numerical algorithms: user classes with (in some cases) basic implementations for:; Numerical Integration; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization and Multi-dimensional Minimization. Fitting and Parameter Estimation :classes for fitting and parameter estimation from a given data set. Note that in this latest release the GenVector (physics and geometry vectors for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree",MatchSource.WIKI,doc/v632/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__MathCore.html
https://root.cern/doc/v632/group__MathCore.html:3293,Modifiability,variab,variable,3293,"2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree and TKDTreeBinning for binning data using a kdTree; ROOT::Math::GoFTest for goodness of fit tests . Modules;  Fitting and Parameter Estimation;  Classes used for fitting (regression analysis) and estimation of parameter values given a data sample. ;  ;  Interface classes for Random number generation;  Pseudo-random numbers generator classes and for generation of random number distributions. ;  ;  Goodness of Fit Tests;  Classical one-dimensional goodness of git tests for unbinned data. ;  ;  Function Classes and Interfaces;  Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ;  ;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  . Files; file  RFit.hxx;  . Classes; class  ROOT::Math::Delaunay2D;  Class to generate a Delaunay triangulation of a 2D set of points. More...;  ; class  TKDTreeBinning;  <- TKDTreeBinning - A class providing multidimensional binning -> More...;  ; class  TStatistic;  Statistical variable, defined by its mean and variance (RMS). More...;  . ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:10:08 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/v632/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__MathCore.html
https://root.cern/doc/v632/group__MathCore.html:2094,Testability,test,tests,2094," Function Evaluation Interfaces. Numerical algorithms: user classes with (in some cases) basic implementations for:; Numerical Integration; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization and Multi-dimensional Minimization. Fitting and Parameter Estimation :classes for fitting and parameter estimation from a given data set. Note that in this latest release the GenVector (physics and geometry vectors for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree and TKDTreeBinning for binning data using a kdTree; ROOT::Math::GoFTest for goodness of fit tests . Modules;  Fitting and Parameter Estimation;  Classes used for fitting (regression analysis) and estimation of parameter values given a data sample. ;  ;  Interface classes for Random number generation;  Pseudo-random numbers generator classes and for generation of random number distributions. ;  ;  Goodness of Fit Tests;  Classical one-dimensional goodness of git tests for unbinned data. ;  ;  Function Classes and Interfaces;  Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ;  ;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  . ",MatchSource.WIKI,doc/v632/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__MathCore.html
https://root.cern/doc/v632/group__MathCore.html:2468,Testability,test,tests,2468,"ry vectors for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree and TKDTreeBinning for binning data using a kdTree; ROOT::Math::GoFTest for goodness of fit tests . Modules;  Fitting and Parameter Estimation;  Classes used for fitting (regression analysis) and estimation of parameter values given a data sample. ;  ;  Interface classes for Random number generation;  Pseudo-random numbers generator classes and for generation of random number distributions. ;  ;  Goodness of Fit Tests;  Classical one-dimensional goodness of git tests for unbinned data. ;  ;  Function Classes and Interfaces;  Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ;  ;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  . Files; file  RFit.hxx;  . Classes; class  ROOT::Math::Delaunay2D;  Class to generate a Delaunay triangulation of a 2D set of points. More...;  ; class  TKDTreeBinning;  <- TKDTreeBinning - A class providing multidimensional binning -> More...;  ; class  TStatistic;  Statistical variable, defined by its mean and variance (RMS). More...;  . ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:10:08 (GVA Time) using Doxyge",MatchSource.WIKI,doc/v632/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__MathCore.html
https://root.cern/doc/v632/group__MathMore.html:1520,Availability,down,downloaded,1520,"l functions, Mathematical functions used in statistics such as probability density functions, cumulative distributions functions and their inverse (quantiles).; Numerical algorithms:; Numerical Integration; Numerical Monte Carlo Integration Classes; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization; Multi-dimensional Minimization. Interpolation Classes; Function Approximation (ChebyshevApprox), based on Chebyshev polynomials; Interface classes for Random number generation. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document). The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). To build MathMore you need to have first GSL installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar file of GSL can be downloaded from the GSL Web site, or (for version 1.8) from here. Windows binaries, compiled using Visual Studio 7.1 can be downloaded from this location.; MathMore (and its ROOT CINT dictionary) can be built within ROOT whenever a GSL library is found in the system. Optionally the GSL library and header file location can be specified in the ROOT configure script with configure –with-gsl-incdir=... –with-gsl-libdir=... MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL needs to be compiled with the option –with-pic. The source code of MathMore is distributed under the GNU General Public License . Modules;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  ;  QuasiRandom num",MatchSource.WIKI,doc/v632/group__MathMore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__MathMore.html
https://root.cern/doc/v632/group__MathMore.html:1644,Availability,down,downloaded,1644,"nctions and their inverse (quantiles).; Numerical algorithms:; Numerical Integration; Numerical Monte Carlo Integration Classes; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization; Multi-dimensional Minimization. Interpolation Classes; Function Approximation (ChebyshevApprox), based on Chebyshev polynomials; Interface classes for Random number generation. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document). The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). To build MathMore you need to have first GSL installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar file of GSL can be downloaded from the GSL Web site, or (for version 1.8) from here. Windows binaries, compiled using Visual Studio 7.1 can be downloaded from this location.; MathMore (and its ROOT CINT dictionary) can be built within ROOT whenever a GSL library is found in the system. Optionally the GSL library and header file location can be specified in the ROOT configure script with configure –with-gsl-incdir=... –with-gsl-libdir=... MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL needs to be compiled with the option –with-pic. The source code of MathMore is distributed under the GNU General Public License . Modules;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  ;  QuasiRandom number generators and distributions;  Classes for generating QuasiRandom numbers and based on GSL. ;  . ROOT v6-32 - Referenc",MatchSource.WIKI,doc/v632/group__MathMore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__MathMore.html
https://root.cern/doc/v632/group__MathMore.html:1409,Deployability,install,installed,1409,"ses and functions for:. Special functions, with all the major functions (Bessel functions, Legendre polynomial, etc..); Statistical functions, Mathematical functions used in statistics such as probability density functions, cumulative distributions functions and their inverse (quantiles).; Numerical algorithms:; Numerical Integration; Numerical Monte Carlo Integration Classes; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization; Multi-dimensional Minimization. Interpolation Classes; Function Approximation (ChebyshevApprox), based on Chebyshev polynomials; Interface classes for Random number generation. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document). The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). To build MathMore you need to have first GSL installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar file of GSL can be downloaded from the GSL Web site, or (for version 1.8) from here. Windows binaries, compiled using Visual Studio 7.1 can be downloaded from this location.; MathMore (and its ROOT CINT dictionary) can be built within ROOT whenever a GSL library is found in the system. Optionally the GSL library and header file location can be specified in the ROOT configure script with configure –with-gsl-incdir=... –with-gsl-libdir=... MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL needs to be compiled with the option –with-pic. The source code of MathMore is distributed under the GNU General Public License . Modules;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various sta",MatchSource.WIKI,doc/v632/group__MathMore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__MathMore.html
https://root.cern/doc/v632/group__MathMore.html:2428,Deployability,continuous,continuous,2428,"n; Numerical Monte Carlo Integration Classes; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization; Multi-dimensional Minimization. Interpolation Classes; Function Approximation (ChebyshevApprox), based on Chebyshev polynomials; Interface classes for Random number generation. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document). The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). To build MathMore you need to have first GSL installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar file of GSL can be downloaded from the GSL Web site, or (for version 1.8) from here. Windows binaries, compiled using Visual Studio 7.1 can be downloaded from this location.; MathMore (and its ROOT CINT dictionary) can be built within ROOT whenever a GSL library is found in the system. Optionally the GSL library and header file location can be specified in the ROOT configure script with configure –with-gsl-incdir=... –with-gsl-libdir=... MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL needs to be compiled with the option –with-pic. The source code of MathMore is distributed under the GNU General Public License . Modules;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  ;  QuasiRandom number generators and distributions;  Classes for generating QuasiRandom numbers and based on GSL. ;  . ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:10:08 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/v632/group__MathMore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__MathMore.html
https://root.cern/doc/v632/group__MathMore.html:1314,Integrability,wrap,wrapping,1314,"ension of the functionality provided by the MathCore. The current set includes classes and functions for:. Special functions, with all the major functions (Bessel functions, Legendre polynomial, etc..); Statistical functions, Mathematical functions used in statistics such as probability density functions, cumulative distributions functions and their inverse (quantiles).; Numerical algorithms:; Numerical Integration; Numerical Monte Carlo Integration Classes; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization; Multi-dimensional Minimization. Interpolation Classes; Function Approximation (ChebyshevApprox), based on Chebyshev polynomials; Interface classes for Random number generation. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document). The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). To build MathMore you need to have first GSL installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar file of GSL can be downloaded from the GSL Web site, or (for version 1.8) from here. Windows binaries, compiled using Visual Studio 7.1 can be downloaded from this location.; MathMore (and its ROOT CINT dictionary) can be built within ROOT whenever a GSL library is found in the system. Optionally the GSL library and header file location can be specified in the ROOT configure script with configure –with-gsl-incdir=... –with-gsl-libdir=... MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL needs to be compiled with the option –with-pic. The source code of MathMore is distributed under the GNU General Public License . Modules;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functio",MatchSource.WIKI,doc/v632/group__MathMore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__MathMore.html
https://root.cern/doc/v632/group__MathMore.html:1869,Modifiability,config,configure,1869,"n; Numerical Monte Carlo Integration Classes; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization; Multi-dimensional Minimization. Interpolation Classes; Function Approximation (ChebyshevApprox), based on Chebyshev polynomials; Interface classes for Random number generation. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document). The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). To build MathMore you need to have first GSL installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar file of GSL can be downloaded from the GSL Web site, or (for version 1.8) from here. Windows binaries, compiled using Visual Studio 7.1 can be downloaded from this location.; MathMore (and its ROOT CINT dictionary) can be built within ROOT whenever a GSL library is found in the system. Optionally the GSL library and header file location can be specified in the ROOT configure script with configure –with-gsl-incdir=... –with-gsl-libdir=... MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL needs to be compiled with the option –with-pic. The source code of MathMore is distributed under the GNU General Public License . Modules;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  ;  QuasiRandom number generators and distributions;  Classes for generating QuasiRandom numbers and based on GSL. ;  . ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:10:08 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/v632/group__MathMore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__MathMore.html
https://root.cern/doc/v632/group__MathMore.html:1891,Modifiability,config,configure,1891,"n; Numerical Monte Carlo Integration Classes; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization; Multi-dimensional Minimization. Interpolation Classes; Function Approximation (ChebyshevApprox), based on Chebyshev polynomials; Interface classes for Random number generation. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document). The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). To build MathMore you need to have first GSL installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar file of GSL can be downloaded from the GSL Web site, or (for version 1.8) from here. Windows binaries, compiled using Visual Studio 7.1 can be downloaded from this location.; MathMore (and its ROOT CINT dictionary) can be built within ROOT whenever a GSL library is found in the system. Optionally the GSL library and header file location can be specified in the ROOT configure script with configure –with-gsl-incdir=... –with-gsl-libdir=... MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL needs to be compiled with the option –with-pic. The source code of MathMore is distributed under the GNU General Public License . Modules;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  ;  QuasiRandom number generators and distributions;  Classes for generating QuasiRandom numbers and based on GSL. ;  . ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:10:08 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/v632/group__MathMore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__MathMore.html
https://root.cern/doc/v632/group__StatFunc.html:339,Deployability,continuous,continuous,339,". ROOT: Statistical functions. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Namespaces |; Classes ; Statistical functionsMath » MathCore | Math » MathMore. ; Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ; Whenever possible the conventions followed are those of the CRC Concise Encyclopedia of Mathematics, Second Edition (or Mathworld). By convention the distributions are centered around 0, so for example in the case of a Gaussian there is no parameter mu. The user must calculate the shift themselves if they wish.; MathCore provides the majority of the probability density functions, of the cumulative distributions and of the quantiles (inverses of the cumulatives). Additional distributions are also provided by the MathMore library. . Modules;  Probability Density Functions (PDF);  Probability density functions of various statistical distributions (continuous and discrete). ;  ;  Cumulative Distribution Functions (CDF);  Cumulative distribution functions of various distributions. ;  ;  Statistical functions from truncated distributions;  Statistical functions for the truncated distributions. ;  ;  Quantile Functions;  Inverse functions of the cumulative distribution functions and the inverse of the complement of the cumulative distribution functions for various distributions. ;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Classes; class  ROOT::Math::Vavilov;  Base class describing a Vavilov distribution. More...;  ; class  ROOT::Math::VavilovAccurate;  Class describing a Vavilov distribution. More...;  ; class  ROOT::Math::VavilovAccurateCdf;  Class describing the Vavilov cdf. More...;  ; class  ROOT::Math::VavilovAccuratePdf;  Class describing the Vavilov pdf. Mo",MatchSource.WIKI,doc/v632/group__StatFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__StatFunc.html
https://root.cern/doc/v632/group__StatFunc.html:1020,Deployability,continuous,continuous,1020,". ROOT: Statistical functions. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Namespaces |; Classes ; Statistical functionsMath » MathCore | Math » MathMore. ; Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ; Whenever possible the conventions followed are those of the CRC Concise Encyclopedia of Mathematics, Second Edition (or Mathworld). By convention the distributions are centered around 0, so for example in the case of a Gaussian there is no parameter mu. The user must calculate the shift themselves if they wish.; MathCore provides the majority of the probability density functions, of the cumulative distributions and of the quantiles (inverses of the cumulatives). Additional distributions are also provided by the MathMore library. . Modules;  Probability Density Functions (PDF);  Probability density functions of various statistical distributions (continuous and discrete). ;  ;  Cumulative Distribution Functions (CDF);  Cumulative distribution functions of various distributions. ;  ;  Statistical functions from truncated distributions;  Statistical functions for the truncated distributions. ;  ;  Quantile Functions;  Inverse functions of the cumulative distribution functions and the inverse of the complement of the cumulative distribution functions for various distributions. ;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Classes; class  ROOT::Math::Vavilov;  Base class describing a Vavilov distribution. More...;  ; class  ROOT::Math::VavilovAccurate;  Class describing a Vavilov distribution. More...;  ; class  ROOT::Math::VavilovAccurateCdf;  Class describing the Vavilov cdf. More...;  ; class  ROOT::Math::VavilovAccuratePdf;  Class describing the Vavilov pdf. Mo",MatchSource.WIKI,doc/v632/group__StatFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/group__StatFunc.html
https://root.cern/doc/v632/legend1_8C.html:291,Availability,error,error,291,". ROOT: graf2d/graf/doc/macros/legend1.C File Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions |; Variables ; legend1.C File Reference. Functions; leg AddEntry (""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");  ; leg AddEntry (""gr"",""Graph with error bars"",""lep"");  ; leg AddEntry (h1,""Histogram filled with random numbers"",""f"");  ; gr Draw (""P"");  ; f1 Draw (""same"");  ; h1 Draw ();  ; h1 FillRandom (""gaus"", 30000);  ;  for (Int_t i=0;i< n;i++);  ; h1 SetFillColor (kGreen);  ; h1 SetFillStyle (3003);  ; leg SetHeader (""The Legend Title"");  ; f1 SetLineColor (kBlue);  ; gr SetLineColor (kRed);  ; gr SetLineWidth (2);  ; f1 SetLineWidth (4);  ; gr SetMarkerColor (7);  ; gr SetMarkerSize (1.3);  ; gr SetMarkerStyle (21);  ; gr SetName (""gr"");  ; gStyle SetOptStat (0);  . Variables; return c1;  ; Double_t ex [n];  ; Double_t ey [n];  ; TF1 * f1 =new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);  ; TGraphErrors * gr = new TGraphErrors(n,x,y,ex,ey);  ; TH1F * h1 = new TH1F(""h1"",""TLegend Example"",200,-10,10);  ;  leg = new TLegend(0.1,0.7,0.48,0.9);  ; const Int_t n = 20;  ; Double_t x [n];  ; Double_t y [n];  . Function Documentation. ◆ AddEntry() [1/3]. leg AddEntry ; (; ""f1"" ; , . ""Function abs(#frac{sin(x)}{x})"" ; , . ""l"" ;  . ). ◆ AddEntry() [2/3]. leg AddEntry ; (; ""gr"" ; , . ""Graph with error bars"" ; , . ""lep"" ;  . ). ◆ AddEntry() [3/3]. leg AddEntry ; (; h1 ; , . ""Histogram filled with random numbers"" ; , . ""f"" ;  . ). ◆ Draw() [1/3]. gr Draw ; (; ""P"" ; ). ◆ Draw() [2/3]. f1 Draw ; (; ""same"" ; ). ◆ Draw() [3/3]. h1 Draw ; (; ). ◆ FillRandom(). h1 FillRandom ; (; ""gaus"" ; , . 30000 ;  . ). ◆ for(). for ; (; ). Definition at line 18 of file legend1.C. ◆ SetFillColor(). h1 SetFillColor ; (; kGreen ; ). ◆ SetFillStyle(). h1 SetFillStyle ; (; 3003 ; ). ◆ SetHeader(). leg SetHeader ; (; ""The Legend Title"" ; ). ◆ SetLineColor() [1/2]. f1 SetLineColor ; (; kBlue ; ). ◆ SetLineColor() [2/2]. gr SetLineColor ; (; kRed ; ). ◆ SetLine",MatchSource.WIKI,doc/v632/legend1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/legend1_8C.html
https://root.cern/doc/v632/legend1_8C.html:1352,Availability,error,error,1352,"random numbers"",""f"");  ; gr Draw (""P"");  ; f1 Draw (""same"");  ; h1 Draw ();  ; h1 FillRandom (""gaus"", 30000);  ;  for (Int_t i=0;i< n;i++);  ; h1 SetFillColor (kGreen);  ; h1 SetFillStyle (3003);  ; leg SetHeader (""The Legend Title"");  ; f1 SetLineColor (kBlue);  ; gr SetLineColor (kRed);  ; gr SetLineWidth (2);  ; f1 SetLineWidth (4);  ; gr SetMarkerColor (7);  ; gr SetMarkerSize (1.3);  ; gr SetMarkerStyle (21);  ; gr SetName (""gr"");  ; gStyle SetOptStat (0);  . Variables; return c1;  ; Double_t ex [n];  ; Double_t ey [n];  ; TF1 * f1 =new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);  ; TGraphErrors * gr = new TGraphErrors(n,x,y,ex,ey);  ; TH1F * h1 = new TH1F(""h1"",""TLegend Example"",200,-10,10);  ;  leg = new TLegend(0.1,0.7,0.48,0.9);  ; const Int_t n = 20;  ; Double_t x [n];  ; Double_t y [n];  . Function Documentation. ◆ AddEntry() [1/3]. leg AddEntry ; (; ""f1"" ; , . ""Function abs(#frac{sin(x)}{x})"" ; , . ""l"" ;  . ). ◆ AddEntry() [2/3]. leg AddEntry ; (; ""gr"" ; , . ""Graph with error bars"" ; , . ""lep"" ;  . ). ◆ AddEntry() [3/3]. leg AddEntry ; (; h1 ; , . ""Histogram filled with random numbers"" ; , . ""f"" ;  . ). ◆ Draw() [1/3]. gr Draw ; (; ""P"" ; ). ◆ Draw() [2/3]. f1 Draw ; (; ""same"" ; ). ◆ Draw() [3/3]. h1 Draw ; (; ). ◆ FillRandom(). h1 FillRandom ; (; ""gaus"" ; , . 30000 ;  . ). ◆ for(). for ; (; ). Definition at line 18 of file legend1.C. ◆ SetFillColor(). h1 SetFillColor ; (; kGreen ; ). ◆ SetFillStyle(). h1 SetFillStyle ; (; 3003 ; ). ◆ SetHeader(). leg SetHeader ; (; ""The Legend Title"" ; ). ◆ SetLineColor() [1/2]. f1 SetLineColor ; (; kBlue ; ). ◆ SetLineColor() [2/2]. gr SetLineColor ; (; kRed ; ). ◆ SetLineWidth() [1/2]. gr SetLineWidth ; (; 2 ; ). ◆ SetLineWidth() [2/2]. f1 SetLineWidth ; (; 4 ; ). ◆ SetMarkerColor(). gr SetMarkerColor ; (; 7 ; ). ◆ SetMarkerSize(). gr SetMarkerSize ; (; 1. ; 3). ◆ SetMarkerStyle(). gr SetMarkerStyle ; (; 21 ; ). ◆ SetName(). gr SetName ; (; ""gr"" ; ). ◆ SetOptStat(). gStyle SetOptStat ; (; 0 ; ). Variable Documentation",MatchSource.WIKI,doc/v632/legend1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/legend1_8C.html
https://root.cern/doc/v632/legend1_8C_source.html:1267,Availability,error,error,1267,"""c1"",""c1"",600,500);; 3 gStyle->SetOptStat(0);; 4 ; 5 TH1F *h1 = new TH1F(""h1"",""TLegend Example"",200,-10,10);; 6 h1->FillRandom(""gaus"",30000);; 7 h1->SetFillColor(kGreen);; 8 h1->SetFillStyle(3003);; 9 h1->Draw();; 10 ; 11 TF1 *f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; 12 f1->SetLineColor(kBlue);; 13 f1->SetLineWidth(4);; 14 f1->Draw(""same"");; 15 ; 16 const Int_t n = 20;; 17 Double_t x[n], y[n], ex[n], ey[n];; 18 for (Int_t i=0;i<n;i++) {; 19 x[i] = i*0.1;; 20 y[i] = 1000*sin(x[i]+0.2);; 21 x[i] = 17.8*x[i]-8.9;; 22 ex[i] = 1.0;; 23 ey[i] = 10.*i;; 24 }; 25 TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; 26 gr->SetName(""gr"");; 27 gr->SetLineColor(kRed);; 28 gr->SetLineWidth(2);; 29 gr->SetMarkerStyle(21);; 30 gr->SetMarkerSize(1.3);; 31 gr->SetMarkerColor(7);; 32 gr->Draw(""P"");; 33 ; 34 leg = new TLegend(0.1,0.7,0.48,0.9);; 35 leg->SetHeader(""The Legend Title"");; 36 leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; 37 leg->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; 38 leg->AddEntry(""gr"",""Graph with error bars"",""lep"");; 39 leg->Draw();; 40 ; 41 return c1;; 42}; 43 ; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:433; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t ",MatchSource.WIKI,doc/v632/legend1_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/legend1_8C_source.html
https://root.cern/doc/v632/legend1_8C_source.html:2647,Availability,error,error,2647,"d SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TAttMarker::SetMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TF1::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF1.cxx:1335; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraph::SetNamevoid SetName(const char *name="""") overrideSet graph name.Definition TGraph.cxx:2364; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:814; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:621; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1636; yDouble_t y[n]Definition legend1.C:17; c1return c1Defi",MatchSource.WIKI,doc/v632/legend1_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/legend1_8C_source.html
https://root.cern/doc/v632/namespaceROOT.html:18318,Availability,down,down,18318,"al::RLogChannel & RGeomLog ();  Log channel for Geomviewer diagnostics. ;  ; template<class RootClass > ; Short_t SetClassVersion (RootClass *);  ; std::vector< std::string > Split (std::string_view str, std::string_view delims, bool skipEmpty);  Splits a string at each character in delims. ;  ; static void StrReplace (std::string &proc, const std::string &pat, const std::string &tr);  Replace all accurances of given string with other string. ;  ; template<typename value_type > ; void ToHumanReadableSize (value_type bytes, Bool_t si, Double_t *coeff, const char **units);  Return the size expressed in 'human readable' format. ;  ; static Bool_t ValidateRule (const std::map< std::string, std::string > &rule, std::string &error_string);  Validate if the user specified rules are correct. ;  ; ROOT::Experimental::RLogChannel & WebGUILog ();  Log channel for WebGUI diagnostics. ;  ; static void WriteAutoVariables (const std::list< std::string > &target, const SourceTypeList_t &source, MembersTypeMap_t &members, std::string &className, std::string &mappedName, std::ostream &output);  Write down the sources. ;  ; void WriteReadRawRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for ReadRaw rule, the function name is being written to rule[""funcname""]. ;  ; void WriteReadRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for Read rule, the function name is being written to rule[""funcname""]. ;  ; void WriteSchemaList (std::list< SchemaRuleMap_t > &rules, const std::string &listName, std::ostream &output);  Write schema rules. ;  . Variables; R__EXTERN TVirtualRWMutex * gCoreMutex = nullptr;  ; R__EXTERN SchemaRuleClassMap_t gReadRawRules;  ; R__EXTERN SchemaRuleClassMap_t gReadRules;  ; struct ROOT::RQt5CreatorReg newRQt5CreatorReg;  ; struct ROOT::RQt6CreatorReg newRQt6CreatorReg;",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:31794,Availability,avail,available,31794,"884 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5869 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 556 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if R",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:35624,Availability,failure,failure,35624," thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and only if the parse is successful and does not overflow for the type of value. . Returnsreturn a EFromHumanReadableSize enum value indicating the success or failure of the parse. ; Definition at line 86 of file StringConv.hxx. ◆ GetClass() [1/5]. template<typename T > . TClass * ROOT::GetClass ; (; const T * ; ). Definition at line 664 of file TClass.h. ◆ GetClass() [2/5]. template<typename T > . TClass * ROOT::GetClass ; (; const T ** ; ). Definition at line 669 of file TClass.h. ◆ GetClass() [3/5]. template<typename T > . TClass * ROOT::GetClass ; (; const T *const * ; ). Definition at line 671 of file TClass.h. ◆ GetClass() [4/5]. template<typename T > . TClass * ROOT::GetClass ; (; T * ; ). Definition at line 663 of file TClass.h. ◆ GetClass() [5/5]. template<typename T > . TClass * ROOT::GetClass ; (; T ** ; ). Definition at line 668 of file TClass.h. ◆ GetDelayedAddClass(). std::vector< std::unique_ptr< TClassRec > > & ROOT::GetDelayedAddClass ; (; ). Definition at line 248 of file TClassTable.cxx. ◆ GetDelayedAddClassAlternate(). std::vector< std::pair< const char *, const char * > > & ROOT::GetDelayedAdd",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:45322,Availability,down,down,45322," 'human readable' format. ; Parameters. bytesthe size in bytes to be converted ; siwhether to use the SI units or not. ; coeffreturn the size expressed in the new unit. ; unitsreturn a pointer to the string representation of the new unit . Definition at line 38 of file StringConv.hxx. ◆ ValidateRule(). static Bool_t ROOT::ValidateRule ; (; const std::map< std::string, std::string > & ; rule, . std::string & ; error_string . ). static . Validate if the user specified rules are correct. ; Definition at line 291 of file RConversionRuleParser.cxx. ◆ WebGUILog(). ROOT::Experimental::RLogChannel & ROOT::WebGUILog ; (; ). Log channel for WebGUI diagnostics. ; Definition at line 24 of file RWebDisplayArgs.cxx. ◆ WriteAutoVariables(). static void ROOT::WriteAutoVariables ; (; const std::list< std::string > & ; target, . const SourceTypeList_t & ; source, . MembersTypeMap_t & ; members, . std::string & ; className, . std::string & ; mappedName, . std::ostream & ; output . ). static . Write down the sources. ; Definition at line 490 of file RConversionRuleParser.cxx. ◆ WriteReadRawRuleFunc(). void ROOT::WriteReadRawRuleFunc ; (; SchemaRuleMap_t & ; rule, . int ; index, . std::string & ; mappedName, . MembersTypeMap_t & ; members, . std::ostream & ; output . ). Write the conversion function for ReadRaw rule, the function name is being written to rule[""funcname""]. ; Definition at line 708 of file RConversionRuleParser.cxx. ◆ WriteReadRuleFunc(). void ROOT::WriteReadRuleFunc ; (; SchemaRuleMap_t & ; rule, . int ; index, . std::string & ; mappedName, . MembersTypeMap_t & ; members, . std::ostream & ; output . ). Write the conversion function for Read rule, the function name is being written to rule[""funcname""]. ; Definition at line 655 of file RConversionRuleParser.cxx. ◆ WriteSchemaList(). void ROOT::WriteSchemaList ; (; std::list< SchemaRuleMap_t > & ; rules, . const std::string & ; listName, . std::ostream & ; output . ). Write schema rules. ; Definition at line 779 of file RCo",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:17176,Deployability,update,update,17176,"nge_t > RangeDynCast (Range_t &&coll);  Takes any collection that can be used in range-based loops and applies dynamic_cast<T> to each element. ;  ; template<typename T , typename U , std::size_t N> ; RRangeCast< T, true, std::span< U > > RangeDynCast (U(&arr)[N]);  ; template<typename T , typename Range_t > ; RRangeCast< T, false, Range_t > RangeStaticCast (Range_t &&coll);  Takes any collection that can be used in range-based loops and applies static_cast<T> to each element. ;  ; template<typename T , typename U , std::size_t N> ; RRangeCast< T, false, std::span< U > > RangeStaticCast (U(&arr)[N]);  ; TNamed * RegisterClassTemplate (const char *name, const char *file, Int_t line);  Global function to register the implementation file and line of a class template (i.e. ;  ; void RemoveClass (const char *cname, TClass *cl);  Global function called by the dtor of a class's init class (see the ClassImp macro). ;  ; void RemoveClassAlternate (ROOT::TClassAlt *);  ; void ResetClassVersion (TClass *, const char *, Short_t);  Global function to update the version number. ;  ; Experimental::RLogChannel & RGeomLog ();  Log channel for Geomviewer diagnostics. ;  ; template<class RootClass > ; Short_t SetClassVersion (RootClass *);  ; std::vector< std::string > Split (std::string_view str, std::string_view delims, bool skipEmpty);  Splits a string at each character in delims. ;  ; static void StrReplace (std::string &proc, const std::string &pat, const std::string &tr);  Replace all accurances of given string with other string. ;  ; template<typename value_type > ; void ToHumanReadableSize (value_type bytes, Bool_t si, Double_t *coeff, const char **units);  Return the size expressed in 'human readable' format. ;  ; static Bool_t ValidateRule (const std::map< std::string, std::string > &rule, std::string &error_string);  Validate if the user specified rules are correct. ;  ; ROOT::Experimental::RLogChannel & WebGUILog ();  Log channel for WebGUI diagnostics. ;  ; static void Wr",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:35438,Deployability,update,updated,35438,"ing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and only if the parse is successful and does not overflow for the type of value. . Returnsreturn a EFromHumanReadableSize enum value indicating the success or failure of the parse. ; Definition at line 86 of file StringConv.hxx. ◆ GetClass() [1/5]. template<typename T > . TClass * ROOT::GetClass ; (; const T * ; ). Definition at line 664 of file TClass.h. ◆ GetClass() [2/5]. template<typename T > . TClass * ROOT::GetClass ; (; const T ** ; ). Definition at line 669 of file TClass.h. ◆ GetClass() [3/5]. template<typename T > . TClass * ROOT::GetClass ; (; const T *const * ; ). Definition at line 671 of file TClass.h. ◆ GetClass() [4/5]. template<typename T > . TClass * ROOT::GetClass ; (; T * ; ). Definition at line 663 of file TClass.h. ◆ GetClass() [5/5]. template<typename T > . TClass * ROOT::GetClass ; (; T ** ; ). Definition at line 668 of file TClass.h. ◆ GetDelayedAddClass(). std::vector< std::unique_ptr< TClassRec > > & ROOT::GetDelayedAddClass ; (; ). Definition at line 248 of file ",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:42571,Deployability,update,update,42571,"geStaticCast() [2/2]. template<typename T , typename U , std::size_t N> . RRangeCast< T, false, std::span< U > > ROOT::RangeStaticCast ; (; U(&) ; arr[N]). Definition at line 186 of file RRangeCast.hxx. ◆ RegisterClassTemplate(). TNamed * ROOT::RegisterClassTemplate ; (; const char * ; name, . const char * ; file, . Int_t ; line . ). Global function to register the implementation file and line of a class template (i.e. ; NOT a concrete class). ; Definition at line 1005 of file TClassTable.cxx. ◆ RemoveClass(). void ROOT::RemoveClass ; (; const char * ; cname, . TClass * ; cl . ). Global function called by the dtor of a class's init class (see the ClassImp macro). ; Definition at line 985 of file TClassTable.cxx. ◆ RemoveClassAlternate(). void ROOT::RemoveClassAlternate ; (; ROOT::TClassAlt * ; alt). Definition at line 931 of file TClassTable.cxx. ◆ ResetClassVersion(). void ROOT::ResetClassVersion ; (; TClass * ; cl, . const char * ; cname, . Short_t ; newid . ). Global function to update the version number. ; This is called via the RootClassVersion macro.; if cl!=0 and cname==-1, set the new class version if and only is greater than the existing one and greater or equal to 2; and also ignore the request if fVersionUsed is true.; Note on class version number:; If no class has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specify via ClassDef indicates that the I/O should use the TClass checksum to distinguish the layout of the class . Definition at line 951 of file TClassTable.cxx. ◆ RGeomLog(). ROOT::Experimental::RLogChannel & ROOT::RGeomLog ; (; ). Log channel for Geomviewer diagnostics. ; Definition at line 49 of file RGeomData.cxx. ◆ SetClassVersion(). template<class RootClass > . Short_t ROOT::SetClassVersion ; (; RootClass * ; ). ◆ Split(). std::vector< std::string > ROOT::Split ; (; std::string_view ; str, . std::string_view ; delims, . bool ; skipEmpty . ). Splits",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:32798,Energy Efficiency,schedul,scheduler,32798,"The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT ob",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:33055,Energy Efficiency,schedul,scheduling,33055,"loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:35327,Energy Efficiency,power,power,35327,"letion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and only if the parse is successful and does not overflow for the type of value. . Returnsreturn a EFromHumanReadableSize enum value indicating the success or failure of the parse. ; Definition at line 86 of file StringConv.hxx. ◆ GetClass() [1/5]. template<typename T > . TClass * ROOT::GetClass ; (; const T * ; ). Definition at line 664 of file TClass.h. ◆ GetClass() [2/5]. template<typename T > . TClass * ROOT::GetClass ; (; const T ** ; ). Definition at line 669 of file TClass.h. ◆ GetClass() [3/5]. template<typename T > . TClass * ROOT::GetClass ; (; const T *const * ; ). Definition at line 671 of file TClass.h. ◆ GetClass() [4/5]. template<typename T > . TClass * ROOT::GetClass ; (; T * ; ). Definition at line 663 of file TClass.h. ◆ GetClass() [5/5]. template<typename T > . TClass * ROOT::GetClass ; (; T ** ;",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:2319,Integrability,depend,depend,2319,"or ROOT. ;  ; namespace  RDF;  ; namespace  TestSupport;  ; namespace  TF1Helper;  ; namespace  TMetaUtils;  ; namespace  TreeUtils;  ; namespace  TThreadedObjectUtils;  ; namespace  TypeTraits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; class  RBrowser;  Web-based ROOT files and objects browser. More...;  ; class  RBrowserCatchedWidget;  ; class  RBrowserData;  Way to browse (hopefully) everything in ROOT. More...;  ; class  RBrowserDataCleanup;  ; class  RBrowserEditorWidget;  ; class  RBrowserInfoWidget;  ; class  RBrowserReply;  Reply on browser request. More...;  ; class  RBrowserRequest;  Request send from client to get content of path element. More...;  ; class  RBrowserTimer;  ; class  RBrowserWidget;  Abstract Web-based widget, which can be used in the RBrowser Used to embed canvas, geometry viewer and potentially any other widgets. More...;  ; class  RBrowserWidgetProvider;  ; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. More...;  ; class  RFileDialog;  Web-based FileDialog. More...;  ; class  RGeoItem;  Representation of single item in the geometry browser. More...;  ; class  RGeomBrowserIter;  Iterator of hierarchical geometry structures. More...;  ; class  RGeomConfig;  Configuration parameters which can be configured on the client Send as is to-from client. More...;  ; class  RGeomDescription;  ; class  RGeomDrawing;  Object with full description for drawing geometry It includes list of visible items and list of nodes required to build them. More...;  ; class  RGeomHierarchy;  ; class  RGeomNode;  Full node description including matrices and other attributes. More...;  ; class  RGeomNodeBase;  Base description of geometry node, req",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:2506,Integrability,interface,interface,2506,"aits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; class  RBrowser;  Web-based ROOT files and objects browser. More...;  ; class  RBrowserCatchedWidget;  ; class  RBrowserData;  Way to browse (hopefully) everything in ROOT. More...;  ; class  RBrowserDataCleanup;  ; class  RBrowserEditorWidget;  ; class  RBrowserInfoWidget;  ; class  RBrowserReply;  Reply on browser request. More...;  ; class  RBrowserRequest;  Request send from client to get content of path element. More...;  ; class  RBrowserTimer;  ; class  RBrowserWidget;  Abstract Web-based widget, which can be used in the RBrowser Used to embed canvas, geometry viewer and potentially any other widgets. More...;  ; class  RBrowserWidgetProvider;  ; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. More...;  ; class  RFileDialog;  Web-based FileDialog. More...;  ; class  RGeoItem;  Representation of single item in the geometry browser. More...;  ; class  RGeomBrowserIter;  Iterator of hierarchical geometry structures. More...;  ; class  RGeomConfig;  Configuration parameters which can be configured on the client Send as is to-from client. More...;  ; class  RGeomDescription;  ; class  RGeomDrawing;  Object with full description for drawing geometry It includes list of visible items and list of nodes required to build them. More...;  ; class  RGeomHierarchy;  ; class  RGeomNode;  Full node description including matrices and other attributes. More...;  ; class  RGeomNodeBase;  Base description of geometry node, required only to build hierarchy. More...;  ; class  RGeomNodeInfo;  Node information including rendering data. More...;  ; class  RGeomNodeVisibility;  Custom settings for physical Node visib",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:5194,Integrability,wrap,wrapper,5194,"es static_cast<T> or dynamic_cast<T> to each element. More...;  ; class  RTreeDrawInvokeTimer;  ; class  RTreeDrawMonitoring;  ; class  RTreeViewer;  ; class  RWebBrowserHandle;  Specialized handle to hold information about running browser process Used to correctly cleanup all processes and temporary directories. More...;  ; class  RWebBrowserImp;  ; class  RWebDisplayArgs;  Holds different arguments for starting browser with RWebDisplayHandle::Display() method. More...;  ; class  RWebDisplayHandle;  Handle of created web-based display Depending from type of web display, holds handle of started browser process or other display-specific information to correctly stop and cleanup display. More...;  ; class  RWebWindow;  Represents web window, which can be shown in web browser or any other supported environment. More...;  ; class  RWebWindowsManager;  Central instance to create and show web-based windows like Canvas or FitPanel. More...;  ; class  RWebWindowWSHandler;  just wrapper to deliver websockets call-backs to the RWebWindow class More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This clas",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:5679,Integrability,interface,interface,5679,"lass  RWebDisplayHandle;  Handle of created web-based display Depending from type of web display, holds handle of started browser process or other display-specific information to correctly stop and cleanup display. More...;  ; class  RWebWindow;  Represents web window, which can be shown in web browser or any other supported environment. More...;  ; class  RWebWindowsManager;  Central instance to create and show web-based windows like Canvas or FitPanel. More...;  ; class  RWebWindowWSHandler;  just wrapper to deliver websockets call-backs to the RWebWindow class More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex cl",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:6151,Integrability,interface,interfaces,6151,"ager;  Central instance to create and show web-based windows like Canvas or FitPanel. More...;  ; class  RWebWindowWSHandler;  just wrapper to deliver websockets call-backs to the RWebWindow class More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This cl",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:6230,Integrability,interface,interface,6230,"lass More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. Mo",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:6716,Integrability,interface,interface,6716," interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. More...;  ; class  TVirtualRWMutex;  ; class  TWriteLockGuard;  . Typedefs; using ColumnNamesPtr_t = std::shared_ptr< const ColumnNames_t >;  ; typedef void(* DelArrFunc_t) (void *);  ; typedef void(* DelFunc_t) (void *);  ; typedef void(* DesFunc_t) (void *);  ; typedef void(* DirAutoAdd_t) (void *, TDirectory *);  ; using Double_v = Double_t;  ; using Float_v = Float_t;  ; using Int32_v = Int_t;  ; using Int_v = Int_t;  ",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:6778,Integrability,wrap,wrapper,6778,". More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. More...;  ; class  TVirtualRWMutex;  ; class  TWriteLockGuard;  . Typedefs; using ColumnNamesPtr_t = std::shared_ptr< const ColumnNames_t >;  ; typedef void(* DelArrFunc_t) (void *);  ; typedef void(* DelFunc_t) (void *);  ; typedef void(* DesFunc_t) (void *);  ; typedef void(* DirAutoAdd_t) (void *, TDirectory *);  ; using Double_v = Double_t;  ; using Float_v = Float_t;  ; using Int32_v = Int_t;  ; using Int_v = Int_t;  ; typedef std::map< std::string, ROOT::Internal::TSchemaType > MembersTypeMap_t;  ; typedef Long64_t(* MergeFunc",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:6901,Integrability,interface,interface,6901," data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. More...;  ; class  TVirtualRWMutex;  ; class  TWriteLockGuard;  . Typedefs; using ColumnNamesPtr_t = std::shared_ptr< const ColumnNames_t >;  ; typedef void(* DelArrFunc_t) (void *);  ; typedef void(* DelFunc_t) (void *);  ; typedef void(* DesFunc_t) (void *);  ; typedef void(* DirAutoAdd_t) (void *, TDirectory *);  ; using Double_v = Double_t;  ; using Float_v = Float_t;  ; using Int32_v = Int_t;  ; using Int_v = Int_t;  ; typedef std::map< std::string, ROOT::Internal::TSchemaType > MembersTypeMap_t;  ; typedef Long64_t(* MergeFunc_t) (void *, TCollection *, TFileMergeInfo *);  ; typedef void *(* NewArrFunc_t) (Long_t size, void *arena);  ; typedef void *(* NewFunc_t) ",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:7079,Integrability,interface,interface,7079,"TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. More...;  ; class  TVirtualRWMutex;  ; class  TWriteLockGuard;  . Typedefs; using ColumnNamesPtr_t = std::shared_ptr< const ColumnNames_t >;  ; typedef void(* DelArrFunc_t) (void *);  ; typedef void(* DelFunc_t) (void *);  ; typedef void(* DesFunc_t) (void *);  ; typedef void(* DirAutoAdd_t) (void *, TDirectory *);  ; using Double_v = Double_t;  ; using Float_v = Float_t;  ; using Int32_v = Int_t;  ; using Int_v = Int_t;  ; typedef std::map< std::string, ROOT::Internal::TSchemaType > MembersTypeMap_t;  ; typedef Long64_t(* MergeFunc_t) (void *, TCollection *, TFileMergeInfo *);  ; typedef void *(* NewArrFunc_t) (Long_t size, void *arena);  ; typedef void *(* NewFunc_t) (void *);  ; typedef void(* ResetAfterMergeFunc_t) (void *, TFileMergeInfo *);  ; using RFileDialogCallback_t = std::function< void(const std::string &)>;  functi",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:20042,Integrability,depend,dependents,20042,"eMutex = nullptr;  ; R__EXTERN SchemaRuleClassMap_t gReadRawRules;  ; R__EXTERN SchemaRuleClassMap_t gReadRules;  ; struct ROOT::RQt5CreatorReg newRQt5CreatorReg;  ; struct ROOT::RQt6CreatorReg newRQt6CreatorReg;  . Detailed Description; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; ClassImp for building the THtml documentation of the class.; To build the THtml documentation.; Class RooRealSumFunc implements a PDF constructed from a sum of functions:; Namespace for new ROOT classes and functions.; VSD Structures.; Sum(i=1,n-1) coef_i * func_i(x) + [ 1 - (Sum(i=1,n-1) coef_i ] * func_n(x); pdf(x) = ------------------------------------------------------------------------------; Sum(i=1,n-1) coef_i * Int(func_i)dx + [ 1 - (Sum(i=1,n-1) coef_i ] * Int(func_n)dx; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; where coef_i and func_i are RooAbsReal objects, and x is the collection of dependents. In the present version coef_i may not depend on x, but this limitation may be removed in the future. Difference between RooAddPdf / RooRealSum{Func|Pdf}. RooAddPdf is a PDF of PDFs, i.e. its components need to be normalised and non-negative.; RooRealSumPdf is a PDF of functions, i.e., its components can be negative, but their sum cannot be. The normalisation is computed automatically, unless the PDF is extended (see above).; RooRealSumFunc is a sum of functions. It is neither normalised, nor need it be positive. . Typedef Documentation. ◆ ColumnNamesPtr_t. using ROOT::ColumnNamesPtr_t = typedef std::shared_ptr<const ColumnNames_t>. Definition at line 1546 of file RDataFrame.cxx. ◆ DelArrFunc_t. typedef void(* ROOT::DelArrFunc_t) (void *). Definition at line 112 of file Rtypes.h. ◆ DelFunc_t. typedef void(* ROOT::DelFunc_t) (void *). Definition at line 111 of file Rtypes.h. ◆ DesFunc_t. typedef void(* ROOT::DesFunc_t) (void *). Definition a",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:20092,Integrability,depend,depend,20092,"ap_t gReadRules;  ; struct ROOT::RQt5CreatorReg newRQt5CreatorReg;  ; struct ROOT::RQt6CreatorReg newRQt6CreatorReg;  . Detailed Description; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; ClassImp for building the THtml documentation of the class.; To build the THtml documentation.; Class RooRealSumFunc implements a PDF constructed from a sum of functions:; Namespace for new ROOT classes and functions.; VSD Structures.; Sum(i=1,n-1) coef_i * func_i(x) + [ 1 - (Sum(i=1,n-1) coef_i ] * func_n(x); pdf(x) = ------------------------------------------------------------------------------; Sum(i=1,n-1) coef_i * Int(func_i)dx + [ 1 - (Sum(i=1,n-1) coef_i ] * Int(func_n)dx; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; where coef_i and func_i are RooAbsReal objects, and x is the collection of dependents. In the present version coef_i may not depend on x, but this limitation may be removed in the future. Difference between RooAddPdf / RooRealSum{Func|Pdf}. RooAddPdf is a PDF of PDFs, i.e. its components need to be normalised and non-negative.; RooRealSumPdf is a PDF of functions, i.e., its components can be negative, but their sum cannot be. The normalisation is computed automatically, unless the PDF is extended (see above).; RooRealSumFunc is a sum of functions. It is neither normalised, nor need it be positive. . Typedef Documentation. ◆ ColumnNamesPtr_t. using ROOT::ColumnNamesPtr_t = typedef std::shared_ptr<const ColumnNames_t>. Definition at line 1546 of file RDataFrame.cxx. ◆ DelArrFunc_t. typedef void(* ROOT::DelArrFunc_t) (void *). Definition at line 112 of file Rtypes.h. ◆ DelFunc_t. typedef void(* ROOT::DelFunc_t) (void *). Definition at line 111 of file Rtypes.h. ◆ DesFunc_t. typedef void(* ROOT::DesFunc_t) (void *). Definition at line 113 of file Rtypes.h. ◆ DirAutoAdd_t. typedef void(* ROOT::DirAutoAdd_t) (void *, TDirecto",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:35248,Integrability,rout,routine,35248,"letion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and only if the parse is successful and does not overflow for the type of value. . Returnsreturn a EFromHumanReadableSize enum value indicating the success or failure of the parse. ; Definition at line 86 of file StringConv.hxx. ◆ GetClass() [1/5]. template<typename T > . TClass * ROOT::GetClass ; (; const T * ; ). Definition at line 664 of file TClass.h. ◆ GetClass() [2/5]. template<typename T > . TClass * ROOT::GetClass ; (; const T ** ; ). Definition at line 669 of file TClass.h. ◆ GetClass() [3/5]. template<typename T > . TClass * ROOT::GetClass ; (; const T *const * ; ). Definition at line 671 of file TClass.h. ◆ GetClass() [4/5]. template<typename T > . TClass * ROOT::GetClass ; (; T * ; ). Definition at line 663 of file TClass.h. ◆ GetClass() [5/5]. template<typename T > . TClass * ROOT::GetClass ; (; T ** ;",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:633,Modifiability,inherit,inherits,633,". ROOT: ROOT Namespace Reference. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Classes |; Typedefs |; Enumerations |; Functions |; Variables ; ROOT Namespace ReferenceMath » MathCore | Math » MathMore » Statistical functions. tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; More... Namespaces; namespace  Browsable;  ; namespace  CocoaTutorials;  ; namespace  Detail;  Special implementation of ROOT::RRangeCast for TCollection, including a check that the cast target type inherits from TObject and a new constructor that takes the TCollection by pointer. ;  ; namespace  Details;  ; namespace  ExecutorUtils;  This namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce. ;  ; namespace  Experimental;  ; namespace  Fit;  Namespace for the fitting classes. ;  ; namespace  FoundationUtils;  ; namespace  Geom;  ; namespace  Internal;  ; namespace  MacOSX;  ; namespace  Math;  ; namespace  MathMore;  ; namespace  Meta;  ; namespace  Minuit;  ; namespace  Minuit2;  ; namespace  option;  The namespace of The Lean Mean C++ Option Parser. ;  ; namespace  Quartz;  ; namespace  R;  namespace associated R package for ROOT. ;  ; namespace  RDF;  ; namespace  TestSupport;  ; namespace  TF1Helper;  ; namespace  TMetaUtils;  ; namespace  TreeUtils;  ; namespace  TThreadedObjectUtils;  ; namespace  TypeTraits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; class  RBrowser;  Web-based ROOT files and objects browser. More...;  ; class  RBrowserCatchedWidget;  ; class  RBrowserData;  Way to browse (hopefully) everything in ROOT. More...;  ; class  RBrowserDataCleanup;  ; class  RBrowserEditorWidget;  ; class  RBrowserInfoWidget;  ; class  RBrowserReply;  Reply on browser request. More...;  ; class  RBrowserRequest;  Request send from client to ge",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:2338,Modifiability,variab,variable,2338,"or ROOT. ;  ; namespace  RDF;  ; namespace  TestSupport;  ; namespace  TF1Helper;  ; namespace  TMetaUtils;  ; namespace  TreeUtils;  ; namespace  TThreadedObjectUtils;  ; namespace  TypeTraits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; class  RBrowser;  Web-based ROOT files and objects browser. More...;  ; class  RBrowserCatchedWidget;  ; class  RBrowserData;  Way to browse (hopefully) everything in ROOT. More...;  ; class  RBrowserDataCleanup;  ; class  RBrowserEditorWidget;  ; class  RBrowserInfoWidget;  ; class  RBrowserReply;  Reply on browser request. More...;  ; class  RBrowserRequest;  Request send from client to get content of path element. More...;  ; class  RBrowserTimer;  ; class  RBrowserWidget;  Abstract Web-based widget, which can be used in the RBrowser Used to embed canvas, geometry viewer and potentially any other widgets. More...;  ; class  RBrowserWidgetProvider;  ; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. More...;  ; class  RFileDialog;  Web-based FileDialog. More...;  ; class  RGeoItem;  Representation of single item in the geometry browser. More...;  ; class  RGeomBrowserIter;  Iterator of hierarchical geometry structures. More...;  ; class  RGeomConfig;  Configuration parameters which can be configured on the client Send as is to-from client. More...;  ; class  RGeomDescription;  ; class  RGeomDrawing;  Object with full description for drawing geometry It includes list of visible items and list of nodes required to build them. More...;  ; class  RGeomHierarchy;  ; class  RGeomNode;  Full node description including matrices and other attributes. More...;  ; class  RGeomNodeBase;  Base description of geometry node, req",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:2896,Modifiability,config,configured,2896,"s  RBrowserReply;  Reply on browser request. More...;  ; class  RBrowserRequest;  Request send from client to get content of path element. More...;  ; class  RBrowserTimer;  ; class  RBrowserWidget;  Abstract Web-based widget, which can be used in the RBrowser Used to embed canvas, geometry viewer and potentially any other widgets. More...;  ; class  RBrowserWidgetProvider;  ; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. More...;  ; class  RFileDialog;  Web-based FileDialog. More...;  ; class  RGeoItem;  Representation of single item in the geometry browser. More...;  ; class  RGeomBrowserIter;  Iterator of hierarchical geometry structures. More...;  ; class  RGeomConfig;  Configuration parameters which can be configured on the client Send as is to-from client. More...;  ; class  RGeomDescription;  ; class  RGeomDrawing;  Object with full description for drawing geometry It includes list of visible items and list of nodes required to build them. More...;  ; class  RGeomHierarchy;  ; class  RGeomNode;  Full node description including matrices and other attributes. More...;  ; class  RGeomNodeBase;  Base description of geometry node, required only to build hierarchy. More...;  ; class  RGeomNodeInfo;  Node information including rendering data. More...;  ; class  RGeomNodeVisibility;  Custom settings for physical Node visibility. More...;  ; class  RGeomRawRenderInfo;  Render info with raw data. More...;  ; class  RGeomRenderInfo;  Base class for render info block. More...;  ; class  RGeomShapeRenderInfo;  Render info with shape itself - client can produce shape better. More...;  ; class  RGeomViewer;  ; class  RGeomVisible;  RGeomVisible contains description of visible node It is path to",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:20460,Modifiability,extend,extended,20460,"cumentation of the class.; To build the THtml documentation.; Class RooRealSumFunc implements a PDF constructed from a sum of functions:; Namespace for new ROOT classes and functions.; VSD Structures.; Sum(i=1,n-1) coef_i * func_i(x) + [ 1 - (Sum(i=1,n-1) coef_i ] * func_n(x); pdf(x) = ------------------------------------------------------------------------------; Sum(i=1,n-1) coef_i * Int(func_i)dx + [ 1 - (Sum(i=1,n-1) coef_i ] * Int(func_n)dx; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; where coef_i and func_i are RooAbsReal objects, and x is the collection of dependents. In the present version coef_i may not depend on x, but this limitation may be removed in the future. Difference between RooAddPdf / RooRealSum{Func|Pdf}. RooAddPdf is a PDF of PDFs, i.e. its components need to be normalised and non-negative.; RooRealSumPdf is a PDF of functions, i.e., its components can be negative, but their sum cannot be. The normalisation is computed automatically, unless the PDF is extended (see above).; RooRealSumFunc is a sum of functions. It is neither normalised, nor need it be positive. . Typedef Documentation. ◆ ColumnNamesPtr_t. using ROOT::ColumnNamesPtr_t = typedef std::shared_ptr<const ColumnNames_t>. Definition at line 1546 of file RDataFrame.cxx. ◆ DelArrFunc_t. typedef void(* ROOT::DelArrFunc_t) (void *). Definition at line 112 of file Rtypes.h. ◆ DelFunc_t. typedef void(* ROOT::DelFunc_t) (void *). Definition at line 111 of file Rtypes.h. ◆ DesFunc_t. typedef void(* ROOT::DesFunc_t) (void *). Definition at line 113 of file Rtypes.h. ◆ DirAutoAdd_t. typedef void(* ROOT::DirAutoAdd_t) (void *, TDirectory *). Definition at line 114 of file Rtypes.h. ◆ Double_v. using ROOT::Double_v = typedef Double_t. Definition at line 55 of file Types.h. ◆ Float_v. using ROOT::Float_v = typedef Float_t. Definition at line 54 of file Types.h. ◆ Int32_v. using ROOT::Int32_v = typedef Int_t. Definition at line 57 of file Types.h. ◆ Int_v. using ROOT",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:32768,Modifiability,config,configured,32768,"The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT ob",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:32936,Modifiability,variab,variable,32936,"loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:34108,Modifiability,plug-in,plug-ins,34108,"uling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str,",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:34180,Modifiability,variab,variable,34180,"g (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:5573,Performance,queue,queue,5573,"mporary directories. More...;  ; class  RWebBrowserImp;  ; class  RWebDisplayArgs;  Holds different arguments for starting browser with RWebDisplayHandle::Display() method. More...;  ; class  RWebDisplayHandle;  Handle of created web-based display Depending from type of web display, holds handle of started browser process or other display-specific information to correctly stop and cleanup display. More...;  ; class  RWebWindow;  Represents web window, which can be shown in web browser or any other supported environment. More...;  ; class  RWebWindowsManager;  Central instance to create and show web-based windows like Canvas or FitPanel. More...;  ; class  RWebWindowWSHandler;  just wrapper to deliver websockets call-backs to the RWebWindow class More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWr",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:10192,Performance,perform,performed,10192," &, bool, int)>;  ; using RGeomSignalFunc_t = std::function< void(const std::string &)>;  ; using RVecB = ROOT::VecOps::RVec< bool >;  ; using RVecC = ROOT::VecOps::RVec< char >;  ; using RVecD = ROOT::VecOps::RVec< double >;  ; using RVecF = ROOT::VecOps::RVec< float >;  ; using RVecI = ROOT::VecOps::RVec< int >;  ; using RVecL = ROOT::VecOps::RVec< long int >;  ; using RVecLL = ROOT::VecOps::RVec< long long int >;  ; using RVecU = ROOT::VecOps::RVec< unsigned int >;  ; using RVecUL = ROOT::VecOps::RVec< unsigned long int >;  ; using RVecULL = ROOT::VecOps::RVec< unsigned long long int >;  ; typedef std::map< std::string, std::list< SchemaRuleMap_t > > SchemaRuleClassMap_t;  ; typedef std::map< std::string, std::string > SchemaRuleMap_t;  ; typedef std::list< std::pair< ROOT::Internal::TSchemaType, std::string > > SourceTypeList_t;  ; using TDataFrame = ROOT::RDataFrame;  ; using TSeqI = TSeq< int >;  ; using TSeqL = TSeq< long >;  ; using TSeqU = TSeq< unsigned int >;  ; using TSeqUL = TSeq< unsigned long >;  ; using UInt32_v = UInt_t;  ; using UInt_v = UInt_t;  ; using WebWindowConnectCallback_t = std::function< void(unsigned)>;  function signature for connect/disconnect call-backs argument is connection id ;  ; using WebWindowDataCallback_t = std::function< void(unsigned, const std::string &)>;  function signature for call-backs from the window clients first argument is connection id, second is received data ;  ; using WebWindowShowCallback_t = std::function< bool(RWebWindow &, const RWebDisplayArgs &)>;  function signature for catching show calls of arbitrary RWebWindow if returns true, normal show procedure will not be invoked ;  ; using WebWindowWaitFunc_t = std::function< int(double)>;  function signature for waiting call-backs Such callback used when calling thread need to waits for some special data, but wants to run application event loop As argument, spent time in second will be provided Waiting will be performed until function returns non-zero value ;  .",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:13648,Performance,multi-thread,multi-threading,13648,"ass_ShowMembers (TClass *cl, const void *obj, TMemberInspector &);  Indirect call to the implementation of ShowMember allowing [forward] declaration with out a full definition of the TClass class. ;  ; static UInt_t ClassTableHash (const char *name, UInt_t size);  ; int CompressionSettings (RCompressionSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: ;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:13770,Performance,multi-thread,multi-threading,13770,"declaration with out a full definition of the TClass class. ;  ; static UInt_t ClassTableHash (const char *name, UInt_t size);  ; int CompressionSettings (RCompressionSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: ;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * >",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:13919,Performance,multi-thread,multi-threading,13919,"nSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: ;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:15300,Performance,multi-thread,multi-threading,15300,"3b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of includes specified in the shema rules. ;  ; UInt_t GetThreadPoolSize ();  Returns the size of ROOT's thread pool. ;  ; bool HasValidDataMembers (SchemaRuleMap_t &rule, MembersTypeMap_t &members, std::string &error_string);  Check if given rule contains references to valid data members. ;  ; Bool_t IsImplicitMTEnabled ();  Returns true if the implicit multi-threading in ROOT is enabled. ;  ; template<class StringCollection_t > ; std::string Join (const std::string &sep, StringCollection_t &&strings);  Concatenate a list of strings with a separator. ;  ; template<class T > ; TSeq< T > MakeSeq (T begin, T end, T step=1);  ; template<class T > ; TSeq< T > MakeSeq (T end);  ; bool ParseRule (std::string command, ROOT::Internal::MembersMap_t &result, std::string &error_string);  Parse the schema rule as specified in the LinkDef file. ;  ; void ProcessReadPragma (const char *args, std::string &error_string);  I am being called when a read pragma is encountered. ;  ; void ProcessReadRawPragma (const char *args, std::string &error_string);  I am being called then a readraw pragma is encountered. ;  ; template<typename T , typename Range_t > ; RRangeCast< T, true, Range_t > RangeDynCast (Range_t &&coll);  Takes any collection that can be used in range-based loops and applies dynamic_cast<T> to each element. ;  ; template<type",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:26123,Performance,perform,performed,26123,"on<void(unsigned)>. function signature for connect/disconnect call-backs argument is connection id ; Definition at line 35 of file RWebWindow.hxx. ◆ WebWindowDataCallback_t. using ROOT::WebWindowDataCallback_t = typedef std::function<void(unsigned, const std::string &)>. function signature for call-backs from the window clients first argument is connection id, second is received data ; Definition at line 39 of file RWebWindow.hxx. ◆ WebWindowShowCallback_t. using ROOT::WebWindowShowCallback_t = typedef std::function<bool(RWebWindow &, const RWebDisplayArgs &)>. function signature for catching show calls of arbitrary RWebWindow if returns true, normal show procedure will not be invoked ; Definition at line 34 of file RWebWindowsManager.hxx. ◆ WebWindowWaitFunc_t. using ROOT::WebWindowWaitFunc_t = typedef std::function<int(double)>. function signature for waiting call-backs Such callback used when calling thread need to waits for some special data, but wants to run application event loop As argument, spent time in second will be provided Waiting will be performed until function returns non-zero value ; Definition at line 46 of file RWebWindow.hxx. Enumeration Type Documentation. ◆ ECompressionAlgorithm. enum ROOT::ECompressionAlgorithm. EnumeratorkUseGlobalCompressionSetting Deprecated name, do not use: . kUseGlobalSetting Deprecated name, do not use: . kZLIB Deprecated name, do not use: . kLZMA Deprecated name, do not use: . kOldCompressionAlgo Deprecated name, do not use: . kLZ4 Deprecated name, do not use: . kZSTD Deprecated name, do not use: . kUndefinedCompressionAlgorithm Deprecated name, do not use: . Definition at line 109 of file Compression.h. ◆ EExecutionPolicy. enum class ROOT::EExecutionPolicy. strong . EnumeratorkSequential ; kMultiThread ; kMultiProcess . Definition at line 5 of file EExecutionPolicy.hxx. ◆ EFromHumanReadableSize. enum class ROOT::EFromHumanReadableSize. strong . EnumeratorkSuccess ; kParseFail ; kOverflow . Definition at line 69 of file",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:31235,Performance,multi-thread,multi-threading,31235,"EAlgorithm::EValues ; algorithm, . int ; compressionLevel . ). ◆ CompressionSettings() [2/2]. int ROOT::CompressionSettings ; (; ROOT::ECompressionAlgorithm ; algorithm, . int ; compressionLevel . ). Deprecated name, do not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5884 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5869 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 556 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs ",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:31431,Performance,multi-thread,multi-threading,31431," not use: . ◆ CreateClass() [1/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5884 of file TClass.cxx. ◆ CreateClass() [2/2]. TClass * ROOT::CreateClass ; (; const char * ; cname, . Version_t ; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5869 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 556 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. Enable",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:31871,Performance,multi-thread,multi-threading,31871,"; id, . const std::type_info & ; info, . TVirtualIsAProxy * ; isa, . const char * ; dfil, . const char * ; ifil, . Int_t ; dl, . Int_t ; il . ). Global function called by a class' static Dictionary() method (see the ClassDef macro). ; Definition at line 5869 of file TClass.cxx. ◆ DisableImplicitMT(). void ROOT::DisableImplicitMT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 556 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The ma",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:32238,Performance,perform,performs,32238,"MT ; (; ). Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ; Definition at line 556 of file TROOT.cxx. ◆ EnableImplicitMT(). void ROOT::EnableImplicitMT ; (; UInt_t ; numthreads = 0). Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ; Parameters. [in]numthreadsNumber of threads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:32606,Performance,multi-thread,multi-threading,32606,"hreads to use. If not specified or set to zero, the number of threads is automatically decided by the implementation. Any other value is used as a hint. ROOT must be built with the compilation flag imt=ON for this feature to be available. The following objects and methods automatically take advantage of multi-threading if a call to EnableImplicitMT has been made before usage:. RDataFrame internally runs the event-loop by parallelizing over clusters of entries; TTree::GetEntry reads multiple branches in parallel; TTree::FlushBaskets writes multiple baskets to disk in parallel; TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/a",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:33139,Performance,multi-thread,multi-threading,33139,"ip decompresses the baskets contained in a TTreeCache in parallel; THx::Fit performs in parallel the evaluation of the objective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad beco",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:33405,Performance,multi-thread,multi-threading,33405,"n parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this metho",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:33603,Performance,concurren,concurrent,33603,"eter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableTh",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:33769,Performance,concurren,concurrent,33769,"rnal scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static st",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:33952,Performance,concurren,concurrent,33952,"OOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typen",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:34023,Performance,concurren,concurrent,34023,"uling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str,",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:34081,Performance,concurren,concurrent,34081,"uling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str,",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:34092,Performance,load,loading,34092,"uling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str,",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:37574,Performance,multi-thread,multi-threading,37574," ROOT::GetDelayedAddClassAlternate ; (; ). Definition at line 254 of file TClassTable.cxx. ◆ GetMacroPath(). TString & ROOT::GetMacroPath ; (; ). Definition at line 476 of file TROOT.cxx. ◆ GetROOT(). TROOT * ROOT::GetROOT ; (; ). Definition at line 472 of file TROOT.cxx. ◆ GetRuleIncludes(). void ROOT::GetRuleIncludes ; (; std::list< std::string > & ; result). Get the list of includes specified in the shema rules. ; Definition at line 855 of file RConversionRuleParser.cxx. ◆ GetThreadPoolSize(). UInt_t ROOT::GetThreadPoolSize ; (; ). Returns the size of ROOT's thread pool. ; Definition at line 577 of file TROOT.cxx. ◆ HasValidDataMembers(). Bool_t ROOT::HasValidDataMembers ; (; SchemaRuleMap_t & ; rule, . MembersTypeMap_t & ; members, . std::string & ; error_string . ). Check if given rule contains references to valid data members. ; Definition at line 461 of file RConversionRuleParser.cxx. ◆ IsImplicitMTEnabled(). bool ROOT::IsImplicitMTEnabled ; (; ). Returns true if the implicit multi-threading in ROOT is enabled. ; Definition at line 570 of file TROOT.cxx. ◆ Join(). template<class StringCollection_t > . std::string ROOT::Join ; (; const std::string & ; sep, . StringCollection_t && ; strings . ). Concatenate a list of strings with a separator. ; Template Parameters. StringCollection_tAny container of strings (vector, initializer_list, ...) . Parameters. [in]sepSeparator inbetween the strings. ; [in]stringscontainer of strings . Returnsthe sep-delimited concatenation of strings ; Definition at line 35 of file StringUtils.hxx. ◆ MakeSeq() [1/2]. template<class T > . TSeq< T > ROOT::MakeSeq ; (; T ; begin, . T ; end, . T ; step = 1 . ). Definition at line 215 of file TSeq.hxx. ◆ MakeSeq() [2/2]. template<class T > . TSeq< T > ROOT::MakeSeq ; (; T ; end). Definition at line 209 of file TSeq.hxx. ◆ ParseRule(). Bool_t ROOT::ParseRule ; (; std::string ; rule, . ROOT::Internal::MembersMap_t & ; result, . std::string & ; error_string . ). Parse the schema rule as specifi",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:14016,Safety,safe,safe,14016,"nSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: ;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:33502,Safety,safe,safe,33502,"n parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this metho",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:33561,Safety,safe,safe,33561,"ows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous ",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:33596,Safety,safe,safe,33596,"eter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableTh",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:34270,Safety,safe,safe,34270,"eates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this ro",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:34431,Safety,safe,safe,34431,"ding within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be p",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:34604,Safety,safe,safe,34604,"obal mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and only if the parse is successful and does not overflow for the",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:34670,Safety,safe,safety,34670,"n ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static std::string::size_type ROOT::FindEndSymbol ; (; std::string & ; command). static . Definition at line 62 of file RConversionRuleParser.cxx. ◆ FromHumanReadableSize(). template<typename T > . EFromHumanReadableSize ROOT::FromHumanReadableSize ; (; std::string_view ; str, . T & ; value . ). Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ; For this routine we use the official SI unit where the [i] is reserved for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes. Parameters. strthe string to be parsed ; valuewill be updated with the result if and only if the parse is successful and does not overflow for the type of value. . Returnsreturn a EFromHumanReadableSize enum value indicating the success or failure of the parse. ; Definition at line 86 of file StringConv",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:43078,Security,checksum,checksum,43078,"a class template (i.e. ; NOT a concrete class). ; Definition at line 1005 of file TClassTable.cxx. ◆ RemoveClass(). void ROOT::RemoveClass ; (; const char * ; cname, . TClass * ; cl . ). Global function called by the dtor of a class's init class (see the ClassImp macro). ; Definition at line 985 of file TClassTable.cxx. ◆ RemoveClassAlternate(). void ROOT::RemoveClassAlternate ; (; ROOT::TClassAlt * ; alt). Definition at line 931 of file TClassTable.cxx. ◆ ResetClassVersion(). void ROOT::ResetClassVersion ; (; TClass * ; cl, . const char * ; cname, . Short_t ; newid . ). Global function to update the version number. ; This is called via the RootClassVersion macro.; if cl!=0 and cname==-1, set the new class version if and only is greater than the existing one and greater or equal to 2; and also ignore the request if fVersionUsed is true.; Note on class version number:; If no class has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specify via ClassDef indicates that the I/O should use the TClass checksum to distinguish the layout of the class . Definition at line 951 of file TClassTable.cxx. ◆ RGeomLog(). ROOT::Experimental::RLogChannel & ROOT::RGeomLog ; (; ). Log channel for Geomviewer diagnostics. ; Definition at line 49 of file RGeomData.cxx. ◆ SetClassVersion(). template<class RootClass > . Short_t ROOT::SetClassVersion ; (; RootClass * ; ). ◆ Split(). std::vector< std::string > ROOT::Split ; (; std::string_view ; str, . std::string_view ; delims, . bool ; skipEmpty . ). Splits a string at each character in delims. ; The behavior mimics str.split from Python, Parameters. [in]strString to tokenise. ; [in]delimsOne or more delimiters used to split the string. ; [in]skipEmptyStrip empty strings from the output. . Definition at line 23 of file StringUtils.cxx. ◆ StrReplace(). static void ROOT::StrReplace ; (; std::string & ; proc, . const std::string & ; pat, . const std::st",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:6223,Usability,simpl,simple,6223,"lass More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. Mo",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT.html:6894,Usability,simpl,simple,6894," data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. More...;  ; class  TVirtualRWMutex;  ; class  TWriteLockGuard;  . Typedefs; using ColumnNamesPtr_t = std::shared_ptr< const ColumnNames_t >;  ; typedef void(* DelArrFunc_t) (void *);  ; typedef void(* DelFunc_t) (void *);  ; typedef void(* DesFunc_t) (void *);  ; typedef void(* DirAutoAdd_t) (void *, TDirectory *);  ; using Double_v = Double_t;  ; using Float_v = Float_t;  ; using Int32_v = Int_t;  ; using Int_v = Int_t;  ; typedef std::map< std::string, ROOT::Internal::TSchemaType > MembersTypeMap_t;  ; typedef Long64_t(* MergeFunc_t) (void *, TCollection *, TFileMergeInfo *);  ; typedef void *(* NewArrFunc_t) (Long_t size, void *arena);  ; typedef void *(* NewFunc_t) ",MatchSource.WIKI,doc/v632/namespaceROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html
https://root.cern/doc/v632/namespaceROOT_1_1Detail.html:4401,Availability,error,error,4401,"lection to contain elements of the type requested (or a derived class). Any deviation from this expectation will only be caught/reported by an assert in debug builds.; This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; The typical use is: for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; ... use bcl as a TBaseClass*; }; for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; ... use bcl as a TBaseClass*; }; a#define a(i)Definition RSha256.hxx:99; ROOT::Detail::TRangeCastDefinition TCollection.h:311; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; Template Parameters. TThe new type to convert to. . Definition at line 337 of file TCollection.h. Function Documentation. ◆ HasBeenDeleted(). R__ALWAYS_INLINE bool ROOT::Detail::HasBeenDeleted ; (; const TObject * ; obj). Check if the TObject's memory has been deleted. ; WarningThis should be only used for error mitigation as the answer is only sometimes correct. It actually just checks whether the object has been deleted, so this will falsely return true for an object that has been destructed but its memory has not been deleted. This will return an undefined value if the memory is re-used between the deletion and the check. i.e. This is useful to prevent a segmentation fault in case where the problem can be detected when the deletion and the usage are 'close-by' . In enviroment where delete taints (changes) the memory, this function always returns false as the marker left by ~TObject will be overwritten. ; Parameters. objThe memory to check . Returnstrue if the object has been destructed and it can be inferred that it has been deleted ; Definition at line 402 of file TObject.h. ◆ HasCallOp() [1/2]. template<typename T > . constexpr bool ROOT::Detail::HasCallOp ; (; char ; ). constexpr . Definition at line 32 of file TypeTraits.hxx. ◆ HasCallOp() [2/2]. template<typename T > . constexpr auto ROOT",MatchSource.WIKI,doc/v632/namespaceROOT_1_1Detail.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Detail.html
https://root.cern/doc/v632/namespaceROOT_1_1Detail.html:4772,Availability,fault,fault,4772,"l : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; ... use bcl as a TBaseClass*; }; a#define a(i)Definition RSha256.hxx:99; ROOT::Detail::TRangeCastDefinition TCollection.h:311; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; Template Parameters. TThe new type to convert to. . Definition at line 337 of file TCollection.h. Function Documentation. ◆ HasBeenDeleted(). R__ALWAYS_INLINE bool ROOT::Detail::HasBeenDeleted ; (; const TObject * ; obj). Check if the TObject's memory has been deleted. ; WarningThis should be only used for error mitigation as the answer is only sometimes correct. It actually just checks whether the object has been deleted, so this will falsely return true for an object that has been destructed but its memory has not been deleted. This will return an undefined value if the memory is re-used between the deletion and the check. i.e. This is useful to prevent a segmentation fault in case where the problem can be detected when the deletion and the usage are 'close-by' . In enviroment where delete taints (changes) the memory, this function always returns false as the marker left by ~TObject will be overwritten. ; Parameters. objThe memory to check . Returnstrue if the object has been destructed and it can be inferred that it has been deleted ; Definition at line 402 of file TObject.h. ◆ HasCallOp() [1/2]. template<typename T > . constexpr bool ROOT::Detail::HasCallOp ; (; char ; ). constexpr . Definition at line 32 of file TypeTraits.hxx. ◆ HasCallOp() [2/2]. template<typename T > . constexpr auto ROOT::Detail::HasCallOp ; (; int ; ); -> decltype(&T::operator(), true) . constexpr . Definition at line 31 of file TypeTraits.hxx. ◆ operator_equal_impl(). template<class ArrayL , class ArrayR > . bool ROOT::Detail::operator_equal_impl ; (; ArrayL const & ; lhs, . size_t const ; lhs_size, . ArrayR const & ; rhs, . size_t const ; rhs_size . ). inline . Definition at line 456 of file span.hx",MatchSource.WIKI,doc/v632/namespaceROOT_1_1Detail.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Detail.html
https://root.cern/doc/v632/namespaceROOT_1_1Detail.html:2111,Energy Efficiency,adapt,adapter,2111,"; struct  is_array_class< std::vector< T > >;  ; struct  make_indices_;  ; struct  make_indices_impl;  ; struct  make_indices_impl< First, Step, N, typename std::enable_if<(N > 1 &&N % 2==0)>::type >;  ; struct  make_indices_impl< First, Step, N, typename std::enable_if<(N > 1 &&N % 2==1)>::type >;  ; struct  make_indices_impl< First, Step, N, typename std::enable_if<(N==0)>::type >;  ; struct  make_indices_impl< First, Step, N, typename std::enable_if<(N==1)>::type >;  ; struct  make_indices_next;  ; struct  make_indices_next2;  ; struct  make_indices_next2< indices< Indices... >, Next, Tail >;  ; struct  make_indices_next< indices< Indices... >, Next >;  ; class  TBranchProxy;  Base class for all the proxy object. More...;  ; class  TCollectionProxyInfo;  ; class  TRangeCast;  ; class  TSchemaRuleSet;  ; class  TStatusBitsChecker;  . Typedefs; template<size_t Start, size_t Last, size_t Step = 1> ; using make_indices = typename make_indices_< Start, Last, Step >::type;  ; template<typename T > ; using TRangeStaticCast = TRangeCast< T, false >;  TRangeStaticCast is an adapter class that allows the typed iteration through a TCollection. ;  . Functions; R__ALWAYS_INLINE bool HasBeenDeleted (const TObject *obj);  Check if the TObject's memory has been deleted. ;  ; template<typename T > ; constexpr bool HasCallOp (char);  ; template<typename T > ; constexpr auto HasCallOp (int) -> decltype(&T::operator(), true);  ; template<class ArrayL , class ArrayR > ; bool operator_equal_impl (ArrayL const &lhs, size_t const lhs_size, ArrayR const &rhs, size_t const rhs_size);  . Detailed Description; Special implementation of ROOT::RRangeCast for TCollection, including a check that the cast target type inherits from TObject and a new constructor that takes the TCollection by pointer. ; Template Parameters. TThe new type to convert to. ; isDynamicIf true, dynamic_cast is used, otherwise static_cast is used. . Typedef Documentation. ◆ make_indices. template<size_t Start, size_t Last",MatchSource.WIKI,doc/v632/namespaceROOT_1_1Detail.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Detail.html
https://root.cern/doc/v632/namespaceROOT_1_1Detail.html:3318,Energy Efficiency,adapt,adapter,3318,"pr bool HasCallOp (char);  ; template<typename T > ; constexpr auto HasCallOp (int) -> decltype(&T::operator(), true);  ; template<class ArrayL , class ArrayR > ; bool operator_equal_impl (ArrayL const &lhs, size_t const lhs_size, ArrayR const &rhs, size_t const rhs_size);  . Detailed Description; Special implementation of ROOT::RRangeCast for TCollection, including a check that the cast target type inherits from TObject and a new constructor that takes the TCollection by pointer. ; Template Parameters. TThe new type to convert to. ; isDynamicIf true, dynamic_cast is used, otherwise static_cast is used. . Typedef Documentation. ◆ make_indices. template<size_t Start, size_t Last, size_t Step = 1> . using ROOT::Detail::make_indices = typedef typename make_indices_< Start, Last, Step >::type. Definition at line 148 of file span.hxx. ◆ TRangeStaticCast. template<typename T > . using ROOT::Detail::TRangeStaticCast = typedef TRangeCast<T, false>. TRangeStaticCast is an adapter class that allows the typed iteration through a TCollection. ; This requires the collection to contain elements of the type requested (or a derived class). Any deviation from this expectation will only be caught/reported by an assert in debug builds.; This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; The typical use is: for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; ... use bcl as a TBaseClass*; }; for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; ... use bcl as a TBaseClass*; }; a#define a(i)Definition RSha256.hxx:99; ROOT::Detail::TRangeCastDefinition TCollection.h:311; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; Template Parameters. TThe new type to convert to. . Definition at line 337 of file TCollection.h. Function Documentation. ◆ HasBeenDeleted(). R__ALWAYS_INLINE bool ROOT::Detail::HasBeenDeleted ; (; const TObject * ; obj). Check if the TObject's me",MatchSource.WIKI,doc/v632/namespaceROOT_1_1Detail.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Detail.html
https://root.cern/doc/v632/namespaceROOT_1_1Detail.html:2111,Integrability,adapter,adapter,2111,"; struct  is_array_class< std::vector< T > >;  ; struct  make_indices_;  ; struct  make_indices_impl;  ; struct  make_indices_impl< First, Step, N, typename std::enable_if<(N > 1 &&N % 2==0)>::type >;  ; struct  make_indices_impl< First, Step, N, typename std::enable_if<(N > 1 &&N % 2==1)>::type >;  ; struct  make_indices_impl< First, Step, N, typename std::enable_if<(N==0)>::type >;  ; struct  make_indices_impl< First, Step, N, typename std::enable_if<(N==1)>::type >;  ; struct  make_indices_next;  ; struct  make_indices_next2;  ; struct  make_indices_next2< indices< Indices... >, Next, Tail >;  ; struct  make_indices_next< indices< Indices... >, Next >;  ; class  TBranchProxy;  Base class for all the proxy object. More...;  ; class  TCollectionProxyInfo;  ; class  TRangeCast;  ; class  TSchemaRuleSet;  ; class  TStatusBitsChecker;  . Typedefs; template<size_t Start, size_t Last, size_t Step = 1> ; using make_indices = typename make_indices_< Start, Last, Step >::type;  ; template<typename T > ; using TRangeStaticCast = TRangeCast< T, false >;  TRangeStaticCast is an adapter class that allows the typed iteration through a TCollection. ;  . Functions; R__ALWAYS_INLINE bool HasBeenDeleted (const TObject *obj);  Check if the TObject's memory has been deleted. ;  ; template<typename T > ; constexpr bool HasCallOp (char);  ; template<typename T > ; constexpr auto HasCallOp (int) -> decltype(&T::operator(), true);  ; template<class ArrayL , class ArrayR > ; bool operator_equal_impl (ArrayL const &lhs, size_t const lhs_size, ArrayR const &rhs, size_t const rhs_size);  . Detailed Description; Special implementation of ROOT::RRangeCast for TCollection, including a check that the cast target type inherits from TObject and a new constructor that takes the TCollection by pointer. ; Template Parameters. TThe new type to convert to. ; isDynamicIf true, dynamic_cast is used, otherwise static_cast is used. . Typedef Documentation. ◆ make_indices. template<size_t Start, size_t Last",MatchSource.WIKI,doc/v632/namespaceROOT_1_1Detail.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Detail.html
