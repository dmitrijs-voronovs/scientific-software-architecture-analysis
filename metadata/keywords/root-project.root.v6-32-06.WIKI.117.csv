id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:37911,Performance,perform,performedDefinition,37911,"e! Real size of the fxTried arraysDefinition TGraphDelaunay.h:58; TGraphDelaunay::fMTriedInt_t * fMTried!Definition TGraphDelaunay.h:61; TGraphDelaunay::fXDouble_t * fX! Pointer to fGraph2D->fXDefinition TGraphDelaunay.h:42; TGraphDelaunay::fGraph2DTGraph2D * fGraph2D! 2D graph containing the user dataDefinition TGraphDelaunay.h:66; TGraphDelaunay::FindAllTrianglesvoid FindAllTriangles()Attempt to find all the Delaunay triangles of the point set.Definition TGraphDelaunay.cxx:290; TGraphDelaunay::fAllTriBool_t fAllTri! True if FindAllTriangles() has been performed on fGraph2DDefinition TGraphDelaunay.h:64; TGraphDelaunay::SetMaxItervoid SetMaxIter(Int_t n=100000)Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoni...Definition TGraphDelaunay.cxx:932; TGraphDelaunay::fMaxIterInt_t fMaxIter! Maximum number of iterations to find Delaunay trianglesDefinition TGraphDelaunay.h:57; TGraphDelaunay::fInitBool_t fInit! True if CreateTrianglesDataStructure() and FindHull() have been performedDefinition TGraphDelaunay.h:65; TGraphDelaunay::fOrderInt_t * fOrder! Array used to order mass points by distanceDefinition TGraphDelaunay.h:63; TGraphDelaunay::EncloseBool_t Enclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) constIs point e inside the triangle t1-t2-t3 ?Definition TGraphDelaunay.cxx:215; TGraphDelaunay::fXScaleFactorDouble_t fXScaleFactor!Definition TGraphDelaunay.h:53; TGraphDelaunay::fNdtInt_t fNdt! Number of Delaunay triangles foundDefinition TGraphDelaunay.h:39; TGraphDelaunay::fZDouble_t * fZ! Pointer to fGraph2D->fZDefinition TGraphDelaunay.h:44; TGraphDelaunay::fYNmaxDouble_t fYNmax! Maximum value of fYNDefinition TGraphDelaunay.h:50; TGraphDelaunay::~TGraphDelaunay~TGraphDelaunay() overrideTGraphDelaunay destructor.Definition TGraphDelaunay.cxx:123; TGraphDelaunay::fZoutDouble_t fZout! Histogram bin height for points lying outside the convex hullDefinition TGraphDelaunay.h:55; TGraphDelaunay::fYScaleFactorDouble_t fYSca",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:5238,Safety,avoid,avoid,5238," fNTried = nullptr;; 136 fMTried = nullptr;; 137 fHullPoints = nullptr;; 138 fOrder = nullptr;; 139 fDist = nullptr;; 140 fXN = nullptr;; 141 fYN = nullptr;; 142}; 143 ; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146/// Return the z value corresponding to the (x,y) point in fGraph2D; 147 ; 148Double_t TGraphDelaunay::ComputeZ(Double_t x, Double_t y); 149{; 150 // Initialise the Delaunay algorithm if needed.; 151 // CreateTrianglesDataStructure computes fXoffset, fYoffset,; 152 // fXScaleFactor and fYScaleFactor;; 153 // needed in this function.; 154 if (!fInit) {; 155 CreateTrianglesDataStructure();; 156 FindHull();; 157 fInit = kTRUE;; 158 }; 159 ; 160 // Find the z value corresponding to the point (x,y).; 161 Double_t xx, yy;; 162 xx = (x+fXoffset)*fXScaleFactor;; 163 yy = (y+fYoffset)*fYScaleFactor;; 164 Double_t zz = Interpolate(xx, yy);; 165 ; 166 // Wrong zeros may appear when points sit on a regular grid.; 167 // The following line try to avoid this problem.; 168 if (zz==0) zz = Interpolate(xx+0.0001, yy);; 169 ; 170 return zz;; 171}; 172 ; 173 ; 174////////////////////////////////////////////////////////////////////////////////; 175/// Function used internally only. It creates the data structures needed to; 176/// compute the Delaunay triangles.; 177 ; 178void TGraphDelaunay::CreateTrianglesDataStructure(); 179{; 180 // Offset fX and fY so they average zero, and scale so the average; 181 // of the X and Y ranges is one. The normalized version of fX and fY used; 182 // in Interpolate.; 183 Double_t xmax = fGraph2D->GetXmax();; 184 Double_t ymax = fGraph2D->GetYmax();; 185 Double_t xmin = fGraph2D->GetXmin();; 186 Double_t ymin = fGraph2D->GetYmin();; 187 fXoffset = -(xmax+xmin)/2.;; 188 fYoffset = -(ymax+ymin)/2.;; 189 fXScaleFactor = 1./(xmax-xmin);; 190 fYScaleFactor = 1./(ymax-ymin);; 191 fXNmax = (xmax+fXoffset)*fXScaleFactor;; 192 fXNmin = (xmin+fXoffset)*fXScaleFactor;; 193 fYNmax = (ymax+fYoffset)*fYScale",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:22869,Testability,test,test,22869,,MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:22946,Testability,test,testing,22946,,MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:23382,Testability,test,test,23382,,MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:31722,Testability,test,tested,31722,"orm valid Delaunay triangles. Choose diagonal; 874 // with highest average z-value. Whichever we choose we will have; 875 // verified two triangles as good and two as bad, only note the good ones; 876 d = degen;; 877 f = fdegen;; 878 o1 = o1degen;; 879 o2 = o2degen;; 880 if ((fZ[o1-1]+fZ[o2-1]) > (fZ[d-1]+fZ[f-1])) {; 881 // best diagonalisation of quadrilateral is current one, we have; 882 // the triangle; 883 t1 = p;; 884 t2 = n;; 885 t3 = m;; 886 // file the good triangles; 887 FileIt(p, n, m);; 888 FileIt(d, o1, o2);; 889 } else {; 890 // use other diagonal to split quadrilateral, use triangle formed by; 891 // point f, the degnerate point d and whichever of o1 and o2 create; 892 // an enclosing triangle; 893 t1 = f;; 894 t2 = d;; 895 if (Enclose(f,d,o1,0)) {; 896 t3 = o1;; 897 } else {; 898 t3 = o2;; 899 }; 900 // file the good triangles; 901 FileIt(f, d, o1);; 902 FileIt(f, d, o2);; 903 }; 904 } else {; 905 // this is a Delaunay triangle, file it; 906 FileIt(p, n, m);; 907 t1 = p;; 908 t2 = n;; 909 t3 = m;; 910 }; 911 // do the interpolation; 912 thevalue = InterpolateOnPlane(t1,t2,t3,0);; 913 return thevalue;; 914L90:; 915 continue;; 916 }; 917 }; 918 }; 919 if (shouldbein) {; 920 Error(""Interpolate"",; 921 ""Point outside hull when expected inside: this point could be dodgy %g %g %d"",; 922 xx, yy, ntris_tried);; 923 }; 924 return thevalue;; 925}; 926 ; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Defines the number of triangles tested for a Delaunay triangle; 930/// (number of iterations) before abandoning the search; 931 ; 932void TGraphDelaunay::SetMaxIter(Int_t n); 933{; 934 fAllTri = kFALSE;; 935 fMaxIter = n;; 936}; 937 ; 938 ; 939////////////////////////////////////////////////////////////////////////////////; 940/// Sets the histogram bin height for points lying outside the convex hull ie:; 941/// the bins in the margin.; 942 ; 943void TGraphDelaunay::SetMarginBinsContent(Double_t z); 944{; 945 fZout =",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:37578,Testability,test,tested,37578,"56; TGraphDelaunay::FileItvoid FileIt(Int_t P, Int_t N, Int_t M)Files the triangle defined by the 3 vertices p, n and m into the fxTried arrays.Definition TGraphDelaunay.cxx:237; TGraphDelaunay::fYNminDouble_t fYNmin! Minimum value of fYNDefinition TGraphDelaunay.h:49; TGraphDelaunay::fTriedSizeInt_t fTriedSize! Real size of the fxTried arraysDefinition TGraphDelaunay.h:58; TGraphDelaunay::fMTriedInt_t * fMTried!Definition TGraphDelaunay.h:61; TGraphDelaunay::fXDouble_t * fX! Pointer to fGraph2D->fXDefinition TGraphDelaunay.h:42; TGraphDelaunay::fGraph2DTGraph2D * fGraph2D! 2D graph containing the user dataDefinition TGraphDelaunay.h:66; TGraphDelaunay::FindAllTrianglesvoid FindAllTriangles()Attempt to find all the Delaunay triangles of the point set.Definition TGraphDelaunay.cxx:290; TGraphDelaunay::fAllTriBool_t fAllTri! True if FindAllTriangles() has been performed on fGraph2DDefinition TGraphDelaunay.h:64; TGraphDelaunay::SetMaxItervoid SetMaxIter(Int_t n=100000)Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoni...Definition TGraphDelaunay.cxx:932; TGraphDelaunay::fMaxIterInt_t fMaxIter! Maximum number of iterations to find Delaunay trianglesDefinition TGraphDelaunay.h:57; TGraphDelaunay::fInitBool_t fInit! True if CreateTrianglesDataStructure() and FindHull() have been performedDefinition TGraphDelaunay.h:65; TGraphDelaunay::fOrderInt_t * fOrder! Array used to order mass points by distanceDefinition TGraphDelaunay.h:63; TGraphDelaunay::EncloseBool_t Enclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) constIs point e inside the triangle t1-t2-t3 ?Definition TGraphDelaunay.cxx:215; TGraphDelaunay::fXScaleFactorDouble_t fXScaleFactor!Definition TGraphDelaunay.h:53; TGraphDelaunay::fNdtInt_t fNdt! Number of Delaunay triangles foundDefinition TGraphDelaunay.h:39; TGraphDelaunay::fZDouble_t * fZ! Pointer to fGraph2D->fZDefinition TGraphDelaunay.h:44; TGraphDelaunay::fYNmaxDouble_t fYNmax! Maximum value of fYNDefinition TG",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
https://root.cern/doc/master/TGraphDelaunay_8h_source.html:2775,Performance,perform,performed,2775,"rs normalized of size fNpoints; 47 Double_t fXNmin; ///<! Minimum value of fXN; 48 Double_t fXNmax; ///<! Maximum value of fXN; 49 Double_t fYNmin; ///<! Minimum value of fYN; 50 Double_t fYNmax; ///<! Maximum value of fYN; 51 Double_t fXoffset; ///<!; 52 Double_t fYoffset; ///<! Parameters used to normalize user data; 53 Double_t fXScaleFactor; ///<!; 54 Double_t fYScaleFactor; ///<!; 55 Double_t fZout; ///<! Histogram bin height for points lying outside the convex hull; 56 Double_t *fDist; ///<! Array used to order mass points by distance; 57 Int_t fMaxIter; ///<! Maximum number of iterations to find Delaunay triangles; 58 Int_t fTriedSize; ///<! Real size of the fxTried arrays; 59 Int_t *fPTried; ///<!; 60 Int_t *fNTried; ///<! Delaunay triangles storage of size fNdt; 61 Int_t *fMTried; ///<!; 62 Int_t *fHullPoints; ///<! Hull points of size fNhull; 63 Int_t *fOrder; ///<! Array used to order mass points by distance; 64 Bool_t fAllTri; ///<! True if FindAllTriangles() has been performed on fGraph2D; 65 Bool_t fInit; ///<! True if CreateTrianglesDataStructure() and FindHull() have been performed; 66 TGraph2D *fGraph2D; ///<! 2D graph containing the user data; 67 ; 68 void CreateTrianglesDataStructure();; 69 Bool_t Enclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) const;; 70 void FileIt(Int_t P, Int_t N, Int_t M);; 71 void FindHull();; 72 Bool_t InHull(Int_t E, Int_t X) const;; 73 Double_t InterpolateOnPlane(Int_t TI1, Int_t TI2, Int_t TI3, Int_t E) const;; 74 ; 75public:; 76 ; 77 TGraphDelaunay();; 78 TGraphDelaunay(TGraph2D *g);; 79 ; 80 ~TGraphDelaunay() override;; 81 ; 82 Double_t ComputeZ(Double_t x, Double_t y);; 83 void FindAllTriangles();; 84 TGraph2D *GetGraph2D() const {return fGraph2D;}; 85 Double_t GetMarginBinsContent() const {return fZout;}; 86 Int_t GetNdt() const {return fNdt;}; 87 Int_t *GetPTried() const {return fPTried;}; 88 Int_t *GetNTried() const {return fNTried;}; 89 Int_t *GetMTried() const {return fMTried;}; 90 Double_t *GetXN() const {return",MatchSource.WIKI,doc/master/TGraphDelaunay_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8h_source.html
https://root.cern/doc/master/TGraphDelaunay_8h_source.html:2885,Performance,perform,performed,2885,"mum value of fXN; 49 Double_t fYNmin; ///<! Minimum value of fYN; 50 Double_t fYNmax; ///<! Maximum value of fYN; 51 Double_t fXoffset; ///<!; 52 Double_t fYoffset; ///<! Parameters used to normalize user data; 53 Double_t fXScaleFactor; ///<!; 54 Double_t fYScaleFactor; ///<!; 55 Double_t fZout; ///<! Histogram bin height for points lying outside the convex hull; 56 Double_t *fDist; ///<! Array used to order mass points by distance; 57 Int_t fMaxIter; ///<! Maximum number of iterations to find Delaunay triangles; 58 Int_t fTriedSize; ///<! Real size of the fxTried arrays; 59 Int_t *fPTried; ///<!; 60 Int_t *fNTried; ///<! Delaunay triangles storage of size fNdt; 61 Int_t *fMTried; ///<!; 62 Int_t *fHullPoints; ///<! Hull points of size fNhull; 63 Int_t *fOrder; ///<! Array used to order mass points by distance; 64 Bool_t fAllTri; ///<! True if FindAllTriangles() has been performed on fGraph2D; 65 Bool_t fInit; ///<! True if CreateTrianglesDataStructure() and FindHull() have been performed; 66 TGraph2D *fGraph2D; ///<! 2D graph containing the user data; 67 ; 68 void CreateTrianglesDataStructure();; 69 Bool_t Enclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) const;; 70 void FileIt(Int_t P, Int_t N, Int_t M);; 71 void FindHull();; 72 Bool_t InHull(Int_t E, Int_t X) const;; 73 Double_t InterpolateOnPlane(Int_t TI1, Int_t TI2, Int_t TI3, Int_t E) const;; 74 ; 75public:; 76 ; 77 TGraphDelaunay();; 78 TGraphDelaunay(TGraph2D *g);; 79 ; 80 ~TGraphDelaunay() override;; 81 ; 82 Double_t ComputeZ(Double_t x, Double_t y);; 83 void FindAllTriangles();; 84 TGraph2D *GetGraph2D() const {return fGraph2D;}; 85 Double_t GetMarginBinsContent() const {return fZout;}; 86 Int_t GetNdt() const {return fNdt;}; 87 Int_t *GetPTried() const {return fPTried;}; 88 Int_t *GetNTried() const {return fNTried;}; 89 Int_t *GetMTried() const {return fMTried;}; 90 Double_t *GetXN() const {return fXN;}; 91 Double_t *GetYN() const {return fYN;}; 92 Double_t GetXNmin() const {return fXNmin;}; 93 Double_t G",MatchSource.WIKI,doc/master/TGraphDelaunay_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8h_source.html
https://root.cern/doc/master/TGraphDelaunay_8h_source.html:8212,Performance,perform,performed,8212,":237; TGraphDelaunay::GetXNmaxDouble_t GetXNmax() constDefinition TGraphDelaunay.h:93; TGraphDelaunay::fYNminDouble_t fYNmin! Minimum value of fYNDefinition TGraphDelaunay.h:49; TGraphDelaunay::fTriedSizeInt_t fTriedSize! Real size of the fxTried arraysDefinition TGraphDelaunay.h:58; TGraphDelaunay::fMTriedInt_t * fMTried!Definition TGraphDelaunay.h:61; TGraphDelaunay::operator=TGraphDelaunay & operator=(const TGraphDelaunay &)=delete; TGraphDelaunay::fXDouble_t * fX! Pointer to fGraph2D->fXDefinition TGraphDelaunay.h:42; TGraphDelaunay::fGraph2DTGraph2D * fGraph2D! 2D graph containing the user dataDefinition TGraphDelaunay.h:66; TGraphDelaunay::FindAllTrianglesvoid FindAllTriangles()Attempt to find all the Delaunay triangles of the point set.Definition TGraphDelaunay.cxx:290; TGraphDelaunay::TGraphDelaunayTGraphDelaunay(const TGraphDelaunay &)=delete; TGraphDelaunay::GetXNDouble_t * GetXN() constDefinition TGraphDelaunay.h:90; TGraphDelaunay::fAllTriBool_t fAllTri! True if FindAllTriangles() has been performed on fGraph2DDefinition TGraphDelaunay.h:64; TGraphDelaunay::GetPTriedInt_t * GetPTried() constDefinition TGraphDelaunay.h:87; TGraphDelaunay::SetMaxItervoid SetMaxIter(Int_t n=100000)Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoni...Definition TGraphDelaunay.cxx:932; TGraphDelaunay::fMaxIterInt_t fMaxIter! Maximum number of iterations to find Delaunay trianglesDefinition TGraphDelaunay.h:57; TGraphDelaunay::GetNTriedInt_t * GetNTried() constDefinition TGraphDelaunay.h:88; TGraphDelaunay::fInitBool_t fInit! True if CreateTrianglesDataStructure() and FindHull() have been performedDefinition TGraphDelaunay.h:65; TGraphDelaunay::GetYNminDouble_t GetYNmin() constDefinition TGraphDelaunay.h:94; TGraphDelaunay::fOrderInt_t * fOrder! Array used to order mass points by distanceDefinition TGraphDelaunay.h:63; TGraphDelaunay::EncloseBool_t Enclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) constIs point e inside the tria",MatchSource.WIKI,doc/master/TGraphDelaunay_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8h_source.html
https://root.cern/doc/master/TGraphDelaunay_8h_source.html:8851,Performance,perform,performedDefinition,8851,"phDelaunay.h:66; TGraphDelaunay::FindAllTrianglesvoid FindAllTriangles()Attempt to find all the Delaunay triangles of the point set.Definition TGraphDelaunay.cxx:290; TGraphDelaunay::TGraphDelaunayTGraphDelaunay(const TGraphDelaunay &)=delete; TGraphDelaunay::GetXNDouble_t * GetXN() constDefinition TGraphDelaunay.h:90; TGraphDelaunay::fAllTriBool_t fAllTri! True if FindAllTriangles() has been performed on fGraph2DDefinition TGraphDelaunay.h:64; TGraphDelaunay::GetPTriedInt_t * GetPTried() constDefinition TGraphDelaunay.h:87; TGraphDelaunay::SetMaxItervoid SetMaxIter(Int_t n=100000)Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoni...Definition TGraphDelaunay.cxx:932; TGraphDelaunay::fMaxIterInt_t fMaxIter! Maximum number of iterations to find Delaunay trianglesDefinition TGraphDelaunay.h:57; TGraphDelaunay::GetNTriedInt_t * GetNTried() constDefinition TGraphDelaunay.h:88; TGraphDelaunay::fInitBool_t fInit! True if CreateTrianglesDataStructure() and FindHull() have been performedDefinition TGraphDelaunay.h:65; TGraphDelaunay::GetYNminDouble_t GetYNmin() constDefinition TGraphDelaunay.h:94; TGraphDelaunay::fOrderInt_t * fOrder! Array used to order mass points by distanceDefinition TGraphDelaunay.h:63; TGraphDelaunay::EncloseBool_t Enclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) constIs point e inside the triangle t1-t2-t3 ?Definition TGraphDelaunay.cxx:215; TGraphDelaunay::fXScaleFactorDouble_t fXScaleFactor!Definition TGraphDelaunay.h:53; TGraphDelaunay::fNdtInt_t fNdt! Number of Delaunay triangles foundDefinition TGraphDelaunay.h:39; TGraphDelaunay::fZDouble_t * fZ! Pointer to fGraph2D->fZDefinition TGraphDelaunay.h:44; TGraphDelaunay::fYNmaxDouble_t fYNmax! Maximum value of fYNDefinition TGraphDelaunay.h:50; TGraphDelaunay::~TGraphDelaunay~TGraphDelaunay() overrideTGraphDelaunay destructor.Definition TGraphDelaunay.cxx:123; TGraphDelaunay::fZoutDouble_t fZout! Histogram bin height for points lying outside the conve",MatchSource.WIKI,doc/master/TGraphDelaunay_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8h_source.html
https://root.cern/doc/master/TGraphDelaunay_8h_source.html:8436,Testability,test,tested,8436,"ize of the fxTried arraysDefinition TGraphDelaunay.h:58; TGraphDelaunay::fMTriedInt_t * fMTried!Definition TGraphDelaunay.h:61; TGraphDelaunay::operator=TGraphDelaunay & operator=(const TGraphDelaunay &)=delete; TGraphDelaunay::fXDouble_t * fX! Pointer to fGraph2D->fXDefinition TGraphDelaunay.h:42; TGraphDelaunay::fGraph2DTGraph2D * fGraph2D! 2D graph containing the user dataDefinition TGraphDelaunay.h:66; TGraphDelaunay::FindAllTrianglesvoid FindAllTriangles()Attempt to find all the Delaunay triangles of the point set.Definition TGraphDelaunay.cxx:290; TGraphDelaunay::TGraphDelaunayTGraphDelaunay(const TGraphDelaunay &)=delete; TGraphDelaunay::GetXNDouble_t * GetXN() constDefinition TGraphDelaunay.h:90; TGraphDelaunay::fAllTriBool_t fAllTri! True if FindAllTriangles() has been performed on fGraph2DDefinition TGraphDelaunay.h:64; TGraphDelaunay::GetPTriedInt_t * GetPTried() constDefinition TGraphDelaunay.h:87; TGraphDelaunay::SetMaxItervoid SetMaxIter(Int_t n=100000)Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoni...Definition TGraphDelaunay.cxx:932; TGraphDelaunay::fMaxIterInt_t fMaxIter! Maximum number of iterations to find Delaunay trianglesDefinition TGraphDelaunay.h:57; TGraphDelaunay::GetNTriedInt_t * GetNTried() constDefinition TGraphDelaunay.h:88; TGraphDelaunay::fInitBool_t fInit! True if CreateTrianglesDataStructure() and FindHull() have been performedDefinition TGraphDelaunay.h:65; TGraphDelaunay::GetYNminDouble_t GetYNmin() constDefinition TGraphDelaunay.h:94; TGraphDelaunay::fOrderInt_t * fOrder! Array used to order mass points by distanceDefinition TGraphDelaunay.h:63; TGraphDelaunay::EncloseBool_t Enclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) constIs point e inside the triangle t1-t2-t3 ?Definition TGraphDelaunay.cxx:215; TGraphDelaunay::fXScaleFactorDouble_t fXScaleFactor!Definition TGraphDelaunay.h:53; TGraphDelaunay::fNdtInt_t fNdt! Number of Delaunay triangles foundDefinition TGraphDelaunay.h:3",MatchSource.WIKI,doc/master/TGraphDelaunay_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8h_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:1196,Availability,error,error,1196,"ile. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Rene Brun 15/09/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#include ""TROOT.h""; 14#include ""TBuffer.h""; 15#include ""TGraphErrors.h""; 16#include ""TStyle.h""; 17#include ""TMath.h""; 18#include ""TVirtualPad.h""; 19#include ""TH1.h""; 20#include ""TF1.h""; 21#include ""TVectorD.h""; 22#include ""TSystem.h""; 23#include ""strtok.h""; 24 ; 25#include <iostream>; 26#include <fstream>; 27#include <cstring>; 28#include <string>; 29 ; 30ClassImp(TGraphErrors);; 31 ; 32 ; 33////////////////////////////////////////////////////////////////////////////////; 34 ; 35/** \class TGraphErrors; 36 \ingroup Graphs; 37A TGraphErrors is a TGraph with error bars.; 38 ; 39The TGraphErrors painting is performed thanks to the TGraphPainter; 40class. All details about the various painting options are given in this class.; 41 ; 42The picture below gives an example:; 43 ; 44Begin_Macro(source); 45{; 46 auto c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; 47 c1->SetFillColor(42);; 48 c1->SetGrid();; 49 c1->GetFrame()->SetFillColor(21);; 50 c1->GetFrame()->SetBorderSize(12);; 51 const Int_t n = 10;; 52 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 53 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 54 Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 55 Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 56 auto gr = new TGraphErrors(n,x,y,ex,ey);; 57 gr->SetTitle(""TGraphErrors Example"");; 58 gr->SetMarkerColor(4);; 59 gr->SetMa",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:1494,Availability,error,error,1494,"E/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#include ""TROOT.h""; 14#include ""TBuffer.h""; 15#include ""TGraphErrors.h""; 16#include ""TStyle.h""; 17#include ""TMath.h""; 18#include ""TVirtualPad.h""; 19#include ""TH1.h""; 20#include ""TF1.h""; 21#include ""TVectorD.h""; 22#include ""TSystem.h""; 23#include ""strtok.h""; 24 ; 25#include <iostream>; 26#include <fstream>; 27#include <cstring>; 28#include <string>; 29 ; 30ClassImp(TGraphErrors);; 31 ; 32 ; 33////////////////////////////////////////////////////////////////////////////////; 34 ; 35/** \class TGraphErrors; 36 \ingroup Graphs; 37A TGraphErrors is a TGraph with error bars.; 38 ; 39The TGraphErrors painting is performed thanks to the TGraphPainter; 40class. All details about the various painting options are given in this class.; 41 ; 42The picture below gives an example:; 43 ; 44Begin_Macro(source); 45{; 46 auto c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; 47 c1->SetFillColor(42);; 48 c1->SetGrid();; 49 c1->GetFrame()->SetFillColor(21);; 50 c1->GetFrame()->SetBorderSize(12);; 51 const Int_t n = 10;; 52 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 53 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 54 Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 55 Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 56 auto gr = new TGraphErrors(n,x,y,ex,ey);; 57 gr->SetTitle(""TGraphErrors Example"");; 58 gr->SetMarkerColor(4);; 59 gr->SetMarkerStyle(21);; 60 gr->Draw(""ALP"");; 61}; 62End_Macro; 63*/; 64 ; 65 ; 66////////////////////////////////////////////////////////////////////////////////; 67/// TGraphErrors default constructor.; 68 ; 69TGraphErrors::TGraphErrors(); 70{; 71 if (!CtorAllocate()) return;; 72}; 73 ; 74 ; 75////////////////////////////////////////////////////////////////////////////////; 76/// TGraphErrors normal constructor.; 77///; 78/// the arrays are preset to zero; 79 ; 80TGraphErrors::TGraphE",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:4025,Availability,error,errors,4025," 95{; 96 if (!CtorAllocate()) return;; 97 ; 98 for (Int_t i = 0; i < n; i++) {; 99 if (ex) fEX[i] = ex[i];; 100 else fEX[i] = 0;; 101 if (ey) fEY[i] = ey[i];; 102 else fEY[i] = 0;; 103 }; 104}; 105 ; 106 ; 107////////////////////////////////////////////////////////////////////////////////; 108/// TGraphErrors normal constructor.; 109///; 110/// if ex or ey are null, the corresponding arrays are preset to zero; 111 ; 112TGraphErrors::TGraphErrors(Int_t n, const Double_t *x, const Double_t *y, const Double_t *ex, const Double_t *ey); 113 : TGraph(n, x, y); 114{; 115 if (!CtorAllocate()) return;; 116 ; 117 n = sizeof(Double_t) * fNpoints;; 118 if (ex) memcpy(fEX, ex, n);; 119 else memset(fEX, 0, n);; 120 if (ey) memcpy(fEY, ey, n);; 121 else memset(fEY, 0, n);; 122}; 123 ; 124 ; 125////////////////////////////////////////////////////////////////////////////////; 126/// Constructor with four vectors of floats in input.; 127///; 128/// A grapherrors is built with the X coordinates taken from vx and Y coord from vy; 129/// and the errors from vectors vex and vey.; 130/// The number of points in the graph is the minimum of number of points; 131/// in vx and vy.; 132 ; 133TGraphErrors::TGraphErrors(const TVectorF &vx, const TVectorF &vy, const TVectorF &vex, const TVectorF &vey); 134 : TGraph(TMath::Min(vx.GetNrows(), vy.GetNrows()), vx.GetMatrixArray(), vy.GetMatrixArray() ); 135{; 136 if (!CtorAllocate()) return;; 137 Int_t ivexlow = vex.GetLwb();; 138 Int_t iveylow = vey.GetLwb();; 139 for (Int_t i = 0; i < fNpoints; i++) {; 140 fEX[i] = vex(i + ivexlow);; 141 fEY[i] = vey(i + iveylow);; 142 }; 143}; 144 ; 145 ; 146////////////////////////////////////////////////////////////////////////////////; 147/// Constructor with four vectors of doubles in input.; 148///; 149/// A grapherrors is built with the X coordinates taken from vx and Y coord from vy; 150/// and the errors from vectors vex and vey.; 151/// The number of points in the graph is the minimum of number of points; ",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:4874,Availability,error,errors,4874,"/////////////////////; 126/// Constructor with four vectors of floats in input.; 127///; 128/// A grapherrors is built with the X coordinates taken from vx and Y coord from vy; 129/// and the errors from vectors vex and vey.; 130/// The number of points in the graph is the minimum of number of points; 131/// in vx and vy.; 132 ; 133TGraphErrors::TGraphErrors(const TVectorF &vx, const TVectorF &vy, const TVectorF &vex, const TVectorF &vey); 134 : TGraph(TMath::Min(vx.GetNrows(), vy.GetNrows()), vx.GetMatrixArray(), vy.GetMatrixArray() ); 135{; 136 if (!CtorAllocate()) return;; 137 Int_t ivexlow = vex.GetLwb();; 138 Int_t iveylow = vey.GetLwb();; 139 for (Int_t i = 0; i < fNpoints; i++) {; 140 fEX[i] = vex(i + ivexlow);; 141 fEY[i] = vey(i + iveylow);; 142 }; 143}; 144 ; 145 ; 146////////////////////////////////////////////////////////////////////////////////; 147/// Constructor with four vectors of doubles in input.; 148///; 149/// A grapherrors is built with the X coordinates taken from vx and Y coord from vy; 150/// and the errors from vectors vex and vey.; 151/// The number of points in the graph is the minimum of number of points; 152/// in vx and vy.; 153 ; 154TGraphErrors::TGraphErrors(const TVectorD &vx, const TVectorD &vy, const TVectorD &vex, const TVectorD &vey); 155 : TGraph(TMath::Min(vx.GetNrows(), vy.GetNrows()), vx.GetMatrixArray(), vy.GetMatrixArray() ); 156{; 157 if (!CtorAllocate()) return;; 158 Int_t ivexlow = vex.GetLwb();; 159 Int_t iveylow = vey.GetLwb();; 160 for (Int_t i = 0; i < fNpoints; i++) {; 161 fEX[i] = vex(i + ivexlow);; 162 fEY[i] = vey(i + iveylow);; 163 }; 164}; 165 ; 166 ; 167////////////////////////////////////////////////////////////////////////////////; 168/// TGraphErrors copy constructor.; 169 ; 170TGraphErrors::TGraphErrors(const TGraphErrors &gr); 171 : TGraph(gr); 172{; 173 if (!CtorAllocate()) return;; 174 ; 175 Int_t n = sizeof(Double_t) * fNpoints;; 176 memcpy(fEX, gr.fEX, n);; 177 memcpy(fEY, gr.fEY, n);; 178}; 179 ; 180",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:10349,Availability,error,error,10349,"4 if (!format_.IsDigit()) {; 285 Error(""TGraphErrors"", ""Incorrect input format! Allowed format tags are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 286 return ;; 287 }; 288 Int_t ntokens = format_.Length() ;; 289 if (ntokens < 2) {; 290 Error(""TGraphErrors"", ""Incorrect input format! Only %d tag(s) in format whereas at least 2 \""%%lg\"" tags are expected!"", ntokens);; 291 return ;; 292 }; 293 Int_t ntokensToBeSaved = 0 ;; 294 Bool_t * isTokenToBeSaved = new Bool_t [ntokens] ;; 295 for (Int_t idx = 0; idx < ntokens; idx++) {; 296 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi() ; //atoi(&format_[idx]) does not work for some reason...; 297 if (isTokenToBeSaved[idx] == 1) {; 298 ntokensToBeSaved++ ;; 299 }; 300 }; 301 if (ntokens >= 2 && (ntokensToBeSaved < 2 || ntokensToBeSaved > 4)) { //first condition not to repeat the previous error message; 302 Error(""TGraphErrors"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2,3 or 4 are expected!"", ntokensToBeSaved);; 303 delete [] isTokenToBeSaved ;; 304 return ;; 305 }; 306 ; 307 // Initializing loop variables; 308 Bool_t isLineToBeSkipped = kFALSE; //empty and ill-formed lines; 309 char *token = nullptr;; 310 TString token_str = """";; 311 Int_t token_idx = 0;; 312 Double_t value[4]; //x,y,ex,ey buffers; 313 for (Int_t k = 0; k < 4; k++); 314 value[k] = 0.;; 315 Int_t value_idx = 0;; 316 ; 317 // Looping; 318 char *rest;; 319 while (std::getline(infile, line, '\n')) {; 320 if (!line.empty()) {; 321 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 322 line.erase(line.end() - 1, line.end()) ;; 323 }; 324 token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, &rest);; 325 while (token != nullptr && value_idx < ntokensToBeSaved) {; 326 if (isTokenToBeSaved[token_idx]) {; 327 token_str = TString(token) ;; 328 token_str.ReplaceAll(""\t"", """") ;; 329 if (!token_str.IsFloat()) {; 330 isLineToBeSkipped = kTRUE ;; 331 break ;; 332 } else {; 333 value[value_idx] = token_str.At",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:12428,Availability,error,errorbars,12428,"328 token_str.ReplaceAll(""\t"", """") ;; 329 if (!token_str.IsFloat()) {; 330 isLineToBeSkipped = kTRUE ;; 331 break ;; 332 } else {; 333 value[value_idx] = token_str.Atof() ;; 334 value_idx++ ;; 335 }; 336 }; 337 token = R__STRTOK_R(nullptr, option, &rest); // next token; 338 token_idx++ ;; 339 }; 340 if (!isLineToBeSkipped && value_idx > 1) { //i.e. 2,3 or 4; 341 x = value[0];; 342 y = value[1];; 343 ex = value[2];; 344 ey = value[3];; 345 SetPoint(np, x, y);; 346 SetPointError(np, ex, ey);; 347 np++ ;; 348 }; 349 }; 350 isLineToBeSkipped = kFALSE;; 351 token = nullptr;; 352 token_idx = 0;; 353 value_idx = 0;; 354 }; 355 Set(np) ;; 356 ; 357 // Cleaning; 358 delete [] isTokenToBeSaved;; 359 delete token;; 360 }; 361 infile.close();; 362}; 363 ; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// TGraphErrors default destructor.; 367 ; 368TGraphErrors::~TGraphErrors(); 369{; 370 delete [] fEX;; 371 delete [] fEY;; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Add a point with errorbars to the graph.; 376 ; 377void TGraphErrors::AddPointError(Double_t x, Double_t y, Double_t ex, Double_t ey); 378{; 379 AddPoint(x, y); // fNpoints will increase automatically; 380 SetPointError(fNpoints - 1, ex, ey);; 381}; 382 ; 383////////////////////////////////////////////////////////////////////////////////; 384/// Apply function to all the data points \f$ y = f(x,y) \f$.; 385///; 386/// The error is calculated as \f$ ey=(f(x,y+ey)-f(x,y-ey))/2 \f$.; 387/// This is the same as \f$ error(fy) = df/dy * ey \f$ for small errors.; 388///; 389/// For generic functions the symmetric errors might become non-symmetric; 390/// and are averaged here. Use TGraphAsymmErrors if desired.; 391///; 392/// Error on \f$ x \f$ doesn't change.; 393///; 394/// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 395 ; 396void TGraphErrors::Apply(TF1 *f); 397{; 398 Double_t x, y, e",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:12837,Availability,error,error,12837,"; 350 isLineToBeSkipped = kFALSE;; 351 token = nullptr;; 352 token_idx = 0;; 353 value_idx = 0;; 354 }; 355 Set(np) ;; 356 ; 357 // Cleaning; 358 delete [] isTokenToBeSaved;; 359 delete token;; 360 }; 361 infile.close();; 362}; 363 ; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// TGraphErrors default destructor.; 367 ; 368TGraphErrors::~TGraphErrors(); 369{; 370 delete [] fEX;; 371 delete [] fEY;; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Add a point with errorbars to the graph.; 376 ; 377void TGraphErrors::AddPointError(Double_t x, Double_t y, Double_t ex, Double_t ey); 378{; 379 AddPoint(x, y); // fNpoints will increase automatically; 380 SetPointError(fNpoints - 1, ex, ey);; 381}; 382 ; 383////////////////////////////////////////////////////////////////////////////////; 384/// Apply function to all the data points \f$ y = f(x,y) \f$.; 385///; 386/// The error is calculated as \f$ ey=(f(x,y+ey)-f(x,y-ey))/2 \f$.; 387/// This is the same as \f$ error(fy) = df/dy * ey \f$ for small errors.; 388///; 389/// For generic functions the symmetric errors might become non-symmetric; 390/// and are averaged here. Use TGraphAsymmErrors if desired.; 391///; 392/// Error on \f$ x \f$ doesn't change.; 393///; 394/// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 395 ; 396void TGraphErrors::Apply(TF1 *f); 397{; 398 Double_t x, y, ex, ey;; 399 ; 400 if (fHistogram) {; 401 delete fHistogram;; 402 fHistogram = nullptr;; 403 }; 404 for (Int_t i = 0; i < GetN(); i++) {; 405 GetPoint(i, x, y);; 406 ex = GetErrorX(i);; 407 ey = GetErrorY(i);; 408 ; 409 SetPoint(i, x, f->Eval(x, y));; 410 SetPointError(i, ex, TMath::Abs(f->Eval(x, y + ey) - f->Eval(x, y - ey)) / 2.);; 411 }; 412 if (gPad) gPad->Modified();; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Apply function to all the data points \f$",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:12928,Availability,error,error,12928,"53 value_idx = 0;; 354 }; 355 Set(np) ;; 356 ; 357 // Cleaning; 358 delete [] isTokenToBeSaved;; 359 delete token;; 360 }; 361 infile.close();; 362}; 363 ; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// TGraphErrors default destructor.; 367 ; 368TGraphErrors::~TGraphErrors(); 369{; 370 delete [] fEX;; 371 delete [] fEY;; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Add a point with errorbars to the graph.; 376 ; 377void TGraphErrors::AddPointError(Double_t x, Double_t y, Double_t ex, Double_t ey); 378{; 379 AddPoint(x, y); // fNpoints will increase automatically; 380 SetPointError(fNpoints - 1, ex, ey);; 381}; 382 ; 383////////////////////////////////////////////////////////////////////////////////; 384/// Apply function to all the data points \f$ y = f(x,y) \f$.; 385///; 386/// The error is calculated as \f$ ey=(f(x,y+ey)-f(x,y-ey))/2 \f$.; 387/// This is the same as \f$ error(fy) = df/dy * ey \f$ for small errors.; 388///; 389/// For generic functions the symmetric errors might become non-symmetric; 390/// and are averaged here. Use TGraphAsymmErrors if desired.; 391///; 392/// Error on \f$ x \f$ doesn't change.; 393///; 394/// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 395 ; 396void TGraphErrors::Apply(TF1 *f); 397{; 398 Double_t x, y, ex, ey;; 399 ; 400 if (fHistogram) {; 401 delete fHistogram;; 402 fHistogram = nullptr;; 403 }; 404 for (Int_t i = 0; i < GetN(); i++) {; 405 GetPoint(i, x, y);; 406 ex = GetErrorX(i);; 407 ey = GetErrorY(i);; 408 ; 409 SetPoint(i, x, f->Eval(x, y));; 410 SetPointError(i, ex, TMath::Abs(f->Eval(x, y + ey) - f->Eval(x, y - ey)) / 2.);; 411 }; 412 if (gPad) gPad->Modified();; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Apply function to all the data points \f$ x = f(x,y) \f$.; 417///; 418/// The error is calculated as \f$ ex=(f(x+ex,y)-",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:12965,Availability,error,errors,12965,"53 value_idx = 0;; 354 }; 355 Set(np) ;; 356 ; 357 // Cleaning; 358 delete [] isTokenToBeSaved;; 359 delete token;; 360 }; 361 infile.close();; 362}; 363 ; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// TGraphErrors default destructor.; 367 ; 368TGraphErrors::~TGraphErrors(); 369{; 370 delete [] fEX;; 371 delete [] fEY;; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Add a point with errorbars to the graph.; 376 ; 377void TGraphErrors::AddPointError(Double_t x, Double_t y, Double_t ex, Double_t ey); 378{; 379 AddPoint(x, y); // fNpoints will increase automatically; 380 SetPointError(fNpoints - 1, ex, ey);; 381}; 382 ; 383////////////////////////////////////////////////////////////////////////////////; 384/// Apply function to all the data points \f$ y = f(x,y) \f$.; 385///; 386/// The error is calculated as \f$ ey=(f(x,y+ey)-f(x,y-ey))/2 \f$.; 387/// This is the same as \f$ error(fy) = df/dy * ey \f$ for small errors.; 388///; 389/// For generic functions the symmetric errors might become non-symmetric; 390/// and are averaged here. Use TGraphAsymmErrors if desired.; 391///; 392/// Error on \f$ x \f$ doesn't change.; 393///; 394/// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 395 ; 396void TGraphErrors::Apply(TF1 *f); 397{; 398 Double_t x, y, ex, ey;; 399 ; 400 if (fHistogram) {; 401 delete fHistogram;; 402 fHistogram = nullptr;; 403 }; 404 for (Int_t i = 0; i < GetN(); i++) {; 405 GetPoint(i, x, y);; 406 ex = GetErrorX(i);; 407 ey = GetErrorY(i);; 408 ; 409 SetPoint(i, x, f->Eval(x, y));; 410 SetPointError(i, ex, TMath::Abs(f->Eval(x, y + ey) - f->Eval(x, y - ey)) / 2.);; 411 }; 412 if (gPad) gPad->Modified();; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Apply function to all the data points \f$ x = f(x,y) \f$.; 417///; 418/// The error is calculated as \f$ ex=(f(x+ex,y)-",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:13025,Availability,error,errors,13025,"359 delete token;; 360 }; 361 infile.close();; 362}; 363 ; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// TGraphErrors default destructor.; 367 ; 368TGraphErrors::~TGraphErrors(); 369{; 370 delete [] fEX;; 371 delete [] fEY;; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Add a point with errorbars to the graph.; 376 ; 377void TGraphErrors::AddPointError(Double_t x, Double_t y, Double_t ex, Double_t ey); 378{; 379 AddPoint(x, y); // fNpoints will increase automatically; 380 SetPointError(fNpoints - 1, ex, ey);; 381}; 382 ; 383////////////////////////////////////////////////////////////////////////////////; 384/// Apply function to all the data points \f$ y = f(x,y) \f$.; 385///; 386/// The error is calculated as \f$ ey=(f(x,y+ey)-f(x,y-ey))/2 \f$.; 387/// This is the same as \f$ error(fy) = df/dy * ey \f$ for small errors.; 388///; 389/// For generic functions the symmetric errors might become non-symmetric; 390/// and are averaged here. Use TGraphAsymmErrors if desired.; 391///; 392/// Error on \f$ x \f$ doesn't change.; 393///; 394/// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 395 ; 396void TGraphErrors::Apply(TF1 *f); 397{; 398 Double_t x, y, ex, ey;; 399 ; 400 if (fHistogram) {; 401 delete fHistogram;; 402 fHistogram = nullptr;; 403 }; 404 for (Int_t i = 0; i < GetN(); i++) {; 405 GetPoint(i, x, y);; 406 ex = GetErrorX(i);; 407 ey = GetErrorY(i);; 408 ; 409 SetPoint(i, x, f->Eval(x, y));; 410 SetPointError(i, ex, TMath::Abs(f->Eval(x, y + ey) - f->Eval(x, y - ey)) / 2.);; 411 }; 412 if (gPad) gPad->Modified();; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Apply function to all the data points \f$ x = f(x,y) \f$.; 417///; 418/// The error is calculated as \f$ ex=(f(x+ex,y)-f(x-ex,y))/2 \f$.; 419/// This is the same as \f$ error(fx) = df/dx * ex \f$ for small errors.; 4",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:13893,Availability,error,error,13893," the same as \f$ error(fy) = df/dy * ey \f$ for small errors.; 388///; 389/// For generic functions the symmetric errors might become non-symmetric; 390/// and are averaged here. Use TGraphAsymmErrors if desired.; 391///; 392/// Error on \f$ x \f$ doesn't change.; 393///; 394/// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 395 ; 396void TGraphErrors::Apply(TF1 *f); 397{; 398 Double_t x, y, ex, ey;; 399 ; 400 if (fHistogram) {; 401 delete fHistogram;; 402 fHistogram = nullptr;; 403 }; 404 for (Int_t i = 0; i < GetN(); i++) {; 405 GetPoint(i, x, y);; 406 ex = GetErrorX(i);; 407 ey = GetErrorY(i);; 408 ; 409 SetPoint(i, x, f->Eval(x, y));; 410 SetPointError(i, ex, TMath::Abs(f->Eval(x, y + ey) - f->Eval(x, y - ey)) / 2.);; 411 }; 412 if (gPad) gPad->Modified();; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Apply function to all the data points \f$ x = f(x,y) \f$.; 417///; 418/// The error is calculated as \f$ ex=(f(x+ex,y)-f(x-ex,y))/2 \f$.; 419/// This is the same as \f$ error(fx) = df/dx * ex \f$ for small errors.; 420///; 421/// For generic functions the symmetric errors might become non-symmetric; 422/// and are averaged here. Use TGraphAsymmErrors if desired.; 423///; 424/// Error on \f$ y \f$ doesn't change.; 425 ; 426void TGraphErrors::ApplyX(TF1 *f); 427{; 428 Double_t x, y, ex, ey;; 429 ; 430 if (fHistogram) {; 431 delete fHistogram;; 432 fHistogram = nullptr;; 433 }; 434 for (Int_t i = 0; i < GetN(); i++) {; 435 GetPoint(i, x, y);; 436 ex = GetErrorX(i);; 437 ey = GetErrorY(i);; 438 ; 439 SetPoint(i, f->Eval(x,y), y);; 440 SetPointError(i, TMath::Abs(f->Eval(x + ex, y) - f->Eval(x - ex, y)) / 2. , ey);; 441 }; 442 if (gPad) gPad->Modified();; 443}; 444 ; 445 ; 446////////////////////////////////////////////////////////////////////////////////; 447/// Calculate scan fields.; 448 ; 449Int_t TGraphErrors::CalculateScanfFields(const char *fmt); 450{; 451 Int_t fields = 0;; 452",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:13984,Availability,error,error,13984,"For generic functions the symmetric errors might become non-symmetric; 390/// and are averaged here. Use TGraphAsymmErrors if desired.; 391///; 392/// Error on \f$ x \f$ doesn't change.; 393///; 394/// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 395 ; 396void TGraphErrors::Apply(TF1 *f); 397{; 398 Double_t x, y, ex, ey;; 399 ; 400 if (fHistogram) {; 401 delete fHistogram;; 402 fHistogram = nullptr;; 403 }; 404 for (Int_t i = 0; i < GetN(); i++) {; 405 GetPoint(i, x, y);; 406 ex = GetErrorX(i);; 407 ey = GetErrorY(i);; 408 ; 409 SetPoint(i, x, f->Eval(x, y));; 410 SetPointError(i, ex, TMath::Abs(f->Eval(x, y + ey) - f->Eval(x, y - ey)) / 2.);; 411 }; 412 if (gPad) gPad->Modified();; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Apply function to all the data points \f$ x = f(x,y) \f$.; 417///; 418/// The error is calculated as \f$ ex=(f(x+ex,y)-f(x-ex,y))/2 \f$.; 419/// This is the same as \f$ error(fx) = df/dx * ex \f$ for small errors.; 420///; 421/// For generic functions the symmetric errors might become non-symmetric; 422/// and are averaged here. Use TGraphAsymmErrors if desired.; 423///; 424/// Error on \f$ y \f$ doesn't change.; 425 ; 426void TGraphErrors::ApplyX(TF1 *f); 427{; 428 Double_t x, y, ex, ey;; 429 ; 430 if (fHistogram) {; 431 delete fHistogram;; 432 fHistogram = nullptr;; 433 }; 434 for (Int_t i = 0; i < GetN(); i++) {; 435 GetPoint(i, x, y);; 436 ex = GetErrorX(i);; 437 ey = GetErrorY(i);; 438 ; 439 SetPoint(i, f->Eval(x,y), y);; 440 SetPointError(i, TMath::Abs(f->Eval(x + ex, y) - f->Eval(x - ex, y)) / 2. , ey);; 441 }; 442 if (gPad) gPad->Modified();; 443}; 444 ; 445 ; 446////////////////////////////////////////////////////////////////////////////////; 447/// Calculate scan fields.; 448 ; 449Int_t TGraphErrors::CalculateScanfFields(const char *fmt); 450{; 451 Int_t fields = 0;; 452 while ((fmt = strchr(fmt, '%'))) {; 453 Bool_t skip = kFALSE;; 454 while (*(+",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:14021,Availability,error,errors,14021,"For generic functions the symmetric errors might become non-symmetric; 390/// and are averaged here. Use TGraphAsymmErrors if desired.; 391///; 392/// Error on \f$ x \f$ doesn't change.; 393///; 394/// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 395 ; 396void TGraphErrors::Apply(TF1 *f); 397{; 398 Double_t x, y, ex, ey;; 399 ; 400 if (fHistogram) {; 401 delete fHistogram;; 402 fHistogram = nullptr;; 403 }; 404 for (Int_t i = 0; i < GetN(); i++) {; 405 GetPoint(i, x, y);; 406 ex = GetErrorX(i);; 407 ey = GetErrorY(i);; 408 ; 409 SetPoint(i, x, f->Eval(x, y));; 410 SetPointError(i, ex, TMath::Abs(f->Eval(x, y + ey) - f->Eval(x, y - ey)) / 2.);; 411 }; 412 if (gPad) gPad->Modified();; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Apply function to all the data points \f$ x = f(x,y) \f$.; 417///; 418/// The error is calculated as \f$ ex=(f(x+ex,y)-f(x-ex,y))/2 \f$.; 419/// This is the same as \f$ error(fx) = df/dx * ex \f$ for small errors.; 420///; 421/// For generic functions the symmetric errors might become non-symmetric; 422/// and are averaged here. Use TGraphAsymmErrors if desired.; 423///; 424/// Error on \f$ y \f$ doesn't change.; 425 ; 426void TGraphErrors::ApplyX(TF1 *f); 427{; 428 Double_t x, y, ex, ey;; 429 ; 430 if (fHistogram) {; 431 delete fHistogram;; 432 fHistogram = nullptr;; 433 }; 434 for (Int_t i = 0; i < GetN(); i++) {; 435 GetPoint(i, x, y);; 436 ex = GetErrorX(i);; 437 ey = GetErrorY(i);; 438 ; 439 SetPoint(i, f->Eval(x,y), y);; 440 SetPointError(i, TMath::Abs(f->Eval(x + ex, y) - f->Eval(x - ex, y)) / 2. , ey);; 441 }; 442 if (gPad) gPad->Modified();; 443}; 444 ; 445 ; 446////////////////////////////////////////////////////////////////////////////////; 447/// Calculate scan fields.; 448 ; 449Int_t TGraphErrors::CalculateScanfFields(const char *fmt); 450{; 451 Int_t fields = 0;; 452 while ((fmt = strchr(fmt, '%'))) {; 453 Bool_t skip = kFALSE;; 454 while (*(+",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:14081,Availability,error,errors,14081,"re. Use TGraphAsymmErrors if desired.; 391///; 392/// Error on \f$ x \f$ doesn't change.; 393///; 394/// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 395 ; 396void TGraphErrors::Apply(TF1 *f); 397{; 398 Double_t x, y, ex, ey;; 399 ; 400 if (fHistogram) {; 401 delete fHistogram;; 402 fHistogram = nullptr;; 403 }; 404 for (Int_t i = 0; i < GetN(); i++) {; 405 GetPoint(i, x, y);; 406 ex = GetErrorX(i);; 407 ey = GetErrorY(i);; 408 ; 409 SetPoint(i, x, f->Eval(x, y));; 410 SetPointError(i, ex, TMath::Abs(f->Eval(x, y + ey) - f->Eval(x, y - ey)) / 2.);; 411 }; 412 if (gPad) gPad->Modified();; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Apply function to all the data points \f$ x = f(x,y) \f$.; 417///; 418/// The error is calculated as \f$ ex=(f(x+ex,y)-f(x-ex,y))/2 \f$.; 419/// This is the same as \f$ error(fx) = df/dx * ex \f$ for small errors.; 420///; 421/// For generic functions the symmetric errors might become non-symmetric; 422/// and are averaged here. Use TGraphAsymmErrors if desired.; 423///; 424/// Error on \f$ y \f$ doesn't change.; 425 ; 426void TGraphErrors::ApplyX(TF1 *f); 427{; 428 Double_t x, y, ex, ey;; 429 ; 430 if (fHistogram) {; 431 delete fHistogram;; 432 fHistogram = nullptr;; 433 }; 434 for (Int_t i = 0; i < GetN(); i++) {; 435 GetPoint(i, x, y);; 436 ex = GetErrorX(i);; 437 ey = GetErrorY(i);; 438 ; 439 SetPoint(i, f->Eval(x,y), y);; 440 SetPointError(i, TMath::Abs(f->Eval(x + ex, y) - f->Eval(x - ex, y)) / 2. , ey);; 441 }; 442 if (gPad) gPad->Modified();; 443}; 444 ; 445 ; 446////////////////////////////////////////////////////////////////////////////////; 447/// Calculate scan fields.; 448 ; 449Int_t TGraphErrors::CalculateScanfFields(const char *fmt); 450{; 451 Int_t fields = 0;; 452 while ((fmt = strchr(fmt, '%'))) {; 453 Bool_t skip = kFALSE;; 454 while (*(++fmt)) {; 455 if ('[' == *fmt) {; 456 if (*++fmt && '^' == *fmt) ++fmt; // ""%[^]a]""; 457 if (*++f",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:17046,Availability,error,errors,17046,"5 if (fX[i] - fEX[i] < xmin) {; 486 if (gPad && gPad->GetLogx()) {; 487 if (fEX[i] < fX[i]) xmin = fX[i] - fEX[i];; 488 else xmin = TMath::Min(xmin, fX[i] / 3);; 489 } else {; 490 xmin = fX[i] - fEX[i];; 491 }; 492 }; 493 if (fX[i] + fEX[i] > xmax) xmax = fX[i] + fEX[i];; 494 if (fY[i] - fEY[i] < ymin) {; 495 if (gPad && gPad->GetLogy()) {; 496 if (fEY[i] < fY[i]) ymin = fY[i] - fEY[i];; 497 else ymin = TMath::Min(ymin, fY[i] / 3);; 498 } else {; 499 ymin = fY[i] - fEY[i];; 500 }; 501 }; 502 if (fY[i] + fEY[i] > ymax) ymax = fY[i] + fEY[i];; 503 }; 504}; 505 ; 506 ; 507////////////////////////////////////////////////////////////////////////////////; 508/// Copy and release.; 509 ; 510void TGraphErrors::CopyAndRelease(Double_t **newarrays,; 511 Int_t ibegin, Int_t iend, Int_t obegin); 512{; 513 CopyPoints(newarrays, ibegin, iend, obegin);; 514 if (newarrays) {; 515 delete[] fX;; 516 fX = newarrays[2];; 517 delete[] fY;; 518 fY = newarrays[3];; 519 delete[] fEX;; 520 fEX = newarrays[0];; 521 delete[] fEY;; 522 fEY = newarrays[1];; 523 delete[] newarrays;; 524 }; 525}; 526 ; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Copy errors from `fEX` and `fEY` to `arrays[0]` and `arrays[1]`; 530/// or to `fEX` and `fEY` if `arrays == 0` and `ibegin != iend`.; 531 ; 532Bool_t TGraphErrors::CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 533 Int_t obegin); 534{; 535 if (TGraph::CopyPoints(arrays ? arrays + 2 : nullptr, ibegin, iend, obegin)) {; 536 Int_t n = (iend - ibegin) * sizeof(Double_t);; 537 if (arrays) {; 538 memmove(&arrays[0][obegin], &fEX[ibegin], n);; 539 memmove(&arrays[1][obegin], &fEY[ibegin], n);; 540 } else {; 541 memmove(&fEX[obegin], &fEX[ibegin], n);; 542 memmove(&fEY[obegin], &fEY[ibegin], n);; 543 }; 544 return kTRUE;; 545 } else {; 546 return kFALSE;; 547 }; 548}; 549 ; 550 ; 551////////////////////////////////////////////////////////////////////////////////; 552/// Constructor allocate.; 553///; ",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:18393,Availability,error,errors,18393,"GraphErrors::CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 533 Int_t obegin); 534{; 535 if (TGraph::CopyPoints(arrays ? arrays + 2 : nullptr, ibegin, iend, obegin)) {; 536 Int_t n = (iend - ibegin) * sizeof(Double_t);; 537 if (arrays) {; 538 memmove(&arrays[0][obegin], &fEX[ibegin], n);; 539 memmove(&arrays[1][obegin], &fEY[ibegin], n);; 540 } else {; 541 memmove(&fEX[obegin], &fEX[ibegin], n);; 542 memmove(&fEY[obegin], &fEY[ibegin], n);; 543 }; 544 return kTRUE;; 545 } else {; 546 return kFALSE;; 547 }; 548}; 549 ; 550 ; 551////////////////////////////////////////////////////////////////////////////////; 552/// Constructor allocate.; 553///; 554/// Note: This function should be called only from the constructor; 555/// since it does not delete previously existing arrays.; 556 ; 557Bool_t TGraphErrors::CtorAllocate(); 558{; 559 ; 560 if (!fNpoints) {; 561 fEX = fEY = nullptr;; 562 return kFALSE;; 563 } else {; 564 fEX = new Double_t[fMaxSize];; 565 fEY = new Double_t[fMaxSize];; 566 }; 567 return kTRUE;; 568}; 569 ; 570////////////////////////////////////////////////////////////////////////////////; 571/// Protected function to perform the merge operation of a graph with errors.; 572 ; 573Bool_t TGraphErrors::DoMerge(const TGraph *g); 574{; 575 if (g->GetN() == 0) return kFALSE;; 576 ; 577 Double_t * ex = g->GetEX();; 578 Double_t * ey = g->GetEY();; 579 if (ex == nullptr || ey == nullptr) {; 580 if (g->IsA() != TGraph::Class() ); 581 Warning(""DoMerge"",""Merging a %s is not compatible with a TGraphErrors - errors will be ignored"",g->IsA()->GetName());; 582 return TGraph::DoMerge(g);; 583 }; 584 for (Int_t i = 0 ; i < g->GetN(); i++) {; 585 Int_t ipoint = GetN();; 586 Double_t x = g->GetX()[i];; 587 Double_t y = g->GetY()[i];; 588 SetPoint(ipoint, x, y);; 589 SetPointError( ipoint, ex[i], ey[i] );; 590 }; 591 return kTRUE;; 592}; 593 ; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Set zero values for point ",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:18734,Availability,error,errors,18734,"/; 552/// Constructor allocate.; 553///; 554/// Note: This function should be called only from the constructor; 555/// since it does not delete previously existing arrays.; 556 ; 557Bool_t TGraphErrors::CtorAllocate(); 558{; 559 ; 560 if (!fNpoints) {; 561 fEX = fEY = nullptr;; 562 return kFALSE;; 563 } else {; 564 fEX = new Double_t[fMaxSize];; 565 fEY = new Double_t[fMaxSize];; 566 }; 567 return kTRUE;; 568}; 569 ; 570////////////////////////////////////////////////////////////////////////////////; 571/// Protected function to perform the merge operation of a graph with errors.; 572 ; 573Bool_t TGraphErrors::DoMerge(const TGraph *g); 574{; 575 if (g->GetN() == 0) return kFALSE;; 576 ; 577 Double_t * ex = g->GetEX();; 578 Double_t * ey = g->GetEY();; 579 if (ex == nullptr || ey == nullptr) {; 580 if (g->IsA() != TGraph::Class() ); 581 Warning(""DoMerge"",""Merging a %s is not compatible with a TGraphErrors - errors will be ignored"",g->IsA()->GetName());; 582 return TGraph::DoMerge(g);; 583 }; 584 for (Int_t i = 0 ; i < g->GetN(); i++) {; 585 Int_t ipoint = GetN();; 586 Double_t x = g->GetX()[i];; 587 Double_t y = g->GetY()[i];; 588 SetPoint(ipoint, x, y);; 589 SetPointError( ipoint, ex[i], ey[i] );; 590 }; 591 return kTRUE;; 592}; 593 ; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Set zero values for point arrays in the range `[begin, end]`.; 597 ; 598void TGraphErrors::FillZero(Int_t begin, Int_t end, Bool_t from_ctor); 599{; 600 if (!from_ctor) {; 601 TGraph::FillZero(begin, end, from_ctor);; 602 }; 603 Int_t n = (end - begin) * sizeof(Double_t);; 604 memset(fEX + begin, 0, n);; 605 memset(fEY + begin, 0, n);; 606}; 607 ; 608 ; 609////////////////////////////////////////////////////////////////////////////////; 610/// It returns the error along X at point `i`.; 611 ; 612Double_t TGraphErrors::GetErrorX(Int_t i) const; 613{; 614 if (i < 0 || i >= fNpoints) return -1;; 615 if (fEX) return fEX[i];; 616 return -1;; 61",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:19630,Availability,error,error,19630,"nst TGraph *g); 574{; 575 if (g->GetN() == 0) return kFALSE;; 576 ; 577 Double_t * ex = g->GetEX();; 578 Double_t * ey = g->GetEY();; 579 if (ex == nullptr || ey == nullptr) {; 580 if (g->IsA() != TGraph::Class() ); 581 Warning(""DoMerge"",""Merging a %s is not compatible with a TGraphErrors - errors will be ignored"",g->IsA()->GetName());; 582 return TGraph::DoMerge(g);; 583 }; 584 for (Int_t i = 0 ; i < g->GetN(); i++) {; 585 Int_t ipoint = GetN();; 586 Double_t x = g->GetX()[i];; 587 Double_t y = g->GetY()[i];; 588 SetPoint(ipoint, x, y);; 589 SetPointError( ipoint, ex[i], ey[i] );; 590 }; 591 return kTRUE;; 592}; 593 ; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Set zero values for point arrays in the range `[begin, end]`.; 597 ; 598void TGraphErrors::FillZero(Int_t begin, Int_t end, Bool_t from_ctor); 599{; 600 if (!from_ctor) {; 601 TGraph::FillZero(begin, end, from_ctor);; 602 }; 603 Int_t n = (end - begin) * sizeof(Double_t);; 604 memset(fEX + begin, 0, n);; 605 memset(fEY + begin, 0, n);; 606}; 607 ; 608 ; 609////////////////////////////////////////////////////////////////////////////////; 610/// It returns the error along X at point `i`.; 611 ; 612Double_t TGraphErrors::GetErrorX(Int_t i) const; 613{; 614 if (i < 0 || i >= fNpoints) return -1;; 615 if (fEX) return fEX[i];; 616 return -1;; 617}; 618 ; 619 ; 620////////////////////////////////////////////////////////////////////////////////; 621/// It returns the error along Y at point `i`.; 622 ; 623Double_t TGraphErrors::GetErrorY(Int_t i) const; 624{; 625 if (i < 0 || i >= fNpoints) return -1;; 626 if (fEY) return fEY[i];; 627 return -1;; 628}; 629 ; 630 ; 631////////////////////////////////////////////////////////////////////////////////; 632/// It returns the error along X at point `i`. For TGraphErrors this method is; 633/// the same as GetErrorX.; 634 ; 635Double_t TGraphErrors::GetErrorXhigh(Int_t i) const; 636{; 637 if (i < 0 || i >= fNpoints) return ",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:19937,Availability,error,error,19937,";; 583 }; 584 for (Int_t i = 0 ; i < g->GetN(); i++) {; 585 Int_t ipoint = GetN();; 586 Double_t x = g->GetX()[i];; 587 Double_t y = g->GetY()[i];; 588 SetPoint(ipoint, x, y);; 589 SetPointError( ipoint, ex[i], ey[i] );; 590 }; 591 return kTRUE;; 592}; 593 ; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Set zero values for point arrays in the range `[begin, end]`.; 597 ; 598void TGraphErrors::FillZero(Int_t begin, Int_t end, Bool_t from_ctor); 599{; 600 if (!from_ctor) {; 601 TGraph::FillZero(begin, end, from_ctor);; 602 }; 603 Int_t n = (end - begin) * sizeof(Double_t);; 604 memset(fEX + begin, 0, n);; 605 memset(fEY + begin, 0, n);; 606}; 607 ; 608 ; 609////////////////////////////////////////////////////////////////////////////////; 610/// It returns the error along X at point `i`.; 611 ; 612Double_t TGraphErrors::GetErrorX(Int_t i) const; 613{; 614 if (i < 0 || i >= fNpoints) return -1;; 615 if (fEX) return fEX[i];; 616 return -1;; 617}; 618 ; 619 ; 620////////////////////////////////////////////////////////////////////////////////; 621/// It returns the error along Y at point `i`.; 622 ; 623Double_t TGraphErrors::GetErrorY(Int_t i) const; 624{; 625 if (i < 0 || i >= fNpoints) return -1;; 626 if (fEY) return fEY[i];; 627 return -1;; 628}; 629 ; 630 ; 631////////////////////////////////////////////////////////////////////////////////; 632/// It returns the error along X at point `i`. For TGraphErrors this method is; 633/// the same as GetErrorX.; 634 ; 635Double_t TGraphErrors::GetErrorXhigh(Int_t i) const; 636{; 637 if (i < 0 || i >= fNpoints) return -1;; 638 if (fEX) return fEX[i];; 639 return -1;; 640}; 641 ; 642 ; 643////////////////////////////////////////////////////////////////////////////////; 644/// It returns the error along X at point `i`. For TGraphErrors this method is; 645/// the same as GetErrorX.; 646 ; 647Double_t TGraphErrors::GetErrorXlow(Int_t i) const; 648{; 649 if (i < 0 || i >= fNpoints) re",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:20244,Availability,error,error,20244,"/////////////////////////////////////////; 596/// Set zero values for point arrays in the range `[begin, end]`.; 597 ; 598void TGraphErrors::FillZero(Int_t begin, Int_t end, Bool_t from_ctor); 599{; 600 if (!from_ctor) {; 601 TGraph::FillZero(begin, end, from_ctor);; 602 }; 603 Int_t n = (end - begin) * sizeof(Double_t);; 604 memset(fEX + begin, 0, n);; 605 memset(fEY + begin, 0, n);; 606}; 607 ; 608 ; 609////////////////////////////////////////////////////////////////////////////////; 610/// It returns the error along X at point `i`.; 611 ; 612Double_t TGraphErrors::GetErrorX(Int_t i) const; 613{; 614 if (i < 0 || i >= fNpoints) return -1;; 615 if (fEX) return fEX[i];; 616 return -1;; 617}; 618 ; 619 ; 620////////////////////////////////////////////////////////////////////////////////; 621/// It returns the error along Y at point `i`.; 622 ; 623Double_t TGraphErrors::GetErrorY(Int_t i) const; 624{; 625 if (i < 0 || i >= fNpoints) return -1;; 626 if (fEY) return fEY[i];; 627 return -1;; 628}; 629 ; 630 ; 631////////////////////////////////////////////////////////////////////////////////; 632/// It returns the error along X at point `i`. For TGraphErrors this method is; 633/// the same as GetErrorX.; 634 ; 635Double_t TGraphErrors::GetErrorXhigh(Int_t i) const; 636{; 637 if (i < 0 || i >= fNpoints) return -1;; 638 if (fEX) return fEX[i];; 639 return -1;; 640}; 641 ; 642 ; 643////////////////////////////////////////////////////////////////////////////////; 644/// It returns the error along X at point `i`. For TGraphErrors this method is; 645/// the same as GetErrorX.; 646 ; 647Double_t TGraphErrors::GetErrorXlow(Int_t i) const; 648{; 649 if (i < 0 || i >= fNpoints) return -1;; 650 if (fEX) return fEX[i];; 651 return -1;; 652}; 653 ; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// It returns the error along Y at point `i`. For TGraphErrors this method is; 657/// the same as GetErrorY.; 658 ; 659Double_t TGraphErrors::Get",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:20618,Availability,error,error,20618," begin, 0, n);; 606}; 607 ; 608 ; 609////////////////////////////////////////////////////////////////////////////////; 610/// It returns the error along X at point `i`.; 611 ; 612Double_t TGraphErrors::GetErrorX(Int_t i) const; 613{; 614 if (i < 0 || i >= fNpoints) return -1;; 615 if (fEX) return fEX[i];; 616 return -1;; 617}; 618 ; 619 ; 620////////////////////////////////////////////////////////////////////////////////; 621/// It returns the error along Y at point `i`.; 622 ; 623Double_t TGraphErrors::GetErrorY(Int_t i) const; 624{; 625 if (i < 0 || i >= fNpoints) return -1;; 626 if (fEY) return fEY[i];; 627 return -1;; 628}; 629 ; 630 ; 631////////////////////////////////////////////////////////////////////////////////; 632/// It returns the error along X at point `i`. For TGraphErrors this method is; 633/// the same as GetErrorX.; 634 ; 635Double_t TGraphErrors::GetErrorXhigh(Int_t i) const; 636{; 637 if (i < 0 || i >= fNpoints) return -1;; 638 if (fEX) return fEX[i];; 639 return -1;; 640}; 641 ; 642 ; 643////////////////////////////////////////////////////////////////////////////////; 644/// It returns the error along X at point `i`. For TGraphErrors this method is; 645/// the same as GetErrorX.; 646 ; 647Double_t TGraphErrors::GetErrorXlow(Int_t i) const; 648{; 649 if (i < 0 || i >= fNpoints) return -1;; 650 if (fEX) return fEX[i];; 651 return -1;; 652}; 653 ; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// It returns the error along Y at point `i`. For TGraphErrors this method is; 657/// the same as GetErrorY.; 658 ; 659Double_t TGraphErrors::GetErrorYhigh(Int_t i) const; 660{; 661 if (i < 0 || i >= fNpoints) return -1;; 662 if (fEY) return fEY[i];; 663 return -1;; 664}; 665 ; 666 ; 667////////////////////////////////////////////////////////////////////////////////; 668/// It returns the error along Y at point `i`. For TGraphErrors this method is; 669/// the same as GetErrorY.; 670 ; 671Double_t TGraphErrors::G",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:20991,Availability,error,error,20991,//////////////////////////////////////////////////; 621/// It returns the error along Y at point `i`.; 622 ; 623Double_t TGraphErrors::GetErrorY(Int_t i) const; 624{; 625 if (i < 0 || i >= fNpoints) return -1;; 626 if (fEY) return fEY[i];; 627 return -1;; 628}; 629 ; 630 ; 631////////////////////////////////////////////////////////////////////////////////; 632/// It returns the error along X at point `i`. For TGraphErrors this method is; 633/// the same as GetErrorX.; 634 ; 635Double_t TGraphErrors::GetErrorXhigh(Int_t i) const; 636{; 637 if (i < 0 || i >= fNpoints) return -1;; 638 if (fEX) return fEX[i];; 639 return -1;; 640}; 641 ; 642 ; 643////////////////////////////////////////////////////////////////////////////////; 644/// It returns the error along X at point `i`. For TGraphErrors this method is; 645/// the same as GetErrorX.; 646 ; 647Double_t TGraphErrors::GetErrorXlow(Int_t i) const; 648{; 649 if (i < 0 || i >= fNpoints) return -1;; 650 if (fEX) return fEX[i];; 651 return -1;; 652}; 653 ; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// It returns the error along Y at point `i`. For TGraphErrors this method is; 657/// the same as GetErrorY.; 658 ; 659Double_t TGraphErrors::GetErrorYhigh(Int_t i) const; 660{; 661 if (i < 0 || i >= fNpoints) return -1;; 662 if (fEY) return fEY[i];; 663 return -1;; 664}; 665 ; 666 ; 667////////////////////////////////////////////////////////////////////////////////; 668/// It returns the error along Y at point `i`. For TGraphErrors this method is; 669/// the same as GetErrorY.; 670 ; 671Double_t TGraphErrors::GetErrorYlow(Int_t i) const; 672{; 673 if (i < 0 || i >= fNpoints) return -1;; 674 if (fEY) return fEY[i];; 675 return -1;; 676}; 677 ; 678////////////////////////////////////////////////////////////////////////////////; 679/// Adds all graphs with errors from the collection to this graph.; 680/// Returns the total number of points in the result or -1 in case of an error.,MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:21365,Availability,error,error,21365,"rns the error along X at point `i`. For TGraphErrors this method is; 633/// the same as GetErrorX.; 634 ; 635Double_t TGraphErrors::GetErrorXhigh(Int_t i) const; 636{; 637 if (i < 0 || i >= fNpoints) return -1;; 638 if (fEX) return fEX[i];; 639 return -1;; 640}; 641 ; 642 ; 643////////////////////////////////////////////////////////////////////////////////; 644/// It returns the error along X at point `i`. For TGraphErrors this method is; 645/// the same as GetErrorX.; 646 ; 647Double_t TGraphErrors::GetErrorXlow(Int_t i) const; 648{; 649 if (i < 0 || i >= fNpoints) return -1;; 650 if (fEX) return fEX[i];; 651 return -1;; 652}; 653 ; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// It returns the error along Y at point `i`. For TGraphErrors this method is; 657/// the same as GetErrorY.; 658 ; 659Double_t TGraphErrors::GetErrorYhigh(Int_t i) const; 660{; 661 if (i < 0 || i >= fNpoints) return -1;; 662 if (fEY) return fEY[i];; 663 return -1;; 664}; 665 ; 666 ; 667////////////////////////////////////////////////////////////////////////////////; 668/// It returns the error along Y at point `i`. For TGraphErrors this method is; 669/// the same as GetErrorY.; 670 ; 671Double_t TGraphErrors::GetErrorYlow(Int_t i) const; 672{; 673 if (i < 0 || i >= fNpoints) return -1;; 674 if (fEY) return fEY[i];; 675 return -1;; 676}; 677 ; 678////////////////////////////////////////////////////////////////////////////////; 679/// Adds all graphs with errors from the collection to this graph.; 680/// Returns the total number of points in the result or -1 in case of an error.; 681 ; 682Int_t TGraphErrors::Merge(TCollection* li); 683{; 684 TIter next(li);; 685 while (TObject* o = next()) {; 686 TGraph *g = dynamic_cast<TGraph*>(o);; 687 if (!g) {; 688 Error(""Merge"",; 689 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 690 return -1;; 691 }; 692 int n0 = GetN();; 693 int n1 = n0+g->GetN();; 694 Set(n1);; 695 Do",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:21738,Availability,error,errors,21738," error along X at point `i`. For TGraphErrors this method is; 645/// the same as GetErrorX.; 646 ; 647Double_t TGraphErrors::GetErrorXlow(Int_t i) const; 648{; 649 if (i < 0 || i >= fNpoints) return -1;; 650 if (fEX) return fEX[i];; 651 return -1;; 652}; 653 ; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// It returns the error along Y at point `i`. For TGraphErrors this method is; 657/// the same as GetErrorY.; 658 ; 659Double_t TGraphErrors::GetErrorYhigh(Int_t i) const; 660{; 661 if (i < 0 || i >= fNpoints) return -1;; 662 if (fEY) return fEY[i];; 663 return -1;; 664}; 665 ; 666 ; 667////////////////////////////////////////////////////////////////////////////////; 668/// It returns the error along Y at point `i`. For TGraphErrors this method is; 669/// the same as GetErrorY.; 670 ; 671Double_t TGraphErrors::GetErrorYlow(Int_t i) const; 672{; 673 if (i < 0 || i >= fNpoints) return -1;; 674 if (fEY) return fEY[i];; 675 return -1;; 676}; 677 ; 678////////////////////////////////////////////////////////////////////////////////; 679/// Adds all graphs with errors from the collection to this graph.; 680/// Returns the total number of points in the result or -1 in case of an error.; 681 ; 682Int_t TGraphErrors::Merge(TCollection* li); 683{; 684 TIter next(li);; 685 while (TObject* o = next()) {; 686 TGraph *g = dynamic_cast<TGraph*>(o);; 687 if (!g) {; 688 Error(""Merge"",; 689 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 690 return -1;; 691 }; 692 int n0 = GetN();; 693 int n1 = n0+g->GetN();; 694 Set(n1);; 695 Double_t * x = g->GetX();; 696 Double_t * y = g->GetY();; 697 Double_t * ex = g->GetEX();; 698 Double_t * ey = g->GetEY();; 699 for (Int_t i = 0 ; i < g->GetN(); i++) {; 700 SetPoint(n0+i, x[i], y[i]);; 701 if (ex) fEX[n0+i] = ex[i];; 702 if (ey) fEY[n0+i] = ey[i];; 703 }; 704 }; 705 return GetN();; 706}; 707 ; 708//////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:21857,Availability,error,error,21857,"650 if (fEX) return fEX[i];; 651 return -1;; 652}; 653 ; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// It returns the error along Y at point `i`. For TGraphErrors this method is; 657/// the same as GetErrorY.; 658 ; 659Double_t TGraphErrors::GetErrorYhigh(Int_t i) const; 660{; 661 if (i < 0 || i >= fNpoints) return -1;; 662 if (fEY) return fEY[i];; 663 return -1;; 664}; 665 ; 666 ; 667////////////////////////////////////////////////////////////////////////////////; 668/// It returns the error along Y at point `i`. For TGraphErrors this method is; 669/// the same as GetErrorY.; 670 ; 671Double_t TGraphErrors::GetErrorYlow(Int_t i) const; 672{; 673 if (i < 0 || i >= fNpoints) return -1;; 674 if (fEY) return fEY[i];; 675 return -1;; 676}; 677 ; 678////////////////////////////////////////////////////////////////////////////////; 679/// Adds all graphs with errors from the collection to this graph.; 680/// Returns the total number of points in the result or -1 in case of an error.; 681 ; 682Int_t TGraphErrors::Merge(TCollection* li); 683{; 684 TIter next(li);; 685 while (TObject* o = next()) {; 686 TGraph *g = dynamic_cast<TGraph*>(o);; 687 if (!g) {; 688 Error(""Merge"",; 689 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 690 return -1;; 691 }; 692 int n0 = GetN();; 693 int n1 = n0+g->GetN();; 694 Set(n1);; 695 Double_t * x = g->GetX();; 696 Double_t * y = g->GetY();; 697 Double_t * ex = g->GetEX();; 698 Double_t * ey = g->GetEY();; 699 for (Int_t i = 0 ; i < g->GetN(); i++) {; 700 SetPoint(n0+i, x[i], y[i]);; 701 if (ex) fEX[n0+i] = ex[i];; 702 if (ey) fEY[n0+i] = ey[i];; 703 }; 704 }; 705 return GetN();; 706}; 707 ; 708////////////////////////////////////////////////////////////////////////////////; 709/// Print graph and errors values.; 710 ; 711void TGraphErrors::Print(Option_t *) const; 712{; 713 for (Int_t i = 0; i < fNpoints; i++) {; 714 printf(""x[%d]=%g, y[%d]=%g, ex[%d]=%g, ey[",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:22656,Availability,error,errors,22656,"///////////////////////////////////////////////////////////////////////////; 668/// It returns the error along Y at point `i`. For TGraphErrors this method is; 669/// the same as GetErrorY.; 670 ; 671Double_t TGraphErrors::GetErrorYlow(Int_t i) const; 672{; 673 if (i < 0 || i >= fNpoints) return -1;; 674 if (fEY) return fEY[i];; 675 return -1;; 676}; 677 ; 678////////////////////////////////////////////////////////////////////////////////; 679/// Adds all graphs with errors from the collection to this graph.; 680/// Returns the total number of points in the result or -1 in case of an error.; 681 ; 682Int_t TGraphErrors::Merge(TCollection* li); 683{; 684 TIter next(li);; 685 while (TObject* o = next()) {; 686 TGraph *g = dynamic_cast<TGraph*>(o);; 687 if (!g) {; 688 Error(""Merge"",; 689 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 690 return -1;; 691 }; 692 int n0 = GetN();; 693 int n1 = n0+g->GetN();; 694 Set(n1);; 695 Double_t * x = g->GetX();; 696 Double_t * y = g->GetY();; 697 Double_t * ex = g->GetEX();; 698 Double_t * ey = g->GetEY();; 699 for (Int_t i = 0 ; i < g->GetN(); i++) {; 700 SetPoint(n0+i, x[i], y[i]);; 701 if (ex) fEX[n0+i] = ex[i];; 702 if (ey) fEY[n0+i] = ey[i];; 703 }; 704 }; 705 return GetN();; 706}; 707 ; 708////////////////////////////////////////////////////////////////////////////////; 709/// Print graph and errors values.; 710 ; 711void TGraphErrors::Print(Option_t *) const; 712{; 713 for (Int_t i = 0; i < fNpoints; i++) {; 714 printf(""x[%d]=%g, y[%d]=%g, ex[%d]=%g, ey[%d]=%g\n"", i, fX[i], i, fY[i], i, fEX[i], i, fEY[i]);; 715 }; 716}; 717 ; 718 ; 719////////////////////////////////////////////////////////////////////////////////; 720/// Save primitive as a C++ statement(s) on output stream out; 721 ; 722void TGraphErrors::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 723{; 724 out << "" "" << std::endl;; 725 static Int_t frameNumber = 1000;; 726 frameNumber++;; 727 ; 728 auto fXName = SaveArra",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:23950,Availability,error,errors,23950,"ouble_t * ey = g->GetEY();; 699 for (Int_t i = 0 ; i < g->GetN(); i++) {; 700 SetPoint(n0+i, x[i], y[i]);; 701 if (ex) fEX[n0+i] = ex[i];; 702 if (ey) fEY[n0+i] = ey[i];; 703 }; 704 }; 705 return GetN();; 706}; 707 ; 708////////////////////////////////////////////////////////////////////////////////; 709/// Print graph and errors values.; 710 ; 711void TGraphErrors::Print(Option_t *) const; 712{; 713 for (Int_t i = 0; i < fNpoints; i++) {; 714 printf(""x[%d]=%g, y[%d]=%g, ex[%d]=%g, ey[%d]=%g\n"", i, fX[i], i, fY[i], i, fEX[i], i, fEY[i]);; 715 }; 716}; 717 ; 718 ; 719////////////////////////////////////////////////////////////////////////////////; 720/// Save primitive as a C++ statement(s) on output stream out; 721 ; 722void TGraphErrors::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 723{; 724 out << "" "" << std::endl;; 725 static Int_t frameNumber = 1000;; 726 frameNumber++;; 727 ; 728 auto fXName = SaveArray(out, ""fx"", frameNumber, fX);; 729 auto fYName = SaveArray(out, ""fy"", frameNumber, fY);; 730 auto fEXName = SaveArray(out, ""fex"", frameNumber, fEX);; 731 auto fEYName = SaveArray(out, ""fey"", frameNumber, fEY);; 732 ; 733 if (gROOT->ClassSaved(TGraphErrors::Class())); 734 out << "" "";; 735 else; 736 out << "" TGraphErrors *"";; 737 out << ""gre = new TGraphErrors("" << fNpoints << "",""; 738 << fXName << "","" << fYName << "",""; 739 << fEXName << "","" << fEYName << "");""; 740 << std::endl;; 741 ; 742 SaveHistogramAndFunctions(out, ""gre"", frameNumber, option);; 743}; 744 ; 745////////////////////////////////////////////////////////////////////////////////; 746/// Multiply the values and errors of a TGraphErrors by a constant c1.; 747///; 748/// If option contains ""x"" the x values and errors are scaled; 749/// If option contains ""y"" the y values and errors are scaled; 750/// If option contains ""xy"" both x and y values and errors are scaled; 751 ; 752void TGraphErrors::Scale(Double_t c1, Option_t *option); 753{; 754 TGraph::Scale(c1, option);; 755 TString opt = o",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:24049,Availability,error,errors,24049,"d::endl;; 725 static Int_t frameNumber = 1000;; 726 frameNumber++;; 727 ; 728 auto fXName = SaveArray(out, ""fx"", frameNumber, fX);; 729 auto fYName = SaveArray(out, ""fy"", frameNumber, fY);; 730 auto fEXName = SaveArray(out, ""fex"", frameNumber, fEX);; 731 auto fEYName = SaveArray(out, ""fey"", frameNumber, fEY);; 732 ; 733 if (gROOT->ClassSaved(TGraphErrors::Class())); 734 out << "" "";; 735 else; 736 out << "" TGraphErrors *"";; 737 out << ""gre = new TGraphErrors("" << fNpoints << "",""; 738 << fXName << "","" << fYName << "",""; 739 << fEXName << "","" << fEYName << "");""; 740 << std::endl;; 741 ; 742 SaveHistogramAndFunctions(out, ""gre"", frameNumber, option);; 743}; 744 ; 745////////////////////////////////////////////////////////////////////////////////; 746/// Multiply the values and errors of a TGraphErrors by a constant c1.; 747///; 748/// If option contains ""x"" the x values and errors are scaled; 749/// If option contains ""y"" the y values and errors are scaled; 750/// If option contains ""xy"" both x and y values and errors are scaled; 751 ; 752void TGraphErrors::Scale(Double_t c1, Option_t *option); 753{; 754 TGraph::Scale(c1, option);; 755 TString opt = option; opt.ToLower();; 756 if (opt.Contains(""x"") && GetEX()) {; 757 for (Int_t i=0; i<GetN(); i++); 758 GetEX()[i] *= c1;; 759 }; 760 if (opt.Contains(""y"") && GetEY()) {; 761 for (Int_t i=0; i<GetN(); i++); 762 GetEY()[i] *= c1;; 763 }; 764}; 765 ; 766////////////////////////////////////////////////////////////////////////////////; 767/// Set `ex` and `ey` values for point pointed by the mouse.; 768 ; 769void TGraphErrors::SetPointError(Double_t ex, Double_t ey); 770{; 771 if (!gPad) {; 772 Error(""SetPointError"", ""Cannot be used without gPad, requires last mouse position"");; 773 return;; 774 }; 775 ; 776 Int_t px = gPad->GetEventX();; 777 Int_t py = gPad->GetEventY();; 778 ; 779 //localize point to be deleted; 780 Int_t ipoint = -2;; 781 Int_t i;; 782 // start with a small window (in case the mouse is very close to one point",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:24115,Availability,error,errors,24115,"d::endl;; 725 static Int_t frameNumber = 1000;; 726 frameNumber++;; 727 ; 728 auto fXName = SaveArray(out, ""fx"", frameNumber, fX);; 729 auto fYName = SaveArray(out, ""fy"", frameNumber, fY);; 730 auto fEXName = SaveArray(out, ""fex"", frameNumber, fEX);; 731 auto fEYName = SaveArray(out, ""fey"", frameNumber, fEY);; 732 ; 733 if (gROOT->ClassSaved(TGraphErrors::Class())); 734 out << "" "";; 735 else; 736 out << "" TGraphErrors *"";; 737 out << ""gre = new TGraphErrors("" << fNpoints << "",""; 738 << fXName << "","" << fYName << "",""; 739 << fEXName << "","" << fEYName << "");""; 740 << std::endl;; 741 ; 742 SaveHistogramAndFunctions(out, ""gre"", frameNumber, option);; 743}; 744 ; 745////////////////////////////////////////////////////////////////////////////////; 746/// Multiply the values and errors of a TGraphErrors by a constant c1.; 747///; 748/// If option contains ""x"" the x values and errors are scaled; 749/// If option contains ""y"" the y values and errors are scaled; 750/// If option contains ""xy"" both x and y values and errors are scaled; 751 ; 752void TGraphErrors::Scale(Double_t c1, Option_t *option); 753{; 754 TGraph::Scale(c1, option);; 755 TString opt = option; opt.ToLower();; 756 if (opt.Contains(""x"") && GetEX()) {; 757 for (Int_t i=0; i<GetN(); i++); 758 GetEX()[i] *= c1;; 759 }; 760 if (opt.Contains(""y"") && GetEY()) {; 761 for (Int_t i=0; i<GetN(); i++); 762 GetEY()[i] *= c1;; 763 }; 764}; 765 ; 766////////////////////////////////////////////////////////////////////////////////; 767/// Set `ex` and `ey` values for point pointed by the mouse.; 768 ; 769void TGraphErrors::SetPointError(Double_t ex, Double_t ey); 770{; 771 if (!gPad) {; 772 Error(""SetPointError"", ""Cannot be used without gPad, requires last mouse position"");; 773 return;; 774 }; 775 ; 776 Int_t px = gPad->GetEventX();; 777 Int_t py = gPad->GetEventY();; 778 ; 779 //localize point to be deleted; 780 Int_t ipoint = -2;; 781 Int_t i;; 782 // start with a small window (in case the mouse is very close to one point",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:24189,Availability,error,errors,24189,"d::endl;; 725 static Int_t frameNumber = 1000;; 726 frameNumber++;; 727 ; 728 auto fXName = SaveArray(out, ""fx"", frameNumber, fX);; 729 auto fYName = SaveArray(out, ""fy"", frameNumber, fY);; 730 auto fEXName = SaveArray(out, ""fex"", frameNumber, fEX);; 731 auto fEYName = SaveArray(out, ""fey"", frameNumber, fEY);; 732 ; 733 if (gROOT->ClassSaved(TGraphErrors::Class())); 734 out << "" "";; 735 else; 736 out << "" TGraphErrors *"";; 737 out << ""gre = new TGraphErrors("" << fNpoints << "",""; 738 << fXName << "","" << fYName << "",""; 739 << fEXName << "","" << fEYName << "");""; 740 << std::endl;; 741 ; 742 SaveHistogramAndFunctions(out, ""gre"", frameNumber, option);; 743}; 744 ; 745////////////////////////////////////////////////////////////////////////////////; 746/// Multiply the values and errors of a TGraphErrors by a constant c1.; 747///; 748/// If option contains ""x"" the x values and errors are scaled; 749/// If option contains ""y"" the y values and errors are scaled; 750/// If option contains ""xy"" both x and y values and errors are scaled; 751 ; 752void TGraphErrors::Scale(Double_t c1, Option_t *option); 753{; 754 TGraph::Scale(c1, option);; 755 TString opt = option; opt.ToLower();; 756 if (opt.Contains(""x"") && GetEX()) {; 757 for (Int_t i=0; i<GetN(); i++); 758 GetEX()[i] *= c1;; 759 }; 760 if (opt.Contains(""y"") && GetEY()) {; 761 for (Int_t i=0; i<GetN(); i++); 762 GetEY()[i] *= c1;; 763 }; 764}; 765 ; 766////////////////////////////////////////////////////////////////////////////////; 767/// Set `ex` and `ey` values for point pointed by the mouse.; 768 ; 769void TGraphErrors::SetPointError(Double_t ex, Double_t ey); 770{; 771 if (!gPad) {; 772 Error(""SetPointError"", ""Cannot be used without gPad, requires last mouse position"");; 773 return;; 774 }; 775 ; 776 Int_t px = gPad->GetEventX();; 777 Int_t py = gPad->GetEventY();; 778 ; 779 //localize point to be deleted; 780 Int_t ipoint = -2;; 781 Int_t i;; 782 // start with a small window (in case the mouse is very close to one point",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:27808,Availability,error,error,27808," fNpoints; i++) {; 836 fEX[i] = ex[i];; 837 fEY[i] = ey[i];; 838 }; 839 delete [] ey;; 840 delete [] ex;; 841 } else {; 842 b.ReadFastArray(fEX, fNpoints);; 843 b.ReadFastArray(fEY, fNpoints);; 844 }; 845 b.CheckByteCount(R__s, R__c, TGraphErrors::IsA());; 846 //====end of old versions; 847 ; 848 } else {; 849 b.WriteClassBuffer(TGraphErrors::Class(), this);; 850 }; 851}; 852 ; 853////////////////////////////////////////////////////////////////////////////////; 854/// Swap points.; 855 ; 856void TGraphErrors::SwapPoints(Int_t pos1, Int_t pos2); 857{; 858 SwapValues(fEX, pos1, pos2);; 859 SwapValues(fEY, pos1, pos2);; 860 TGraph::SwapPoints(pos1, pos2);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Update the fX, fY, fEX, and fEY arrays with the sorted values.; 865 ; 866void TGraphErrors::UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low); 867{; 868 std::vector<Double_t> fEXSorted(numSortedPoints);; 869 std::vector<Double_t> fEYSorted(numSortedPoints);; 870 ; 871 // Fill the sorted X and Y error values based on the sorted indices; 872 std::generate(fEXSorted.begin(), fEXSorted.end(),; 873 [begin = low, &sorting_indices, this]() mutable { return fEX[sorting_indices[begin++]]; });; 874 std::generate(fEYSorted.begin(), fEYSorted.end(),; 875 [begin = low, &sorting_indices, this]() mutable { return fEY[sorting_indices[begin++]]; });; 876 ; 877 // Copy the sorted X and Y error values back to the original arrays; 878 std::copy(fEXSorted.begin(), fEXSorted.end(), fEX + low);; 879 std::copy(fEYSorted.begin(), fEYSorted.end(), fEY + low);; 880 ; 881 TGraph::UpdateArrays(sorting_indices, numSortedPoints, low);; 882}; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; h#define h(i)Definition RSha256.hxx:106; Version_tshort Version_tDefinition RtypesCore.h:65; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALS",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:28191,Availability,error,error,28191,"/////////////////; 854/// Swap points.; 855 ; 856void TGraphErrors::SwapPoints(Int_t pos1, Int_t pos2); 857{; 858 SwapValues(fEX, pos1, pos2);; 859 SwapValues(fEY, pos1, pos2);; 860 TGraph::SwapPoints(pos1, pos2);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Update the fX, fY, fEX, and fEY arrays with the sorted values.; 865 ; 866void TGraphErrors::UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low); 867{; 868 std::vector<Double_t> fEXSorted(numSortedPoints);; 869 std::vector<Double_t> fEYSorted(numSortedPoints);; 870 ; 871 // Fill the sorted X and Y error values based on the sorted indices; 872 std::generate(fEXSorted.begin(), fEXSorted.end(),; 873 [begin = low, &sorting_indices, this]() mutable { return fEX[sorting_indices[begin++]]; });; 874 std::generate(fEYSorted.begin(), fEYSorted.end(),; 875 [begin = low, &sorting_indices, this]() mutable { return fEY[sorting_indices[begin++]]; });; 876 ; 877 // Copy the sorted X and Y error values back to the original arrays; 878 std::copy(fEXSorted.begin(), fEXSorted.end(), fEX + low);; 879 std::copy(fEYSorted.begin(), fEYSorted.end(), fEY + low);; 880 ; 881 TGraph::UpdateArrays(sorting_indices, numSortedPoints, low);; 882}; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; h#define h(i)Definition RSha256.hxx:106; Version_tshort Version_tDefinition RtypesCore.h:65; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TF1.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineCol",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:32023,Availability,error,error,32023,"ext const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; TGraphErrors.h; TH1.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TVectorD.h; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphErrors.cxx:480; TGraphErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEX, and fEY arrays with the sorted values.Definition TGraphErrors.cxx:866; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraphErrors.h:69; TGraphErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:612; TGraphErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraphErrors.h:30; TGraphErrors::~TGraphErrors~TGraphErrors() overrideTGraphErrors default destructor.Definition",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:32541,Availability,error,error,32541,"x:95; TMath.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TVectorD.h; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphErrors.cxx:480; TGraphErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEX, and fEY arrays with the sorted values.Definition TGraphErrors.cxx:866; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraphErrors.h:69; TGraphErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:612; TGraphErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraphErrors.h:30; TGraphErrors::~TGraphErrors~TGraphErrors() overrideTGraphErrors default destructor.Definition TGraphErrors.cxx:368; TGraphErrors::Classstatic TClass * Class(); TGraphErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphErrors by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraphErrors.Definition TGraphErrors.cxx:81",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:32763,Availability,error,error,32763,"Pad.h; gPad#define gPadDefinition TVirtualPad.h:308; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphErrors.cxx:480; TGraphErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEX, and fEY arrays with the sorted values.Definition TGraphErrors.cxx:866; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraphErrors.h:69; TGraphErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:612; TGraphErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraphErrors.h:30; TGraphErrors::~TGraphErrors~TGraphErrors() overrideTGraphErrors default destructor.Definition TGraphErrors.cxx:368; TGraphErrors::Classstatic TClass * Class(); TGraphErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphErrors by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraphErrors.Definition TGraphErrors.cxx:817; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual vo",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:32874,Availability,error,errorsDefinition,32874,":43; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphErrors.cxx:480; TGraphErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEX, and fEY arrays with the sorted values.Definition TGraphErrors.cxx:866; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraphErrors.h:69; TGraphErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:612; TGraphErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraphErrors.h:30; TGraphErrors::~TGraphErrors~TGraphErrors() overrideTGraphErrors default destructor.Definition TGraphErrors.cxx:368; TGraphErrors::Classstatic TClass * Class(); TGraphErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphErrors by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraphErrors.Definition TGraphErrors.cxx:817; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGr",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:33170,Availability,error,errors,33170,"t &ymax) const overrideCompute range.Definition TGraphErrors.cxx:480; TGraphErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEX, and fEY arrays with the sorted values.Definition TGraphErrors.cxx:866; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraphErrors.h:69; TGraphErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:612; TGraphErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraphErrors.h:30; TGraphErrors::~TGraphErrors~TGraphErrors() overrideTGraphErrors default destructor.Definition TGraphErrors.cxx:368; TGraphErrors::Classstatic TClass * Class(); TGraphErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphErrors by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraphErrors.Definition TGraphErrors.cxx:817; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Dou",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:33821,Availability,error,errorbars,33821,"raphErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraphErrors.h:30; TGraphErrors::~TGraphErrors~TGraphErrors() overrideTGraphErrors default destructor.Definition TGraphErrors.cxx:368; TGraphErrors::Classstatic TClass * Class(); TGraphErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphErrors by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraphErrors.Definition TGraphErrors.cxx:817; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt retu",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:33930,Availability,error,errorsDefinition,33930,"phErrors::~TGraphErrors~TGraphErrors() overrideTGraphErrors default destructor.Definition TGraphErrors.cxx:368; TGraphErrors::Classstatic TClass * Class(); TGraphErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphErrors by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraphErrors.Definition TGraphErrors.cxx:817; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYl",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:34046,Availability,error,errors,34046,"Errors.cxx:368; TGraphErrors::Classstatic TClass * Class(); TGraphErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphErrors by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraphErrors.Definition TGraphErrors.cxx:817; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definit",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:34384,Availability,error,errors,34384,"char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraphErrors.Definition TGraphErrors.cxx:817; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184;",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:34832,Availability,error,error,34832,"_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::IsATClass * IsA() const overrideDefinition TGraphErrors.h:78; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682;",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:34978,Availability,error,error,34978,"tion TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::IsATClass * IsA() const overrideDefinition TGraphErrors.h:78; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition ",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:35126,Availability,error,error,35126,"11; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::IsATClass * IsA() const overrideDefinition TGraphErrors.h:78; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErr",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:35435,Availability,error,errors,35435,"; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::IsATClass * IsA() const overrideDefinition TGraphErrors.h:78; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphErrors.cxx:722; TGraphErrors::Applyvoi",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:35722,Availability,error,errors,35722," points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::IsATClass * IsA() const overrideDefinition TGraphErrors.h:78; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphErrors.cxx:722; TGraphErrors::Applyvoid Apply(TF1 *f) overrideApply function to all the data points .Definition TGraphErrors.cxx:396; TGraphErrors::CtorAllocateBool_t CtorAllocate()Constructor allocate.Definition TGraphErrors.cxx:557; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definiti",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:36157,Availability,error,error,36157," the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::IsATClass * IsA() const overrideDefinition TGraphErrors.h:78; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphErrors.cxx:722; TGraphErrors::Applyvoid Apply(TF1 *f) overrideApply function to all the data points .Definition TGraphErrors.cxx:396; TGraphErrors::CtorAllocateBool_t CtorAllocate()Constructor allocate.Definition TGraphErrors.cxx:557; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Classstatic TClass * Class(); TGraph::AddPointvirtual void AddPoint(Double_t x, Double_t y)Append a new point to the graph.Definition TGraph.h:98; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGraph.h:46; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::fMaxSizeInt_t fMaxSize!C",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:40226,Availability,error,error,40226,"points in the graph Existing coordinates are preserved New coordinates above fNpoints a...Definition TGraph.cxx:2277; TGraph::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) constGet x and y values for point number i.Definition TGraph.cxx:1533; TGraph::CopyPointsvirtual Bool_t CopyPoints(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:779; TGraph::operator=TGraph & operator=(const TGraph &)Equal operator for this graph.Definition TGraph.cxx:232; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TIterDefinition TCollection.h:235; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::AtofDouble_t Atof() constReturn floating-point value contained in string.Definition TString.cxx:2054; TString::IsFloatBool_t IsFloat() constReturns kTRUE if string contains a floating point or integer number.Definition TString.cxx:1858; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::Formatstatic TString Format(const char",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:16528,Deployability,release,release,16528,"*++fmt && ']' == *fmt) ++fmt; // ""%[]a]"" or ""%[^]a]""; 458 while (*fmt && *fmt != ']'); 459 ++fmt;; 460 if (!skip) ++fields;; 461 break;; 462 }; 463 if ('%' == *fmt) break; // %% literal %; 464 if ('*' == *fmt) {; 465 skip = kTRUE; // %*d -- skip a number; 466 } else if (strchr(""dDiouxXxfegEscpn"", *fmt)) {; 467 if (!skip) ++fields;; 468 break;; 469 }; 470 // skip modifiers & field width; 471 }; 472 }; 473 return fields;; 474}; 475 ; 476 ; 477////////////////////////////////////////////////////////////////////////////////; 478/// Compute range.; 479 ; 480void TGraphErrors::ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const; 481{; 482 TGraph::ComputeRange(xmin, ymin, xmax, ymax);; 483 ; 484 for (Int_t i = 0; i < fNpoints; i++) {; 485 if (fX[i] - fEX[i] < xmin) {; 486 if (gPad && gPad->GetLogx()) {; 487 if (fEX[i] < fX[i]) xmin = fX[i] - fEX[i];; 488 else xmin = TMath::Min(xmin, fX[i] / 3);; 489 } else {; 490 xmin = fX[i] - fEX[i];; 491 }; 492 }; 493 if (fX[i] + fEX[i] > xmax) xmax = fX[i] + fEX[i];; 494 if (fY[i] - fEY[i] < ymin) {; 495 if (gPad && gPad->GetLogy()) {; 496 if (fEY[i] < fY[i]) ymin = fY[i] - fEY[i];; 497 else ymin = TMath::Min(ymin, fY[i] / 3);; 498 } else {; 499 ymin = fY[i] - fEY[i];; 500 }; 501 }; 502 if (fY[i] + fEY[i] > ymax) ymax = fY[i] + fEY[i];; 503 }; 504}; 505 ; 506 ; 507////////////////////////////////////////////////////////////////////////////////; 508/// Copy and release.; 509 ; 510void TGraphErrors::CopyAndRelease(Double_t **newarrays,; 511 Int_t ibegin, Int_t iend, Int_t obegin); 512{; 513 CopyPoints(newarrays, ibegin, iend, obegin);; 514 if (newarrays) {; 515 delete[] fX;; 516 fX = newarrays[2];; 517 delete[] fY;; 518 fY = newarrays[3];; 519 delete[] fEX;; 520 fEX = newarrays[0];; 521 delete[] fEY;; 522 fEY = newarrays[1];; 523 delete[] newarrays;; 524 }; 525}; 526 ; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Copy errors from `fEX` and `fEY` to `arrays",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:35923,Deployability,release,release,35923,"finition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::IsATClass * IsA() const overrideDefinition TGraphErrors.h:78; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphErrors.cxx:722; TGraphErrors::Applyvoid Apply(TF1 *f) overrideApply function to all the data points .Definition TGraphErrors.cxx:396; TGraphErrors::CtorAllocateBool_t CtorAllocate()Constructor allocate.Definition TGraphErrors.cxx:557; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Classstatic TClass * Class(); TGraph::AddPointvirtual void AddPoint(Double_t x, Double_t y)Append a new point to the graph.Definition T",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:17836,Energy Efficiency,allocate,allocate,17836,"/; 508/// Copy and release.; 509 ; 510void TGraphErrors::CopyAndRelease(Double_t **newarrays,; 511 Int_t ibegin, Int_t iend, Int_t obegin); 512{; 513 CopyPoints(newarrays, ibegin, iend, obegin);; 514 if (newarrays) {; 515 delete[] fX;; 516 fX = newarrays[2];; 517 delete[] fY;; 518 fY = newarrays[3];; 519 delete[] fEX;; 520 fEX = newarrays[0];; 521 delete[] fEY;; 522 fEY = newarrays[1];; 523 delete[] newarrays;; 524 }; 525}; 526 ; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Copy errors from `fEX` and `fEY` to `arrays[0]` and `arrays[1]`; 530/// or to `fEX` and `fEY` if `arrays == 0` and `ibegin != iend`.; 531 ; 532Bool_t TGraphErrors::CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 533 Int_t obegin); 534{; 535 if (TGraph::CopyPoints(arrays ? arrays + 2 : nullptr, ibegin, iend, obegin)) {; 536 Int_t n = (iend - ibegin) * sizeof(Double_t);; 537 if (arrays) {; 538 memmove(&arrays[0][obegin], &fEX[ibegin], n);; 539 memmove(&arrays[1][obegin], &fEY[ibegin], n);; 540 } else {; 541 memmove(&fEX[obegin], &fEX[ibegin], n);; 542 memmove(&fEY[obegin], &fEY[ibegin], n);; 543 }; 544 return kTRUE;; 545 } else {; 546 return kFALSE;; 547 }; 548}; 549 ; 550 ; 551////////////////////////////////////////////////////////////////////////////////; 552/// Constructor allocate.; 553///; 554/// Note: This function should be called only from the constructor; 555/// since it does not delete previously existing arrays.; 556 ; 557Bool_t TGraphErrors::CtorAllocate(); 558{; 559 ; 560 if (!fNpoints) {; 561 fEX = fEY = nullptr;; 562 return kFALSE;; 563 } else {; 564 fEX = new Double_t[fMaxSize];; 565 fEY = new Double_t[fMaxSize];; 566 }; 567 return kTRUE;; 568}; 569 ; 570////////////////////////////////////////////////////////////////////////////////; 571/// Protected function to perform the merge operation of a graph with errors.; 572 ; 573Bool_t TGraphErrors::DoMerge(const TGraph *g); 574{; 575 if (g->GetN() == 0) return kFALSE;; 576 ;",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:25820,Energy Efficiency,allocate,allocate,25820,"t gPad, requires last mouse position"");; 773 return;; 774 }; 775 ; 776 Int_t px = gPad->GetEventX();; 777 Int_t py = gPad->GetEventY();; 778 ; 779 //localize point to be deleted; 780 Int_t ipoint = -2;; 781 Int_t i;; 782 // start with a small window (in case the mouse is very close to one point); 783 for (i = 0; i < fNpoints; i++) {; 784 Int_t dpx = px - gPad->XtoAbsPixel(gPad->XtoPad(fX[i]));; 785 Int_t dpy = py - gPad->YtoAbsPixel(gPad->YtoPad(fY[i]));; 786 if (dpx * dpx + dpy * dpy < 25) {; 787 ipoint = i;; 788 break;; 789 }; 790 }; 791 if (ipoint == -2) return;; 792 ; 793 fEX[ipoint] = ex;; 794 fEY[ipoint] = ey;; 795 gPad->Modified();; 796}; 797 ; 798 ; 799////////////////////////////////////////////////////////////////////////////////; 800/// Set `ex` and `ey` values for point number i.; 801 ; 802void TGraphErrors::SetPointError(Int_t i, Double_t ex, Double_t ey); 803{; 804 if (i < 0) return;; 805 if (i >= fNpoints) {; 806 // re-allocate the object; 807 TGraphErrors::SetPoint(i, 0, 0);; 808 }; 809 fEX[i] = ex;; 810 fEY[i] = ey;; 811}; 812 ; 813 ; 814////////////////////////////////////////////////////////////////////////////////; 815/// Stream an object of class TGraphErrors.; 816 ; 817void TGraphErrors::Streamer(TBuffer &b); 818{; 819 if (b.IsReading()) {; 820 UInt_t R__s, R__c;; 821 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 822 if (R__v > 2) {; 823 b.ReadClassBuffer(TGraphErrors::Class(), this, R__v, R__s, R__c);; 824 return;; 825 }; 826 //====process old versions before automatic schema evolution; 827 TGraph::Streamer(b);; 828 fEX = new Double_t[fNpoints];; 829 fEY = new Double_t[fNpoints];; 830 if (R__v < 2) {; 831 Float_t *ex = new Float_t[fNpoints];; 832 Float_t *ey = new Float_t[fNpoints];; 833 b.ReadFastArray(ex, fNpoints);; 834 b.ReadFastArray(ey, fNpoints);; 835 for (Int_t i = 0; i < fNpoints; i++) {; 836 fEX[i] = ex[i];; 837 fEY[i] = ey[i];; 838 }; 839 delete [] ey;; 840 delete [] ex;; 841 } else {; 842 b.ReadFastArray(fEX, fNpoints);; 843 b.Read",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:36577,Energy Efficiency,allocate,allocate,36577,"raphErrors.cxx:532; TGraphErrors::IsATClass * IsA() const overrideDefinition TGraphErrors.h:78; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphErrors.cxx:722; TGraphErrors::Applyvoid Apply(TF1 *f) overrideApply function to all the data points .Definition TGraphErrors.cxx:396; TGraphErrors::CtorAllocateBool_t CtorAllocate()Constructor allocate.Definition TGraphErrors.cxx:557; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Classstatic TClass * Class(); TGraph::AddPointvirtual void AddPoint(Double_t x, Double_t y)Append a new point to the graph.Definition TGraph.h:98; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGraph.h:46; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::fMaxSizeInt_t fMaxSize!Current dimension of arrays fX and fYDefinition TGraph.h:45; TGraph::SaveHistogramAndFunctionsvoid SaveHistogramAndFunctions(std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option)Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes.Definition TGraph.cxx:2199; TGraph::fHistogramTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:10355,Integrability,message,message,10355,"4 if (!format_.IsDigit()) {; 285 Error(""TGraphErrors"", ""Incorrect input format! Allowed format tags are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 286 return ;; 287 }; 288 Int_t ntokens = format_.Length() ;; 289 if (ntokens < 2) {; 290 Error(""TGraphErrors"", ""Incorrect input format! Only %d tag(s) in format whereas at least 2 \""%%lg\"" tags are expected!"", ntokens);; 291 return ;; 292 }; 293 Int_t ntokensToBeSaved = 0 ;; 294 Bool_t * isTokenToBeSaved = new Bool_t [ntokens] ;; 295 for (Int_t idx = 0; idx < ntokens; idx++) {; 296 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi() ; //atoi(&format_[idx]) does not work for some reason...; 297 if (isTokenToBeSaved[idx] == 1) {; 298 ntokensToBeSaved++ ;; 299 }; 300 }; 301 if (ntokens >= 2 && (ntokensToBeSaved < 2 || ntokensToBeSaved > 4)) { //first condition not to repeat the previous error message; 302 Error(""TGraphErrors"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2,3 or 4 are expected!"", ntokensToBeSaved);; 303 delete [] isTokenToBeSaved ;; 304 return ;; 305 }; 306 ; 307 // Initializing loop variables; 308 Bool_t isLineToBeSkipped = kFALSE; //empty and ill-formed lines; 309 char *token = nullptr;; 310 TString token_str = """";; 311 Int_t token_idx = 0;; 312 Double_t value[4]; //x,y,ex,ey buffers; 313 for (Int_t k = 0; k < 4; k++); 314 value[k] = 0.;; 315 Int_t value_idx = 0;; 316 ; 317 // Looping; 318 char *rest;; 319 while (std::getline(infile, line, '\n')) {; 320 if (!line.empty()) {; 321 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 322 line.erase(line.end() - 1, line.end()) ;; 323 }; 324 token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, &rest);; 325 while (token != nullptr && value_idx < ntokensToBeSaved) {; 326 if (isTokenToBeSaved[token_idx]) {; 327 token_str = TString(token) ;; 328 token_str.ReplaceAll(""\t"", """") ;; 329 if (!token_str.IsFloat()) {; 330 isLineToBeSkipped = kTRUE ;; 331 break ;; 332 } else {; 333 value[value_idx] = token_str.At",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:40102,Integrability,message,message,40102,"1102; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::Setvirtual void Set(Int_t n)Set number of points in the graph Existing coordinates are preserved New coordinates above fNpoints a...Definition TGraph.cxx:2277; TGraph::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) constGet x and y values for point number i.Definition TGraph.cxx:1533; TGraph::CopyPointsvirtual Bool_t CopyPoints(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:779; TGraph::operator=TGraph & operator=(const TGraph &)Equal operator for this graph.Definition TGraph.cxx:232; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TIterDefinition TCollection.h:235; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::AtofDouble_t Atof() constReturn floating-point value contained in string.Definition TString.cxx:2054; TString::IsFloatBool_t IsFloat() constReturns kTRUE if string contains a floating point or integer number.Definition TString.cxx:1858; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::ReplaceAll",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:40232,Integrability,message,message,40232,"points in the graph Existing coordinates are preserved New coordinates above fNpoints a...Definition TGraph.cxx:2277; TGraph::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) constGet x and y values for point number i.Definition TGraph.cxx:1533; TGraph::CopyPointsvirtual Bool_t CopyPoints(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:779; TGraph::operator=TGraph & operator=(const TGraph &)Equal operator for this graph.Definition TGraph.cxx:232; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TIterDefinition TCollection.h:235; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::AtofDouble_t Atof() constReturn floating-point value contained in string.Definition TString.cxx:2054; TString::IsFloatBool_t IsFloat() constReturns kTRUE if string contains a floating point or integer number.Definition TString.cxx:1858; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::Formatstatic TString Format(const char",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:10593,Modifiability,variab,variables,10593,"4 if (!format_.IsDigit()) {; 285 Error(""TGraphErrors"", ""Incorrect input format! Allowed format tags are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 286 return ;; 287 }; 288 Int_t ntokens = format_.Length() ;; 289 if (ntokens < 2) {; 290 Error(""TGraphErrors"", ""Incorrect input format! Only %d tag(s) in format whereas at least 2 \""%%lg\"" tags are expected!"", ntokens);; 291 return ;; 292 }; 293 Int_t ntokensToBeSaved = 0 ;; 294 Bool_t * isTokenToBeSaved = new Bool_t [ntokens] ;; 295 for (Int_t idx = 0; idx < ntokens; idx++) {; 296 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi() ; //atoi(&format_[idx]) does not work for some reason...; 297 if (isTokenToBeSaved[idx] == 1) {; 298 ntokensToBeSaved++ ;; 299 }; 300 }; 301 if (ntokens >= 2 && (ntokensToBeSaved < 2 || ntokensToBeSaved > 4)) { //first condition not to repeat the previous error message; 302 Error(""TGraphErrors"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2,3 or 4 are expected!"", ntokensToBeSaved);; 303 delete [] isTokenToBeSaved ;; 304 return ;; 305 }; 306 ; 307 // Initializing loop variables; 308 Bool_t isLineToBeSkipped = kFALSE; //empty and ill-formed lines; 309 char *token = nullptr;; 310 TString token_str = """";; 311 Int_t token_idx = 0;; 312 Double_t value[4]; //x,y,ex,ey buffers; 313 for (Int_t k = 0; k < 4; k++); 314 value[k] = 0.;; 315 Int_t value_idx = 0;; 316 ; 317 // Looping; 318 char *rest;; 319 while (std::getline(infile, line, '\n')) {; 320 if (!line.empty()) {; 321 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 322 line.erase(line.end() - 1, line.end()) ;; 323 }; 324 token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, &rest);; 325 while (token != nullptr && value_idx < ntokensToBeSaved) {; 326 if (isTokenToBeSaved[token_idx]) {; 327 token_str = TString(token) ;; 328 token_str.ReplaceAll(""\t"", """") ;; 329 if (!token_str.IsFloat()) {; 330 isLineToBeSkipped = kTRUE ;; 331 break ;; 332 } else {; 333 value[value_idx] = token_str.At",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:22102,Modifiability,inherit,inherit,22102,"///////////////////////////////////////////////////////////////////////////; 668/// It returns the error along Y at point `i`. For TGraphErrors this method is; 669/// the same as GetErrorY.; 670 ; 671Double_t TGraphErrors::GetErrorYlow(Int_t i) const; 672{; 673 if (i < 0 || i >= fNpoints) return -1;; 674 if (fEY) return fEY[i];; 675 return -1;; 676}; 677 ; 678////////////////////////////////////////////////////////////////////////////////; 679/// Adds all graphs with errors from the collection to this graph.; 680/// Returns the total number of points in the result or -1 in case of an error.; 681 ; 682Int_t TGraphErrors::Merge(TCollection* li); 683{; 684 TIter next(li);; 685 while (TObject* o = next()) {; 686 TGraph *g = dynamic_cast<TGraph*>(o);; 687 if (!g) {; 688 Error(""Merge"",; 689 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 690 return -1;; 691 }; 692 int n0 = GetN();; 693 int n1 = n0+g->GetN();; 694 Set(n1);; 695 Double_t * x = g->GetX();; 696 Double_t * y = g->GetY();; 697 Double_t * ex = g->GetEX();; 698 Double_t * ey = g->GetEY();; 699 for (Int_t i = 0 ; i < g->GetN(); i++) {; 700 SetPoint(n0+i, x[i], y[i]);; 701 if (ex) fEX[n0+i] = ex[i];; 702 if (ey) fEY[n0+i] = ey[i];; 703 }; 704 }; 705 return GetN();; 706}; 707 ; 708////////////////////////////////////////////////////////////////////////////////; 709/// Print graph and errors values.; 710 ; 711void TGraphErrors::Print(Option_t *) const; 712{; 713 for (Int_t i = 0; i < fNpoints; i++) {; 714 printf(""x[%d]=%g, y[%d]=%g, ex[%d]=%g, ey[%d]=%g\n"", i, fX[i], i, fY[i], i, fEX[i], i, fEY[i]);; 715 }; 716}; 717 ; 718 ; 719////////////////////////////////////////////////////////////////////////////////; 720/// Save primitive as a C++ statement(s) on output stream out; 721 ; 722void TGraphErrors::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 723{; 724 out << "" "" << std::endl;; 725 static Int_t frameNumber = 1000;; 726 frameNumber++;; 727 ; 728 auto fXName = SaveArra",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:1245,Performance,perform,performed,1245,"4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#include ""TROOT.h""; 14#include ""TBuffer.h""; 15#include ""TGraphErrors.h""; 16#include ""TStyle.h""; 17#include ""TMath.h""; 18#include ""TVirtualPad.h""; 19#include ""TH1.h""; 20#include ""TF1.h""; 21#include ""TVectorD.h""; 22#include ""TSystem.h""; 23#include ""strtok.h""; 24 ; 25#include <iostream>; 26#include <fstream>; 27#include <cstring>; 28#include <string>; 29 ; 30ClassImp(TGraphErrors);; 31 ; 32 ; 33////////////////////////////////////////////////////////////////////////////////; 34 ; 35/** \class TGraphErrors; 36 \ingroup Graphs; 37A TGraphErrors is a TGraph with error bars.; 38 ; 39The TGraphErrors painting is performed thanks to the TGraphPainter; 40class. All details about the various painting options are given in this class.; 41 ; 42The picture below gives an example:; 43 ; 44Begin_Macro(source); 45{; 46 auto c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; 47 c1->SetFillColor(42);; 48 c1->SetGrid();; 49 c1->GetFrame()->SetFillColor(21);; 50 c1->GetFrame()->SetBorderSize(12);; 51 const Int_t n = 10;; 52 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 53 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 54 Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 55 Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 56 auto gr = new TGraphErrors(n,x,y,ex,ey);; 57 gr->SetTitle(""TGraphErrors Example"");; 58 gr->SetMarkerColor(4);; 59 gr->SetMarkerStyle(21);; 60 gr->Draw(""ALP"");; 61}; 62End_Macro; 63*/; 64 ; 65 ; 66////////////////////////////////////////////////////////////////////////////////; 67/// TGraphErrors default constructor.; 68 ; 69",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:18349,Performance,perform,perform,18349,"GraphErrors::CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 533 Int_t obegin); 534{; 535 if (TGraph::CopyPoints(arrays ? arrays + 2 : nullptr, ibegin, iend, obegin)) {; 536 Int_t n = (iend - ibegin) * sizeof(Double_t);; 537 if (arrays) {; 538 memmove(&arrays[0][obegin], &fEX[ibegin], n);; 539 memmove(&arrays[1][obegin], &fEY[ibegin], n);; 540 } else {; 541 memmove(&fEX[obegin], &fEX[ibegin], n);; 542 memmove(&fEY[obegin], &fEY[ibegin], n);; 543 }; 544 return kTRUE;; 545 } else {; 546 return kFALSE;; 547 }; 548}; 549 ; 550 ; 551////////////////////////////////////////////////////////////////////////////////; 552/// Constructor allocate.; 553///; 554/// Note: This function should be called only from the constructor; 555/// since it does not delete previously existing arrays.; 556 ; 557Bool_t TGraphErrors::CtorAllocate(); 558{; 559 ; 560 if (!fNpoints) {; 561 fEX = fEY = nullptr;; 562 return kFALSE;; 563 } else {; 564 fEX = new Double_t[fMaxSize];; 565 fEY = new Double_t[fMaxSize];; 566 }; 567 return kTRUE;; 568}; 569 ; 570////////////////////////////////////////////////////////////////////////////////; 571/// Protected function to perform the merge operation of a graph with errors.; 572 ; 573Bool_t TGraphErrors::DoMerge(const TGraph *g); 574{; 575 if (g->GetN() == 0) return kFALSE;; 576 ; 577 Double_t * ex = g->GetEX();; 578 Double_t * ey = g->GetEY();; 579 if (ex == nullptr || ey == nullptr) {; 580 if (g->IsA() != TGraph::Class() ); 581 Warning(""DoMerge"",""Merging a %s is not compatible with a TGraphErrors - errors will be ignored"",g->IsA()->GetName());; 582 return TGraph::DoMerge(g);; 583 }; 584 for (Int_t i = 0 ; i < g->GetN(); i++) {; 585 Int_t ipoint = GetN();; 586 Double_t x = g->GetX()[i];; 587 Double_t y = g->GetY()[i];; 588 SetPoint(ipoint, x, y);; 589 SetPointError( ipoint, ex[i], ey[i] );; 590 }; 591 return kTRUE;; 592}; 593 ; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Set zero values for point ",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:34340,Performance,perform,perform,34340,"char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraphErrors.Definition TGraphErrors.cxx:817; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184;",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:38716,Performance,perform,perform,38716,"ys with the sorted values.Definition TGraph.cxx:2592; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::fYDouble_t * fY[fNpoints] array of Y pointsDefinition TGraph.h:48; TGraph::SaveArrayTString SaveArray(std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr)Save array as C++ code Returns name of created array.Definition TGraph.cxx:2175; TGraph::ComputeRangevirtual void ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) constCompute the x/y range of the points in this graph.Definition TGraph.cxx:731; TGraph::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""y"")Multiply the values of a TGraph by a constant c1.Definition TGraph.cxx:2259; TGraph::SwapValuesstatic void SwapValues(Double_t *arr, Int_t pos1, Int_t pos2)Swap values.Definition TGraph.cxx:2611; TGraph::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraph.Definition TGraph.cxx:2516; TGraph::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::SwapPointsvirtual void SwapPoints(Int_t pos1, Int_t pos2)Swap points.Definition TGraph.cxx:2583; TGraph::FillZerovirtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE)Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes.Definition TGraph.cxx:1102; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::Setvirtual void Set(Int_t n)Set number of points in the graph Existing coordinates are preserved New coordinates above fNpoints a...Definition TGraph.cxx:2277; TGraph::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) constGet x and y values for point number i.Definition TGraph.cxx:1533; TGraph::CopyPointsvirtual Bool_t CopyPoints(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definit",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8cxx_source.html:7502,Safety,avoid,avoid,7502," from the TH1 object passed as argument; 203 ; 204TGraphErrors::TGraphErrors(const TH1 *h); 205 : TGraph(h); 206{; 207 if (!CtorAllocate()) return;; 208 ; 209 for (Int_t i = 0; i < fNpoints; i++) {; 210 fEX[i] = h->GetBinWidth(i + 1) * gStyle->GetErrorX();; 211 fEY[i] = h->GetBinError(i + 1);; 212 }; 213}; 214 ; 215 ; 216////////////////////////////////////////////////////////////////////////////////; 217/// GraphErrors constructor reading input from `filename`.; 218///; 219/// `filename` is assumed to contain at least 2 columns of numbers; 220///; 221/// Convention for format (default=`""%lg %lg %lg %lg""`); 222///; 223/// - format = `%lg %lg` read only 2 first columns into X,Y; 224/// - format = `%lg %lg %lg` read only 3 first columns into X,Y and EY; 225/// - format = `%lg %lg %lg %lg` read only 4 first columns into X,Y,EX,EY.; 226///; 227/// For files separated by a specific delimiter different from ' ' and `\\t` (e.g. `;` in csv files); 228/// you can avoid using `%*s` to bypass this delimiter by explicitly specify the `option` argument,; 229/// e.g. `option="" \\t,;""` for columns of figures separated by any of these characters (`' ', '\\t', ',', ';'`); 230/// used once (e.g. `""1;1""`) or in a combined way (`"" 1;,;; 1""`).; 231///; 232/// Note in that case, the instantiation is about 2 times slower.; 233/// In case a delimiter is specified, the format `""%lg %lg %lg""` will read X,Y,EX.; 234 ; 235TGraphErrors::TGraphErrors(const char *filename, const char *format, Option_t *option); 236 : TGraph(100); 237{; 238 if (!CtorAllocate()) return;; 239 Double_t x, y, ex, ey;; 240 TString fname = filename;; 241 gSystem->ExpandPathName(fname);; 242 std::ifstream infile(fname.Data());; 243 if (!infile.good()) {; 244 MakeZombie();; 245 Error(""TGraphErrors"", ""Cannot open file: %s, TGraphErrors is Zombie"", filename);; 246 fNpoints = 0;; 247 return;; 248 }; 249 std::string line;; 250 Int_t np = 0;; 251 ; 252 if (strcmp(option, """") == 0) { // No delimiters specified (standard construc",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
https://root.cern/doc/master/TGraphErrors_8h.html:547,Availability,error,error,547,". ROOT: hist/hist/inc/TGraphErrors.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TGraphErrors.h File Reference. #include ""TGraph.h"". Include dependency graph for TGraphErrors.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGraphErrors;  A TGraphErrors is a TGraph with error bars. More...;  . histhistincTGraphErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphErrors_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h.html
https://root.cern/doc/master/TGraphErrors_8h.html:204,Integrability,depend,dependency,204,". ROOT: hist/hist/inc/TGraphErrors.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TGraphErrors.h File Reference. #include ""TGraph.h"". Include dependency graph for TGraphErrors.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGraphErrors;  A TGraphErrors is a TGraph with error bars. More...;  . histhistincTGraphErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphErrors_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:826,Availability,error,error,826,". ROOT: hist/hist/inc/TGraphErrors.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphErrors.h. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Rene Brun 15/09/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGraphErrors; 13#define ROOT_TGraphErrors; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TGraphErrors //; 19// //; 20// a Graph with error bars //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TGraph.h""; 25 ; 26class TGraphErrors : public TGraph {; 27 ; 28protected:; 29 Double_t *fEX{nullptr}; ///<[fNpoints] array of X errors; 30 Double_t *fEY{nullptr}; ///<[fNpoints] array of Y errors; 31 ; 32 void SwapPoints(Int_t pos1, Int_t pos2) override;; 33 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 34 ; 35 Double_t** Allocate(Int_t size) override;; 36 void CopyAndRelease(Double_t **newarrays,; 37 Int_t ibegin, Int_t iend, Int_t obegin) override;; 38 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 39 Int_t obegin) override;; 40 Bool_t CtorAllocate();; 41 void FillZero(Int_t begin, Int_t end,; 42 Bool_t from_ctor = kTRUE) override;; 43 Bool_t DoMerge(const TGraph * g) override;; 44 ; 45 ; 46public:; 47 TGraphErrors();; 48 TGraphErrors(Int_t n);; 49 TGraphErrors(Int_t n, const Float_t *x, const Float_t *y, const Float_t *ex = nullptr, const Float_t *ey = nullptr);; 50 TGraphErrors(Int_t n, const Double_t *x, const Double_t *y, const Double_t *ex = nullptr, const D",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:1073,Availability,error,errors,1073,"//////////////; 17// //; 18// TGraphErrors //; 19// //; 20// a Graph with error bars //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TGraph.h""; 25 ; 26class TGraphErrors : public TGraph {; 27 ; 28protected:; 29 Double_t *fEX{nullptr}; ///<[fNpoints] array of X errors; 30 Double_t *fEY{nullptr}; ///<[fNpoints] array of Y errors; 31 ; 32 void SwapPoints(Int_t pos1, Int_t pos2) override;; 33 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 34 ; 35 Double_t** Allocate(Int_t size) override;; 36 void CopyAndRelease(Double_t **newarrays,; 37 Int_t ibegin, Int_t iend, Int_t obegin) override;; 38 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 39 Int_t obegin) override;; 40 Bool_t CtorAllocate();; 41 void FillZero(Int_t begin, Int_t end,; 42 Bool_t from_ctor = kTRUE) override;; 43 Bool_t DoMerge(const TGraph * g) override;; 44 ; 45 ; 46public:; 47 TGraphErrors();; 48 TGraphErrors(Int_t n);; 49 TGraphErrors(Int_t n, const Float_t *x, const Float_t *y, const Float_t *ex = nullptr, const Float_t *ey = nullptr);; 50 TGraphErrors(Int_t n, const Double_t *x, const Double_t *y, const Double_t *ex = nullptr, const Double_t *ey = nullptr);; 51 TGraphErrors(const TVectorF &vx, const TVectorF &vy, const TVectorF &vex, const TVectorF &vey);; 52 TGraphErrors(const TVectorD &vx, const TVectorD &vy, const TVectorD &vex, const TVectorD &vey);; 53 TGraphErrors(const TGraphErrors &gr);; 54 TGraphErrors& operator=(const TGraphErrors &gr);; 55 TGraphErrors(const TH1 *h);; 56 TGraphErrors(const char *filename, const char *format=""%lg %lg %lg %lg"", Option_t *option="""");; 57 ~TGraphErrors() override;; 58 virtual void AddPointError(Double_t x, Double_t y, Double_t ex = 0., Double_t ey = 0.);; 59 void Apply(TF1 *f) override;; 60 virtual void ApplyX(TF1 *f);; 61 static Int_t CalculateScanfFields(const char *fmt);; 62 void ComputeRange(Double_t &xmin, Double_t &ymin, Dou",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:1134,Availability,error,errors,1134,"//////////////; 17// //; 18// TGraphErrors //; 19// //; 20// a Graph with error bars //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TGraph.h""; 25 ; 26class TGraphErrors : public TGraph {; 27 ; 28protected:; 29 Double_t *fEX{nullptr}; ///<[fNpoints] array of X errors; 30 Double_t *fEY{nullptr}; ///<[fNpoints] array of Y errors; 31 ; 32 void SwapPoints(Int_t pos1, Int_t pos2) override;; 33 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 34 ; 35 Double_t** Allocate(Int_t size) override;; 36 void CopyAndRelease(Double_t **newarrays,; 37 Int_t ibegin, Int_t iend, Int_t obegin) override;; 38 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 39 Int_t obegin) override;; 40 Bool_t CtorAllocate();; 41 void FillZero(Int_t begin, Int_t end,; 42 Bool_t from_ctor = kTRUE) override;; 43 Bool_t DoMerge(const TGraph * g) override;; 44 ; 45 ; 46public:; 47 TGraphErrors();; 48 TGraphErrors(Int_t n);; 49 TGraphErrors(Int_t n, const Float_t *x, const Float_t *y, const Float_t *ex = nullptr, const Float_t *ey = nullptr);; 50 TGraphErrors(Int_t n, const Double_t *x, const Double_t *y, const Double_t *ex = nullptr, const Double_t *ey = nullptr);; 51 TGraphErrors(const TVectorF &vx, const TVectorF &vy, const TVectorF &vex, const TVectorF &vey);; 52 TGraphErrors(const TVectorD &vx, const TVectorD &vy, const TVectorD &vex, const TVectorD &vey);; 53 TGraphErrors(const TGraphErrors &gr);; 54 TGraphErrors& operator=(const TGraphErrors &gr);; 55 TGraphErrors(const TH1 *h);; 56 TGraphErrors(const char *filename, const char *format=""%lg %lg %lg %lg"", Option_t *option="""");; 57 ~TGraphErrors() override;; 58 virtual void AddPointError(Double_t x, Double_t y, Double_t ex = 0., Double_t ey = 0.);; 59 void Apply(TF1 *f) override;; 60 virtual void ApplyX(TF1 *f);; 61 static Int_t CalculateScanfFields(const char *fmt);; 62 void ComputeRange(Double_t &xmin, Double_t &ymin, Dou",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:3648,Availability,error,error,3648,"al void ApplyX(TF1 *f);; 61 static Int_t CalculateScanfFields(const char *fmt);; 62 void ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const override;; 63 Double_t GetErrorX(Int_t bin) const override;; 64 Double_t GetErrorY(Int_t bin) const override;; 65 Double_t GetErrorXhigh(Int_t bin) const override;; 66 Double_t GetErrorXlow(Int_t bin) const override;; 67 Double_t GetErrorYhigh(Int_t bin) const override;; 68 Double_t GetErrorYlow(Int_t bin) const override;; 69 Double_t *GetEX() const override {return fEX;}; 70 Double_t *GetEY() const override {return fEY;}; 71 Int_t Merge(TCollection* list) override;; 72 void Print(Option_t *chopt="""") const override;; 73 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 74 void Scale(Double_t c1=1., Option_t *option=""y"") override; // *MENU*; 75 virtual void SetPointError(Double_t ex, Double_t ey); // *MENU; 76 virtual void SetPointError(Int_t i, Double_t ex, Double_t ey);; 77 ; 78 ClassDefOverride(TGraphErrors,3) //A graph with error bars; 79};; 80 ; 81inline Double_t **TGraphErrors::Allocate(Int_t size) {; 82 return AllocateArrays(4, size);; 83}; 84 ; 85#endif; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; h#define h(i)Definition RSha256.hxx:106; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t ",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:6269,Availability,error,error,6269,"id char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; TGraph.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphErrors.cxx:480; TGraphErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEX, and fEY arrays with the sorted values.Definition TGraphErrors.cxx:866; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraphErrors.h:69; TGraphErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:612; TGraphErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraphErrors.h:30; TGraphErrors::~TGraphErrors~TGraphErrors() overrideTGraphErrors default destructor.Definition",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:6787,Availability,error,error,6787,"r char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; TGraph.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphErrors.cxx:480; TGraphErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEX, and fEY arrays with the sorted values.Definition TGraphErrors.cxx:866; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraphErrors.h:69; TGraphErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:612; TGraphErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraphErrors.h:30; TGraphErrors::~TGraphErrors~TGraphErrors() overrideTGraphErrors default destructor.Definition TGraphErrors.cxx:368; TGraphErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphErrors by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraph",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:7009,Availability,error,error,7009,"yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphErrors.cxx:480; TGraphErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEX, and fEY arrays with the sorted values.Definition TGraphErrors.cxx:866; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraphErrors.h:69; TGraphErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:612; TGraphErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraphErrors.h:30; TGraphErrors::~TGraphErrors~TGraphErrors() overrideTGraphErrors default destructor.Definition TGraphErrors.cxx:368; TGraphErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphErrors by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t ",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:7120,Availability,error,errorsDefinition,7120,":95; TCollectionCollection abstract base class.Definition TCollection.h:65; TF11-Dim function classDefinition TF1.h:233; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphErrors.cxx:480; TGraphErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEX, and fEY arrays with the sorted values.Definition TGraphErrors.cxx:866; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraphErrors.h:69; TGraphErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:612; TGraphErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraphErrors.h:30; TGraphErrors::~TGraphErrors~TGraphErrors() overrideTGraphErrors default destructor.Definition TGraphErrors.cxx:368; TGraphErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphErrors by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overrid",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:7372,Availability,error,errors,7372,"min, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphErrors.cxx:480; TGraphErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEX, and fEY arrays with the sorted values.Definition TGraphErrors.cxx:866; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraphErrors.h:69; TGraphErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:612; TGraphErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraphErrors.h:30; TGraphErrors::~TGraphErrors~TGraphErrors() overrideTGraphErrors default destructor.Definition TGraphErrors.cxx:368; TGraphErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphErrors by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMer",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:7896,Availability,error,errorbars,7896,"efinition TGraphErrors.h:69; TGraphErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:612; TGraphErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraphErrors.h:30; TGraphErrors::~TGraphErrors~TGraphErrors() overrideTGraphErrors default destructor.Definition TGraphErrors.cxx:368; TGraphErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphErrors by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphErrors.h:81; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply fu",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:8005,Availability,error,errorsDefinition,8005,"rrideIt returns the error along X at point i.Definition TGraphErrors.cxx:612; TGraphErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraphErrors.h:30; TGraphErrors::~TGraphErrors~TGraphErrors() overrideTGraphErrors default destructor.Definition TGraphErrors.cxx:368; TGraphErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphErrors by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphErrors.h:81; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhig",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:8121,Availability,error,errors,8121,"ouble_t * fEY[fNpoints] array of Y errorsDefinition TGraphErrors.h:30; TGraphErrors::~TGraphErrors~TGraphErrors() overrideTGraphErrors default destructor.Definition TGraphErrors.cxx:368; TGraphErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphErrors by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphErrors.h:81; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definit",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:8459,Availability,error,errors,8459,"rs by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphErrors.h:81; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:9053,Availability,error,error,9053,"ition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphErrors.h:81; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:9199,Availability,error,error,9199,"711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphErrors.h:81; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors d",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:9347,Availability,error,error,9347,"TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphErrors.h:81; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error al",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:9656,Availability,error,errors,9656,"eAllocate internal data structures for newsize points.Definition TGraphErrors.h:81; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphErrors.cxx:722; TGraphErrors::Applyvoid Apply(TF1 *f) overrideApply function to all the data points .Definition TG",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:9867,Availability,error,errors,9867," TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphErrors.cxx:722; TGraphErrors::Applyvoid Apply(TF1 *f) overrideApply function to all the data points .Definition TGraphErrors.cxx:396; TGraphErrors::CtorAllocateBool_t CtorAllocate()Constructor allocate.Definition TGraphErrors.cxx:557; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definit",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:10302,Availability,error,error,10302,"ors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphErrors.cxx:722; TGraphErrors::Applyvoid Apply(TF1 *f) overrideApply function to all the data points .Definition TGraphErrors.cxx:396; TGraphErrors::CtorAllocateBool_t CtorAllocate()Constructor allocate.Definition TGraphErrors.cxx:557; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TVectorTTVectorT.Definition TVectorT.h:27; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:10068,Deployability,release,release,10068,"rorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphErrors.cxx:722; TGraphErrors::Applyvoid Apply(TF1 *f) overrideApply function to all the data points .Definition TGraphErrors.cxx:396; TGraphErrors::CtorAllocateBool_t CtorAllocate()Constructor allocate.Definition TGraphErrors.cxx:557; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; TH1TH1 is the base c",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:10722,Energy Efficiency,allocate,allocate,10722,"ors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphErrors.cxx:722; TGraphErrors::Applyvoid Apply(TF1 *f) overrideApply function to all the data points .Definition TGraphErrors.cxx:396; TGraphErrors::CtorAllocateBool_t CtorAllocate()Constructor allocate.Definition TGraphErrors.cxx:557; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TVectorTTVectorT.Definition TVectorT.h:27; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; exDouble_t ex[n]Definition legend1.C:17. histhistincTGraphErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphErrors_8h_source.html:8415,Performance,perform,perform,8415,"rs by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphErrors.h:81; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:1076,Availability,error,error,1076,"ors.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphMultiErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Simon Spies 18/02/19; 3 ; 4/*************************************************************************; 5 * Copyright (C) 2018-2019, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TStyle.h""; 14#include ""TVirtualPad.h""; 15#include ""TEfficiency.h""; 16#include ""Riostream.h""; 17 ; 18#include ""TArrayD.h""; 19#include ""TVector.h""; 20#include ""TH1.h""; 21#include ""TF1.h""; 22#include ""TMath.h""; 23#include ""Math/QuantFuncMathCore.h""; 24 ; 25#include ""TGraphMultiErrors.h""; 26 ; 27ClassImp(TGraphMultiErrors); 28 ; 29/** \class TGraphMultiErrors; 30 \ingroup Graphs; 31TGraph with asymmetric error bars and multiple y error dimensions.; 32 ; 33The TGraphMultiErrors painting is performed thanks to the TGraphPainter; 34class. All details about the various painting options are given in this class.; 35 ; 36The picture below gives an example:; 37 ; 38Begin_Macro(source); 39{; 40 auto c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; 41 c1->SetGrid();; 42 c1->GetFrame()->SetBorderSize(12);; 43 const Int_t np = 5;; 44 Double_t x[np] = {0, 1, 2, 3, 4};; 45 Double_t y[np] = {0, 2, 4, 1, 3};; 46 Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; 47 Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; 48 Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; 49 Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 2};; 50 Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; 51 Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; 52 auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; 53 gme->AddY",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:1102,Availability,error,error,1102,"ors.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphMultiErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Simon Spies 18/02/19; 3 ; 4/*************************************************************************; 5 * Copyright (C) 2018-2019, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TStyle.h""; 14#include ""TVirtualPad.h""; 15#include ""TEfficiency.h""; 16#include ""Riostream.h""; 17 ; 18#include ""TArrayD.h""; 19#include ""TVector.h""; 20#include ""TH1.h""; 21#include ""TF1.h""; 22#include ""TMath.h""; 23#include ""Math/QuantFuncMathCore.h""; 24 ; 25#include ""TGraphMultiErrors.h""; 26 ; 27ClassImp(TGraphMultiErrors); 28 ; 29/** \class TGraphMultiErrors; 30 \ingroup Graphs; 31TGraph with asymmetric error bars and multiple y error dimensions.; 32 ; 33The TGraphMultiErrors painting is performed thanks to the TGraphPainter; 34class. All details about the various painting options are given in this class.; 35 ; 36The picture below gives an example:; 37 ; 38Begin_Macro(source); 39{; 40 auto c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; 41 c1->SetGrid();; 42 c1->GetFrame()->SetBorderSize(12);; 43 const Int_t np = 5;; 44 Double_t x[np] = {0, 1, 2, 3, 4};; 45 Double_t y[np] = {0, 2, 4, 1, 3};; 46 Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; 47 Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; 48 Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; 49 Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 2};; 50 Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; 51 Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; 52 auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; 53 gme->AddY",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:1423,Availability,error,errors,1423,"terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TStyle.h""; 14#include ""TVirtualPad.h""; 15#include ""TEfficiency.h""; 16#include ""Riostream.h""; 17 ; 18#include ""TArrayD.h""; 19#include ""TVector.h""; 20#include ""TH1.h""; 21#include ""TF1.h""; 22#include ""TMath.h""; 23#include ""Math/QuantFuncMathCore.h""; 24 ; 25#include ""TGraphMultiErrors.h""; 26 ; 27ClassImp(TGraphMultiErrors); 28 ; 29/** \class TGraphMultiErrors; 30 \ingroup Graphs; 31TGraph with asymmetric error bars and multiple y error dimensions.; 32 ; 33The TGraphMultiErrors painting is performed thanks to the TGraphPainter; 34class. All details about the various painting options are given in this class.; 35 ; 36The picture below gives an example:; 37 ; 38Begin_Macro(source); 39{; 40 auto c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; 41 c1->SetGrid();; 42 c1->GetFrame()->SetBorderSize(12);; 43 const Int_t np = 5;; 44 Double_t x[np] = {0, 1, 2, 3, 4};; 45 Double_t y[np] = {0, 2, 4, 1, 3};; 46 Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; 47 Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; 48 Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; 49 Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 2};; 50 Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; 51 Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; 52 auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; 53 gme->AddYError(np, eylsys, eyhsys);; 54 gme->SetMarkerStyle(20);; 55 gme->SetLineColor(kRed);; 56 gme->GetAttLine(0)->SetLineColor(kRed);; 57 gme->GetAttLine(1)->SetLineColor(kBlue);; 58 gme->GetAttFill(1)->SetFillStyle(0);; 59 gme->Draw(""APS ; Z ; 5 s=0.5"");; 60}; 61End_Macro; 62*/; 63////////////////////////////////////////////////////////////////////////////////; 64/// TGraphMultiErrors default constructor.; 65 ; 66TGraphMul",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:3056,Availability,error,errors,3056,"0.8};; 52 auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; 53 gme->AddYError(np, eylsys, eyhsys);; 54 gme->SetMarkerStyle(20);; 55 gme->SetLineColor(kRed);; 56 gme->GetAttLine(0)->SetLineColor(kRed);; 57 gme->GetAttLine(1)->SetLineColor(kBlue);; 58 gme->GetAttFill(1)->SetFillStyle(0);; 59 gme->Draw(""APS ; Z ; 5 s=0.5"");; 60}; 61End_Macro; 62*/; 63////////////////////////////////////////////////////////////////////////////////; 64/// TGraphMultiErrors default constructor.; 65 ; 66TGraphMultiErrors::TGraphMultiErrors(); 67 : fNYErrors(0), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst), fExL(nullptr), fExH(nullptr); 68{; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// TGraphMultiErrors default constructor with name and title.; 73 ; 74TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title) : TGraphMultiErrors(); 75{; 76 SetNameTitle(name, title);; 77}; 78 ; 79////////////////////////////////////////////////////////////////////////////////; 80/// TGraphMultiErrors normal constructor with np points and ne y-errors.; 81///; 82/// All values are initialized to 0.; 83 ; 84TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne); 85 : TGraph(np), fNYErrors(ne), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst); 86{; 87 CtorAllocate();; 88}; 89 ; 90////////////////////////////////////////////////////////////////////////////////; 91/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 92///; 93/// All values are initialized to 0.; 94 ; 95TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne); 96 : TGraphMultiErrors(np, ne); 97{; 98 SetNameTitle(name, title);; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////////; 102/// TGraphMultiErrors normal constructor with `np` points and a single y-error.; 103///; 104/// The signature of t",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:3463,Availability,error,errors,3463,"0}; 61End_Macro; 62*/; 63////////////////////////////////////////////////////////////////////////////////; 64/// TGraphMultiErrors default constructor.; 65 ; 66TGraphMultiErrors::TGraphMultiErrors(); 67 : fNYErrors(0), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst), fExL(nullptr), fExH(nullptr); 68{; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// TGraphMultiErrors default constructor with name and title.; 73 ; 74TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title) : TGraphMultiErrors(); 75{; 76 SetNameTitle(name, title);; 77}; 78 ; 79////////////////////////////////////////////////////////////////////////////////; 80/// TGraphMultiErrors normal constructor with np points and ne y-errors.; 81///; 82/// All values are initialized to 0.; 83 ; 84TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne); 85 : TGraph(np), fNYErrors(ne), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst); 86{; 87 CtorAllocate();; 88}; 89 ; 90////////////////////////////////////////////////////////////////////////////////; 91/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 92///; 93/// All values are initialized to 0.; 94 ; 95TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne); 96 : TGraphMultiErrors(np, ne); 97{; 98 SetNameTitle(name, title);; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////////; 102/// TGraphMultiErrors normal constructor with `np` points and a single y-error.; 103///; 104/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 105/// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.; 106 ; 107TGraphMultiErrors::TGraphMultiErrors(Int_t np, const Float_t *x, const Float_t *y, const Float_t *exL,; 108 const Float_t *exH, const Float_t *eyL, const Float_t *eyH, Int_t m); 109 : TGraph(np, x, y),",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:3865,Availability,error,error,3865,"aphMultiErrors default constructor with name and title.; 73 ; 74TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title) : TGraphMultiErrors(); 75{; 76 SetNameTitle(name, title);; 77}; 78 ; 79////////////////////////////////////////////////////////////////////////////////; 80/// TGraphMultiErrors normal constructor with np points and ne y-errors.; 81///; 82/// All values are initialized to 0.; 83 ; 84TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne); 85 : TGraph(np), fNYErrors(ne), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst); 86{; 87 CtorAllocate();; 88}; 89 ; 90////////////////////////////////////////////////////////////////////////////////; 91/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 92///; 93/// All values are initialized to 0.; 94 ; 95TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne); 96 : TGraphMultiErrors(np, ne); 97{; 98 SetNameTitle(name, title);; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////////; 102/// TGraphMultiErrors normal constructor with `np` points and a single y-error.; 103///; 104/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 105/// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.; 106 ; 107TGraphMultiErrors::TGraphMultiErrors(Int_t np, const Float_t *x, const Float_t *y, const Float_t *exL,; 108 const Float_t *exH, const Float_t *eyL, const Float_t *eyH, Int_t m); 109 : TGraph(np, x, y), fNYErrors(1), fSumErrorsMode(m); 110{; 111 if (!CtorAllocate()); 112 return;; 113 ; 114 for (Int_t i = 0; i < fNpoints; i++) {; 115 if (exL); 116 fExL[i] = exL[i];; 117 else; 118 fExL[i] = 0.;; 119 if (exH); 120 fExH[i] = exH[i];; 121 else; 122 fExH[i] = 0.;; 123 if (eyL); 124 fEyL[0][i] = eyL[i];; 125 else; 126 fEyL[0][i] = 0.;; 127 if (eyH); 128 fEyH[0][i] = eyH[i];; 129 else; 130 fEyH[0][i] = 0.;;",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:4921,Availability,error,error,4921,"rors normal constructor with `np` points and a single y-error.; 103///; 104/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 105/// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.; 106 ; 107TGraphMultiErrors::TGraphMultiErrors(Int_t np, const Float_t *x, const Float_t *y, const Float_t *exL,; 108 const Float_t *exH, const Float_t *eyL, const Float_t *eyH, Int_t m); 109 : TGraph(np, x, y), fNYErrors(1), fSumErrorsMode(m); 110{; 111 if (!CtorAllocate()); 112 return;; 113 ; 114 for (Int_t i = 0; i < fNpoints; i++) {; 115 if (exL); 116 fExL[i] = exL[i];; 117 else; 118 fExL[i] = 0.;; 119 if (exH); 120 fExH[i] = exH[i];; 121 else; 122 fExH[i] = 0.;; 123 if (eyL); 124 fEyL[0][i] = eyL[i];; 125 else; 126 fEyL[0][i] = 0.;; 127 if (eyH); 128 fEyH[0][i] = eyH[i];; 129 else; 130 fEyH[0][i] = 0.;; 131 }; 132 ; 133 CalcYErrorsSum();; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and a single y-error.; 138///; 139/// If `exL`,`exH` or `eyL`,`eyH` are NULL, the corresponding values are preset to zero.; 140 ; 141TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, const Float_t *x,; 142 const Float_t *y, const Float_t *exL, const Float_t *exH, const Float_t *eyL,; 143 const Float_t *eyH, Int_t m); 144 : TGraphMultiErrors(np, x, y, exL, exH, eyL, eyH, m); 145{; 146 SetNameTitle(name, title);; 147}; 148 ; 149////////////////////////////////////////////////////////////////////////////////; 150/// TGraphMultiErrors normal constructor with `np` points and a single y-error.; 151///; 152/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 153/// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.; 154 ; 155TGraphMultiErrors::TGraphMultiErrors(Int_t np, const D",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:5532,Availability,error,error,5532," x, y), fNYErrors(1), fSumErrorsMode(m); 110{; 111 if (!CtorAllocate()); 112 return;; 113 ; 114 for (Int_t i = 0; i < fNpoints; i++) {; 115 if (exL); 116 fExL[i] = exL[i];; 117 else; 118 fExL[i] = 0.;; 119 if (exH); 120 fExH[i] = exH[i];; 121 else; 122 fExH[i] = 0.;; 123 if (eyL); 124 fEyL[0][i] = eyL[i];; 125 else; 126 fEyL[0][i] = 0.;; 127 if (eyH); 128 fEyH[0][i] = eyH[i];; 129 else; 130 fEyH[0][i] = 0.;; 131 }; 132 ; 133 CalcYErrorsSum();; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and a single y-error.; 138///; 139/// If `exL`,`exH` or `eyL`,`eyH` are NULL, the corresponding values are preset to zero.; 140 ; 141TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, const Float_t *x,; 142 const Float_t *y, const Float_t *exL, const Float_t *exH, const Float_t *eyL,; 143 const Float_t *eyH, Int_t m); 144 : TGraphMultiErrors(np, x, y, exL, exH, eyL, eyH, m); 145{; 146 SetNameTitle(name, title);; 147}; 148 ; 149////////////////////////////////////////////////////////////////////////////////; 150/// TGraphMultiErrors normal constructor with `np` points and a single y-error.; 151///; 152/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 153/// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.; 154 ; 155TGraphMultiErrors::TGraphMultiErrors(Int_t np, const Double_t *x, const Double_t *y, const Double_t *exL,; 156 const Double_t *exH, const Double_t *eyL, const Double_t *eyH, Int_t m); 157 : TGraph(np, x, y), fNYErrors(1), fSumErrorsMode(m); 158{; 159 if (!CtorAllocate()); 160 return;; 161 ; 162 Int_t n = fNpoints * sizeof(Double_t);; 163 ; 164 if (exL); 165 memcpy(fExL, exL, n);; 166 else; 167 memset(fExL, 0, n);; 168 if (exH); 169 memcpy(fExH, exH, n);; 170 else; 171 memset(fExH, 0, n);; 172 ; 173 if (eyL); 174 fEyL[0].S",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:6639,Availability,error,error,6639,"error.; 151///; 152/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 153/// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.; 154 ; 155TGraphMultiErrors::TGraphMultiErrors(Int_t np, const Double_t *x, const Double_t *y, const Double_t *exL,; 156 const Double_t *exH, const Double_t *eyL, const Double_t *eyH, Int_t m); 157 : TGraph(np, x, y), fNYErrors(1), fSumErrorsMode(m); 158{; 159 if (!CtorAllocate()); 160 return;; 161 ; 162 Int_t n = fNpoints * sizeof(Double_t);; 163 ; 164 if (exL); 165 memcpy(fExL, exL, n);; 166 else; 167 memset(fExL, 0, n);; 168 if (exH); 169 memcpy(fExH, exH, n);; 170 else; 171 memset(fExH, 0, n);; 172 ; 173 if (eyL); 174 fEyL[0].Set(fNpoints, eyL);; 175 else; 176 fEyL[0].Reset(0.);; 177 ; 178 if (eyH); 179 fEyH[0].Set(fNpoints, eyH);; 180 else; 181 fEyH[0].Reset(0.);; 182 ; 183 CalcYErrorsSum();; 184}; 185 ; 186////////////////////////////////////////////////////////////////////////////////; 187/// TGraphMultiErrors normal constructor with name, title, `np` points and a single y-error.; 188///; 189/// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.; 190 ; 191TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, const Double_t *x,; 192 const Double_t *y, const Double_t *exL, const Double_t *exH, const Double_t *eyL,; 193 const Double_t *eyH, Int_t m); 194 : TGraphMultiErrors(np, x, y, exL, exH, eyL, eyH, m); 195{; 196 SetNameTitle(name, title);; 197}; 198 ; 199////////////////////////////////////////////////////////////////////////////////; 200/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 201///; 202/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 203/// The multiple y-errors are passed as std::vectors of std::vectors.; 204 ; 205TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Floa",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:7252,Availability,error,errors,7252," 159 if (!CtorAllocate()); 160 return;; 161 ; 162 Int_t n = fNpoints * sizeof(Double_t);; 163 ; 164 if (exL); 165 memcpy(fExL, exL, n);; 166 else; 167 memset(fExL, 0, n);; 168 if (exH); 169 memcpy(fExH, exH, n);; 170 else; 171 memset(fExH, 0, n);; 172 ; 173 if (eyL); 174 fEyL[0].Set(fNpoints, eyL);; 175 else; 176 fEyL[0].Reset(0.);; 177 ; 178 if (eyH); 179 fEyH[0].Set(fNpoints, eyH);; 180 else; 181 fEyH[0].Reset(0.);; 182 ; 183 CalcYErrorsSum();; 184}; 185 ; 186////////////////////////////////////////////////////////////////////////////////; 187/// TGraphMultiErrors normal constructor with name, title, `np` points and a single y-error.; 188///; 189/// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.; 190 ; 191TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, const Double_t *x,; 192 const Double_t *y, const Double_t *exL, const Double_t *exH, const Double_t *eyL,; 193 const Double_t *eyH, Int_t m); 194 : TGraphMultiErrors(np, x, y, exL, exH, eyL, eyH, m); 195{; 196 SetNameTitle(name, title);; 197}; 198 ; 199////////////////////////////////////////////////////////////////////////////////; 200/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 201///; 202/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 203/// The multiple y-errors are passed as std::vectors of std::vectors.; 204 ; 205TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL,; 206 const Float_t *exH, std::vector<std::vector<Float_t>> eyL,; 207 std::vector<std::vector<Float_t>> eyH, Int_t m); 208 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 209{; 210 if (!CtorAllocate()); 211 return;; 212 ; 213 for (Int_t i = 0; i < fNpoints; i++) {; 214 if (exL); 215 fExL[i] = exL[i];; 216 else; 217 fExL[i] = 0.;; 218 if (exH); 219 fExH[i] = exH[i];; 220 else; 221 fExH[i] = 0.;; 222 ; 223 for (Int_t j = 0; j < fNYErrors; j++) {; 224 if",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:7369,Availability,error,errors,7369," eyH);; 180 else; 181 fEyH[0].Reset(0.);; 182 ; 183 CalcYErrorsSum();; 184}; 185 ; 186////////////////////////////////////////////////////////////////////////////////; 187/// TGraphMultiErrors normal constructor with name, title, `np` points and a single y-error.; 188///; 189/// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.; 190 ; 191TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, const Double_t *x,; 192 const Double_t *y, const Double_t *exL, const Double_t *exH, const Double_t *eyL,; 193 const Double_t *eyH, Int_t m); 194 : TGraphMultiErrors(np, x, y, exL, exH, eyL, eyH, m); 195{; 196 SetNameTitle(name, title);; 197}; 198 ; 199////////////////////////////////////////////////////////////////////////////////; 200/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 201///; 202/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 203/// The multiple y-errors are passed as std::vectors of std::vectors.; 204 ; 205TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL,; 206 const Float_t *exH, std::vector<std::vector<Float_t>> eyL,; 207 std::vector<std::vector<Float_t>> eyH, Int_t m); 208 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 209{; 210 if (!CtorAllocate()); 211 return;; 212 ; 213 for (Int_t i = 0; i < fNpoints; i++) {; 214 if (exL); 215 fExL[i] = exL[i];; 216 else; 217 fExL[i] = 0.;; 218 if (exH); 219 fExH[i] = exH[i];; 220 else; 221 fExH[i] = 0.;; 222 ; 223 for (Int_t j = 0; j < fNYErrors; j++) {; 224 if (Int_t(eyL.size()) > j && Int_t(eyL[j].size()) > i); 225 fEyL[j][i] = eyL[j][i];; 226 else; 227 fEyL[j][i] = 0.;; 228 if (Int_t(eyH.size()) > j && Int_t(eyH[j].size()) > i); 229 fEyH[j][i] = eyH[j][i];; 230 else; 231 fEyH[j][i] = 0.;; 232 }; 233 }; 234 ; 235 CalcYErrorsSum();; 236}; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:8464,Availability,error,errors,8464," The multiple y-errors are passed as std::vectors of std::vectors.; 204 ; 205TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL,; 206 const Float_t *exH, std::vector<std::vector<Float_t>> eyL,; 207 std::vector<std::vector<Float_t>> eyH, Int_t m); 208 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 209{; 210 if (!CtorAllocate()); 211 return;; 212 ; 213 for (Int_t i = 0; i < fNpoints; i++) {; 214 if (exL); 215 fExL[i] = exL[i];; 216 else; 217 fExL[i] = 0.;; 218 if (exH); 219 fExH[i] = exH[i];; 220 else; 221 fExH[i] = 0.;; 222 ; 223 for (Int_t j = 0; j < fNYErrors; j++) {; 224 if (Int_t(eyL.size()) > j && Int_t(eyL[j].size()) > i); 225 fEyL[j][i] = eyL[j][i];; 226 else; 227 fEyL[j][i] = 0.;; 228 if (Int_t(eyH.size()) > j && Int_t(eyH[j].size()) > i); 229 fEyH[j][i] = eyH[j][i];; 230 else; 231 fEyH[j][i] = 0.;; 232 }; 233 }; 234 ; 235 CalcYErrorsSum();; 236}; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; 240///; 241/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 242/// The multiple y-errors are passed as std::vectors of std::vectors.; 243 ; 244TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Float_t *x,; 245 const Float_t *y, const Float_t *exL, const Float_t *exH,; 246 std::vector<std::vector<Float_t>> eyL, std::vector<std::vector<Float_t>> eyH,; 247 Int_t m); 248 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 249{; 250 SetNameTitle(name, title);; 251}; 252 ; 253////////////////////////////////////////////////////////////////////////////////; 254/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 255///; 256/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 257/// The multiple y-errors are passed as std::vectors of std::vectors",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:8581,Availability,error,errors,8581,"oat_t>> eyL,; 207 std::vector<std::vector<Float_t>> eyH, Int_t m); 208 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 209{; 210 if (!CtorAllocate()); 211 return;; 212 ; 213 for (Int_t i = 0; i < fNpoints; i++) {; 214 if (exL); 215 fExL[i] = exL[i];; 216 else; 217 fExL[i] = 0.;; 218 if (exH); 219 fExH[i] = exH[i];; 220 else; 221 fExH[i] = 0.;; 222 ; 223 for (Int_t j = 0; j < fNYErrors; j++) {; 224 if (Int_t(eyL.size()) > j && Int_t(eyL[j].size()) > i); 225 fEyL[j][i] = eyL[j][i];; 226 else; 227 fEyL[j][i] = 0.;; 228 if (Int_t(eyH.size()) > j && Int_t(eyH[j].size()) > i); 229 fEyH[j][i] = eyH[j][i];; 230 else; 231 fEyH[j][i] = 0.;; 232 }; 233 }; 234 ; 235 CalcYErrorsSum();; 236}; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; 240///; 241/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 242/// The multiple y-errors are passed as std::vectors of std::vectors.; 243 ; 244TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Float_t *x,; 245 const Float_t *y, const Float_t *exL, const Float_t *exH,; 246 std::vector<std::vector<Float_t>> eyL, std::vector<std::vector<Float_t>> eyH,; 247 Int_t m); 248 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 249{; 250 SetNameTitle(name, title);; 251}; 252 ; 253////////////////////////////////////////////////////////////////////////////////; 254/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 255///; 256/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 257/// The multiple y-errors are passed as std::vectors of std::vectors.; 258 ; 259TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Double_t *x, const Double_t *y, const Double_t *exL,; 260 const Double_t *exH, std::vector<std::vector<Double_t>> eyL,; 261 std::vector<std::vector<Double_t>> eyH, I",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:9188,Availability,error,errors,9188,"];; 220 else; 221 fExH[i] = 0.;; 222 ; 223 for (Int_t j = 0; j < fNYErrors; j++) {; 224 if (Int_t(eyL.size()) > j && Int_t(eyL[j].size()) > i); 225 fEyL[j][i] = eyL[j][i];; 226 else; 227 fEyL[j][i] = 0.;; 228 if (Int_t(eyH.size()) > j && Int_t(eyH[j].size()) > i); 229 fEyH[j][i] = eyH[j][i];; 230 else; 231 fEyH[j][i] = 0.;; 232 }; 233 }; 234 ; 235 CalcYErrorsSum();; 236}; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; 240///; 241/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 242/// The multiple y-errors are passed as std::vectors of std::vectors.; 243 ; 244TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Float_t *x,; 245 const Float_t *y, const Float_t *exL, const Float_t *exH,; 246 std::vector<std::vector<Float_t>> eyL, std::vector<std::vector<Float_t>> eyH,; 247 Int_t m); 248 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 249{; 250 SetNameTitle(name, title);; 251}; 252 ; 253////////////////////////////////////////////////////////////////////////////////; 254/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 255///; 256/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 257/// The multiple y-errors are passed as std::vectors of std::vectors.; 258 ; 259TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Double_t *x, const Double_t *y, const Double_t *exL,; 260 const Double_t *exH, std::vector<std::vector<Double_t>> eyL,; 261 std::vector<std::vector<Double_t>> eyH, Int_t m); 262 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 263{; 264 if (!CtorAllocate()); 265 return;; 266 ; 267 Int_t n = fNpoints * sizeof(Double_t);; 268 ; 269 if (exL); 270 memcpy(fExL, exL, n);; 271 else; 272 memset(fExL, 0, n);; 273 if (exH); 274 memcpy(fExH, exH, n);; 275 else; 276 memset(fExH, 0, n);;",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:9305,Availability,error,errors,9305,"///////////////////////////////////////////////////////////; 239/// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; 240///; 241/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 242/// The multiple y-errors are passed as std::vectors of std::vectors.; 243 ; 244TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Float_t *x,; 245 const Float_t *y, const Float_t *exL, const Float_t *exH,; 246 std::vector<std::vector<Float_t>> eyL, std::vector<std::vector<Float_t>> eyH,; 247 Int_t m); 248 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 249{; 250 SetNameTitle(name, title);; 251}; 252 ; 253////////////////////////////////////////////////////////////////////////////////; 254/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 255///; 256/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 257/// The multiple y-errors are passed as std::vectors of std::vectors.; 258 ; 259TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Double_t *x, const Double_t *y, const Double_t *exL,; 260 const Double_t *exH, std::vector<std::vector<Double_t>> eyL,; 261 std::vector<std::vector<Double_t>> eyH, Int_t m); 262 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 263{; 264 if (!CtorAllocate()); 265 return;; 266 ; 267 Int_t n = fNpoints * sizeof(Double_t);; 268 ; 269 if (exL); 270 memcpy(fExL, exL, n);; 271 else; 272 memset(fExL, 0, n);; 273 if (exH); 274 memcpy(fExH, exH, n);; 275 else; 276 memset(fExH, 0, n);; 277 ; 278 for (Int_t i = 0; i < fNpoints; i++) {; 279 for (Int_t j = 0; j < fNYErrors; j++) {; 280 if (Int_t(eyL.size()) > j && Int_t(eyL[j].size()) > i); 281 fEyL[j][i] = eyL[j][i];; 282 else; 283 fEyL[j][i] = 0.;; 284 if (Int_t(eyH.size()) > j && Int_t(eyH[j].size()) > i); 285 fEyH[j][i] = eyH[j][i];; 286 else; 287 fEyH[j][i] = 0.;; 288 }; 289 }; 290 ; 291 CalcYErrorsSum();; 292}; 293 ; 294/////////",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:10480,Availability,error,errors,10480,"GraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Double_t *x, const Double_t *y, const Double_t *exL,; 260 const Double_t *exH, std::vector<std::vector<Double_t>> eyL,; 261 std::vector<std::vector<Double_t>> eyH, Int_t m); 262 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 263{; 264 if (!CtorAllocate()); 265 return;; 266 ; 267 Int_t n = fNpoints * sizeof(Double_t);; 268 ; 269 if (exL); 270 memcpy(fExL, exL, n);; 271 else; 272 memset(fExL, 0, n);; 273 if (exH); 274 memcpy(fExH, exH, n);; 275 else; 276 memset(fExH, 0, n);; 277 ; 278 for (Int_t i = 0; i < fNpoints; i++) {; 279 for (Int_t j = 0; j < fNYErrors; j++) {; 280 if (Int_t(eyL.size()) > j && Int_t(eyL[j].size()) > i); 281 fEyL[j][i] = eyL[j][i];; 282 else; 283 fEyL[j][i] = 0.;; 284 if (Int_t(eyH.size()) > j && Int_t(eyH[j].size()) > i); 285 fEyH[j][i] = eyH[j][i];; 286 else; 287 fEyH[j][i] = 0.;; 288 }; 289 }; 290 ; 291 CalcYErrorsSum();; 292}; 293 ; 294////////////////////////////////////////////////////////////////////////////////; 295/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 296///; 297/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 298/// The multiple y-errors are passed as std::vectors of std::vectors.; 299 ; 300TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x,; 301 const Double_t *y, const Double_t *exL, const Double_t *exH,; 302 std::vector<std::vector<Double_t>> eyL, std::vector<std::vector<Double_t>> eyH,; 303 Int_t m); 304 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 305{; 306 SetNameTitle(name, title);; 307}; 308 ; 309////////////////////////////////////////////////////////////////////////////////; 310/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 311///; 312/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 313/// The multiple y-errors are passed as std::vectors of TArr",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:10597,Availability,error,errors,10597,"Graph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 263{; 264 if (!CtorAllocate()); 265 return;; 266 ; 267 Int_t n = fNpoints * sizeof(Double_t);; 268 ; 269 if (exL); 270 memcpy(fExL, exL, n);; 271 else; 272 memset(fExL, 0, n);; 273 if (exH); 274 memcpy(fExH, exH, n);; 275 else; 276 memset(fExH, 0, n);; 277 ; 278 for (Int_t i = 0; i < fNpoints; i++) {; 279 for (Int_t j = 0; j < fNYErrors; j++) {; 280 if (Int_t(eyL.size()) > j && Int_t(eyL[j].size()) > i); 281 fEyL[j][i] = eyL[j][i];; 282 else; 283 fEyL[j][i] = 0.;; 284 if (Int_t(eyH.size()) > j && Int_t(eyH[j].size()) > i); 285 fEyH[j][i] = eyH[j][i];; 286 else; 287 fEyH[j][i] = 0.;; 288 }; 289 }; 290 ; 291 CalcYErrorsSum();; 292}; 293 ; 294////////////////////////////////////////////////////////////////////////////////; 295/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 296///; 297/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 298/// The multiple y-errors are passed as std::vectors of std::vectors.; 299 ; 300TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x,; 301 const Double_t *y, const Double_t *exL, const Double_t *exH,; 302 std::vector<std::vector<Double_t>> eyL, std::vector<std::vector<Double_t>> eyH,; 303 Int_t m); 304 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 305{; 306 SetNameTitle(name, title);; 307}; 308 ; 309////////////////////////////////////////////////////////////////////////////////; 310/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 311///; 312/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 313/// The multiple y-errors are passed as std::vectors of TArrayF objects.; 314 ; 315TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL,; 316 const Float_t *exH, std::vector<TArrayF> eyL, std::vector<TArrayF> eyH, Int_t m); 317 : TGraph(np, x,",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:11210,Availability,error,errors,11210,"_t i = 0; i < fNpoints; i++) {; 279 for (Int_t j = 0; j < fNYErrors; j++) {; 280 if (Int_t(eyL.size()) > j && Int_t(eyL[j].size()) > i); 281 fEyL[j][i] = eyL[j][i];; 282 else; 283 fEyL[j][i] = 0.;; 284 if (Int_t(eyH.size()) > j && Int_t(eyH[j].size()) > i); 285 fEyH[j][i] = eyH[j][i];; 286 else; 287 fEyH[j][i] = 0.;; 288 }; 289 }; 290 ; 291 CalcYErrorsSum();; 292}; 293 ; 294////////////////////////////////////////////////////////////////////////////////; 295/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 296///; 297/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 298/// The multiple y-errors are passed as std::vectors of std::vectors.; 299 ; 300TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x,; 301 const Double_t *y, const Double_t *exL, const Double_t *exH,; 302 std::vector<std::vector<Double_t>> eyL, std::vector<std::vector<Double_t>> eyH,; 303 Int_t m); 304 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 305{; 306 SetNameTitle(name, title);; 307}; 308 ; 309////////////////////////////////////////////////////////////////////////////////; 310/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 311///; 312/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 313/// The multiple y-errors are passed as std::vectors of TArrayF objects.; 314 ; 315TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL,; 316 const Float_t *exH, std::vector<TArrayF> eyL, std::vector<TArrayF> eyH, Int_t m); 317 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 318{; 319 if (!CtorAllocate()); 320 return;; 321 ; 322 for (Int_t i = 0; i < fNpoints; i++) {; 323 if (exL); 324 fExL[i] = exL[i];; 325 else; 326 fExL[i] = 0.;; 327 if (exH); 328 fExH[i] = exH[i];; 329 else; 330 fExH[i] = 0.;; 331 ; 332 for (Int_t j = 0; j < fNYErrors; j++) {; 333 i",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:11327,Availability,error,errors,11327,"////////////////////////////////////////////////; 295/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 296///; 297/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 298/// The multiple y-errors are passed as std::vectors of std::vectors.; 299 ; 300TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x,; 301 const Double_t *y, const Double_t *exL, const Double_t *exH,; 302 std::vector<std::vector<Double_t>> eyL, std::vector<std::vector<Double_t>> eyH,; 303 Int_t m); 304 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 305{; 306 SetNameTitle(name, title);; 307}; 308 ; 309////////////////////////////////////////////////////////////////////////////////; 310/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 311///; 312/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 313/// The multiple y-errors are passed as std::vectors of TArrayF objects.; 314 ; 315TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL,; 316 const Float_t *exH, std::vector<TArrayF> eyL, std::vector<TArrayF> eyH, Int_t m); 317 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 318{; 319 if (!CtorAllocate()); 320 return;; 321 ; 322 for (Int_t i = 0; i < fNpoints; i++) {; 323 if (exL); 324 fExL[i] = exL[i];; 325 else; 326 fExL[i] = 0.;; 327 if (exH); 328 fExH[i] = exH[i];; 329 else; 330 fExH[i] = 0.;; 331 ; 332 for (Int_t j = 0; j < fNYErrors; j++) {; 333 if (Int_t(eyL.size()) > j && eyL[j].GetSize() > i); 334 fEyL[j][i] = eyL[j][i];; 335 else; 336 fEyL[j][i] = 0.;; 337 if (Int_t(eyH.size()) > j && eyH[j].GetSize() > i); 338 fEyH[j][i] = eyH[j][i];; 339 else; 340 fEyH[j][i] = 0.;; 341 }; 342 }; 343 ; 344 CalcYErrorsSum();; 345}; 346 ; 347////////////////////////////////////////////////////////////////////////////////; 348/// TGraphMultiErrors normal construct",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:12386,Availability,error,errors,12386,"g values are preset to zero.; 313/// The multiple y-errors are passed as std::vectors of TArrayF objects.; 314 ; 315TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL,; 316 const Float_t *exH, std::vector<TArrayF> eyL, std::vector<TArrayF> eyH, Int_t m); 317 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 318{; 319 if (!CtorAllocate()); 320 return;; 321 ; 322 for (Int_t i = 0; i < fNpoints; i++) {; 323 if (exL); 324 fExL[i] = exL[i];; 325 else; 326 fExL[i] = 0.;; 327 if (exH); 328 fExH[i] = exH[i];; 329 else; 330 fExH[i] = 0.;; 331 ; 332 for (Int_t j = 0; j < fNYErrors; j++) {; 333 if (Int_t(eyL.size()) > j && eyL[j].GetSize() > i); 334 fEyL[j][i] = eyL[j][i];; 335 else; 336 fEyL[j][i] = 0.;; 337 if (Int_t(eyH.size()) > j && eyH[j].GetSize() > i); 338 fEyH[j][i] = eyH[j][i];; 339 else; 340 fEyH[j][i] = 0.;; 341 }; 342 }; 343 ; 344 CalcYErrorsSum();; 345}; 346 ; 347////////////////////////////////////////////////////////////////////////////////; 348/// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; 349///; 350/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 351/// The multiple y-errors are passed as std::vectors of TArrayF objects.; 352 ; 353TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Float_t *x,; 354 const Float_t *y, const Float_t *exL, const Float_t *exH, std::vector<TArrayF> eyL,; 355 std::vector<TArrayF> eyH, Int_t m); 356 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 357{; 358 SetNameTitle(name, title);; 359}; 360 ; 361////////////////////////////////////////////////////////////////////////////////; 362/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 363///; 364/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 365/// The multiple y-errors are passed as std::vectors of TArrayD objects.; 366 ; 367TGraphMultiEr",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:12503,Availability,error,errors,12503,"oat_t *exH, std::vector<TArrayF> eyL, std::vector<TArrayF> eyH, Int_t m); 317 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 318{; 319 if (!CtorAllocate()); 320 return;; 321 ; 322 for (Int_t i = 0; i < fNpoints; i++) {; 323 if (exL); 324 fExL[i] = exL[i];; 325 else; 326 fExL[i] = 0.;; 327 if (exH); 328 fExH[i] = exH[i];; 329 else; 330 fExH[i] = 0.;; 331 ; 332 for (Int_t j = 0; j < fNYErrors; j++) {; 333 if (Int_t(eyL.size()) > j && eyL[j].GetSize() > i); 334 fEyL[j][i] = eyL[j][i];; 335 else; 336 fEyL[j][i] = 0.;; 337 if (Int_t(eyH.size()) > j && eyH[j].GetSize() > i); 338 fEyH[j][i] = eyH[j][i];; 339 else; 340 fEyH[j][i] = 0.;; 341 }; 342 }; 343 ; 344 CalcYErrorsSum();; 345}; 346 ; 347////////////////////////////////////////////////////////////////////////////////; 348/// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; 349///; 350/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 351/// The multiple y-errors are passed as std::vectors of TArrayF objects.; 352 ; 353TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Float_t *x,; 354 const Float_t *y, const Float_t *exL, const Float_t *exH, std::vector<TArrayF> eyL,; 355 std::vector<TArrayF> eyH, Int_t m); 356 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 357{; 358 SetNameTitle(name, title);; 359}; 360 ; 361////////////////////////////////////////////////////////////////////////////////; 362/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 363///; 364/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 365/// The multiple y-errors are passed as std::vectors of TArrayD objects.; 366 ; 367TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Double_t *x, const Double_t *y, const Double_t *exL,; 368 const Double_t *exH, std::vector<TArrayD> eyL, std::vector<TArrayD> eyH, Int_t m); 369 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMo",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:13082,Availability,error,errors,13082,"; 328 fExH[i] = exH[i];; 329 else; 330 fExH[i] = 0.;; 331 ; 332 for (Int_t j = 0; j < fNYErrors; j++) {; 333 if (Int_t(eyL.size()) > j && eyL[j].GetSize() > i); 334 fEyL[j][i] = eyL[j][i];; 335 else; 336 fEyL[j][i] = 0.;; 337 if (Int_t(eyH.size()) > j && eyH[j].GetSize() > i); 338 fEyH[j][i] = eyH[j][i];; 339 else; 340 fEyH[j][i] = 0.;; 341 }; 342 }; 343 ; 344 CalcYErrorsSum();; 345}; 346 ; 347////////////////////////////////////////////////////////////////////////////////; 348/// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; 349///; 350/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 351/// The multiple y-errors are passed as std::vectors of TArrayF objects.; 352 ; 353TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Float_t *x,; 354 const Float_t *y, const Float_t *exL, const Float_t *exH, std::vector<TArrayF> eyL,; 355 std::vector<TArrayF> eyH, Int_t m); 356 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 357{; 358 SetNameTitle(name, title);; 359}; 360 ; 361////////////////////////////////////////////////////////////////////////////////; 362/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 363///; 364/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 365/// The multiple y-errors are passed as std::vectors of TArrayD objects.; 366 ; 367TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Double_t *x, const Double_t *y, const Double_t *exL,; 368 const Double_t *exH, std::vector<TArrayD> eyL, std::vector<TArrayD> eyH, Int_t m); 369 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 370{; 371 if (!CtorAllocate()); 372 return;; 373 ; 374 Int_t n = fNpoints * sizeof(Double_t);; 375 ; 376 if (exL); 377 memcpy(fExL, exL, n);; 378 else; 379 memset(fExL, 0, n);; 380 if (exH); 381 memcpy(fExH, exH, n);; 382 else; 383 memset(fExH, 0, n);; 384 ; 385 for (Int_t i = 0; i < fNpoints; i++",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:13199,Availability,error,errors,13199," ; 347////////////////////////////////////////////////////////////////////////////////; 348/// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; 349///; 350/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 351/// The multiple y-errors are passed as std::vectors of TArrayF objects.; 352 ; 353TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Float_t *x,; 354 const Float_t *y, const Float_t *exL, const Float_t *exH, std::vector<TArrayF> eyL,; 355 std::vector<TArrayF> eyH, Int_t m); 356 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 357{; 358 SetNameTitle(name, title);; 359}; 360 ; 361////////////////////////////////////////////////////////////////////////////////; 362/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 363///; 364/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 365/// The multiple y-errors are passed as std::vectors of TArrayD objects.; 366 ; 367TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Double_t *x, const Double_t *y, const Double_t *exL,; 368 const Double_t *exH, std::vector<TArrayD> eyL, std::vector<TArrayD> eyH, Int_t m); 369 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 370{; 371 if (!CtorAllocate()); 372 return;; 373 ; 374 Int_t n = fNpoints * sizeof(Double_t);; 375 ; 376 if (exL); 377 memcpy(fExL, exL, n);; 378 else; 379 memset(fExL, 0, n);; 380 if (exH); 381 memcpy(fExH, exH, n);; 382 else; 383 memset(fExH, 0, n);; 384 ; 385 for (Int_t i = 0; i < fNpoints; i++) {; 386 for (Int_t j = 0; j < fNYErrors; j++) {; 387 if (Int_t(eyL.size()) > j && eyL[j].GetSize() > i); 388 fEyL[j][i] = eyL[j][i];; 389 else; 390 fEyL[j][i] = 0.;; 391 if (Int_t(eyH.size()) > j && eyH[j].GetSize() > i); 392 fEyH[j][i] = eyH[j][i];; 393 else; 394 fEyH[j][i] = 0.;; 395 }; 396 }; 397 ; 398 CalcYErrorsSum();; 399}; 400 ; 401/////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:14336,Availability,error,errors,14336,"::vectors of TArrayD objects.; 366 ; 367TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Double_t *x, const Double_t *y, const Double_t *exL,; 368 const Double_t *exH, std::vector<TArrayD> eyL, std::vector<TArrayD> eyH, Int_t m); 369 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 370{; 371 if (!CtorAllocate()); 372 return;; 373 ; 374 Int_t n = fNpoints * sizeof(Double_t);; 375 ; 376 if (exL); 377 memcpy(fExL, exL, n);; 378 else; 379 memset(fExL, 0, n);; 380 if (exH); 381 memcpy(fExH, exH, n);; 382 else; 383 memset(fExH, 0, n);; 384 ; 385 for (Int_t i = 0; i < fNpoints; i++) {; 386 for (Int_t j = 0; j < fNYErrors; j++) {; 387 if (Int_t(eyL.size()) > j && eyL[j].GetSize() > i); 388 fEyL[j][i] = eyL[j][i];; 389 else; 390 fEyL[j][i] = 0.;; 391 if (Int_t(eyH.size()) > j && eyH[j].GetSize() > i); 392 fEyH[j][i] = eyH[j][i];; 393 else; 394 fEyH[j][i] = 0.;; 395 }; 396 }; 397 ; 398 CalcYErrorsSum();; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 403///; 404/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 405/// The multiple y-errors are passed as std::vectors of TArrayD objects.; 406 ; 407TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x,; 408 const Double_t *y, const Double_t *exL, const Double_t *exH,; 409 std::vector<TArrayD> eyL, std::vector<TArrayD> eyH, Int_t m); 410 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 411{; 412 SetNameTitle(name, title);; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Constructor with six vectors of floats in input and a single y error dimension.; 417/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 418/// A grapherrors is built with the X coordinates taken from `t",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:14453,Availability,error,errors,14453,"369 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 370{; 371 if (!CtorAllocate()); 372 return;; 373 ; 374 Int_t n = fNpoints * sizeof(Double_t);; 375 ; 376 if (exL); 377 memcpy(fExL, exL, n);; 378 else; 379 memset(fExL, 0, n);; 380 if (exH); 381 memcpy(fExH, exH, n);; 382 else; 383 memset(fExH, 0, n);; 384 ; 385 for (Int_t i = 0; i < fNpoints; i++) {; 386 for (Int_t j = 0; j < fNYErrors; j++) {; 387 if (Int_t(eyL.size()) > j && eyL[j].GetSize() > i); 388 fEyL[j][i] = eyL[j][i];; 389 else; 390 fEyL[j][i] = 0.;; 391 if (Int_t(eyH.size()) > j && eyH[j].GetSize() > i); 392 fEyH[j][i] = eyH[j][i];; 393 else; 394 fEyH[j][i] = 0.;; 395 }; 396 }; 397 ; 398 CalcYErrorsSum();; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 403///; 404/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 405/// The multiple y-errors are passed as std::vectors of TArrayD objects.; 406 ; 407TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x,; 408 const Double_t *y, const Double_t *exL, const Double_t *exH,; 409 std::vector<TArrayD> eyL, std::vector<TArrayD> eyH, Int_t m); 410 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 411{; 412 SetNameTitle(name, title);; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Constructor with six vectors of floats in input and a single y error dimension.; 417/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 418/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 419/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; 420/// The number of points in the graph is the minimum of number of points; 421/// in `tvX` and `tvY`.; 422 ; 423TGraphMultiErrors::TG",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:15034,Availability,error,error,15034,"384 ; 385 for (Int_t i = 0; i < fNpoints; i++) {; 386 for (Int_t j = 0; j < fNYErrors; j++) {; 387 if (Int_t(eyL.size()) > j && eyL[j].GetSize() > i); 388 fEyL[j][i] = eyL[j][i];; 389 else; 390 fEyL[j][i] = 0.;; 391 if (Int_t(eyH.size()) > j && eyH[j].GetSize() > i); 392 fEyH[j][i] = eyH[j][i];; 393 else; 394 fEyH[j][i] = 0.;; 395 }; 396 }; 397 ; 398 CalcYErrorsSum();; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 403///; 404/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 405/// The multiple y-errors are passed as std::vectors of TArrayD objects.; 406 ; 407TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x,; 408 const Double_t *y, const Double_t *exL, const Double_t *exH,; 409 std::vector<TArrayD> eyL, std::vector<TArrayD> eyH, Int_t m); 410 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 411{; 412 SetNameTitle(name, title);; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Constructor with six vectors of floats in input and a single y error dimension.; 417/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 418/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 419/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; 420/// The number of points in the graph is the minimum of number of points; 421/// in `tvX` and `tvY`.; 422 ; 423TGraphMultiErrors::TGraphMultiErrors(const TVectorF &tvX, const TVectorF &tvY, const TVectorF &tvExL,; 424 const TVectorF &tvExH, const TVectorF &tvEyL, const TVectorF &tvEyH, Int_t m); 425 : fNYErrors(1), fSumErrorsMode(m); 426{; 427 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 428 ; 429 if (!TGraph::CtorAllocate()); ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:15273,Availability,error,errors,15273,"//; 402/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 403///; 404/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 405/// The multiple y-errors are passed as std::vectors of TArrayD objects.; 406 ; 407TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x,; 408 const Double_t *y, const Double_t *exL, const Double_t *exH,; 409 std::vector<TArrayD> eyL, std::vector<TArrayD> eyH, Int_t m); 410 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 411{; 412 SetNameTitle(name, title);; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Constructor with six vectors of floats in input and a single y error dimension.; 417/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 418/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 419/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; 420/// The number of points in the graph is the minimum of number of points; 421/// in `tvX` and `tvY`.; 422 ; 423TGraphMultiErrors::TGraphMultiErrors(const TVectorF &tvX, const TVectorF &tvY, const TVectorF &tvExL,; 424 const TVectorF &tvExH, const TVectorF &tvEyL, const TVectorF &tvEyH, Int_t m); 425 : fNYErrors(1), fSumErrorsMode(m); 426{; 427 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 428 ; 429 if (!TGraph::CtorAllocate()); 430 return;; 431 ; 432 if (!CtorAllocate()); 433 return;; 434 ; 435 Int_t itvXL = tvX.GetLwb();; 436 Int_t itvYL = tvY.GetLwb();; 437 Int_t itvExLL = tvExL.GetLwb();; 438 Int_t itvExHL = tvExH.GetLwb();; 439 Int_t itvEyLL = tvEyL.GetLwb();; 440 Int_t itvEyHL = tvEyH.GetLwb();; 441 ; 442 for (Int_t i = 0; i < fNpoints; i++) {; 443 fX[i] = tvX(itvXL + i);; 444 fY[i] = tvY(itvYL + i);; 445 fExL[i] = tvExL(itvExLL + i);; 446 fExH[i] = tvExH(itvExHL + i);; 447 fEyL[0",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:16514,Availability,error,error,16514,"ctors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; 420/// The number of points in the graph is the minimum of number of points; 421/// in `tvX` and `tvY`.; 422 ; 423TGraphMultiErrors::TGraphMultiErrors(const TVectorF &tvX, const TVectorF &tvY, const TVectorF &tvExL,; 424 const TVectorF &tvExH, const TVectorF &tvEyL, const TVectorF &tvEyH, Int_t m); 425 : fNYErrors(1), fSumErrorsMode(m); 426{; 427 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 428 ; 429 if (!TGraph::CtorAllocate()); 430 return;; 431 ; 432 if (!CtorAllocate()); 433 return;; 434 ; 435 Int_t itvXL = tvX.GetLwb();; 436 Int_t itvYL = tvY.GetLwb();; 437 Int_t itvExLL = tvExL.GetLwb();; 438 Int_t itvExHL = tvExH.GetLwb();; 439 Int_t itvEyLL = tvEyL.GetLwb();; 440 Int_t itvEyHL = tvEyH.GetLwb();; 441 ; 442 for (Int_t i = 0; i < fNpoints; i++) {; 443 fX[i] = tvX(itvXL + i);; 444 fY[i] = tvY(itvYL + i);; 445 fExL[i] = tvExL(itvExLL + i);; 446 fExH[i] = tvExH(itvExHL + i);; 447 fEyL[0][i] = tvEyL(itvEyLL + i);; 448 fEyH[0][i] = tvEyH(itvEyHL + i);; 449 }; 450 ; 451 CalcYErrorsSum();; 452}; 453 ; 454////////////////////////////////////////////////////////////////////////////////; 455/// Constructor with six vectors of doubles in input and a single y error dimension.; 456/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 457/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 458/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; 459/// The number of points in the graph is the minimum of number of points; 460/// in `tvX` and `tvY`.; 461 ; 462TGraphMultiErrors::TGraphMultiErrors(const TVectorD &tvX, const TVectorD &tvY, const TVectorD &tvExL,; 463 const TVectorD &tvExH, const TVectorD &tvEyL, const TVectorD &tvEyH, Int_t m); 464 : fNYErrors(1), fSumErrorsMode(m); 465{; 466 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 467 ; 468 if (!TGraph::CtorAllocate()); 469 return;; 470 ; 471 if (!Ct",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:16753,Availability,error,errors,16753,".GetNrows());; 428 ; 429 if (!TGraph::CtorAllocate()); 430 return;; 431 ; 432 if (!CtorAllocate()); 433 return;; 434 ; 435 Int_t itvXL = tvX.GetLwb();; 436 Int_t itvYL = tvY.GetLwb();; 437 Int_t itvExLL = tvExL.GetLwb();; 438 Int_t itvExHL = tvExH.GetLwb();; 439 Int_t itvEyLL = tvEyL.GetLwb();; 440 Int_t itvEyHL = tvEyH.GetLwb();; 441 ; 442 for (Int_t i = 0; i < fNpoints; i++) {; 443 fX[i] = tvX(itvXL + i);; 444 fY[i] = tvY(itvYL + i);; 445 fExL[i] = tvExL(itvExLL + i);; 446 fExH[i] = tvExH(itvExHL + i);; 447 fEyL[0][i] = tvEyL(itvEyLL + i);; 448 fEyH[0][i] = tvEyH(itvEyHL + i);; 449 }; 450 ; 451 CalcYErrorsSum();; 452}; 453 ; 454////////////////////////////////////////////////////////////////////////////////; 455/// Constructor with six vectors of doubles in input and a single y error dimension.; 456/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 457/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 458/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; 459/// The number of points in the graph is the minimum of number of points; 460/// in `tvX` and `tvY`.; 461 ; 462TGraphMultiErrors::TGraphMultiErrors(const TVectorD &tvX, const TVectorD &tvY, const TVectorD &tvExL,; 463 const TVectorD &tvExH, const TVectorD &tvEyL, const TVectorD &tvEyH, Int_t m); 464 : fNYErrors(1), fSumErrorsMode(m); 465{; 466 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 467 ; 468 if (!TGraph::CtorAllocate()); 469 return;; 470 ; 471 if (!CtorAllocate()); 472 return;; 473 ; 474 Int_t itvXL = tvX.GetLwb();; 475 Int_t itvYL = tvY.GetLwb();; 476 Int_t itvExLL = tvExL.GetLwb();; 477 Int_t itvExHL = tvExH.GetLwb();; 478 Int_t itvEyLL = tvEyL.GetLwb();; 479 Int_t itvEyHL = tvEyH.GetLwb();; 480 ; 481 for (Int_t i = 0; i < fNpoints; i++) {; 482 fX[i] = tvX(i + itvXL);; 483 fY[i] = tvY(i + itvYL);; 484 fExL[i] = tvExL(i + itvExLL);; 485 fExH[i] = tvExH(i + itvExHL);; 486 fEyL[0",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:17998,Availability,error,error,17998,"ors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; 459/// The number of points in the graph is the minimum of number of points; 460/// in `tvX` and `tvY`.; 461 ; 462TGraphMultiErrors::TGraphMultiErrors(const TVectorD &tvX, const TVectorD &tvY, const TVectorD &tvExL,; 463 const TVectorD &tvExH, const TVectorD &tvEyL, const TVectorD &tvEyH, Int_t m); 464 : fNYErrors(1), fSumErrorsMode(m); 465{; 466 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 467 ; 468 if (!TGraph::CtorAllocate()); 469 return;; 470 ; 471 if (!CtorAllocate()); 472 return;; 473 ; 474 Int_t itvXL = tvX.GetLwb();; 475 Int_t itvYL = tvY.GetLwb();; 476 Int_t itvExLL = tvExL.GetLwb();; 477 Int_t itvExHL = tvExH.GetLwb();; 478 Int_t itvEyLL = tvEyL.GetLwb();; 479 Int_t itvEyHL = tvEyH.GetLwb();; 480 ; 481 for (Int_t i = 0; i < fNpoints; i++) {; 482 fX[i] = tvX(i + itvXL);; 483 fY[i] = tvY(i + itvYL);; 484 fExL[i] = tvExL(i + itvExLL);; 485 fExH[i] = tvExH(i + itvExHL);; 486 fEyL[0][i] = tvEyL(i + itvEyLL);; 487 fEyH[0][i] = tvEyH(i + itvEyHL);; 488 }; 489 ; 490 CalcYErrorsSum();; 491}; 492 ; 493////////////////////////////////////////////////////////////////////////////////; 494/// Constructor with multiple vectors of floats in input and multiple y error dimension.; 495/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 496/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL/H[yErrorDimension]`.; 497/// The number of points in the graph is the minimum of number of points; 498/// in `tvX` and `tvY`.; 499 ; 500TGraphMultiErrors::TGraphMultiErrors(Int_t ne, const TVectorF &tvX, const TVectorF &tvY, const TVectorF &tvExL,; 501 const TVectorF &tvExH, const TVectorF *tvEyL, const TVectorF *tvEyH, Int_t m); 502 : fNYErrors(ne), fSumErrorsMode(m); 503{; 504 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 505 ; 506 if (!TGraph::CtorAllocate()); 507 return;; 508 ; 509 if (!CtorAllocate()); 510 return;; 511 ; 512 Int_t itvXL = tvX.GetLwb();; 513 Int_t itvYL ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:18131,Availability,error,errors,18131,"_t m); 464 : fNYErrors(1), fSumErrorsMode(m); 465{; 466 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 467 ; 468 if (!TGraph::CtorAllocate()); 469 return;; 470 ; 471 if (!CtorAllocate()); 472 return;; 473 ; 474 Int_t itvXL = tvX.GetLwb();; 475 Int_t itvYL = tvY.GetLwb();; 476 Int_t itvExLL = tvExL.GetLwb();; 477 Int_t itvExHL = tvExH.GetLwb();; 478 Int_t itvEyLL = tvEyL.GetLwb();; 479 Int_t itvEyHL = tvEyH.GetLwb();; 480 ; 481 for (Int_t i = 0; i < fNpoints; i++) {; 482 fX[i] = tvX(i + itvXL);; 483 fY[i] = tvY(i + itvYL);; 484 fExL[i] = tvExL(i + itvExLL);; 485 fExH[i] = tvExH(i + itvExHL);; 486 fEyL[0][i] = tvEyL(i + itvEyLL);; 487 fEyH[0][i] = tvEyH(i + itvEyHL);; 488 }; 489 ; 490 CalcYErrorsSum();; 491}; 492 ; 493////////////////////////////////////////////////////////////////////////////////; 494/// Constructor with multiple vectors of floats in input and multiple y error dimension.; 495/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 496/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL/H[yErrorDimension]`.; 497/// The number of points in the graph is the minimum of number of points; 498/// in `tvX` and `tvY`.; 499 ; 500TGraphMultiErrors::TGraphMultiErrors(Int_t ne, const TVectorF &tvX, const TVectorF &tvY, const TVectorF &tvExL,; 501 const TVectorF &tvExH, const TVectorF *tvEyL, const TVectorF *tvEyH, Int_t m); 502 : fNYErrors(ne), fSumErrorsMode(m); 503{; 504 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 505 ; 506 if (!TGraph::CtorAllocate()); 507 return;; 508 ; 509 if (!CtorAllocate()); 510 return;; 511 ; 512 Int_t itvXL = tvX.GetLwb();; 513 Int_t itvYL = tvY.GetLwb();; 514 Int_t itvExLL = tvExL.GetLwb();; 515 Int_t itvExHL = tvExH.GetLwb();; 516 ; 517 for (Int_t i = 0; i < fNpoints; i++) {; 518 fX[i] = tvX(i + itvXL);; 519 fY[i] = tvY(i + itvYL);; 520 fExL[i] = tvExL(i + itvExLL);; 521 fExH[i] = tvExH(i + itvExHL);; 522 ; 523 for (Int_t j = 0; j < ne; j++) {; 524 fEyL[j][i] = tvEyL[j",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:19401,Availability,error,error,19401,"t TVectorF &tvY, const TVectorF &tvExL,; 501 const TVectorF &tvExH, const TVectorF *tvEyL, const TVectorF *tvEyH, Int_t m); 502 : fNYErrors(ne), fSumErrorsMode(m); 503{; 504 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 505 ; 506 if (!TGraph::CtorAllocate()); 507 return;; 508 ; 509 if (!CtorAllocate()); 510 return;; 511 ; 512 Int_t itvXL = tvX.GetLwb();; 513 Int_t itvYL = tvY.GetLwb();; 514 Int_t itvExLL = tvExL.GetLwb();; 515 Int_t itvExHL = tvExH.GetLwb();; 516 ; 517 for (Int_t i = 0; i < fNpoints; i++) {; 518 fX[i] = tvX(i + itvXL);; 519 fY[i] = tvY(i + itvYL);; 520 fExL[i] = tvExL(i + itvExLL);; 521 fExH[i] = tvExH(i + itvExHL);; 522 ; 523 for (Int_t j = 0; j < ne; j++) {; 524 fEyL[j][i] = tvEyL[j](i + tvEyL[j].GetLwb());; 525 fEyH[j][i] = tvEyH[j](i + tvEyH[j].GetLwb());; 526 }; 527 }; 528 ; 529 CalcYErrorsSum();; 530}; 531 ; 532////////////////////////////////////////////////////////////////////////////////; 533/// Constructor with multiple vectors of doubles in input and multiple y error dimensions; 534/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 535/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL/H[yErrorDimension]`.; 536/// The number of points in the graph is the minimum of number of points; 537/// in `tvX` and `tvY`.; 538 ; 539TGraphMultiErrors::TGraphMultiErrors(Int_t ne, const TVectorD &tvX, const TVectorD &tvY, const TVectorD &tvExL,; 540 const TVectorD &tvExH, const TVectorD *tvEyL, const TVectorD *tvEyH, Int_t m); 541 : fNYErrors(ne), fSumErrorsMode(m); 542{; 543 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 544 ; 545 if (!TGraph::CtorAllocate()); 546 return;; 547 ; 548 if (!CtorAllocate()); 549 return;; 550 ; 551 Int_t itvXL = tvX.GetLwb();; 552 Int_t itvYL = tvY.GetLwb();; 553 Int_t itvExLL = tvExL.GetLwb();; 554 Int_t itvExHL = tvExH.GetLwb();; 555 ; 556 for (Int_t i = 0; i < fNpoints; i++) {; 557 fX[i] = tvX(i + itvXL);; 558 fY[i] = tvY(i + itvYL);; 559 fExL[i] = tv",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:19534,Availability,error,errors,19534,"t TVectorF &tvY, const TVectorF &tvExL,; 501 const TVectorF &tvExH, const TVectorF *tvEyL, const TVectorF *tvEyH, Int_t m); 502 : fNYErrors(ne), fSumErrorsMode(m); 503{; 504 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 505 ; 506 if (!TGraph::CtorAllocate()); 507 return;; 508 ; 509 if (!CtorAllocate()); 510 return;; 511 ; 512 Int_t itvXL = tvX.GetLwb();; 513 Int_t itvYL = tvY.GetLwb();; 514 Int_t itvExLL = tvExL.GetLwb();; 515 Int_t itvExHL = tvExH.GetLwb();; 516 ; 517 for (Int_t i = 0; i < fNpoints; i++) {; 518 fX[i] = tvX(i + itvXL);; 519 fY[i] = tvY(i + itvYL);; 520 fExL[i] = tvExL(i + itvExLL);; 521 fExH[i] = tvExH(i + itvExHL);; 522 ; 523 for (Int_t j = 0; j < ne; j++) {; 524 fEyL[j][i] = tvEyL[j](i + tvEyL[j].GetLwb());; 525 fEyH[j][i] = tvEyH[j](i + tvEyH[j].GetLwb());; 526 }; 527 }; 528 ; 529 CalcYErrorsSum();; 530}; 531 ; 532////////////////////////////////////////////////////////////////////////////////; 533/// Constructor with multiple vectors of doubles in input and multiple y error dimensions; 534/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 535/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL/H[yErrorDimension]`.; 536/// The number of points in the graph is the minimum of number of points; 537/// in `tvX` and `tvY`.; 538 ; 539TGraphMultiErrors::TGraphMultiErrors(Int_t ne, const TVectorD &tvX, const TVectorD &tvY, const TVectorD &tvExL,; 540 const TVectorD &tvExH, const TVectorD *tvEyL, const TVectorD *tvEyH, Int_t m); 541 : fNYErrors(ne), fSumErrorsMode(m); 542{; 543 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 544 ; 545 if (!TGraph::CtorAllocate()); 546 return;; 547 ; 548 if (!CtorAllocate()); 549 return;; 550 ; 551 Int_t itvXL = tvX.GetLwb();; 552 Int_t itvYL = tvY.GetLwb();; 553 Int_t itvExLL = tvExL.GetLwb();; 554 Int_t itvExHL = tvExH.GetLwb();; 555 ; 556 for (Int_t i = 0; i < fNpoints; i++) {; 557 fX[i] = tvX(i + itvXL);; 558 fY[i] = tvY(i + itvYL);; 559 fExL[i] = tv",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:22579,Availability,error,errors,22579,"&tgme) {; 602 TGraph::operator=(tgme);; 603 // delete arrays; 604 if (fExL); 605 delete[] fExL;; 606 if (fExH); 607 delete[] fExH;; 608 if (fEyLSum); 609 delete[] fEyLSum;; 610 if (fEyHSum); 611 delete[] fEyHSum;; 612 ; 613 fNYErrors = tgme.fNYErrors;; 614 fSumErrorsMode = tgme.fSumErrorsMode;; 615 ; 616 if (!CtorAllocate()); 617 return *this;; 618 ; 619 Int_t n = fNpoints * sizeof(Double_t);; 620 memcpy(fExL, tgme.fExL, n);; 621 memcpy(fExH, tgme.fExH, n);; 622 memcpy(fEyLSum, tgme.fEyLSum, n);; 623 memcpy(fEyHSum, tgme.fEyHSum, n);; 624 ; 625 for (Int_t j = 0; j < fNYErrors; j++) {; 626 fEyL[j] = tgme.fEyL[j];; 627 fEyH[j] = tgme.fEyH[j];; 628 tgme.fAttFill[j].Copy(fAttFill[j]);; 629 tgme.fAttLine[j].Copy(fAttLine[j]);; 630 }; 631 }; 632 return *this;; 633}; 634 ; 635////////////////////////////////////////////////////////////////////////////////; 636/// TGraphMultiErrors constructor importing its parameters from the TH1 object passed as argument.; 637/// The low and high errors are set to the bin error of the histogram.; 638 ; 639TGraphMultiErrors::TGraphMultiErrors(const TH1 *h, Int_t ne); 640 : TGraph(h), fNYErrors(ne), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst); 641{; 642 if (!CtorAllocate()); 643 return;; 644 ; 645 for (Int_t i = 0; i < fNpoints; i++) {; 646 fExL[i] = h->GetBinWidth(i + 1) * gStyle->GetErrorX();; 647 fExH[i] = h->GetBinWidth(i + 1) * gStyle->GetErrorX();; 648 fEyL[0][i] = h->GetBinError(i + 1);; 649 fEyH[0][i] = h->GetBinError(i + 1);; 650 ; 651 for (Int_t j = 1; j < fNYErrors; j++) {; 652 fEyL[j][i] = 0.;; 653 fEyH[j][i] = 0.;; 654 }; 655 }; 656 ; 657 CalcYErrorsSum();; 658 ; 659 TAttFill::Copy(fAttFill[0]);; 660 TAttLine::Copy(fAttLine[0]);; 661}; 662 ; 663////////////////////////////////////////////////////////////////////////////////; 664/// Creates a TGraphMultiErrors by dividing two input TH1 histograms:; 665/// pass/total. (see TGraphMultiErrors::Divide); 666 ; 667TGraphMultiErrors::TGraphMultiErrors(const TH1 *pass, const TH1 *total",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:22605,Availability,error,error,22605,"&tgme) {; 602 TGraph::operator=(tgme);; 603 // delete arrays; 604 if (fExL); 605 delete[] fExL;; 606 if (fExH); 607 delete[] fExH;; 608 if (fEyLSum); 609 delete[] fEyLSum;; 610 if (fEyHSum); 611 delete[] fEyHSum;; 612 ; 613 fNYErrors = tgme.fNYErrors;; 614 fSumErrorsMode = tgme.fSumErrorsMode;; 615 ; 616 if (!CtorAllocate()); 617 return *this;; 618 ; 619 Int_t n = fNpoints * sizeof(Double_t);; 620 memcpy(fExL, tgme.fExL, n);; 621 memcpy(fExH, tgme.fExH, n);; 622 memcpy(fEyLSum, tgme.fEyLSum, n);; 623 memcpy(fEyHSum, tgme.fEyHSum, n);; 624 ; 625 for (Int_t j = 0; j < fNYErrors; j++) {; 626 fEyL[j] = tgme.fEyL[j];; 627 fEyH[j] = tgme.fEyH[j];; 628 tgme.fAttFill[j].Copy(fAttFill[j]);; 629 tgme.fAttLine[j].Copy(fAttLine[j]);; 630 }; 631 }; 632 return *this;; 633}; 634 ; 635////////////////////////////////////////////////////////////////////////////////; 636/// TGraphMultiErrors constructor importing its parameters from the TH1 object passed as argument.; 637/// The low and high errors are set to the bin error of the histogram.; 638 ; 639TGraphMultiErrors::TGraphMultiErrors(const TH1 *h, Int_t ne); 640 : TGraph(h), fNYErrors(ne), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst); 641{; 642 if (!CtorAllocate()); 643 return;; 644 ; 645 for (Int_t i = 0; i < fNpoints; i++) {; 646 fExL[i] = h->GetBinWidth(i + 1) * gStyle->GetErrorX();; 647 fExH[i] = h->GetBinWidth(i + 1) * gStyle->GetErrorX();; 648 fEyL[0][i] = h->GetBinError(i + 1);; 649 fEyH[0][i] = h->GetBinError(i + 1);; 650 ; 651 for (Int_t j = 1; j < fNYErrors; j++) {; 652 fEyL[j][i] = 0.;; 653 fEyH[j][i] = 0.;; 654 }; 655 }; 656 ; 657 CalcYErrorsSum();; 658 ; 659 TAttFill::Copy(fAttFill[0]);; 660 TAttLine::Copy(fAttLine[0]);; 661}; 662 ; 663////////////////////////////////////////////////////////////////////////////////; 664/// Creates a TGraphMultiErrors by dividing two input TH1 histograms:; 665/// pass/total. (see TGraphMultiErrors::Divide); 666 ; 667TGraphMultiErrors::TGraphMultiErrors(const TH1 *pass, const TH1 *total",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:26555,Availability,error,errors,26555,"SE;; 725 }; 726 ; 727 fExL = new Double_t[fMaxSize];; 728 fExH = new Double_t[fMaxSize];; 729 fEyL.resize(fNYErrors, TArrayD(fMaxSize));; 730 fEyH.resize(fNYErrors, TArrayD(fMaxSize));; 731 fEyLSum = new Double_t[fMaxSize];; 732 fEyHSum = new Double_t[fMaxSize];; 733 fAttFill.resize(fNYErrors);; 734 fAttLine.resize(fNYErrors);; 735 ; 736 Int_t n = fMaxSize * sizeof(Double_t);; 737 memset(fExL, 0, n);; 738 memset(fExH, 0, n);; 739 memset(fEyLSum, 0, n);; 740 memset(fEyHSum, 0, n);; 741 ; 742 return kTRUE;; 743}; 744 ; 745////////////////////////////////////////////////////////////////////////////////; 746/// Copy and release.; 747 ; 748void TGraphMultiErrors::CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin); 749{; 750 CopyPoints(newarrays, ibegin, iend, obegin);; 751 if (newarrays) {; 752 delete[] fX;; 753 fX = newarrays[0];; 754 delete[] fY;; 755 fY = newarrays[1];; 756 ; 757 delete[] fExL;; 758 fExL = newarrays[2];; 759 delete[] fExH;; 760 fExH = newarrays[3];; 761 ; 762 if (fEyLSum); 763 delete[] fEyLSum;; 764 fEyLSum = newarrays[4];; 765 if (fEyHSum); 766 delete[] fEyHSum;; 767 fEyHSum = newarrays[5];; 768 ; 769 delete[] newarrays;; 770 }; 771}; 772 ; 773////////////////////////////////////////////////////////////////////////////////; 774/// Copy errors from `fE***` to `arrays[***]`; 775/// or to `f***` Copy points.; 776 ; 777Bool_t TGraphMultiErrors::CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin); 778{; 779 if (TGraph::CopyPoints(arrays, ibegin, iend, obegin)) {; 780 Int_t n = (iend - ibegin) * sizeof(Double_t);; 781 ; 782 if (arrays) {; 783 memmove(&arrays[2][obegin], &fExL[ibegin], n);; 784 memmove(&arrays[3][obegin], &fExH[ibegin], n);; 785 memmove(&arrays[4][obegin], &fEyLSum[ibegin], n);; 786 memmove(&arrays[5][obegin], &fEyHSum[ibegin], n);; 787 } else {; 788 memmove(&fExL[obegin], &fExL[ibegin], n);; 789 memmove(&fExH[obegin], &fExH[ibegin], n);; 790 memmove(&fEyLSum[obegin], &fEyLSum[ibegin], n);; 791 me",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:28168,Availability,error,error,28168,"7 } else {; 788 memmove(&fExL[obegin], &fExL[ibegin], n);; 789 memmove(&fExH[obegin], &fExH[ibegin], n);; 790 memmove(&fEyLSum[obegin], &fEyLSum[ibegin], n);; 791 memmove(&fEyHSum[obegin], &fEyHSum[ibegin], n);; 792 }; 793 ; 794 return kTRUE;; 795 } else; 796 return kFALSE;; 797}; 798 ; 799////////////////////////////////////////////////////////////////////////////////; 800/// Set zero values for point arrays in the range `[begin, end]`.; 801 ; 802void TGraphMultiErrors::FillZero(Int_t begin, Int_t end, Bool_t from_ctor); 803{; 804 if (!from_ctor); 805 TGraph::FillZero(begin, end, from_ctor);; 806 ; 807 Int_t n = (end - begin) * sizeof(Double_t);; 808 memset(fExL + begin, 0, n);; 809 memset(fExH + begin, 0, n);; 810 memset(fEyLSum + begin, 0, n);; 811 memset(fEyHSum + begin, 0, n);; 812 ; 813 for (Int_t j = 0; j < fNYErrors; j++) {; 814 memset(fEyL[j].GetArray() + begin, 0, n);; 815 memset(fEyH[j].GetArray() + begin, 0, n);; 816 }; 817}; 818 ; 819////////////////////////////////////////////////////////////////////////////////; 820/// Recalculates the summed y error arrays.; 821 ; 822void TGraphMultiErrors::CalcYErrorsSum() const; 823{; 824 if (!fEyLSum); 825 fEyLSum = new Double_t[fNpoints];; 826 if (!fEyHSum); 827 fEyHSum = new Double_t[fNpoints];; 828 ; 829 for (Int_t i = 0; i < fNpoints; i++) {; 830 fEyLSum[i] = GetErrorYlow(i);; 831 fEyHSum[i] = GetErrorYhigh(i);; 832 }; 833}; 834 ; 835////////////////////////////////////////////////////////////////////////////////; 836/// Protected function to perform the merge operation of a graph with multiple asymmetric errors.; 837 ; 838Bool_t TGraphMultiErrors::DoMerge(const TGraph *tg); 839{; 840 if (tg->GetN() == 0); 841 return kFALSE;; 842 ; 843 if (tg->IsA() == TGraphMultiErrors::Class()) {; 844 auto tgme = (TGraphMultiErrors *)tg;; 845 ; 846 for (Int_t i = 0; i < tgme->GetN(); i++) {; 847 Int_t ipoint = GetN();; 848 Double_t x, y;; 849 tgme->GetPoint(i, x, y);; 850 SetPoint(ipoint, x, y);; 851 SetPointEX(ipoint, tgme-",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:28680,Availability,error,errors,28680,"/////////////////////////////; 800/// Set zero values for point arrays in the range `[begin, end]`.; 801 ; 802void TGraphMultiErrors::FillZero(Int_t begin, Int_t end, Bool_t from_ctor); 803{; 804 if (!from_ctor); 805 TGraph::FillZero(begin, end, from_ctor);; 806 ; 807 Int_t n = (end - begin) * sizeof(Double_t);; 808 memset(fExL + begin, 0, n);; 809 memset(fExH + begin, 0, n);; 810 memset(fEyLSum + begin, 0, n);; 811 memset(fEyHSum + begin, 0, n);; 812 ; 813 for (Int_t j = 0; j < fNYErrors; j++) {; 814 memset(fEyL[j].GetArray() + begin, 0, n);; 815 memset(fEyH[j].GetArray() + begin, 0, n);; 816 }; 817}; 818 ; 819////////////////////////////////////////////////////////////////////////////////; 820/// Recalculates the summed y error arrays.; 821 ; 822void TGraphMultiErrors::CalcYErrorsSum() const; 823{; 824 if (!fEyLSum); 825 fEyLSum = new Double_t[fNpoints];; 826 if (!fEyHSum); 827 fEyHSum = new Double_t[fNpoints];; 828 ; 829 for (Int_t i = 0; i < fNpoints; i++) {; 830 fEyLSum[i] = GetErrorYlow(i);; 831 fEyHSum[i] = GetErrorYhigh(i);; 832 }; 833}; 834 ; 835////////////////////////////////////////////////////////////////////////////////; 836/// Protected function to perform the merge operation of a graph with multiple asymmetric errors.; 837 ; 838Bool_t TGraphMultiErrors::DoMerge(const TGraph *tg); 839{; 840 if (tg->GetN() == 0); 841 return kFALSE;; 842 ; 843 if (tg->IsA() == TGraphMultiErrors::Class()) {; 844 auto tgme = (TGraphMultiErrors *)tg;; 845 ; 846 for (Int_t i = 0; i < tgme->GetN(); i++) {; 847 Int_t ipoint = GetN();; 848 Double_t x, y;; 849 tgme->GetPoint(i, x, y);; 850 SetPoint(ipoint, x, y);; 851 SetPointEX(ipoint, tgme->GetErrorXlow(i), tgme->GetErrorXhigh(i));; 852 for (Int_t j = 0; j < tgme->GetNYErrors(); j++); 853 SetPointEY(ipoint, j, tgme->GetErrorYlow(i, j), tgme->GetErrorYhigh(i, j));; 854 }; 855 ; 856 return kTRUE;; 857 } else {; 858 Warning(""DoMerge"", ""Merging a %s is not compatible with a TGraphMultiErrors - Errors will be ignored"",; 859 tg->Is",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:31734,Availability,error,error,31734,");; 894 ; 895 std::copy(fExLSorted.begin(), fExLSorted.end(), fExL + low);; 896 std::copy(fExHSorted.begin(), fExHSorted.end(), fExH + low);; 897 ; 898 for (Int_t j = 0; j < fNYErrors; j++) {; 899 std::vector<Double_t> fEyLSorted(numSortedPoints);; 900 std::vector<Double_t> fEyHSorted(numSortedPoints);; 901 ; 902 std::generate(fEyLSorted.begin(), fEyLSorted.end(),; 903 [begin = low, &sorting_indices, &j, this]() mutable { return fEyL[j].GetArray()[sorting_indices[begin++]]; });; 904 std::generate(fEyHSorted.begin(), fEyHSorted.end(),; 905 [begin = low, &sorting_indices, &j, this]() mutable { return fEyL[j].GetArray()[sorting_indices[begin++]]; });; 906 ; 907 std::copy(fEyLSorted.begin(), fEyLSorted.end(), fEyL[j].GetArray() + low);; 908 std::copy(fEyHSorted.begin(), fEyHSorted.end(), fEyL[j].GetArray() + low);; 909 }; 910 ; 911 TGraph::UpdateArrays(sorting_indices, numSortedPoints, low);; 912}; 913 ; 914////////////////////////////////////////////////////////////////////////////////; 915/// Add a new y error to the graph and fill it with the values from `eyL` and `eyH`; 916 ; 917void TGraphMultiErrors::AddYError(Int_t np, const Double_t *eyL, const Double_t *eyH); 918{; 919 fEyL.emplace_back(np, eyL);; 920 fEyH.emplace_back(np, eyH);; 921 fEyL.back().Set(fNpoints);; 922 fEyH.back().Set(fNpoints);; 923 fAttFill.emplace_back();; 924 fAttLine.emplace_back();; 925 ; 926 fNYErrors += 1;; 927 ; 928 CalcYErrorsSum();; 929}; 930 ; 931////////////////////////////////////////////////////////////////////////////////; 932/// Allocate internal data structures for `size` points.; 933Double_t **TGraphMultiErrors::Allocate(Int_t size); 934{; 935 return AllocateArrays(6, size);; 936}; 937 ; 938////////////////////////////////////////////////////////////////////////////////; 939/// Apply a function to all data points \f$ y = f(x,y) \f$.; 940///; 941/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 942/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 943///; 944/// Only the first er",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:32715,Availability,error,error,32715,"///////////////////////////////////////////////////////////; 915/// Add a new y error to the graph and fill it with the values from `eyL` and `eyH`; 916 ; 917void TGraphMultiErrors::AddYError(Int_t np, const Double_t *eyL, const Double_t *eyH); 918{; 919 fEyL.emplace_back(np, eyL);; 920 fEyH.emplace_back(np, eyH);; 921 fEyL.back().Set(fNpoints);; 922 fEyH.back().Set(fNpoints);; 923 fAttFill.emplace_back();; 924 fAttLine.emplace_back();; 925 ; 926 fNYErrors += 1;; 927 ; 928 CalcYErrorsSum();; 929}; 930 ; 931////////////////////////////////////////////////////////////////////////////////; 932/// Allocate internal data structures for `size` points.; 933Double_t **TGraphMultiErrors::Allocate(Int_t size); 934{; 935 return AllocateArrays(6, size);; 936}; 937 ; 938////////////////////////////////////////////////////////////////////////////////; 939/// Apply a function to all data points \f$ y = f(x,y) \f$.; 940///; 941/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 942/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 943///; 944/// Only the first error dimension is affected.; 945///; 946/// Special treatment has to be applied for the functions where the; 947/// role of ""up"" and ""down"" is reversed.; 948///; 949/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 950 ; 951void TGraphMultiErrors::Apply(TF1 *f); 952{; 953 Double_t x, y, eyL, eyH, eyLNew, eyHNew, fxy;; 954 ; 955 if (fHistogram) {; 956 delete fHistogram;; 957 fHistogram = nullptr;; 958 }; 959 ; 960 for (Int_t i = 0; i < fNpoints; i++) {; 961 GetPoint(i, x, y);; 962 eyL = GetErrorYlow(i, 0);; 963 eyH = GetErrorYhigh(i, 0);; 964 ; 965 fxy = f->Eval(x, y);; 966 SetPoint(i, x, fxy);; 967 ; 968 if (f->Eval(x, y - eyL) < f->Eval(x, y + eyH)) {; 969 eyLNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 970 eyHNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 971 } else {; 972 eyHNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 973 eyLNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 974 }; 975 ; 976 // sy",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:32850,Availability,down,down,32850,"6 ; 917void TGraphMultiErrors::AddYError(Int_t np, const Double_t *eyL, const Double_t *eyH); 918{; 919 fEyL.emplace_back(np, eyL);; 920 fEyH.emplace_back(np, eyH);; 921 fEyL.back().Set(fNpoints);; 922 fEyH.back().Set(fNpoints);; 923 fAttFill.emplace_back();; 924 fAttLine.emplace_back();; 925 ; 926 fNYErrors += 1;; 927 ; 928 CalcYErrorsSum();; 929}; 930 ; 931////////////////////////////////////////////////////////////////////////////////; 932/// Allocate internal data structures for `size` points.; 933Double_t **TGraphMultiErrors::Allocate(Int_t size); 934{; 935 return AllocateArrays(6, size);; 936}; 937 ; 938////////////////////////////////////////////////////////////////////////////////; 939/// Apply a function to all data points \f$ y = f(x,y) \f$.; 940///; 941/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 942/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 943///; 944/// Only the first error dimension is affected.; 945///; 946/// Special treatment has to be applied for the functions where the; 947/// role of ""up"" and ""down"" is reversed.; 948///; 949/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 950 ; 951void TGraphMultiErrors::Apply(TF1 *f); 952{; 953 Double_t x, y, eyL, eyH, eyLNew, eyHNew, fxy;; 954 ; 955 if (fHistogram) {; 956 delete fHistogram;; 957 fHistogram = nullptr;; 958 }; 959 ; 960 for (Int_t i = 0; i < fNpoints; i++) {; 961 GetPoint(i, x, y);; 962 eyL = GetErrorYlow(i, 0);; 963 eyH = GetErrorYhigh(i, 0);; 964 ; 965 fxy = f->Eval(x, y);; 966 SetPoint(i, x, fxy);; 967 ; 968 if (f->Eval(x, y - eyL) < f->Eval(x, y + eyH)) {; 969 eyLNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 970 eyHNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 971 } else {; 972 eyHNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 973 eyLNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 974 }; 975 ; 976 // systematic errors and error on x doesn't change; 977 SetPointEY(i, 0, eyLNew, eyHNew);; 978 }; 979 ; 980 if (gPad); 981 gPad->Modified();; 982}; 983 ; 98",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:33664,Availability,error,errors,33664,"//////////////////////////////////////////////////; 939/// Apply a function to all data points \f$ y = f(x,y) \f$.; 940///; 941/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 942/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 943///; 944/// Only the first error dimension is affected.; 945///; 946/// Special treatment has to be applied for the functions where the; 947/// role of ""up"" and ""down"" is reversed.; 948///; 949/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 950 ; 951void TGraphMultiErrors::Apply(TF1 *f); 952{; 953 Double_t x, y, eyL, eyH, eyLNew, eyHNew, fxy;; 954 ; 955 if (fHistogram) {; 956 delete fHistogram;; 957 fHistogram = nullptr;; 958 }; 959 ; 960 for (Int_t i = 0; i < fNpoints; i++) {; 961 GetPoint(i, x, y);; 962 eyL = GetErrorYlow(i, 0);; 963 eyH = GetErrorYhigh(i, 0);; 964 ; 965 fxy = f->Eval(x, y);; 966 SetPoint(i, x, fxy);; 967 ; 968 if (f->Eval(x, y - eyL) < f->Eval(x, y + eyH)) {; 969 eyLNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 970 eyHNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 971 } else {; 972 eyHNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 973 eyLNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 974 }; 975 ; 976 // systematic errors and error on x doesn't change; 977 SetPointEY(i, 0, eyLNew, eyHNew);; 978 }; 979 ; 980 if (gPad); 981 gPad->Modified();; 982}; 983 ; 984////////////////////////////////////////////////////////////////////////////////; 985/// This function is only kept for backward compatibility.; 986/// You should rather use the Divide method.; 987/// It calls `Divide(pass,total,""cl=0.683 b(1,1) mode"")` which is equivalent to the; 988/// former BayesDivide method.; 989 ; 990void TGraphMultiErrors::BayesDivide(const TH1 *pass, const TH1 *total, Option_t *); 991{; 992 Divide(pass, total, ""cl=0.683 b(1,1) mode"");; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// This function was adapted from the TGraphAsymmErrors class.; 997/// See TGra",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:33675,Availability,error,error,33675,"//////////////////////////////////////////////////; 939/// Apply a function to all data points \f$ y = f(x,y) \f$.; 940///; 941/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 942/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 943///; 944/// Only the first error dimension is affected.; 945///; 946/// Special treatment has to be applied for the functions where the; 947/// role of ""up"" and ""down"" is reversed.; 948///; 949/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 950 ; 951void TGraphMultiErrors::Apply(TF1 *f); 952{; 953 Double_t x, y, eyL, eyH, eyLNew, eyHNew, fxy;; 954 ; 955 if (fHistogram) {; 956 delete fHistogram;; 957 fHistogram = nullptr;; 958 }; 959 ; 960 for (Int_t i = 0; i < fNpoints; i++) {; 961 GetPoint(i, x, y);; 962 eyL = GetErrorYlow(i, 0);; 963 eyH = GetErrorYhigh(i, 0);; 964 ; 965 fxy = f->Eval(x, y);; 966 SetPoint(i, x, fxy);; 967 ; 968 if (f->Eval(x, y - eyL) < f->Eval(x, y + eyH)) {; 969 eyLNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 970 eyHNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 971 } else {; 972 eyHNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 973 eyLNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 974 }; 975 ; 976 // systematic errors and error on x doesn't change; 977 SetPointEY(i, 0, eyLNew, eyHNew);; 978 }; 979 ; 980 if (gPad); 981 gPad->Modified();; 982}; 983 ; 984////////////////////////////////////////////////////////////////////////////////; 985/// This function is only kept for backward compatibility.; 986/// You should rather use the Divide method.; 987/// It calls `Divide(pass,total,""cl=0.683 b(1,1) mode"")` which is equivalent to the; 988/// former BayesDivide method.; 989 ; 990void TGraphMultiErrors::BayesDivide(const TH1 *pass, const TH1 *total, Option_t *); 991{; 992 Divide(pass, total, ""cl=0.683 b(1,1) mode"");; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// This function was adapted from the TGraphAsymmErrors class.; 997/// See TGra",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:34528,Availability,error,error,34528," + eyH) - fxy);; 971 } else {; 972 eyHNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 973 eyLNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 974 }; 975 ; 976 // systematic errors and error on x doesn't change; 977 SetPointEY(i, 0, eyLNew, eyHNew);; 978 }; 979 ; 980 if (gPad); 981 gPad->Modified();; 982}; 983 ; 984////////////////////////////////////////////////////////////////////////////////; 985/// This function is only kept for backward compatibility.; 986/// You should rather use the Divide method.; 987/// It calls `Divide(pass,total,""cl=0.683 b(1,1) mode"")` which is equivalent to the; 988/// former BayesDivide method.; 989 ; 990void TGraphMultiErrors::BayesDivide(const TH1 *pass, const TH1 *total, Option_t *); 991{; 992 Divide(pass, total, ""cl=0.683 b(1,1) mode"");; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// This function was adapted from the TGraphAsymmErrors class.; 997/// See TGraphAsymmErrors::Divide for the documentation; 998///; 999/// Only the first error dimension is affected.; 1000 ; 1001void TGraphMultiErrors::Divide(const TH1 *pass, const TH1 *total, Option_t *opt); 1002{; 1003 // check pointers; 1004 if (!pass || !total) {; 1005 Error(""Divide"", ""one of the passed pointers is zero"");; 1006 return;; 1007 }; 1008 ; 1009 // check dimension of histograms; only 1-dimensional ones are accepted; 1010 if ((pass->GetDimension() > 1) || (total->GetDimension() > 1)) {; 1011 Error(""Divide"", ""passed histograms are not one-dimensional"");; 1012 return;; 1013 }; 1014 ; 1015 // check whether histograms are filled with weights -> use number of effective; 1016 // entries; 1017 Bool_t bEffective = false;; 1018 // compare sum of weights with sum of squares of weights; 1019 // re-compute here to be sure to get the right values; 1020 Double_t psumw = 0;; 1021 Double_t psumw2 = 0;; 1022 if (pass->GetSumw2()->fN > 0) {; 1023 for (int i = 0; i < pass->GetNbinsX(); ++i) {; 1024 psumw += pass->GetBinContent(i);; 1025 psumw",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:40294,Availability,error,error,40294," && (option.Contains(""sh"") || (usePosteriorMode && !option.Contains(""cen"")))) {; 1156 useShortestInterval = true;; 1157 }; 1158 ; 1159 // interpret as Poisson ratio; 1160 Bool_t bPoissonRatio = false;; 1161 if (option.Contains(""pois"")) {; 1162 bPoissonRatio = true;; 1163 option.ReplaceAll(""pois"", """");; 1164 }; 1165 ; 1166 // weights works only in case of Normal approximation or Bayesian for binomial interval; 1167 // in case of Poisson ratio we can use weights by rescaling the obtained results using the effective entries; 1168 if ((bEffective && !bPoissonRatio) && !bIsBayesian && pBound != &TEfficiency::Normal) {; 1169 Warning(""Divide"", ""Histograms have weights: only Normal or Bayesian error calculation is supported"");; 1170 Info(""Divide"", ""Using now the Normal approximation for weighted histograms"");; 1171 }; 1172 ; 1173 if (bPoissonRatio) {; 1174 if (pass->GetDimension() != total->GetDimension()) {; 1175 Error(""Divide"", ""passed histograms are not of the same dimension"");; 1176 return;; 1177 }; 1178 ; 1179 if (!TEfficiency::CheckBinning(*pass, *total)) {; 1180 Error(""Divide"", ""passed histograms are not consistent"");; 1181 return;; 1182 }; 1183 } else {; 1184 // check consistency of histograms, allowing weights; 1185 if (!TEfficiency::CheckConsistency(*pass, *total, ""w"")) {; 1186 Error(""Divide"", ""passed histograms are not consistent"");; 1187 return;; 1188 }; 1189 }; 1190 ; 1191 // Set the graph to have a number of points equal to the number of histogram; 1192 // bins; 1193 Int_t nbins = pass->GetNbinsX();; 1194 Set(nbins);; 1195 ; 1196 // Ok, now set the points for each bin; 1197 // (Note: the TH1 bin content is shifted to the right by one:; 1198 // bin=0 is underflow, bin=nbins+1 is overflow.); 1199 ; 1200 // this keeps track of the number of points added to the graph; 1201 Int_t npoint = 0;; 1202 // number of total and passed events; 1203 Double_t t = 0, p = 0;; 1204 Double_t tw = 0, tw2 = 0, pw = 0, pw2 = 0, wratio = 1; // for the case of weights; 1205 // loop ove",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:44121,Availability,error,errors,44121," with total <= 0; 1256 ; 1257 // in the case of weights have the formula only for; 1258 // the normal and bayesian statistics (see below); 1259 ; 1260 }; 1261 ; 1262 // use bin contents; 1263 else {; 1264 t = TMath::Nint(total->GetBinContent(b));; 1265 p = TMath::Nint(pass->GetBinContent(b));; 1266 ; 1267 if (bPoissonRatio); 1268 t += p;; 1269 ; 1270 if (t == 0. && !plot0Bins); 1271 continue; // skip bins with total = 0; 1272 }; 1273 ; 1274 // using bayesian statistics; 1275 if (bIsBayesian) {; 1276 if ((bEffective && !bPoissonRatio) && tw2 <= 0) {; 1277 // case of bins with zero errors; 1278 eff = pw / tw;; 1279 low = eff;; 1280 upper = eff;; 1281 } else {; 1282 Double_t aa, bb;; 1283 ; 1284 if (bEffective && !bPoissonRatio) {; 1285 // tw/tw2 re-normalize the weights; 1286 double norm = tw / tw2; // case of tw2 = 0 is treated above; 1287 aa = pw * norm + alpha;; 1288 bb = (tw - pw) * norm + beta;; 1289 } else {; 1290 aa = double(p) + alpha;; 1291 bb = double(t - p) + beta;; 1292 }; 1293 if (usePosteriorMode); 1294 eff = TEfficiency::BetaMode(aa, bb);; 1295 else; 1296 eff = TEfficiency::BetaMean(aa, bb);; 1297 ; 1298 if (useShortestInterval) {; 1299 TEfficiency::BetaShortestInterval(conf, aa, bb, low, upper);; 1300 } else {; 1301 low = TEfficiency::BetaCentralInterval(conf, aa, bb, false);; 1302 upper = TEfficiency::BetaCentralInterval(conf, aa, bb, true);; 1303 }; 1304 }; 1305 }; 1306 // case of non-bayesian statistics; 1307 else {; 1308 if (bEffective && !bPoissonRatio) {; 1309 ; 1310 if (tw > 0) {; 1311 ; 1312 eff = pw / tw;; 1313 ; 1314 // use normal error calculation using variance of MLE with weights (F.James 8.5.2); 1315 // this is the same formula used in ROOT for TH1::Divide(""B""); 1316 ; 1317 double variance = (pw2 * (1. - 2 * eff) + tw2 * eff * eff) / (tw * tw);; 1318 double sigma = sqrt(variance);; 1319 ; 1320 double prob = 0.5 * (1. - conf);; 1321 double delta = ROOT::Math::normal_quantile_c(prob, sigma);; 1322 low = eff - delta;; 1323 upper = eff + delta",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:45115,Availability,error,error,45115," with total <= 0; 1256 ; 1257 // in the case of weights have the formula only for; 1258 // the normal and bayesian statistics (see below); 1259 ; 1260 }; 1261 ; 1262 // use bin contents; 1263 else {; 1264 t = TMath::Nint(total->GetBinContent(b));; 1265 p = TMath::Nint(pass->GetBinContent(b));; 1266 ; 1267 if (bPoissonRatio); 1268 t += p;; 1269 ; 1270 if (t == 0. && !plot0Bins); 1271 continue; // skip bins with total = 0; 1272 }; 1273 ; 1274 // using bayesian statistics; 1275 if (bIsBayesian) {; 1276 if ((bEffective && !bPoissonRatio) && tw2 <= 0) {; 1277 // case of bins with zero errors; 1278 eff = pw / tw;; 1279 low = eff;; 1280 upper = eff;; 1281 } else {; 1282 Double_t aa, bb;; 1283 ; 1284 if (bEffective && !bPoissonRatio) {; 1285 // tw/tw2 re-normalize the weights; 1286 double norm = tw / tw2; // case of tw2 = 0 is treated above; 1287 aa = pw * norm + alpha;; 1288 bb = (tw - pw) * norm + beta;; 1289 } else {; 1290 aa = double(p) + alpha;; 1291 bb = double(t - p) + beta;; 1292 }; 1293 if (usePosteriorMode); 1294 eff = TEfficiency::BetaMode(aa, bb);; 1295 else; 1296 eff = TEfficiency::BetaMean(aa, bb);; 1297 ; 1298 if (useShortestInterval) {; 1299 TEfficiency::BetaShortestInterval(conf, aa, bb, low, upper);; 1300 } else {; 1301 low = TEfficiency::BetaCentralInterval(conf, aa, bb, false);; 1302 upper = TEfficiency::BetaCentralInterval(conf, aa, bb, true);; 1303 }; 1304 }; 1305 }; 1306 // case of non-bayesian statistics; 1307 else {; 1308 if (bEffective && !bPoissonRatio) {; 1309 ; 1310 if (tw > 0) {; 1311 ; 1312 eff = pw / tw;; 1313 ; 1314 // use normal error calculation using variance of MLE with weights (F.James 8.5.2); 1315 // this is the same formula used in ROOT for TH1::Divide(""B""); 1316 ; 1317 double variance = (pw2 * (1. - 2 * eff) + tw2 * eff * eff) / (tw * tw);; 1318 double sigma = sqrt(variance);; 1319 ; 1320 double prob = 0.5 * (1. - conf);; 1321 double delta = ROOT::Math::normal_quantile_c(prob, sigma);; 1322 low = eff - delta;; 1323 upper = eff + delta",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:46315,Availability,error,errors,46315,"r > 1); 1327 upper = 1.;; 1328 }; 1329 } else {; 1330 // when not using weights (all cases) or in case of Poisson ratio with weights; 1331 if (t != 0.); 1332 eff = ((Double_t)p) / t;; 1333 ; 1334 low = pBound(t, p, conf, false);; 1335 upper = pBound(t, p, conf, true);; 1336 }; 1337 }; 1338 // treat as Poisson ratio; 1339 if (bPoissonRatio) {; 1340 Double_t ratio = eff / (1 - eff);; 1341 // take the intervals in eff as intervals in the Poisson ratio; 1342 low = low / (1. - low);; 1343 upper = upper / (1. - upper);; 1344 eff = ratio;; 1345 if (bEffective) {; 1346 // scale result by the ratio of the weight; 1347 eff *= wratio;; 1348 low *= wratio;; 1349 upper *= wratio;; 1350 }; 1351 }; 1352 // Set the point center and its errors; 1353 if (TMath::Finite(eff)) {; 1354 SetPoint(npoint, pass->GetBinCenter(b), eff);; 1355 SetPointEX(npoint, pass->GetBinCenter(b) - pass->GetBinLowEdge(b),; 1356 pass->GetBinLowEdge(b) - pass->GetBinCenter(b) + pass->GetBinWidth(b));; 1357 SetPointEY(npoint, 0, eff - low, upper - eff);; 1358 npoint++; // we have added a point to the graph; 1359 }; 1360 }; 1361 ; 1362 Set(npoint); // tell the graph how many points we've really added; 1363 if (npoint < nbins); 1364 Warning(""Divide"", ""Number of graph points is different than histogram bins - %d points have been skipped"",; 1365 nbins - npoint);; 1366 ; 1367 if (bVerbose) {; 1368 Info(""Divide"", ""made a graph with %d points from %d bins"", npoint, nbins);; 1369 Info(""Divide"", ""used confidence level: %.2lf\n"", conf);; 1370 if (bIsBayesian); 1371 Info(""Divide"", ""used prior probability ~ beta(%.2lf,%.2lf)"", alpha, beta);; 1372 Print();; 1373 }; 1374}; 1375 ; 1376////////////////////////////////////////////////////////////////////////////////; 1377/// Compute Range.; 1378 ; 1379void TGraphMultiErrors::ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const; 1380{; 1381 TGraph::ComputeRange(xmin, ymin, xmax, ymax);; 1382 ; 1383 for (Int_t i = 0; i < fNpoints; i++) {; 1384 if (fX",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:48514,Availability,error,error,48514,"t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const; 1380{; 1381 TGraph::ComputeRange(xmin, ymin, xmax, ymax);; 1382 ; 1383 for (Int_t i = 0; i < fNpoints; i++) {; 1384 if (fX[i] - fExL[i] < xmin) {; 1385 if (gPad && gPad->GetLogx()) {; 1386 if (fExL[i] < fX[i]); 1387 xmin = fX[i] - fExL[i];; 1388 else; 1389 xmin = TMath::Min(xmin, fX[i] / 3.);; 1390 } else; 1391 xmin = fX[i] - fExL[i];; 1392 }; 1393 ; 1394 if (fX[i] + fExH[i] > xmax); 1395 xmax = fX[i] + fExH[i];; 1396 ; 1397 Double_t eyLMax = 0., eyHMax = 0.;; 1398 for (Int_t j = 0; j < fNYErrors; j++) {; 1399 eyLMax = TMath::Max(eyLMax, fEyL[j][i]);; 1400 eyHMax = TMath::Max(eyHMax, fEyH[j][i]);; 1401 }; 1402 ; 1403 if (fY[i] - eyLMax < ymin) {; 1404 if (gPad && gPad->GetLogy()) {; 1405 if (eyLMax < fY[i]); 1406 ymin = fY[i] - eyLMax;; 1407 else; 1408 ymin = TMath::Min(ymin, fY[i] / 3.);; 1409 } else; 1410 ymin = fY[i] - eyLMax;; 1411 }; 1412 ; 1413 if (fY[i] + eyHMax > ymax); 1414 ymax = fY[i] + eyHMax;; 1415 }; 1416}; 1417 ; 1418////////////////////////////////////////////////////////////////////////////////; 1419/// Deletes the y error with the index `e`.; 1420/// Note that you must keep at least 1 error; 1421 ; 1422void TGraphMultiErrors::DeleteYError(Int_t e); 1423{; 1424 if (fNYErrors == 1 || e >= fNYErrors); 1425 return;; 1426 ; 1427 fEyL.erase(fEyL.begin() + e);; 1428 fEyH.erase(fEyH.begin() + e);; 1429 fAttFill.erase(fAttFill.begin() + e);; 1430 fAttLine.erase(fAttLine.begin() + e);; 1431 ; 1432 fNYErrors -= 1;; 1433}; 1434 ; 1435////////////////////////////////////////////////////////////////////////////////; 1436/// Get error on x coordinate for point `i`.; 1437/// In case of asymmetric errors the mean of the square sum is returned; 1438 ; 1439Double_t TGraphMultiErrors::GetErrorX(Int_t i) const; 1440{; 1441 if (i < 0 || i >= fNpoints || (!fExL && !fExH)); 1442 return -1.;; 1443 ; 1444 Double_t exL = fExL ? fExL[i] : 0.;; 1445 Double_t exH = fExH ? fExH[i] : 0.;; 1446 return TMath::Sqrt((exL",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:48584,Availability,error,error,48584,"etLogx()) {; 1386 if (fExL[i] < fX[i]); 1387 xmin = fX[i] - fExL[i];; 1388 else; 1389 xmin = TMath::Min(xmin, fX[i] / 3.);; 1390 } else; 1391 xmin = fX[i] - fExL[i];; 1392 }; 1393 ; 1394 if (fX[i] + fExH[i] > xmax); 1395 xmax = fX[i] + fExH[i];; 1396 ; 1397 Double_t eyLMax = 0., eyHMax = 0.;; 1398 for (Int_t j = 0; j < fNYErrors; j++) {; 1399 eyLMax = TMath::Max(eyLMax, fEyL[j][i]);; 1400 eyHMax = TMath::Max(eyHMax, fEyH[j][i]);; 1401 }; 1402 ; 1403 if (fY[i] - eyLMax < ymin) {; 1404 if (gPad && gPad->GetLogy()) {; 1405 if (eyLMax < fY[i]); 1406 ymin = fY[i] - eyLMax;; 1407 else; 1408 ymin = TMath::Min(ymin, fY[i] / 3.);; 1409 } else; 1410 ymin = fY[i] - eyLMax;; 1411 }; 1412 ; 1413 if (fY[i] + eyHMax > ymax); 1414 ymax = fY[i] + eyHMax;; 1415 }; 1416}; 1417 ; 1418////////////////////////////////////////////////////////////////////////////////; 1419/// Deletes the y error with the index `e`.; 1420/// Note that you must keep at least 1 error; 1421 ; 1422void TGraphMultiErrors::DeleteYError(Int_t e); 1423{; 1424 if (fNYErrors == 1 || e >= fNYErrors); 1425 return;; 1426 ; 1427 fEyL.erase(fEyL.begin() + e);; 1428 fEyH.erase(fEyH.begin() + e);; 1429 fAttFill.erase(fAttFill.begin() + e);; 1430 fAttLine.erase(fAttLine.begin() + e);; 1431 ; 1432 fNYErrors -= 1;; 1433}; 1434 ; 1435////////////////////////////////////////////////////////////////////////////////; 1436/// Get error on x coordinate for point `i`.; 1437/// In case of asymmetric errors the mean of the square sum is returned; 1438 ; 1439Double_t TGraphMultiErrors::GetErrorX(Int_t i) const; 1440{; 1441 if (i < 0 || i >= fNpoints || (!fExL && !fExH)); 1442 return -1.;; 1443 ; 1444 Double_t exL = fExL ? fExL[i] : 0.;; 1445 Double_t exH = fExH ? fExH[i] : 0.;; 1446 return TMath::Sqrt((exL * exL + exH * exH) / 2.);; 1447}; 1448 ; 1449////////////////////////////////////////////////////////////////////////////////; 1450/// Get error on y coordinate for point `i`.; 1451/// The multiple errors of the dimensions are summed ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:49022,Availability,error,error,49022,"ors; j++) {; 1399 eyLMax = TMath::Max(eyLMax, fEyL[j][i]);; 1400 eyHMax = TMath::Max(eyHMax, fEyH[j][i]);; 1401 }; 1402 ; 1403 if (fY[i] - eyLMax < ymin) {; 1404 if (gPad && gPad->GetLogy()) {; 1405 if (eyLMax < fY[i]); 1406 ymin = fY[i] - eyLMax;; 1407 else; 1408 ymin = TMath::Min(ymin, fY[i] / 3.);; 1409 } else; 1410 ymin = fY[i] - eyLMax;; 1411 }; 1412 ; 1413 if (fY[i] + eyHMax > ymax); 1414 ymax = fY[i] + eyHMax;; 1415 }; 1416}; 1417 ; 1418////////////////////////////////////////////////////////////////////////////////; 1419/// Deletes the y error with the index `e`.; 1420/// Note that you must keep at least 1 error; 1421 ; 1422void TGraphMultiErrors::DeleteYError(Int_t e); 1423{; 1424 if (fNYErrors == 1 || e >= fNYErrors); 1425 return;; 1426 ; 1427 fEyL.erase(fEyL.begin() + e);; 1428 fEyH.erase(fEyH.begin() + e);; 1429 fAttFill.erase(fAttFill.begin() + e);; 1430 fAttLine.erase(fAttLine.begin() + e);; 1431 ; 1432 fNYErrors -= 1;; 1433}; 1434 ; 1435////////////////////////////////////////////////////////////////////////////////; 1436/// Get error on x coordinate for point `i`.; 1437/// In case of asymmetric errors the mean of the square sum is returned; 1438 ; 1439Double_t TGraphMultiErrors::GetErrorX(Int_t i) const; 1440{; 1441 if (i < 0 || i >= fNpoints || (!fExL && !fExH)); 1442 return -1.;; 1443 ; 1444 Double_t exL = fExL ? fExL[i] : 0.;; 1445 Double_t exH = fExH ? fExH[i] : 0.;; 1446 return TMath::Sqrt((exL * exL + exH * exH) / 2.);; 1447}; 1448 ; 1449////////////////////////////////////////////////////////////////////////////////; 1450/// Get error on y coordinate for point `i`.; 1451/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1452/// In case of asymmetric errors the mean of the square sum is returned; 1453 ; 1454Double_t TGraphMultiErrors::GetErrorY(Int_t i) const; 1455{; 1456 if (i < 0 || i >= fNpoints || (fEyL.empty() && fEyH.empty())); 1457 return -1.;; 1458 ; 1459 Double_t eyL = GetErrorYlow(i);; 1460 Double_t e",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:49090,Availability,error,errors,49090,"Max < fY[i]); 1406 ymin = fY[i] - eyLMax;; 1407 else; 1408 ymin = TMath::Min(ymin, fY[i] / 3.);; 1409 } else; 1410 ymin = fY[i] - eyLMax;; 1411 }; 1412 ; 1413 if (fY[i] + eyHMax > ymax); 1414 ymax = fY[i] + eyHMax;; 1415 }; 1416}; 1417 ; 1418////////////////////////////////////////////////////////////////////////////////; 1419/// Deletes the y error with the index `e`.; 1420/// Note that you must keep at least 1 error; 1421 ; 1422void TGraphMultiErrors::DeleteYError(Int_t e); 1423{; 1424 if (fNYErrors == 1 || e >= fNYErrors); 1425 return;; 1426 ; 1427 fEyL.erase(fEyL.begin() + e);; 1428 fEyH.erase(fEyH.begin() + e);; 1429 fAttFill.erase(fAttFill.begin() + e);; 1430 fAttLine.erase(fAttLine.begin() + e);; 1431 ; 1432 fNYErrors -= 1;; 1433}; 1434 ; 1435////////////////////////////////////////////////////////////////////////////////; 1436/// Get error on x coordinate for point `i`.; 1437/// In case of asymmetric errors the mean of the square sum is returned; 1438 ; 1439Double_t TGraphMultiErrors::GetErrorX(Int_t i) const; 1440{; 1441 if (i < 0 || i >= fNpoints || (!fExL && !fExH)); 1442 return -1.;; 1443 ; 1444 Double_t exL = fExL ? fExL[i] : 0.;; 1445 Double_t exH = fExH ? fExH[i] : 0.;; 1446 return TMath::Sqrt((exL * exL + exH * exH) / 2.);; 1447}; 1448 ; 1449////////////////////////////////////////////////////////////////////////////////; 1450/// Get error on y coordinate for point `i`.; 1451/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1452/// In case of asymmetric errors the mean of the square sum is returned; 1453 ; 1454Double_t TGraphMultiErrors::GetErrorY(Int_t i) const; 1455{; 1456 if (i < 0 || i >= fNpoints || (fEyL.empty() && fEyH.empty())); 1457 return -1.;; 1458 ; 1459 Double_t eyL = GetErrorYlow(i);; 1460 Double_t eyH = GetErrorYhigh(i);; 1461 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1462}; 1463 ; 1464////////////////////////////////////////////////////////////////////////////////; 1465/// Get error e on y c",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:49540,Availability,error,error,49540,"Deletes the y error with the index `e`.; 1420/// Note that you must keep at least 1 error; 1421 ; 1422void TGraphMultiErrors::DeleteYError(Int_t e); 1423{; 1424 if (fNYErrors == 1 || e >= fNYErrors); 1425 return;; 1426 ; 1427 fEyL.erase(fEyL.begin() + e);; 1428 fEyH.erase(fEyH.begin() + e);; 1429 fAttFill.erase(fAttFill.begin() + e);; 1430 fAttLine.erase(fAttLine.begin() + e);; 1431 ; 1432 fNYErrors -= 1;; 1433}; 1434 ; 1435////////////////////////////////////////////////////////////////////////////////; 1436/// Get error on x coordinate for point `i`.; 1437/// In case of asymmetric errors the mean of the square sum is returned; 1438 ; 1439Double_t TGraphMultiErrors::GetErrorX(Int_t i) const; 1440{; 1441 if (i < 0 || i >= fNpoints || (!fExL && !fExH)); 1442 return -1.;; 1443 ; 1444 Double_t exL = fExL ? fExL[i] : 0.;; 1445 Double_t exH = fExH ? fExH[i] : 0.;; 1446 return TMath::Sqrt((exL * exL + exH * exH) / 2.);; 1447}; 1448 ; 1449////////////////////////////////////////////////////////////////////////////////; 1450/// Get error on y coordinate for point `i`.; 1451/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1452/// In case of asymmetric errors the mean of the square sum is returned; 1453 ; 1454Double_t TGraphMultiErrors::GetErrorY(Int_t i) const; 1455{; 1456 if (i < 0 || i >= fNpoints || (fEyL.empty() && fEyH.empty())); 1457 return -1.;; 1458 ; 1459 Double_t eyL = GetErrorYlow(i);; 1460 Double_t eyH = GetErrorYhigh(i);; 1461 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1462}; 1463 ; 1464////////////////////////////////////////////////////////////////////////////////; 1465/// Get error e on y coordinate for point `i`.; 1466/// In case of asymmetric errors the mean of the square sum is returned; 1467 ; 1468Double_t TGraphMultiErrors::GetErrorY(Int_t i, Int_t e) const; 1469{; 1470 if (i < 0 || i >= fNpoints || e >= fNYErrors || (fEyL.empty() && fEyH.empty())); 1471 return -1.;; 1472 ; 1473 Double_t eyL = fEyL.empty() ? 0.",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:49599,Availability,error,errors,49599,"rors::DeleteYError(Int_t e); 1423{; 1424 if (fNYErrors == 1 || e >= fNYErrors); 1425 return;; 1426 ; 1427 fEyL.erase(fEyL.begin() + e);; 1428 fEyH.erase(fEyH.begin() + e);; 1429 fAttFill.erase(fAttFill.begin() + e);; 1430 fAttLine.erase(fAttLine.begin() + e);; 1431 ; 1432 fNYErrors -= 1;; 1433}; 1434 ; 1435////////////////////////////////////////////////////////////////////////////////; 1436/// Get error on x coordinate for point `i`.; 1437/// In case of asymmetric errors the mean of the square sum is returned; 1438 ; 1439Double_t TGraphMultiErrors::GetErrorX(Int_t i) const; 1440{; 1441 if (i < 0 || i >= fNpoints || (!fExL && !fExH)); 1442 return -1.;; 1443 ; 1444 Double_t exL = fExL ? fExL[i] : 0.;; 1445 Double_t exH = fExH ? fExH[i] : 0.;; 1446 return TMath::Sqrt((exL * exL + exH * exH) / 2.);; 1447}; 1448 ; 1449////////////////////////////////////////////////////////////////////////////////; 1450/// Get error on y coordinate for point `i`.; 1451/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1452/// In case of asymmetric errors the mean of the square sum is returned; 1453 ; 1454Double_t TGraphMultiErrors::GetErrorY(Int_t i) const; 1455{; 1456 if (i < 0 || i >= fNpoints || (fEyL.empty() && fEyH.empty())); 1457 return -1.;; 1458 ; 1459 Double_t eyL = GetErrorYlow(i);; 1460 Double_t eyH = GetErrorYhigh(i);; 1461 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1462}; 1463 ; 1464////////////////////////////////////////////////////////////////////////////////; 1465/// Get error e on y coordinate for point `i`.; 1466/// In case of asymmetric errors the mean of the square sum is returned; 1467 ; 1468Double_t TGraphMultiErrors::GetErrorY(Int_t i, Int_t e) const; 1469{; 1470 if (i < 0 || i >= fNpoints || e >= fNYErrors || (fEyL.empty() && fEyH.empty())); 1471 return -1.;; 1472 ; 1473 Double_t eyL = fEyL.empty() ? 0. : fEyL[e][i];; 1474 Double_t eyH = fEyH.empty() ? 0. : fEyH[e][i];; 1475 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:49697,Availability,error,errors,49697," fEyH.erase(fEyH.begin() + e);; 1429 fAttFill.erase(fAttFill.begin() + e);; 1430 fAttLine.erase(fAttLine.begin() + e);; 1431 ; 1432 fNYErrors -= 1;; 1433}; 1434 ; 1435////////////////////////////////////////////////////////////////////////////////; 1436/// Get error on x coordinate for point `i`.; 1437/// In case of asymmetric errors the mean of the square sum is returned; 1438 ; 1439Double_t TGraphMultiErrors::GetErrorX(Int_t i) const; 1440{; 1441 if (i < 0 || i >= fNpoints || (!fExL && !fExH)); 1442 return -1.;; 1443 ; 1444 Double_t exL = fExL ? fExL[i] : 0.;; 1445 Double_t exH = fExH ? fExH[i] : 0.;; 1446 return TMath::Sqrt((exL * exL + exH * exH) / 2.);; 1447}; 1448 ; 1449////////////////////////////////////////////////////////////////////////////////; 1450/// Get error on y coordinate for point `i`.; 1451/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1452/// In case of asymmetric errors the mean of the square sum is returned; 1453 ; 1454Double_t TGraphMultiErrors::GetErrorY(Int_t i) const; 1455{; 1456 if (i < 0 || i >= fNpoints || (fEyL.empty() && fEyH.empty())); 1457 return -1.;; 1458 ; 1459 Double_t eyL = GetErrorYlow(i);; 1460 Double_t eyH = GetErrorYhigh(i);; 1461 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1462}; 1463 ; 1464////////////////////////////////////////////////////////////////////////////////; 1465/// Get error e on y coordinate for point `i`.; 1466/// In case of asymmetric errors the mean of the square sum is returned; 1467 ; 1468Double_t TGraphMultiErrors::GetErrorY(Int_t i, Int_t e) const; 1469{; 1470 if (i < 0 || i >= fNpoints || e >= fNYErrors || (fEyL.empty() && fEyH.empty())); 1471 return -1.;; 1472 ; 1473 Double_t eyL = fEyL.empty() ? 0. : fEyL[e][i];; 1474 Double_t eyH = fEyH.empty() ? 0. : fEyH[e][i];; 1475 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Get low error on x coordinat",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:50154,Availability,error,error,50154,"uare sum is returned; 1438 ; 1439Double_t TGraphMultiErrors::GetErrorX(Int_t i) const; 1440{; 1441 if (i < 0 || i >= fNpoints || (!fExL && !fExH)); 1442 return -1.;; 1443 ; 1444 Double_t exL = fExL ? fExL[i] : 0.;; 1445 Double_t exH = fExH ? fExH[i] : 0.;; 1446 return TMath::Sqrt((exL * exL + exH * exH) / 2.);; 1447}; 1448 ; 1449////////////////////////////////////////////////////////////////////////////////; 1450/// Get error on y coordinate for point `i`.; 1451/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1452/// In case of asymmetric errors the mean of the square sum is returned; 1453 ; 1454Double_t TGraphMultiErrors::GetErrorY(Int_t i) const; 1455{; 1456 if (i < 0 || i >= fNpoints || (fEyL.empty() && fEyH.empty())); 1457 return -1.;; 1458 ; 1459 Double_t eyL = GetErrorYlow(i);; 1460 Double_t eyH = GetErrorYhigh(i);; 1461 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1462}; 1463 ; 1464////////////////////////////////////////////////////////////////////////////////; 1465/// Get error e on y coordinate for point `i`.; 1466/// In case of asymmetric errors the mean of the square sum is returned; 1467 ; 1468Double_t TGraphMultiErrors::GetErrorY(Int_t i, Int_t e) const; 1469{; 1470 if (i < 0 || i >= fNpoints || e >= fNYErrors || (fEyL.empty() && fEyH.empty())); 1471 return -1.;; 1472 ; 1473 Double_t eyL = fEyL.empty() ? 0. : fEyL[e][i];; 1474 Double_t eyH = fEyH.empty() ? 0. : fEyH[e][i];; 1475 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Get low error on x coordinate for point `i`.; 1480 ; 1481Double_t TGraphMultiErrors::GetErrorXlow(Int_t i) const; 1482{; 1483 if (i < 0 || i >= fNpoints || !fExL); 1484 return -1.;; 1485 else; 1486 return fExL[i];; 1487}; 1488 ; 1489////////////////////////////////////////////////////////////////////////////////; 1490/// Get high error on x coordinate for point `i`.; 1491 ; 1492D",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:50224,Availability,error,errors,50224," exL = fExL ? fExL[i] : 0.;; 1445 Double_t exH = fExH ? fExH[i] : 0.;; 1446 return TMath::Sqrt((exL * exL + exH * exH) / 2.);; 1447}; 1448 ; 1449////////////////////////////////////////////////////////////////////////////////; 1450/// Get error on y coordinate for point `i`.; 1451/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1452/// In case of asymmetric errors the mean of the square sum is returned; 1453 ; 1454Double_t TGraphMultiErrors::GetErrorY(Int_t i) const; 1455{; 1456 if (i < 0 || i >= fNpoints || (fEyL.empty() && fEyH.empty())); 1457 return -1.;; 1458 ; 1459 Double_t eyL = GetErrorYlow(i);; 1460 Double_t eyH = GetErrorYhigh(i);; 1461 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1462}; 1463 ; 1464////////////////////////////////////////////////////////////////////////////////; 1465/// Get error e on y coordinate for point `i`.; 1466/// In case of asymmetric errors the mean of the square sum is returned; 1467 ; 1468Double_t TGraphMultiErrors::GetErrorY(Int_t i, Int_t e) const; 1469{; 1470 if (i < 0 || i >= fNpoints || e >= fNYErrors || (fEyL.empty() && fEyH.empty())); 1471 return -1.;; 1472 ; 1473 Double_t eyL = fEyL.empty() ? 0. : fEyL[e][i];; 1474 Double_t eyH = fEyH.empty() ? 0. : fEyH[e][i];; 1475 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Get low error on x coordinate for point `i`.; 1480 ; 1481Double_t TGraphMultiErrors::GetErrorXlow(Int_t i) const; 1482{; 1483 if (i < 0 || i >= fNpoints || !fExL); 1484 return -1.;; 1485 else; 1486 return fExL[i];; 1487}; 1488 ; 1489////////////////////////////////////////////////////////////////////////////////; 1490/// Get high error on x coordinate for point `i`.; 1491 ; 1492Double_t TGraphMultiErrors::GetErrorXhigh(Int_t i) const; 1493{; 1494 if (i < 0 || i >= fNpoints || !fExH); 1495 return -1.;; 1496 else; 1497 return fExH[i];; 1498}; 1499 ; 1500///////////",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:50741,Availability,error,error,50741,"rors the mean of the square sum is returned; 1453 ; 1454Double_t TGraphMultiErrors::GetErrorY(Int_t i) const; 1455{; 1456 if (i < 0 || i >= fNpoints || (fEyL.empty() && fEyH.empty())); 1457 return -1.;; 1458 ; 1459 Double_t eyL = GetErrorYlow(i);; 1460 Double_t eyH = GetErrorYhigh(i);; 1461 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1462}; 1463 ; 1464////////////////////////////////////////////////////////////////////////////////; 1465/// Get error e on y coordinate for point `i`.; 1466/// In case of asymmetric errors the mean of the square sum is returned; 1467 ; 1468Double_t TGraphMultiErrors::GetErrorY(Int_t i, Int_t e) const; 1469{; 1470 if (i < 0 || i >= fNpoints || e >= fNYErrors || (fEyL.empty() && fEyH.empty())); 1471 return -1.;; 1472 ; 1473 Double_t eyL = fEyL.empty() ? 0. : fEyL[e][i];; 1474 Double_t eyH = fEyH.empty() ? 0. : fEyH[e][i];; 1475 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Get low error on x coordinate for point `i`.; 1480 ; 1481Double_t TGraphMultiErrors::GetErrorXlow(Int_t i) const; 1482{; 1483 if (i < 0 || i >= fNpoints || !fExL); 1484 return -1.;; 1485 else; 1486 return fExL[i];; 1487}; 1488 ; 1489////////////////////////////////////////////////////////////////////////////////; 1490/// Get high error on x coordinate for point `i`.; 1491 ; 1492Double_t TGraphMultiErrors::GetErrorXhigh(Int_t i) const; 1493{; 1494 if (i < 0 || i >= fNpoints || !fExH); 1495 return -1.;; 1496 else; 1497 return fExH[i];; 1498}; 1499 ; 1500////////////////////////////////////////////////////////////////////////////////; 1501/// Get low error on y coordinate for point `i`.; 1502/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1503 ; 1504Double_t TGraphMultiErrors::GetErrorYlow(Int_t i) const; 1505{; 1506 if (i < 0 || i >= fNpoints || fEyL.empty()); 1507 return -1.;; 1508 ; 1509 if (fSumErrorsMode == TGraph",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:51065,Availability,error,error,51065,"qrt((eyL * eyL + eyH * eyH) / 2.);; 1462}; 1463 ; 1464////////////////////////////////////////////////////////////////////////////////; 1465/// Get error e on y coordinate for point `i`.; 1466/// In case of asymmetric errors the mean of the square sum is returned; 1467 ; 1468Double_t TGraphMultiErrors::GetErrorY(Int_t i, Int_t e) const; 1469{; 1470 if (i < 0 || i >= fNpoints || e >= fNYErrors || (fEyL.empty() && fEyH.empty())); 1471 return -1.;; 1472 ; 1473 Double_t eyL = fEyL.empty() ? 0. : fEyL[e][i];; 1474 Double_t eyH = fEyH.empty() ? 0. : fEyH[e][i];; 1475 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Get low error on x coordinate for point `i`.; 1480 ; 1481Double_t TGraphMultiErrors::GetErrorXlow(Int_t i) const; 1482{; 1483 if (i < 0 || i >= fNpoints || !fExL); 1484 return -1.;; 1485 else; 1486 return fExL[i];; 1487}; 1488 ; 1489////////////////////////////////////////////////////////////////////////////////; 1490/// Get high error on x coordinate for point `i`.; 1491 ; 1492Double_t TGraphMultiErrors::GetErrorXhigh(Int_t i) const; 1493{; 1494 if (i < 0 || i >= fNpoints || !fExH); 1495 return -1.;; 1496 else; 1497 return fExH[i];; 1498}; 1499 ; 1500////////////////////////////////////////////////////////////////////////////////; 1501/// Get low error on y coordinate for point `i`.; 1502/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1503 ; 1504Double_t TGraphMultiErrors::GetErrorYlow(Int_t i) const; 1505{; 1506 if (i < 0 || i >= fNpoints || fEyL.empty()); 1507 return -1.;; 1508 ; 1509 if (fSumErrorsMode == TGraphMultiErrors::kOnlyFirst); 1510 return fEyL[0][i];; 1511 else if (fSumErrorsMode == TGraphMultiErrors::kSquareSum) {; 1512 Double_t sum = 0.;; 1513 for (Int_t j = 0; j < fNYErrors; j++); 1514 sum += fEyL[j][i] * fEyL[j][i];; 1515 return TMath::Sqrt(sum);; 1516 } else if (fSumErrorsMode == TGraphMultiErrors::",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:51389,Availability,error,error,51389,t_t e) const; 1469{; 1470 if (i < 0 || i >= fNpoints || e >= fNYErrors || (fEyL.empty() && fEyH.empty())); 1471 return -1.;; 1472 ; 1473 Double_t eyL = fEyL.empty() ? 0. : fEyL[e][i];; 1474 Double_t eyH = fEyH.empty() ? 0. : fEyH[e][i];; 1475 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Get low error on x coordinate for point `i`.; 1480 ; 1481Double_t TGraphMultiErrors::GetErrorXlow(Int_t i) const; 1482{; 1483 if (i < 0 || i >= fNpoints || !fExL); 1484 return -1.;; 1485 else; 1486 return fExL[i];; 1487}; 1488 ; 1489////////////////////////////////////////////////////////////////////////////////; 1490/// Get high error on x coordinate for point `i`.; 1491 ; 1492Double_t TGraphMultiErrors::GetErrorXhigh(Int_t i) const; 1493{; 1494 if (i < 0 || i >= fNpoints || !fExH); 1495 return -1.;; 1496 else; 1497 return fExH[i];; 1498}; 1499 ; 1500////////////////////////////////////////////////////////////////////////////////; 1501/// Get low error on y coordinate for point `i`.; 1502/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1503 ; 1504Double_t TGraphMultiErrors::GetErrorYlow(Int_t i) const; 1505{; 1506 if (i < 0 || i >= fNpoints || fEyL.empty()); 1507 return -1.;; 1508 ; 1509 if (fSumErrorsMode == TGraphMultiErrors::kOnlyFirst); 1510 return fEyL[0][i];; 1511 else if (fSumErrorsMode == TGraphMultiErrors::kSquareSum) {; 1512 Double_t sum = 0.;; 1513 for (Int_t j = 0; j < fNYErrors; j++); 1514 sum += fEyL[j][i] * fEyL[j][i];; 1515 return TMath::Sqrt(sum);; 1516 } else if (fSumErrorsMode == TGraphMultiErrors::kAbsSum) {; 1517 Double_t sum = 0.;; 1518 for (Int_t j = 0; j < fNYErrors; j++); 1519 sum += fEyL[j][i];; 1520 return sum;; 1521 }; 1522 ; 1523 return -1.;; 1524}; 1525 ; 1526////////////////////////////////////////////////////////////////////////////////; 1527/// Get high error on y coordinate for point `i`.; 1528/// The ,MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:51448,Availability,error,errors,51448,ouble_t eyL = fEyL.empty() ? 0. : fEyL[e][i];; 1474 Double_t eyH = fEyH.empty() ? 0. : fEyH[e][i];; 1475 return TMath::Sqrt((eyL * eyL + eyH * eyH) / 2.);; 1476}; 1477 ; 1478////////////////////////////////////////////////////////////////////////////////; 1479/// Get low error on x coordinate for point `i`.; 1480 ; 1481Double_t TGraphMultiErrors::GetErrorXlow(Int_t i) const; 1482{; 1483 if (i < 0 || i >= fNpoints || !fExL); 1484 return -1.;; 1485 else; 1486 return fExL[i];; 1487}; 1488 ; 1489////////////////////////////////////////////////////////////////////////////////; 1490/// Get high error on x coordinate for point `i`.; 1491 ; 1492Double_t TGraphMultiErrors::GetErrorXhigh(Int_t i) const; 1493{; 1494 if (i < 0 || i >= fNpoints || !fExH); 1495 return -1.;; 1496 else; 1497 return fExH[i];; 1498}; 1499 ; 1500////////////////////////////////////////////////////////////////////////////////; 1501/// Get low error on y coordinate for point `i`.; 1502/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1503 ; 1504Double_t TGraphMultiErrors::GetErrorYlow(Int_t i) const; 1505{; 1506 if (i < 0 || i >= fNpoints || fEyL.empty()); 1507 return -1.;; 1508 ; 1509 if (fSumErrorsMode == TGraphMultiErrors::kOnlyFirst); 1510 return fEyL[0][i];; 1511 else if (fSumErrorsMode == TGraphMultiErrors::kSquareSum) {; 1512 Double_t sum = 0.;; 1513 for (Int_t j = 0; j < fNYErrors; j++); 1514 sum += fEyL[j][i] * fEyL[j][i];; 1515 return TMath::Sqrt(sum);; 1516 } else if (fSumErrorsMode == TGraphMultiErrors::kAbsSum) {; 1517 Double_t sum = 0.;; 1518 for (Int_t j = 0; j < fNYErrors; j++); 1519 sum += fEyL[j][i];; 1520 return sum;; 1521 }; 1522 ; 1523 return -1.;; 1524}; 1525 ; 1526////////////////////////////////////////////////////////////////////////////////; 1527/// Get high error on y coordinate for point `i`.; 1528/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1529 ; 1530Double_t TGraphMultiErrors::GetErrorYhigh(Int_t i) ,MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:52281,Availability,error,error,52281, 1496 else; 1497 return fExH[i];; 1498}; 1499 ; 1500////////////////////////////////////////////////////////////////////////////////; 1501/// Get low error on y coordinate for point `i`.; 1502/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1503 ; 1504Double_t TGraphMultiErrors::GetErrorYlow(Int_t i) const; 1505{; 1506 if (i < 0 || i >= fNpoints || fEyL.empty()); 1507 return -1.;; 1508 ; 1509 if (fSumErrorsMode == TGraphMultiErrors::kOnlyFirst); 1510 return fEyL[0][i];; 1511 else if (fSumErrorsMode == TGraphMultiErrors::kSquareSum) {; 1512 Double_t sum = 0.;; 1513 for (Int_t j = 0; j < fNYErrors; j++); 1514 sum += fEyL[j][i] * fEyL[j][i];; 1515 return TMath::Sqrt(sum);; 1516 } else if (fSumErrorsMode == TGraphMultiErrors::kAbsSum) {; 1517 Double_t sum = 0.;; 1518 for (Int_t j = 0; j < fNYErrors; j++); 1519 sum += fEyL[j][i];; 1520 return sum;; 1521 }; 1522 ; 1523 return -1.;; 1524}; 1525 ; 1526////////////////////////////////////////////////////////////////////////////////; 1527/// Get high error on y coordinate for point `i`.; 1528/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1529 ; 1530Double_t TGraphMultiErrors::GetErrorYhigh(Int_t i) const; 1531{; 1532 if (i < 0 || i >= fNpoints || fEyH.empty()); 1533 return -1.;; 1534 ; 1535 if (fSumErrorsMode == TGraphMultiErrors::kOnlyFirst); 1536 return fEyH[0][i];; 1537 else if (fSumErrorsMode == TGraphMultiErrors::kSquareSum) {; 1538 Double_t sum = 0.;; 1539 for (Int_t j = 0; j < fNYErrors; j++); 1540 sum += fEyH[j][i] * fEyH[j][i];; 1541 return TMath::Sqrt(sum);; 1542 } else if (fSumErrorsMode == TGraphMultiErrors::kAbsSum) {; 1543 Double_t sum = 0.;; 1544 for (Int_t j = 0; j < fNYErrors; j++); 1545 sum += fEyH[j][i];; 1546 return sum;; 1547 }; 1548 ; 1549 return -1.;; 1550}; 1551 ; 1552////////////////////////////////////////////////////////////////////////////////; 1553/// Get low error e on y coordinate for point `i`.; 1554 ; 1555Double_t TGraph,MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:52340,Availability,error,errors,52340,"//////////; 1501/// Get low error on y coordinate for point `i`.; 1502/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1503 ; 1504Double_t TGraphMultiErrors::GetErrorYlow(Int_t i) const; 1505{; 1506 if (i < 0 || i >= fNpoints || fEyL.empty()); 1507 return -1.;; 1508 ; 1509 if (fSumErrorsMode == TGraphMultiErrors::kOnlyFirst); 1510 return fEyL[0][i];; 1511 else if (fSumErrorsMode == TGraphMultiErrors::kSquareSum) {; 1512 Double_t sum = 0.;; 1513 for (Int_t j = 0; j < fNYErrors; j++); 1514 sum += fEyL[j][i] * fEyL[j][i];; 1515 return TMath::Sqrt(sum);; 1516 } else if (fSumErrorsMode == TGraphMultiErrors::kAbsSum) {; 1517 Double_t sum = 0.;; 1518 for (Int_t j = 0; j < fNYErrors; j++); 1519 sum += fEyL[j][i];; 1520 return sum;; 1521 }; 1522 ; 1523 return -1.;; 1524}; 1525 ; 1526////////////////////////////////////////////////////////////////////////////////; 1527/// Get high error on y coordinate for point `i`.; 1528/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1529 ; 1530Double_t TGraphMultiErrors::GetErrorYhigh(Int_t i) const; 1531{; 1532 if (i < 0 || i >= fNpoints || fEyH.empty()); 1533 return -1.;; 1534 ; 1535 if (fSumErrorsMode == TGraphMultiErrors::kOnlyFirst); 1536 return fEyH[0][i];; 1537 else if (fSumErrorsMode == TGraphMultiErrors::kSquareSum) {; 1538 Double_t sum = 0.;; 1539 for (Int_t j = 0; j < fNYErrors; j++); 1540 sum += fEyH[j][i] * fEyH[j][i];; 1541 return TMath::Sqrt(sum);; 1542 } else if (fSumErrorsMode == TGraphMultiErrors::kAbsSum) {; 1543 Double_t sum = 0.;; 1544 for (Int_t j = 0; j < fNYErrors; j++); 1545 sum += fEyH[j][i];; 1546 return sum;; 1547 }; 1548 ; 1549 return -1.;; 1550}; 1551 ; 1552////////////////////////////////////////////////////////////////////////////////; 1553/// Get low error e on y coordinate for point `i`.; 1554 ; 1555Double_t TGraphMultiErrors::GetErrorYlow(Int_t i, Int_t e) const; 1556{; 1557 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyL.empty()",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:53173,Availability,error,error,53173,"521 }; 1522 ; 1523 return -1.;; 1524}; 1525 ; 1526////////////////////////////////////////////////////////////////////////////////; 1527/// Get high error on y coordinate for point `i`.; 1528/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1529 ; 1530Double_t TGraphMultiErrors::GetErrorYhigh(Int_t i) const; 1531{; 1532 if (i < 0 || i >= fNpoints || fEyH.empty()); 1533 return -1.;; 1534 ; 1535 if (fSumErrorsMode == TGraphMultiErrors::kOnlyFirst); 1536 return fEyH[0][i];; 1537 else if (fSumErrorsMode == TGraphMultiErrors::kSquareSum) {; 1538 Double_t sum = 0.;; 1539 for (Int_t j = 0; j < fNYErrors; j++); 1540 sum += fEyH[j][i] * fEyH[j][i];; 1541 return TMath::Sqrt(sum);; 1542 } else if (fSumErrorsMode == TGraphMultiErrors::kAbsSum) {; 1543 Double_t sum = 0.;; 1544 for (Int_t j = 0; j < fNYErrors; j++); 1545 sum += fEyH[j][i];; 1546 return sum;; 1547 }; 1548 ; 1549 return -1.;; 1550}; 1551 ; 1552////////////////////////////////////////////////////////////////////////////////; 1553/// Get low error e on y coordinate for point `i`.; 1554 ; 1555Double_t TGraphMultiErrors::GetErrorYlow(Int_t i, Int_t e) const; 1556{; 1557 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyL.empty()); 1558 return -1.;; 1559 ; 1560 return fEyL[e][i];; 1561}; 1562 ; 1563////////////////////////////////////////////////////////////////////////////////; 1564/// Get high error e on y coordinate for point `i`.; 1565 ; 1566Double_t TGraphMultiErrors::GetErrorYhigh(Int_t i, Int_t e) const; 1567{; 1568 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyH.empty()); 1569 return -1.;; 1570 ; 1571 return fEyH[e][i];; 1572}; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Get all low errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1576 ; 1577Double_t *TGraphMultiErrors::GetEYlow() const; 1578{; 1579 if (!fEyLSum); 1580 CalcYErrorsSum();; 1581 ; 1582 return fEyLSum;; 1583}; 1584 ; 1585///////",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:53532,Availability,error,error,53532,"; 1531{; 1532 if (i < 0 || i >= fNpoints || fEyH.empty()); 1533 return -1.;; 1534 ; 1535 if (fSumErrorsMode == TGraphMultiErrors::kOnlyFirst); 1536 return fEyH[0][i];; 1537 else if (fSumErrorsMode == TGraphMultiErrors::kSquareSum) {; 1538 Double_t sum = 0.;; 1539 for (Int_t j = 0; j < fNYErrors; j++); 1540 sum += fEyH[j][i] * fEyH[j][i];; 1541 return TMath::Sqrt(sum);; 1542 } else if (fSumErrorsMode == TGraphMultiErrors::kAbsSum) {; 1543 Double_t sum = 0.;; 1544 for (Int_t j = 0; j < fNYErrors; j++); 1545 sum += fEyH[j][i];; 1546 return sum;; 1547 }; 1548 ; 1549 return -1.;; 1550}; 1551 ; 1552////////////////////////////////////////////////////////////////////////////////; 1553/// Get low error e on y coordinate for point `i`.; 1554 ; 1555Double_t TGraphMultiErrors::GetErrorYlow(Int_t i, Int_t e) const; 1556{; 1557 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyL.empty()); 1558 return -1.;; 1559 ; 1560 return fEyL[e][i];; 1561}; 1562 ; 1563////////////////////////////////////////////////////////////////////////////////; 1564/// Get high error e on y coordinate for point `i`.; 1565 ; 1566Double_t TGraphMultiErrors::GetErrorYhigh(Int_t i, Int_t e) const; 1567{; 1568 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyH.empty()); 1569 return -1.;; 1570 ; 1571 return fEyH[e][i];; 1572}; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Get all low errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1576 ; 1577Double_t *TGraphMultiErrors::GetEYlow() const; 1578{; 1579 if (!fEyLSum); 1580 CalcYErrorsSum();; 1581 ; 1582 return fEyLSum;; 1583}; 1584 ; 1585////////////////////////////////////////////////////////////////////////////////; 1586/// Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1587 ; 1588Double_t *TGraphMultiErrors::GetEYhigh() const; 1589{; 1590 if (!fEyHSum); 1591 CalcYErrorsSum();; 1592 ; 1593 return fEyHSum;; 1594}; 1595 ; 1596//////////////",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:53895,Availability,error,errors,53895,"else if (fSumErrorsMode == TGraphMultiErrors::kAbsSum) {; 1543 Double_t sum = 0.;; 1544 for (Int_t j = 0; j < fNYErrors; j++); 1545 sum += fEyH[j][i];; 1546 return sum;; 1547 }; 1548 ; 1549 return -1.;; 1550}; 1551 ; 1552////////////////////////////////////////////////////////////////////////////////; 1553/// Get low error e on y coordinate for point `i`.; 1554 ; 1555Double_t TGraphMultiErrors::GetErrorYlow(Int_t i, Int_t e) const; 1556{; 1557 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyL.empty()); 1558 return -1.;; 1559 ; 1560 return fEyL[e][i];; 1561}; 1562 ; 1563////////////////////////////////////////////////////////////////////////////////; 1564/// Get high error e on y coordinate for point `i`.; 1565 ; 1566Double_t TGraphMultiErrors::GetErrorYhigh(Int_t i, Int_t e) const; 1567{; 1568 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyH.empty()); 1569 return -1.;; 1570 ; 1571 return fEyH[e][i];; 1572}; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Get all low errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1576 ; 1577Double_t *TGraphMultiErrors::GetEYlow() const; 1578{; 1579 if (!fEyLSum); 1580 CalcYErrorsSum();; 1581 ; 1582 return fEyLSum;; 1583}; 1584 ; 1585////////////////////////////////////////////////////////////////////////////////; 1586/// Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1587 ; 1588Double_t *TGraphMultiErrors::GetEYhigh() const; 1589{; 1590 if (!fEyHSum); 1591 CalcYErrorsSum();; 1592 ; 1593 return fEyHSum;; 1594}; 1595 ; 1596////////////////////////////////////////////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607/////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:54229,Availability,error,errors,54229,"////////////////////; 1553/// Get low error e on y coordinate for point `i`.; 1554 ; 1555Double_t TGraphMultiErrors::GetErrorYlow(Int_t i, Int_t e) const; 1556{; 1557 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyL.empty()); 1558 return -1.;; 1559 ; 1560 return fEyL[e][i];; 1561}; 1562 ; 1563////////////////////////////////////////////////////////////////////////////////; 1564/// Get high error e on y coordinate for point `i`.; 1565 ; 1566Double_t TGraphMultiErrors::GetErrorYhigh(Int_t i, Int_t e) const; 1567{; 1568 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyH.empty()); 1569 return -1.;; 1570 ; 1571 return fEyH[e][i];; 1572}; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Get all low errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1576 ; 1577Double_t *TGraphMultiErrors::GetEYlow() const; 1578{; 1579 if (!fEyLSum); 1580 CalcYErrorsSum();; 1581 ; 1582 return fEyLSum;; 1583}; 1584 ; 1585////////////////////////////////////////////////////////////////////////////////; 1586/// Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1587 ; 1588Double_t *TGraphMultiErrors::GetEYhigh() const; 1589{; 1590 if (!fEyHSum); 1591 CalcYErrorsSum();; 1592 ; 1593 return fEyHSum;; 1594}; 1595 ; 1596////////////////////////////////////////////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:54563,Availability,error,errors,54563,"/////////////////////////////////////////////////////////////; 1564/// Get high error e on y coordinate for point `i`.; 1565 ; 1566Double_t TGraphMultiErrors::GetErrorYhigh(Int_t i, Int_t e) const; 1567{; 1568 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyH.empty()); 1569 return -1.;; 1570 ; 1571 return fEyH[e][i];; 1572}; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Get all low errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1576 ; 1577Double_t *TGraphMultiErrors::GetEYlow() const; 1578{; 1579 if (!fEyLSum); 1580 CalcYErrorsSum();; 1581 ; 1582 return fEyLSum;; 1583}; 1584 ; 1585////////////////////////////////////////////////////////////////////////////////; 1586/// Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1587 ; 1588Double_t *TGraphMultiErrors::GetEYhigh() const; 1589{; 1590 if (!fEyHSum); 1591 CalcYErrorsSum();; 1592 ; 1593 return fEyHSum;; 1594}; 1595 ; 1596////////////////////////////////////////////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 162",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:54900,Availability,error,errors,54900,////////////////////; 1575/// Get all low errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1576 ; 1577Double_t *TGraphMultiErrors::GetEYlow() const; 1578{; 1579 if (!fEyLSum); 1580 CalcYErrorsSum();; 1581 ; 1582 return fEyLSum;; 1583}; 1584 ; 1585////////////////////////////////////////////////////////////////////////////////; 1586/// Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1587 ; 1588Double_t *TGraphMultiErrors::GetEYhigh() const; 1589{; 1590 if (!fEyHSum); 1591 CalcYErrorsSum();; 1592 ; 1593 return fEyHSum;; 1594}; 1595 ; 1596////////////////////////////////////////////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Get AttLine pointer for specified error dimension.; 1631 ; 1632TAttLine *TGraphMultiErrors::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640//////////////////////////////////////////////////////////////////,MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:55259,Availability,error,error,55259,/////////////////; 1586/// Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1587 ; 1588Double_t *TGraphMultiErrors::GetEYhigh() const; 1589{; 1590 if (!fEyHSum); 1591 CalcYErrorsSum();; 1592 ; 1593 return fEyHSum;; 1594}; 1595 ; 1596////////////////////////////////////////////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Get AttLine pointer for specified error dimension.; 1631 ; 1632TAttLine *TGraphMultiErrors::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640////////////////////////////////////////////////////////////////////////////////; 1641/// Get Fill Color for specified error e (-1 = Global and x errors).; 1642 ; 1643Color_t TGraphMultiErrors::GetFillColor(Int_t e) const; 1644{; 1645 if (e == -1); 1646 return GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 165,MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:55585,Availability,error,error,55585,////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Get AttLine pointer for specified error dimension.; 1631 ; 1632TAttLine *TGraphMultiErrors::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640////////////////////////////////////////////////////////////////////////////////; 1641/// Get Fill Color for specified error e (-1 = Global and x errors).; 1642 ; 1643Color_t TGraphMultiErrors::GetFillColor(Int_t e) const; 1644{; 1645 if (e == -1); 1646 return GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// Get Fill Style for specified error e (-1 = Global and x errors).; 1655 ; 1656Style_t TGraphMultiErrors::GetFillStyle(Int_t e) const; 1657{; 1658 if (e == -1); 1659 return GetFillStyle();; 1660 else if (e >= 0 && e < fNYEr,MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:55906,Availability,error,error,55906,///////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Get AttLine pointer for specified error dimension.; 1631 ; 1632TAttLine *TGraphMultiErrors::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640////////////////////////////////////////////////////////////////////////////////; 1641/// Get Fill Color for specified error e (-1 = Global and x errors).; 1642 ; 1643Color_t TGraphMultiErrors::GetFillColor(Int_t e) const; 1644{; 1645 if (e == -1); 1646 return GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// Get Fill Style for specified error e (-1 = Global and x errors).; 1655 ; 1656Style_t TGraphMultiErrors::GetFillStyle(Int_t e) const; 1657{; 1658 if (e == -1); 1659 return GetFillStyle();; 1660 else if (e >= 0 && e < fNYErrors); 1661 return fAttFill[e].GetFillStyle();; 1662 else; 1663 return 0;; 1664}; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Get Line Color for specified error e (-1 = Global and x errors).; 1668 ; 1669Color_t TGraphMultiErrors::GetLineColor(Int_t e) const; 1670{; 1671 if (e,MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:55933,Availability,error,errors,55933,///////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Get AttLine pointer for specified error dimension.; 1631 ; 1632TAttLine *TGraphMultiErrors::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640////////////////////////////////////////////////////////////////////////////////; 1641/// Get Fill Color for specified error e (-1 = Global and x errors).; 1642 ; 1643Color_t TGraphMultiErrors::GetFillColor(Int_t e) const; 1644{; 1645 if (e == -1); 1646 return GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// Get Fill Style for specified error e (-1 = Global and x errors).; 1655 ; 1656Style_t TGraphMultiErrors::GetFillStyle(Int_t e) const; 1657{; 1658 if (e == -1); 1659 return GetFillStyle();; 1660 else if (e >= 0 && e < fNYErrors); 1661 return fAttFill[e].GetFillStyle();; 1662 else; 1663 return 0;; 1664}; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Get Line Color for specified error e (-1 = Global and x errors).; 1668 ; 1669Color_t TGraphMultiErrors::GetLineColor(Int_t e) const; 1670{; 1671 if (e,MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:56310,Availability,error,error,56310,pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Get AttLine pointer for specified error dimension.; 1631 ; 1632TAttLine *TGraphMultiErrors::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640////////////////////////////////////////////////////////////////////////////////; 1641/// Get Fill Color for specified error e (-1 = Global and x errors).; 1642 ; 1643Color_t TGraphMultiErrors::GetFillColor(Int_t e) const; 1644{; 1645 if (e == -1); 1646 return GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// Get Fill Style for specified error e (-1 = Global and x errors).; 1655 ; 1656Style_t TGraphMultiErrors::GetFillStyle(Int_t e) const; 1657{; 1658 if (e == -1); 1659 return GetFillStyle();; 1660 else if (e >= 0 && e < fNYErrors); 1661 return fAttFill[e].GetFillStyle();; 1662 else; 1663 return 0;; 1664}; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Get Line Color for specified error e (-1 = Global and x errors).; 1668 ; 1669Color_t TGraphMultiErrors::GetLineColor(Int_t e) const; 1670{; 1671 if (e == -1); 1672 return GetLineColor();; 1673 else if (e >= 0 && e < fNYErrors); 1674 return fAttLine[e].GetLineColor();; 1675 else; 1676 return 0;; 1677}; 1678 ; 1679////////////////////////////////////////////////////////////////////////////////; 1680/// Get Line Style for specified error e (-1 = Global and x errors).; 1681 ; 1682Style_t TGraphMultiErrors::GetLineStyle(Int_t e) const; 1683{; 1684 if ,MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:56337,Availability,error,errors,56337,pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Get AttLine pointer for specified error dimension.; 1631 ; 1632TAttLine *TGraphMultiErrors::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640////////////////////////////////////////////////////////////////////////////////; 1641/// Get Fill Color for specified error e (-1 = Global and x errors).; 1642 ; 1643Color_t TGraphMultiErrors::GetFillColor(Int_t e) const; 1644{; 1645 if (e == -1); 1646 return GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// Get Fill Style for specified error e (-1 = Global and x errors).; 1655 ; 1656Style_t TGraphMultiErrors::GetFillStyle(Int_t e) const; 1657{; 1658 if (e == -1); 1659 return GetFillStyle();; 1660 else if (e >= 0 && e < fNYErrors); 1661 return fAttFill[e].GetFillStyle();; 1662 else; 1663 return 0;; 1664}; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Get Line Color for specified error e (-1 = Global and x errors).; 1668 ; 1669Color_t TGraphMultiErrors::GetLineColor(Int_t e) const; 1670{; 1671 if (e == -1); 1672 return GetLineColor();; 1673 else if (e >= 0 && e < fNYErrors); 1674 return fAttLine[e].GetLineColor();; 1675 else; 1676 return 0;; 1677}; 1678 ; 1679////////////////////////////////////////////////////////////////////////////////; 1680/// Get Line Style for specified error e (-1 = Global and x errors).; 1681 ; 1682Style_t TGraphMultiErrors::GetLineStyle(Int_t e) const; 1683{; 1684 if ,MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:56714,Availability,error,error,56714,::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640////////////////////////////////////////////////////////////////////////////////; 1641/// Get Fill Color for specified error e (-1 = Global and x errors).; 1642 ; 1643Color_t TGraphMultiErrors::GetFillColor(Int_t e) const; 1644{; 1645 if (e == -1); 1646 return GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// Get Fill Style for specified error e (-1 = Global and x errors).; 1655 ; 1656Style_t TGraphMultiErrors::GetFillStyle(Int_t e) const; 1657{; 1658 if (e == -1); 1659 return GetFillStyle();; 1660 else if (e >= 0 && e < fNYErrors); 1661 return fAttFill[e].GetFillStyle();; 1662 else; 1663 return 0;; 1664}; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Get Line Color for specified error e (-1 = Global and x errors).; 1668 ; 1669Color_t TGraphMultiErrors::GetLineColor(Int_t e) const; 1670{; 1671 if (e == -1); 1672 return GetLineColor();; 1673 else if (e >= 0 && e < fNYErrors); 1674 return fAttLine[e].GetLineColor();; 1675 else; 1676 return 0;; 1677}; 1678 ; 1679////////////////////////////////////////////////////////////////////////////////; 1680/// Get Line Style for specified error e (-1 = Global and x errors).; 1681 ; 1682Style_t TGraphMultiErrors::GetLineStyle(Int_t e) const; 1683{; 1684 if (e == -1); 1685 return GetLineStyle();; 1686 else if (e >= 0 && e < fNYErrors); 1687 return fAttLine[e].GetLineStyle();; 1688 else; 1689 return 0;; 1690}; 1691 ; 1692////////////////////////////////////////////////////////////////////////////////; 1693/// Get Line Width for specified error e (-1 = Global and x errors).; 1694 ; 1695Width_t TGraphMultiErrors::GetLineWidth(Int_t e) const; 1696{; 1697 if ,MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:56741,Availability,error,errors,56741,::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640////////////////////////////////////////////////////////////////////////////////; 1641/// Get Fill Color for specified error e (-1 = Global and x errors).; 1642 ; 1643Color_t TGraphMultiErrors::GetFillColor(Int_t e) const; 1644{; 1645 if (e == -1); 1646 return GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// Get Fill Style for specified error e (-1 = Global and x errors).; 1655 ; 1656Style_t TGraphMultiErrors::GetFillStyle(Int_t e) const; 1657{; 1658 if (e == -1); 1659 return GetFillStyle();; 1660 else if (e >= 0 && e < fNYErrors); 1661 return fAttFill[e].GetFillStyle();; 1662 else; 1663 return 0;; 1664}; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Get Line Color for specified error e (-1 = Global and x errors).; 1668 ; 1669Color_t TGraphMultiErrors::GetLineColor(Int_t e) const; 1670{; 1671 if (e == -1); 1672 return GetLineColor();; 1673 else if (e >= 0 && e < fNYErrors); 1674 return fAttLine[e].GetLineColor();; 1675 else; 1676 return 0;; 1677}; 1678 ; 1679////////////////////////////////////////////////////////////////////////////////; 1680/// Get Line Style for specified error e (-1 = Global and x errors).; 1681 ; 1682Style_t TGraphMultiErrors::GetLineStyle(Int_t e) const; 1683{; 1684 if (e == -1); 1685 return GetLineStyle();; 1686 else if (e >= 0 && e < fNYErrors); 1687 return fAttLine[e].GetLineStyle();; 1688 else; 1689 return 0;; 1690}; 1691 ; 1692////////////////////////////////////////////////////////////////////////////////; 1693/// Get Line Width for specified error e (-1 = Global and x errors).; 1694 ; 1695Width_t TGraphMultiErrors::GetLineWidth(Int_t e) const; 1696{; 1697 if ,MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:57118,Availability,error,error,57118,rn GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// Get Fill Style for specified error e (-1 = Global and x errors).; 1655 ; 1656Style_t TGraphMultiErrors::GetFillStyle(Int_t e) const; 1657{; 1658 if (e == -1); 1659 return GetFillStyle();; 1660 else if (e >= 0 && e < fNYErrors); 1661 return fAttFill[e].GetFillStyle();; 1662 else; 1663 return 0;; 1664}; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Get Line Color for specified error e (-1 = Global and x errors).; 1668 ; 1669Color_t TGraphMultiErrors::GetLineColor(Int_t e) const; 1670{; 1671 if (e == -1); 1672 return GetLineColor();; 1673 else if (e >= 0 && e < fNYErrors); 1674 return fAttLine[e].GetLineColor();; 1675 else; 1676 return 0;; 1677}; 1678 ; 1679////////////////////////////////////////////////////////////////////////////////; 1680/// Get Line Style for specified error e (-1 = Global and x errors).; 1681 ; 1682Style_t TGraphMultiErrors::GetLineStyle(Int_t e) const; 1683{; 1684 if (e == -1); 1685 return GetLineStyle();; 1686 else if (e >= 0 && e < fNYErrors); 1687 return fAttLine[e].GetLineStyle();; 1688 else; 1689 return 0;; 1690}; 1691 ; 1692////////////////////////////////////////////////////////////////////////////////; 1693/// Get Line Width for specified error e (-1 = Global and x errors).; 1694 ; 1695Width_t TGraphMultiErrors::GetLineWidth(Int_t e) const; 1696{; 1697 if (e == -1); 1698 return GetLineWidth();; 1699 else if (e >= 0 && e < fNYErrors); 1700 return fAttLine[e].GetLineWidth();; 1701 else; 1702 return 0;; 1703}; 1704 ; 1705////////////////////////////////////////////////////////////////////////////////; 1706/// Print graph and errors values.; 1707 ; 1708void TGraphMultiErrors::Print(Option_t *) const; 1709{; 1710 for (Int_t i = 0; i < fNpoints; i++) {; 1711,MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:57145,Availability,error,errors,57145,rn GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// Get Fill Style for specified error e (-1 = Global and x errors).; 1655 ; 1656Style_t TGraphMultiErrors::GetFillStyle(Int_t e) const; 1657{; 1658 if (e == -1); 1659 return GetFillStyle();; 1660 else if (e >= 0 && e < fNYErrors); 1661 return fAttFill[e].GetFillStyle();; 1662 else; 1663 return 0;; 1664}; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Get Line Color for specified error e (-1 = Global and x errors).; 1668 ; 1669Color_t TGraphMultiErrors::GetLineColor(Int_t e) const; 1670{; 1671 if (e == -1); 1672 return GetLineColor();; 1673 else if (e >= 0 && e < fNYErrors); 1674 return fAttLine[e].GetLineColor();; 1675 else; 1676 return 0;; 1677}; 1678 ; 1679////////////////////////////////////////////////////////////////////////////////; 1680/// Get Line Style for specified error e (-1 = Global and x errors).; 1681 ; 1682Style_t TGraphMultiErrors::GetLineStyle(Int_t e) const; 1683{; 1684 if (e == -1); 1685 return GetLineStyle();; 1686 else if (e >= 0 && e < fNYErrors); 1687 return fAttLine[e].GetLineStyle();; 1688 else; 1689 return 0;; 1690}; 1691 ; 1692////////////////////////////////////////////////////////////////////////////////; 1693/// Get Line Width for specified error e (-1 = Global and x errors).; 1694 ; 1695Width_t TGraphMultiErrors::GetLineWidth(Int_t e) const; 1696{; 1697 if (e == -1); 1698 return GetLineWidth();; 1699 else if (e >= 0 && e < fNYErrors); 1700 return fAttLine[e].GetLineWidth();; 1701 else; 1702 return 0;; 1703}; 1704 ; 1705////////////////////////////////////////////////////////////////////////////////; 1706/// Print graph and errors values.; 1707 ; 1708void TGraphMultiErrors::Print(Option_t *) const; 1709{; 1710 for (Int_t i = 0; i < fNpoints; i++) {; 1711,MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:57522,Availability,error,error,57522,"rn GetFillStyle();; 1660 else if (e >= 0 && e < fNYErrors); 1661 return fAttFill[e].GetFillStyle();; 1662 else; 1663 return 0;; 1664}; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Get Line Color for specified error e (-1 = Global and x errors).; 1668 ; 1669Color_t TGraphMultiErrors::GetLineColor(Int_t e) const; 1670{; 1671 if (e == -1); 1672 return GetLineColor();; 1673 else if (e >= 0 && e < fNYErrors); 1674 return fAttLine[e].GetLineColor();; 1675 else; 1676 return 0;; 1677}; 1678 ; 1679////////////////////////////////////////////////////////////////////////////////; 1680/// Get Line Style for specified error e (-1 = Global and x errors).; 1681 ; 1682Style_t TGraphMultiErrors::GetLineStyle(Int_t e) const; 1683{; 1684 if (e == -1); 1685 return GetLineStyle();; 1686 else if (e >= 0 && e < fNYErrors); 1687 return fAttLine[e].GetLineStyle();; 1688 else; 1689 return 0;; 1690}; 1691 ; 1692////////////////////////////////////////////////////////////////////////////////; 1693/// Get Line Width for specified error e (-1 = Global and x errors).; 1694 ; 1695Width_t TGraphMultiErrors::GetLineWidth(Int_t e) const; 1696{; 1697 if (e == -1); 1698 return GetLineWidth();; 1699 else if (e >= 0 && e < fNYErrors); 1700 return fAttLine[e].GetLineWidth();; 1701 else; 1702 return 0;; 1703}; 1704 ; 1705////////////////////////////////////////////////////////////////////////////////; 1706/// Print graph and errors values.; 1707 ; 1708void TGraphMultiErrors::Print(Option_t *) const; 1709{; 1710 for (Int_t i = 0; i < fNpoints; i++) {; 1711 printf(""x[%d]=%g, y[%d]=%g"", i, fX[i], i, fY[i]);; 1712 if (fExL); 1713 printf("", exl[%d]=%g"", i, fExL[i]);; 1714 if (fExH); 1715 printf("", exh[%d]=%g"", i, fExH[i]);; 1716 if (!fEyL.empty()); 1717 for (Int_t j = 0; j < fNYErrors; j++); 1718 printf("", eyl[%d][%d]=%g"", j, i, fEyL[j][i]);; 1719 if (!fEyH.empty()); 1720 for (Int_t j = 0; j < fNYErrors; j++); 1721 printf("", eyh[%d][%d]=%g"", j, i, fEyH[j][",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:57549,Availability,error,errors,57549,"rn GetFillStyle();; 1660 else if (e >= 0 && e < fNYErrors); 1661 return fAttFill[e].GetFillStyle();; 1662 else; 1663 return 0;; 1664}; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Get Line Color for specified error e (-1 = Global and x errors).; 1668 ; 1669Color_t TGraphMultiErrors::GetLineColor(Int_t e) const; 1670{; 1671 if (e == -1); 1672 return GetLineColor();; 1673 else if (e >= 0 && e < fNYErrors); 1674 return fAttLine[e].GetLineColor();; 1675 else; 1676 return 0;; 1677}; 1678 ; 1679////////////////////////////////////////////////////////////////////////////////; 1680/// Get Line Style for specified error e (-1 = Global and x errors).; 1681 ; 1682Style_t TGraphMultiErrors::GetLineStyle(Int_t e) const; 1683{; 1684 if (e == -1); 1685 return GetLineStyle();; 1686 else if (e >= 0 && e < fNYErrors); 1687 return fAttLine[e].GetLineStyle();; 1688 else; 1689 return 0;; 1690}; 1691 ; 1692////////////////////////////////////////////////////////////////////////////////; 1693/// Get Line Width for specified error e (-1 = Global and x errors).; 1694 ; 1695Width_t TGraphMultiErrors::GetLineWidth(Int_t e) const; 1696{; 1697 if (e == -1); 1698 return GetLineWidth();; 1699 else if (e >= 0 && e < fNYErrors); 1700 return fAttLine[e].GetLineWidth();; 1701 else; 1702 return 0;; 1703}; 1704 ; 1705////////////////////////////////////////////////////////////////////////////////; 1706/// Print graph and errors values.; 1707 ; 1708void TGraphMultiErrors::Print(Option_t *) const; 1709{; 1710 for (Int_t i = 0; i < fNpoints; i++) {; 1711 printf(""x[%d]=%g, y[%d]=%g"", i, fX[i], i, fY[i]);; 1712 if (fExL); 1713 printf("", exl[%d]=%g"", i, fExL[i]);; 1714 if (fExH); 1715 printf("", exh[%d]=%g"", i, fExH[i]);; 1716 if (!fEyL.empty()); 1717 for (Int_t j = 0; j < fNYErrors; j++); 1718 printf("", eyl[%d][%d]=%g"", j, i, fEyL[j][i]);; 1719 if (!fEyH.empty()); 1720 for (Int_t j = 0; j < fNYErrors; j++); 1721 printf("", eyh[%d][%d]=%g"", j, i, fEyH[j][",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:57913,Availability,error,errors,57913,"== -1); 1672 return GetLineColor();; 1673 else if (e >= 0 && e < fNYErrors); 1674 return fAttLine[e].GetLineColor();; 1675 else; 1676 return 0;; 1677}; 1678 ; 1679////////////////////////////////////////////////////////////////////////////////; 1680/// Get Line Style for specified error e (-1 = Global and x errors).; 1681 ; 1682Style_t TGraphMultiErrors::GetLineStyle(Int_t e) const; 1683{; 1684 if (e == -1); 1685 return GetLineStyle();; 1686 else if (e >= 0 && e < fNYErrors); 1687 return fAttLine[e].GetLineStyle();; 1688 else; 1689 return 0;; 1690}; 1691 ; 1692////////////////////////////////////////////////////////////////////////////////; 1693/// Get Line Width for specified error e (-1 = Global and x errors).; 1694 ; 1695Width_t TGraphMultiErrors::GetLineWidth(Int_t e) const; 1696{; 1697 if (e == -1); 1698 return GetLineWidth();; 1699 else if (e >= 0 && e < fNYErrors); 1700 return fAttLine[e].GetLineWidth();; 1701 else; 1702 return 0;; 1703}; 1704 ; 1705////////////////////////////////////////////////////////////////////////////////; 1706/// Print graph and errors values.; 1707 ; 1708void TGraphMultiErrors::Print(Option_t *) const; 1709{; 1710 for (Int_t i = 0; i < fNpoints; i++) {; 1711 printf(""x[%d]=%g, y[%d]=%g"", i, fX[i], i, fY[i]);; 1712 if (fExL); 1713 printf("", exl[%d]=%g"", i, fExL[i]);; 1714 if (fExH); 1715 printf("", exh[%d]=%g"", i, fExH[i]);; 1716 if (!fEyL.empty()); 1717 for (Int_t j = 0; j < fNYErrors; j++); 1718 printf("", eyl[%d][%d]=%g"", j, i, fEyL[j][i]);; 1719 if (!fEyH.empty()); 1720 for (Int_t j = 0; j < fNYErrors; j++); 1721 printf("", eyh[%d][%d]=%g"", j, i, fEyH[j][i]);; 1722 printf(""\n"");; 1723 }; 1724}; 1725 ; 1726////////////////////////////////////////////////////////////////////////////////; 1727/// Save primitive as a C++ statement(s) on output stream out; 1728 ; 1729void TGraphMultiErrors::SavePrimitive(std::ostream &out, Option_t *option); 1730{; 1731 out << "" "" << std::endl;; 1732 static Int_t frameNumber = 5000;; 1733 frameNumber++;; 1",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:59972,Availability,error,errors,59972," TGraphMultiErrors::SavePrimitive(std::ostream &out, Option_t *option); 1730{; 1731 out << "" "" << std::endl;; 1732 static Int_t frameNumber = 5000;; 1733 frameNumber++;; 1734 ; 1735 if (gROOT->ClassSaved(TGraphMultiErrors::Class())); 1736 out << "" "";; 1737 else; 1738 out << "" TGraphMultiErrors* "";; 1739 ; 1740 out << ""tgme = new TGraphMultiErrors("" << fNpoints << "", "" << fNYErrors << "");"" << std::endl;; 1741 ; 1742 for (Int_t j = 0; j < fNYErrors; j++) {; 1743 fAttFill[j].SaveFillAttributes(out, TString::Format(""tgme->GetAttFill(%d)"", j).Data(), 0, 1001);; 1744 fAttLine[j].SaveLineAttributes(out, TString::Format(""tgme->GetAttLine(%d)"", j).Data(), 1, 1, 1);; 1745 }; 1746 ; 1747 for (Int_t i = 0; i < fNpoints; i++) {; 1748 out << "" tgme->SetPoint("" << i << "", "" << fX[i] << "", "" << fY[i] << "");"" << std::endl;; 1749 out << "" tgme->SetPointEX("" << i << "", "" << fExL[i] << "", "" << fExH[i] << "");"" << std::endl;; 1750 ; 1751 for (Int_t j = 0; j < fNYErrors; j++); 1752 out << "" tgme->SetPointEY("" << i << "", "" << j << "", "" << fEyL[j][i] << "", "" << fEyH[j][i] << "");""; 1753 << std::endl;; 1754 }; 1755 ; 1756 SaveHistogramAndFunctions(out, ""tgme"", frameNumber, option);; 1757}; 1758 ; 1759////////////////////////////////////////////////////////////////////////////////; 1760/// Multiply the values and errors of a TGraphMultiErrors by a constant c1.; 1761///; 1762/// If option contains ""x"" the x values and errors are scaled; 1763/// If option contains ""y"" the y values and (multiple) errors are scaled; 1764/// If option contains ""xy"" both x and y values and (multiple) errors are scaled; 1765 ; 1766void TGraphMultiErrors::Scale(Double_t c1, Option_t *option); 1767{; 1768 TGraph::Scale(c1, option);; 1769 TString opt = option; opt.ToLower();; 1770 if (opt.Contains(""x"") && GetEXlow()) {; 1771 for (Int_t i=0; i<GetN(); i++); 1772 GetEXlow()[i] *= c1;; 1773 }; 1774 if (opt.Contains(""x"") && GetEXhigh()) {; 1775 for (Int_t i=0; i<GetN(); i++); 1776 GetEXhigh()[i] *= c1;; 1777 }; 1778 if (opt.",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:60078,Availability,error,errors,60078,"a(), 0, 1001);; 1744 fAttLine[j].SaveLineAttributes(out, TString::Format(""tgme->GetAttLine(%d)"", j).Data(), 1, 1, 1);; 1745 }; 1746 ; 1747 for (Int_t i = 0; i < fNpoints; i++) {; 1748 out << "" tgme->SetPoint("" << i << "", "" << fX[i] << "", "" << fY[i] << "");"" << std::endl;; 1749 out << "" tgme->SetPointEX("" << i << "", "" << fExL[i] << "", "" << fExH[i] << "");"" << std::endl;; 1750 ; 1751 for (Int_t j = 0; j < fNYErrors; j++); 1752 out << "" tgme->SetPointEY("" << i << "", "" << j << "", "" << fEyL[j][i] << "", "" << fEyH[j][i] << "");""; 1753 << std::endl;; 1754 }; 1755 ; 1756 SaveHistogramAndFunctions(out, ""tgme"", frameNumber, option);; 1757}; 1758 ; 1759////////////////////////////////////////////////////////////////////////////////; 1760/// Multiply the values and errors of a TGraphMultiErrors by a constant c1.; 1761///; 1762/// If option contains ""x"" the x values and errors are scaled; 1763/// If option contains ""y"" the y values and (multiple) errors are scaled; 1764/// If option contains ""xy"" both x and y values and (multiple) errors are scaled; 1765 ; 1766void TGraphMultiErrors::Scale(Double_t c1, Option_t *option); 1767{; 1768 TGraph::Scale(c1, option);; 1769 TString opt = option; opt.ToLower();; 1770 if (opt.Contains(""x"") && GetEXlow()) {; 1771 for (Int_t i=0; i<GetN(); i++); 1772 GetEXlow()[i] *= c1;; 1773 }; 1774 if (opt.Contains(""x"") && GetEXhigh()) {; 1775 for (Int_t i=0; i<GetN(); i++); 1776 GetEXhigh()[i] *= c1;; 1777 }; 1778 if (opt.Contains(""y"")) {; 1779 for (size_t d=0; d<fEyL.size(); d++); 1780 for (Int_t i=0; i<fEyL[d].GetSize(); i++); 1781 fEyL[d][i] *= c1;; 1782 for (size_t d=0; d<fEyH.size(); d++); 1783 for (Int_t i=0; i<fEyH[d].GetSize(); i++); 1784 fEyH[d][i] *= c1;; 1785 }; 1786}; 1787 ; 1788////////////////////////////////////////////////////////////////////////////////; 1789/// Set ex and ey values for point pointed by the mouse.; 1790///; 1791/// Up to 3 y error dimensions possible.; 1792 ; 1793void TGraphMultiErrors::SetPointError(Double_t exL, Double_t e",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:60156,Availability,error,errors,60156,"a(), 0, 1001);; 1744 fAttLine[j].SaveLineAttributes(out, TString::Format(""tgme->GetAttLine(%d)"", j).Data(), 1, 1, 1);; 1745 }; 1746 ; 1747 for (Int_t i = 0; i < fNpoints; i++) {; 1748 out << "" tgme->SetPoint("" << i << "", "" << fX[i] << "", "" << fY[i] << "");"" << std::endl;; 1749 out << "" tgme->SetPointEX("" << i << "", "" << fExL[i] << "", "" << fExH[i] << "");"" << std::endl;; 1750 ; 1751 for (Int_t j = 0; j < fNYErrors; j++); 1752 out << "" tgme->SetPointEY("" << i << "", "" << j << "", "" << fEyL[j][i] << "", "" << fEyH[j][i] << "");""; 1753 << std::endl;; 1754 }; 1755 ; 1756 SaveHistogramAndFunctions(out, ""tgme"", frameNumber, option);; 1757}; 1758 ; 1759////////////////////////////////////////////////////////////////////////////////; 1760/// Multiply the values and errors of a TGraphMultiErrors by a constant c1.; 1761///; 1762/// If option contains ""x"" the x values and errors are scaled; 1763/// If option contains ""y"" the y values and (multiple) errors are scaled; 1764/// If option contains ""xy"" both x and y values and (multiple) errors are scaled; 1765 ; 1766void TGraphMultiErrors::Scale(Double_t c1, Option_t *option); 1767{; 1768 TGraph::Scale(c1, option);; 1769 TString opt = option; opt.ToLower();; 1770 if (opt.Contains(""x"") && GetEXlow()) {; 1771 for (Int_t i=0; i<GetN(); i++); 1772 GetEXlow()[i] *= c1;; 1773 }; 1774 if (opt.Contains(""x"") && GetEXhigh()) {; 1775 for (Int_t i=0; i<GetN(); i++); 1776 GetEXhigh()[i] *= c1;; 1777 }; 1778 if (opt.Contains(""y"")) {; 1779 for (size_t d=0; d<fEyL.size(); d++); 1780 for (Int_t i=0; i<fEyL[d].GetSize(); i++); 1781 fEyL[d][i] *= c1;; 1782 for (size_t d=0; d<fEyH.size(); d++); 1783 for (Int_t i=0; i<fEyH[d].GetSize(); i++); 1784 fEyH[d][i] *= c1;; 1785 }; 1786}; 1787 ; 1788////////////////////////////////////////////////////////////////////////////////; 1789/// Set ex and ey values for point pointed by the mouse.; 1790///; 1791/// Up to 3 y error dimensions possible.; 1792 ; 1793void TGraphMultiErrors::SetPointError(Double_t exL, Double_t e",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:60242,Availability,error,errors,60242,"a(), 0, 1001);; 1744 fAttLine[j].SaveLineAttributes(out, TString::Format(""tgme->GetAttLine(%d)"", j).Data(), 1, 1, 1);; 1745 }; 1746 ; 1747 for (Int_t i = 0; i < fNpoints; i++) {; 1748 out << "" tgme->SetPoint("" << i << "", "" << fX[i] << "", "" << fY[i] << "");"" << std::endl;; 1749 out << "" tgme->SetPointEX("" << i << "", "" << fExL[i] << "", "" << fExH[i] << "");"" << std::endl;; 1750 ; 1751 for (Int_t j = 0; j < fNYErrors; j++); 1752 out << "" tgme->SetPointEY("" << i << "", "" << j << "", "" << fEyL[j][i] << "", "" << fEyH[j][i] << "");""; 1753 << std::endl;; 1754 }; 1755 ; 1756 SaveHistogramAndFunctions(out, ""tgme"", frameNumber, option);; 1757}; 1758 ; 1759////////////////////////////////////////////////////////////////////////////////; 1760/// Multiply the values and errors of a TGraphMultiErrors by a constant c1.; 1761///; 1762/// If option contains ""x"" the x values and errors are scaled; 1763/// If option contains ""y"" the y values and (multiple) errors are scaled; 1764/// If option contains ""xy"" both x and y values and (multiple) errors are scaled; 1765 ; 1766void TGraphMultiErrors::Scale(Double_t c1, Option_t *option); 1767{; 1768 TGraph::Scale(c1, option);; 1769 TString opt = option; opt.ToLower();; 1770 if (opt.Contains(""x"") && GetEXlow()) {; 1771 for (Int_t i=0; i<GetN(); i++); 1772 GetEXlow()[i] *= c1;; 1773 }; 1774 if (opt.Contains(""x"") && GetEXhigh()) {; 1775 for (Int_t i=0; i<GetN(); i++); 1776 GetEXhigh()[i] *= c1;; 1777 }; 1778 if (opt.Contains(""y"")) {; 1779 for (size_t d=0; d<fEyL.size(); d++); 1780 for (Int_t i=0; i<fEyL[d].GetSize(); i++); 1781 fEyL[d][i] *= c1;; 1782 for (size_t d=0; d<fEyH.size(); d++); 1783 for (Int_t i=0; i<fEyH[d].GetSize(); i++); 1784 fEyH[d][i] *= c1;; 1785 }; 1786}; 1787 ; 1788////////////////////////////////////////////////////////////////////////////////; 1789/// Set ex and ey values for point pointed by the mouse.; 1790///; 1791/// Up to 3 y error dimensions possible.; 1792 ; 1793void TGraphMultiErrors::SetPointError(Double_t exL, Double_t e",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:61111,Availability,error,error,61111,"ption contains ""y"" the y values and (multiple) errors are scaled; 1764/// If option contains ""xy"" both x and y values and (multiple) errors are scaled; 1765 ; 1766void TGraphMultiErrors::Scale(Double_t c1, Option_t *option); 1767{; 1768 TGraph::Scale(c1, option);; 1769 TString opt = option; opt.ToLower();; 1770 if (opt.Contains(""x"") && GetEXlow()) {; 1771 for (Int_t i=0; i<GetN(); i++); 1772 GetEXlow()[i] *= c1;; 1773 }; 1774 if (opt.Contains(""x"") && GetEXhigh()) {; 1775 for (Int_t i=0; i<GetN(); i++); 1776 GetEXhigh()[i] *= c1;; 1777 }; 1778 if (opt.Contains(""y"")) {; 1779 for (size_t d=0; d<fEyL.size(); d++); 1780 for (Int_t i=0; i<fEyL[d].GetSize(); i++); 1781 fEyL[d][i] *= c1;; 1782 for (size_t d=0; d<fEyH.size(); d++); 1783 for (Int_t i=0; i<fEyH[d].GetSize(); i++); 1784 fEyH[d][i] *= c1;; 1785 }; 1786}; 1787 ; 1788////////////////////////////////////////////////////////////////////////////////; 1789/// Set ex and ey values for point pointed by the mouse.; 1790///; 1791/// Up to 3 y error dimensions possible.; 1792 ; 1793void TGraphMultiErrors::SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2,; 1794 Double_t eyH2, Double_t eyL3, Double_t eyH3); 1795{; 1796 if (!gPad) {; 1797 Error(""SetPointError"", ""Cannot be used without gPad, requires last mouse position"");; 1798 return;; 1799 }; 1800 ; 1801 Int_t px = gPad->GetEventX();; 1802 Int_t py = gPad->GetEventY();; 1803 ; 1804 // localize point to be deleted; 1805 Int_t ipoint = -2;; 1806 // start with a small window (in case the mouse is very close to one point); 1807 for (Int_t i = 0; i < fNpoints; i++) {; 1808 Int_t dpx = px - gPad->XtoAbsPixel(gPad->XtoPad(fX[i]));; 1809 Int_t dpy = py - gPad->YtoAbsPixel(gPad->YtoPad(fY[i]));; 1810 ; 1811 if (dpx * dpx + dpy * dpy < 25) {; 1812 ipoint = i;; 1813 break;; 1814 }; 1815 }; 1816 ; 1817 if (ipoint == -2); 1818 return;; 1819 ; 1820 SetPointEX(ipoint, exL, exH);; 1821 ; 1822 if (fNYErrors > 0); 1823 SetPointEY(ipoint, 0, eyL1, eyH1);; 1",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:64916,Availability,error,error,64916,"hMultiErrors::SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH); 1886{; 1887 SetPointEYlow(i, ne, eyL);; 1888 SetPointEYhigh(i, ne, eyH);; 1889}; 1890 ; 1891////////////////////////////////////////////////////////////////////////////////; 1892/// Set eyL values for point `i`.; 1893 ; 1894void TGraphMultiErrors::SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL); 1895{; 1896 for (Int_t j = 0; j < fNYErrors; j++) {; 1897 if (j < ne); 1898 SetPointEYlow(i, j, eyL[j]);; 1899 else; 1900 SetPointEYlow(i, j, 0.);; 1901 }; 1902}; 1903 ; 1904////////////////////////////////////////////////////////////////////////////////; 1905/// Set eyH values for point `i`.; 1906 ; 1907void TGraphMultiErrors::SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH); 1908{; 1909 for (Int_t j = 0; j < fNYErrors; j++) {; 1910 if (j < ne); 1911 SetPointEYhigh(i, j, eyH[j]);; 1912 else; 1913 SetPointEYhigh(i, j, 0.);; 1914 }; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Set error e ey values for point `i`.; 1919 ; 1920void TGraphMultiErrors::SetPointEY(Int_t i, Int_t e, Double_t eyL, Double_t eyH); 1921{; 1922 SetPointEYlow(i, e, eyL);; 1923 SetPointEYhigh(i, e, eyH);; 1924}; 1925 ; 1926////////////////////////////////////////////////////////////////////////////////; 1927/// Set error e eyL value for point `i`.; 1928 ; 1929void TGraphMultiErrors::SetPointEYlow(Int_t i, Int_t e, Double_t eyL); 1930{; 1931 if (i < 0 || e < 0); 1932 return;; 1933 ; 1934 if (i >= fNpoints); 1935 // re-allocate the object; 1936 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1937 ; 1938 while (e >= fNYErrors); 1939 AddYError(fNpoints);; 1940 ; 1941 fEyL[e][i] = eyL;; 1942 if (fEyLSum); 1943 fEyLSum[i] = GetErrorYlow(i);; 1944 else; 1945 CalcYErrorsSum();; 1946}; 1947 ; 1948////////////////////////////////////////////////////////////////////////////////; 1949/// Set error e eyH value for point `i`.; 1950 ; 1951void TGraphMultiErrors::SetPo",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:65227,Availability,error,error,65227,"//////////////////////////; 1892/// Set eyL values for point `i`.; 1893 ; 1894void TGraphMultiErrors::SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL); 1895{; 1896 for (Int_t j = 0; j < fNYErrors; j++) {; 1897 if (j < ne); 1898 SetPointEYlow(i, j, eyL[j]);; 1899 else; 1900 SetPointEYlow(i, j, 0.);; 1901 }; 1902}; 1903 ; 1904////////////////////////////////////////////////////////////////////////////////; 1905/// Set eyH values for point `i`.; 1906 ; 1907void TGraphMultiErrors::SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH); 1908{; 1909 for (Int_t j = 0; j < fNYErrors; j++) {; 1910 if (j < ne); 1911 SetPointEYhigh(i, j, eyH[j]);; 1912 else; 1913 SetPointEYhigh(i, j, 0.);; 1914 }; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Set error e ey values for point `i`.; 1919 ; 1920void TGraphMultiErrors::SetPointEY(Int_t i, Int_t e, Double_t eyL, Double_t eyH); 1921{; 1922 SetPointEYlow(i, e, eyL);; 1923 SetPointEYhigh(i, e, eyH);; 1924}; 1925 ; 1926////////////////////////////////////////////////////////////////////////////////; 1927/// Set error e eyL value for point `i`.; 1928 ; 1929void TGraphMultiErrors::SetPointEYlow(Int_t i, Int_t e, Double_t eyL); 1930{; 1931 if (i < 0 || e < 0); 1932 return;; 1933 ; 1934 if (i >= fNpoints); 1935 // re-allocate the object; 1936 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1937 ; 1938 while (e >= fNYErrors); 1939 AddYError(fNpoints);; 1940 ; 1941 fEyL[e][i] = eyL;; 1942 if (fEyLSum); 1943 fEyLSum[i] = GetErrorYlow(i);; 1944 else; 1945 CalcYErrorsSum();; 1946}; 1947 ; 1948////////////////////////////////////////////////////////////////////////////////; 1949/// Set error e eyH value for point `i`.; 1950 ; 1951void TGraphMultiErrors::SetPointEYhigh(Int_t i, Int_t e, Double_t eyH); 1952{; 1953 if (i < 0 || e < 0); 1954 return;; 1955 ; 1956 if (i >= fNpoints); 1957 // re-allocate the object; 1958 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1959 ; 1960 while (e >= fNYErrors)",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:65796,Availability,error,error,65796,"(Int_t j = 0; j < fNYErrors; j++) {; 1910 if (j < ne); 1911 SetPointEYhigh(i, j, eyH[j]);; 1912 else; 1913 SetPointEYhigh(i, j, 0.);; 1914 }; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Set error e ey values for point `i`.; 1919 ; 1920void TGraphMultiErrors::SetPointEY(Int_t i, Int_t e, Double_t eyL, Double_t eyH); 1921{; 1922 SetPointEYlow(i, e, eyL);; 1923 SetPointEYhigh(i, e, eyH);; 1924}; 1925 ; 1926////////////////////////////////////////////////////////////////////////////////; 1927/// Set error e eyL value for point `i`.; 1928 ; 1929void TGraphMultiErrors::SetPointEYlow(Int_t i, Int_t e, Double_t eyL); 1930{; 1931 if (i < 0 || e < 0); 1932 return;; 1933 ; 1934 if (i >= fNpoints); 1935 // re-allocate the object; 1936 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1937 ; 1938 while (e >= fNYErrors); 1939 AddYError(fNpoints);; 1940 ; 1941 fEyL[e][i] = eyL;; 1942 if (fEyLSum); 1943 fEyLSum[i] = GetErrorYlow(i);; 1944 else; 1945 CalcYErrorsSum();; 1946}; 1947 ; 1948////////////////////////////////////////////////////////////////////////////////; 1949/// Set error e eyH value for point `i`.; 1950 ; 1951void TGraphMultiErrors::SetPointEYhigh(Int_t i, Int_t e, Double_t eyH); 1952{; 1953 if (i < 0 || e < 0); 1954 return;; 1955 ; 1956 if (i >= fNpoints); 1957 // re-allocate the object; 1958 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1959 ; 1960 while (e >= fNYErrors); 1961 AddYError(fNpoints);; 1962 ; 1963 fEyH[e][i] = eyH;; 1964 if (fEyHSum); 1965 fEyHSum[i] = GetErrorYhigh(i);; 1966 else; 1967 CalcYErrorsSum();; 1968}; 1969 ; 1970////////////////////////////////////////////////////////////////////////////////; 1971/// Set error e ey values.; 1972 ; 1973void TGraphMultiErrors::SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH); 1974{; 1975 SetEYlow(e, np, eyL);; 1976 SetEYhigh(e, np, eyH);; 1977}; 1978 ; 1979////////////////////////////////////////////////////////////////////////////////; 1980/// ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:66367,Availability,error,error,66367,"t error e eyL value for point `i`.; 1928 ; 1929void TGraphMultiErrors::SetPointEYlow(Int_t i, Int_t e, Double_t eyL); 1930{; 1931 if (i < 0 || e < 0); 1932 return;; 1933 ; 1934 if (i >= fNpoints); 1935 // re-allocate the object; 1936 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1937 ; 1938 while (e >= fNYErrors); 1939 AddYError(fNpoints);; 1940 ; 1941 fEyL[e][i] = eyL;; 1942 if (fEyLSum); 1943 fEyLSum[i] = GetErrorYlow(i);; 1944 else; 1945 CalcYErrorsSum();; 1946}; 1947 ; 1948////////////////////////////////////////////////////////////////////////////////; 1949/// Set error e eyH value for point `i`.; 1950 ; 1951void TGraphMultiErrors::SetPointEYhigh(Int_t i, Int_t e, Double_t eyH); 1952{; 1953 if (i < 0 || e < 0); 1954 return;; 1955 ; 1956 if (i >= fNpoints); 1957 // re-allocate the object; 1958 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1959 ; 1960 while (e >= fNYErrors); 1961 AddYError(fNpoints);; 1962 ; 1963 fEyH[e][i] = eyH;; 1964 if (fEyHSum); 1965 fEyHSum[i] = GetErrorYhigh(i);; 1966 else; 1967 CalcYErrorsSum();; 1968}; 1969 ; 1970////////////////////////////////////////////////////////////////////////////////; 1971/// Set error e ey values.; 1972 ; 1973void TGraphMultiErrors::SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH); 1974{; 1975 SetEYlow(e, np, eyL);; 1976 SetEYhigh(e, np, eyH);; 1977}; 1978 ; 1979////////////////////////////////////////////////////////////////////////////////; 1980/// Set error e eyL values.; 1981 ; 1982void TGraphMultiErrors::SetEYlow(Int_t e, Int_t np, const Double_t *eyL); 1983{; 1984 for (Int_t i = 0; i < fNpoints; i++) {; 1985 if (i < np); 1986 SetPointEYlow(i, e, eyL[i]);; 1987 else; 1988 SetPointEYlow(i, e, 0.);; 1989 }; 1990}; 1991 ; 1992////////////////////////////////////////////////////////////////////////////////; 1993/// Set error e eyH values.; 1994 ; 1995void TGraphMultiErrors::SetEYhigh(Int_t e, Int_t np, const Double_t *eyH); 1996{; 1997 for (Int_t i = 0; i < fNpoints; i++) {; 1998 if (i < np); 1999 SetPo",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:66666,Availability,error,error,66666," 1939 AddYError(fNpoints);; 1940 ; 1941 fEyL[e][i] = eyL;; 1942 if (fEyLSum); 1943 fEyLSum[i] = GetErrorYlow(i);; 1944 else; 1945 CalcYErrorsSum();; 1946}; 1947 ; 1948////////////////////////////////////////////////////////////////////////////////; 1949/// Set error e eyH value for point `i`.; 1950 ; 1951void TGraphMultiErrors::SetPointEYhigh(Int_t i, Int_t e, Double_t eyH); 1952{; 1953 if (i < 0 || e < 0); 1954 return;; 1955 ; 1956 if (i >= fNpoints); 1957 // re-allocate the object; 1958 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1959 ; 1960 while (e >= fNYErrors); 1961 AddYError(fNpoints);; 1962 ; 1963 fEyH[e][i] = eyH;; 1964 if (fEyHSum); 1965 fEyHSum[i] = GetErrorYhigh(i);; 1966 else; 1967 CalcYErrorsSum();; 1968}; 1969 ; 1970////////////////////////////////////////////////////////////////////////////////; 1971/// Set error e ey values.; 1972 ; 1973void TGraphMultiErrors::SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH); 1974{; 1975 SetEYlow(e, np, eyL);; 1976 SetEYhigh(e, np, eyH);; 1977}; 1978 ; 1979////////////////////////////////////////////////////////////////////////////////; 1980/// Set error e eyL values.; 1981 ; 1982void TGraphMultiErrors::SetEYlow(Int_t e, Int_t np, const Double_t *eyL); 1983{; 1984 for (Int_t i = 0; i < fNpoints; i++) {; 1985 if (i < np); 1986 SetPointEYlow(i, e, eyL[i]);; 1987 else; 1988 SetPointEYlow(i, e, 0.);; 1989 }; 1990}; 1991 ; 1992////////////////////////////////////////////////////////////////////////////////; 1993/// Set error e eyH values.; 1994 ; 1995void TGraphMultiErrors::SetEYhigh(Int_t e, Int_t np, const Double_t *eyH); 1996{; 1997 for (Int_t i = 0; i < fNpoints; i++) {; 1998 if (i < np); 1999 SetPointEYhigh(i, e, eyH[i]);; 2000 else; 2001 SetPointEYhigh(i, e, 0.);; 2002 }; 2003}; 2004 ; 2005////////////////////////////////////////////////////////////////////////////////; 2006/// Set the sum errors mode and recalculate summed errors.; 2007void TGraphMultiErrors::SetSumErrorsMode(Int_t m); 2008{; 2009 i",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:67039,Availability,error,error,67039,"nts); 1957 // re-allocate the object; 1958 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1959 ; 1960 while (e >= fNYErrors); 1961 AddYError(fNpoints);; 1962 ; 1963 fEyH[e][i] = eyH;; 1964 if (fEyHSum); 1965 fEyHSum[i] = GetErrorYhigh(i);; 1966 else; 1967 CalcYErrorsSum();; 1968}; 1969 ; 1970////////////////////////////////////////////////////////////////////////////////; 1971/// Set error e ey values.; 1972 ; 1973void TGraphMultiErrors::SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH); 1974{; 1975 SetEYlow(e, np, eyL);; 1976 SetEYhigh(e, np, eyH);; 1977}; 1978 ; 1979////////////////////////////////////////////////////////////////////////////////; 1980/// Set error e eyL values.; 1981 ; 1982void TGraphMultiErrors::SetEYlow(Int_t e, Int_t np, const Double_t *eyL); 1983{; 1984 for (Int_t i = 0; i < fNpoints; i++) {; 1985 if (i < np); 1986 SetPointEYlow(i, e, eyL[i]);; 1987 else; 1988 SetPointEYlow(i, e, 0.);; 1989 }; 1990}; 1991 ; 1992////////////////////////////////////////////////////////////////////////////////; 1993/// Set error e eyH values.; 1994 ; 1995void TGraphMultiErrors::SetEYhigh(Int_t e, Int_t np, const Double_t *eyH); 1996{; 1997 for (Int_t i = 0; i < fNpoints; i++) {; 1998 if (i < np); 1999 SetPointEYhigh(i, e, eyH[i]);; 2000 else; 2001 SetPointEYhigh(i, e, 0.);; 2002 }; 2003}; 2004 ; 2005////////////////////////////////////////////////////////////////////////////////; 2006/// Set the sum errors mode and recalculate summed errors.; 2007void TGraphMultiErrors::SetSumErrorsMode(Int_t m); 2008{; 2009 if (fSumErrorsMode == m); 2010 return;; 2011 fSumErrorsMode = m;; 2012 CalcYErrorsSum();; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).; 2017 ; 2018void TGraphMultiErrors::SetAttFill(Int_t e, TAttFill *taf); 2019{; 2020 if (e == -1); 2021 taf->TAttFill::Copy(*this);; 2022 else if (e >= 0 && e <",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:67423,Availability,error,errors,67423,"values.; 1972 ; 1973void TGraphMultiErrors::SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH); 1974{; 1975 SetEYlow(e, np, eyL);; 1976 SetEYhigh(e, np, eyH);; 1977}; 1978 ; 1979////////////////////////////////////////////////////////////////////////////////; 1980/// Set error e eyL values.; 1981 ; 1982void TGraphMultiErrors::SetEYlow(Int_t e, Int_t np, const Double_t *eyL); 1983{; 1984 for (Int_t i = 0; i < fNpoints; i++) {; 1985 if (i < np); 1986 SetPointEYlow(i, e, eyL[i]);; 1987 else; 1988 SetPointEYlow(i, e, 0.);; 1989 }; 1990}; 1991 ; 1992////////////////////////////////////////////////////////////////////////////////; 1993/// Set error e eyH values.; 1994 ; 1995void TGraphMultiErrors::SetEYhigh(Int_t e, Int_t np, const Double_t *eyH); 1996{; 1997 for (Int_t i = 0; i < fNpoints; i++) {; 1998 if (i < np); 1999 SetPointEYhigh(i, e, eyH[i]);; 2000 else; 2001 SetPointEYhigh(i, e, 0.);; 2002 }; 2003}; 2004 ; 2005////////////////////////////////////////////////////////////////////////////////; 2006/// Set the sum errors mode and recalculate summed errors.; 2007void TGraphMultiErrors::SetSumErrorsMode(Int_t m); 2008{; 2009 if (fSumErrorsMode == m); 2010 return;; 2011 fSumErrorsMode = m;; 2012 CalcYErrorsSum();; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).; 2017 ; 2018void TGraphMultiErrors::SetAttFill(Int_t e, TAttFill *taf); 2019{; 2020 if (e == -1); 2021 taf->TAttFill::Copy(*this);; 2022 else if (e >= 0 && e < fNYErrors); 2023 taf->TAttFill::Copy(fAttFill[e]);; 2024}; 2025 ; 2026////////////////////////////////////////////////////////////////////////////////; 2027/// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).; 2028 ; 2029void TGraphMultiErrors::SetAttLine(Int_t e, TAttLine *taf); 2030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 20",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:67458,Availability,error,errors,67458,"values.; 1972 ; 1973void TGraphMultiErrors::SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH); 1974{; 1975 SetEYlow(e, np, eyL);; 1976 SetEYhigh(e, np, eyH);; 1977}; 1978 ; 1979////////////////////////////////////////////////////////////////////////////////; 1980/// Set error e eyL values.; 1981 ; 1982void TGraphMultiErrors::SetEYlow(Int_t e, Int_t np, const Double_t *eyL); 1983{; 1984 for (Int_t i = 0; i < fNpoints; i++) {; 1985 if (i < np); 1986 SetPointEYlow(i, e, eyL[i]);; 1987 else; 1988 SetPointEYlow(i, e, 0.);; 1989 }; 1990}; 1991 ; 1992////////////////////////////////////////////////////////////////////////////////; 1993/// Set error e eyH values.; 1994 ; 1995void TGraphMultiErrors::SetEYhigh(Int_t e, Int_t np, const Double_t *eyH); 1996{; 1997 for (Int_t i = 0; i < fNpoints; i++) {; 1998 if (i < np); 1999 SetPointEYhigh(i, e, eyH[i]);; 2000 else; 2001 SetPointEYhigh(i, e, 0.);; 2002 }; 2003}; 2004 ; 2005////////////////////////////////////////////////////////////////////////////////; 2006/// Set the sum errors mode and recalculate summed errors.; 2007void TGraphMultiErrors::SetSumErrorsMode(Int_t m); 2008{; 2009 if (fSumErrorsMode == m); 2010 return;; 2011 fSumErrorsMode = m;; 2012 CalcYErrorsSum();; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).; 2017 ; 2018void TGraphMultiErrors::SetAttFill(Int_t e, TAttFill *taf); 2019{; 2020 if (e == -1); 2021 taf->TAttFill::Copy(*this);; 2022 else if (e >= 0 && e < fNYErrors); 2023 taf->TAttFill::Copy(fAttFill[e]);; 2024}; 2025 ; 2026////////////////////////////////////////////////////////////////////////////////; 2027/// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).; 2028 ; 2029void TGraphMultiErrors::SetAttLine(Int_t e, TAttLine *taf); 2030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 20",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:67759,Availability,error,error,67759,"//////; 1980/// Set error e eyL values.; 1981 ; 1982void TGraphMultiErrors::SetEYlow(Int_t e, Int_t np, const Double_t *eyL); 1983{; 1984 for (Int_t i = 0; i < fNpoints; i++) {; 1985 if (i < np); 1986 SetPointEYlow(i, e, eyL[i]);; 1987 else; 1988 SetPointEYlow(i, e, 0.);; 1989 }; 1990}; 1991 ; 1992////////////////////////////////////////////////////////////////////////////////; 1993/// Set error e eyH values.; 1994 ; 1995void TGraphMultiErrors::SetEYhigh(Int_t e, Int_t np, const Double_t *eyH); 1996{; 1997 for (Int_t i = 0; i < fNpoints; i++) {; 1998 if (i < np); 1999 SetPointEYhigh(i, e, eyH[i]);; 2000 else; 2001 SetPointEYhigh(i, e, 0.);; 2002 }; 2003}; 2004 ; 2005////////////////////////////////////////////////////////////////////////////////; 2006/// Set the sum errors mode and recalculate summed errors.; 2007void TGraphMultiErrors::SetSumErrorsMode(Int_t m); 2008{; 2009 if (fSumErrorsMode == m); 2010 return;; 2011 fSumErrorsMode = m;; 2012 CalcYErrorsSum();; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).; 2017 ; 2018void TGraphMultiErrors::SetAttFill(Int_t e, TAttFill *taf); 2019{; 2020 if (e == -1); 2021 taf->TAttFill::Copy(*this);; 2022 else if (e >= 0 && e < fNYErrors); 2023 taf->TAttFill::Copy(fAttFill[e]);; 2024}; 2025 ; 2026////////////////////////////////////////////////////////////////////////////////; 2027/// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).; 2028 ; 2029void TGraphMultiErrors::SetAttLine(Int_t e, TAttLine *taf); 2030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMulti",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:67819,Availability,error,errors,67819,"//////; 1980/// Set error e eyL values.; 1981 ; 1982void TGraphMultiErrors::SetEYlow(Int_t e, Int_t np, const Double_t *eyL); 1983{; 1984 for (Int_t i = 0; i < fNpoints; i++) {; 1985 if (i < np); 1986 SetPointEYlow(i, e, eyL[i]);; 1987 else; 1988 SetPointEYlow(i, e, 0.);; 1989 }; 1990}; 1991 ; 1992////////////////////////////////////////////////////////////////////////////////; 1993/// Set error e eyH values.; 1994 ; 1995void TGraphMultiErrors::SetEYhigh(Int_t e, Int_t np, const Double_t *eyH); 1996{; 1997 for (Int_t i = 0; i < fNpoints; i++) {; 1998 if (i < np); 1999 SetPointEYhigh(i, e, eyH[i]);; 2000 else; 2001 SetPointEYhigh(i, e, 0.);; 2002 }; 2003}; 2004 ; 2005////////////////////////////////////////////////////////////////////////////////; 2006/// Set the sum errors mode and recalculate summed errors.; 2007void TGraphMultiErrors::SetSumErrorsMode(Int_t m); 2008{; 2009 if (fSumErrorsMode == m); 2010 return;; 2011 fSumErrorsMode = m;; 2012 CalcYErrorsSum();; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).; 2017 ; 2018void TGraphMultiErrors::SetAttFill(Int_t e, TAttFill *taf); 2019{; 2020 if (e == -1); 2021 taf->TAttFill::Copy(*this);; 2022 else if (e >= 0 && e < fNYErrors); 2023 taf->TAttFill::Copy(fAttFill[e]);; 2024}; 2025 ; 2026////////////////////////////////////////////////////////////////////////////////; 2027/// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).; 2028 ; 2029void TGraphMultiErrors::SetAttLine(Int_t e, TAttLine *taf); 2030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMulti",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:68175,Availability,error,error,68175,"Set error e eyH values.; 1994 ; 1995void TGraphMultiErrors::SetEYhigh(Int_t e, Int_t np, const Double_t *eyH); 1996{; 1997 for (Int_t i = 0; i < fNpoints; i++) {; 1998 if (i < np); 1999 SetPointEYhigh(i, e, eyH[i]);; 2000 else; 2001 SetPointEYhigh(i, e, 0.);; 2002 }; 2003}; 2004 ; 2005////////////////////////////////////////////////////////////////////////////////; 2006/// Set the sum errors mode and recalculate summed errors.; 2007void TGraphMultiErrors::SetSumErrorsMode(Int_t m); 2008{; 2009 if (fSumErrorsMode == m); 2010 return;; 2011 fSumErrorsMode = m;; 2012 CalcYErrorsSum();; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).; 2017 ; 2018void TGraphMultiErrors::SetAttFill(Int_t e, TAttFill *taf); 2019{; 2020 if (e == -1); 2021 taf->TAttFill::Copy(*this);; 2022 else if (e >= 0 && e < fNYErrors); 2023 taf->TAttFill::Copy(fAttFill[e]);; 2024}; 2025 ; 2026////////////////////////////////////////////////////////////////////////////////; 2027/// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).; 2028 ; 2029void TGraphMultiErrors::SetAttLine(Int_t e, TAttLine *taf); 2030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMultiErrors::SetFillColor(Int_t e, Color_t fcolor); 2041{; 2042 if (e == -1); 2043 SetFillColor(fcolor);; 2044 else if (e >= 0 && e < fNYErrors); 2045 fAttFill[e].SetFillColor(fcolor);; 2046}; 2047 ; 2048////////////////////////////////////////////////////////////////////////////////; 2049/// Set Fill Color and Alpha of error e (-1 = Global and x errors).; 2050 ; 2051void TGraphMultiErrors::",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:68235,Availability,error,errors,68235,"Set error e eyH values.; 1994 ; 1995void TGraphMultiErrors::SetEYhigh(Int_t e, Int_t np, const Double_t *eyH); 1996{; 1997 for (Int_t i = 0; i < fNpoints; i++) {; 1998 if (i < np); 1999 SetPointEYhigh(i, e, eyH[i]);; 2000 else; 2001 SetPointEYhigh(i, e, 0.);; 2002 }; 2003}; 2004 ; 2005////////////////////////////////////////////////////////////////////////////////; 2006/// Set the sum errors mode and recalculate summed errors.; 2007void TGraphMultiErrors::SetSumErrorsMode(Int_t m); 2008{; 2009 if (fSumErrorsMode == m); 2010 return;; 2011 fSumErrorsMode = m;; 2012 CalcYErrorsSum();; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).; 2017 ; 2018void TGraphMultiErrors::SetAttFill(Int_t e, TAttFill *taf); 2019{; 2020 if (e == -1); 2021 taf->TAttFill::Copy(*this);; 2022 else if (e >= 0 && e < fNYErrors); 2023 taf->TAttFill::Copy(fAttFill[e]);; 2024}; 2025 ; 2026////////////////////////////////////////////////////////////////////////////////; 2027/// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).; 2028 ; 2029void TGraphMultiErrors::SetAttLine(Int_t e, TAttLine *taf); 2030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMultiErrors::SetFillColor(Int_t e, Color_t fcolor); 2041{; 2042 if (e == -1); 2043 SetFillColor(fcolor);; 2044 else if (e >= 0 && e < fNYErrors); 2045 fAttFill[e].SetFillColor(fcolor);; 2046}; 2047 ; 2048////////////////////////////////////////////////////////////////////////////////; 2049/// Set Fill Color and Alpha of error e (-1 = Global and x errors).; 2050 ; 2051void TGraphMultiErrors::",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:68582,Availability,error,error,68582,"mode and recalculate summed errors.; 2007void TGraphMultiErrors::SetSumErrorsMode(Int_t m); 2008{; 2009 if (fSumErrorsMode == m); 2010 return;; 2011 fSumErrorsMode = m;; 2012 CalcYErrorsSum();; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).; 2017 ; 2018void TGraphMultiErrors::SetAttFill(Int_t e, TAttFill *taf); 2019{; 2020 if (e == -1); 2021 taf->TAttFill::Copy(*this);; 2022 else if (e >= 0 && e < fNYErrors); 2023 taf->TAttFill::Copy(fAttFill[e]);; 2024}; 2025 ; 2026////////////////////////////////////////////////////////////////////////////////; 2027/// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).; 2028 ; 2029void TGraphMultiErrors::SetAttLine(Int_t e, TAttLine *taf); 2030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMultiErrors::SetFillColor(Int_t e, Color_t fcolor); 2041{; 2042 if (e == -1); 2043 SetFillColor(fcolor);; 2044 else if (e >= 0 && e < fNYErrors); 2045 fAttFill[e].SetFillColor(fcolor);; 2046}; 2047 ; 2048////////////////////////////////////////////////////////////////////////////////; 2049/// Set Fill Color and Alpha of error e (-1 = Global and x errors).; 2050 ; 2051void TGraphMultiErrors::SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha); 2052{; 2053 if (e == -1); 2054 SetFillColorAlpha(fcolor, falpha);; 2055 else if (e >= 0 && e < fNYErrors); 2056 fAttFill[e].SetFillColorAlpha(fcolor, falpha);; 2057}; 2058 ; 2059////////////////////////////////////////////////////////////////////////////////; 2060/// Set Fill Style of error e (-1 = Global and x errors).; 2061 ; 2062v",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:68609,Availability,error,errors,68609,"mode and recalculate summed errors.; 2007void TGraphMultiErrors::SetSumErrorsMode(Int_t m); 2008{; 2009 if (fSumErrorsMode == m); 2010 return;; 2011 fSumErrorsMode = m;; 2012 CalcYErrorsSum();; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).; 2017 ; 2018void TGraphMultiErrors::SetAttFill(Int_t e, TAttFill *taf); 2019{; 2020 if (e == -1); 2021 taf->TAttFill::Copy(*this);; 2022 else if (e >= 0 && e < fNYErrors); 2023 taf->TAttFill::Copy(fAttFill[e]);; 2024}; 2025 ; 2026////////////////////////////////////////////////////////////////////////////////; 2027/// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).; 2028 ; 2029void TGraphMultiErrors::SetAttLine(Int_t e, TAttLine *taf); 2030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMultiErrors::SetFillColor(Int_t e, Color_t fcolor); 2041{; 2042 if (e == -1); 2043 SetFillColor(fcolor);; 2044 else if (e >= 0 && e < fNYErrors); 2045 fAttFill[e].SetFillColor(fcolor);; 2046}; 2047 ; 2048////////////////////////////////////////////////////////////////////////////////; 2049/// Set Fill Color and Alpha of error e (-1 = Global and x errors).; 2050 ; 2051void TGraphMultiErrors::SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha); 2052{; 2053 if (e == -1); 2054 SetFillColorAlpha(fcolor, falpha);; 2055 else if (e >= 0 && e < fNYErrors); 2056 fAttFill[e].SetFillColorAlpha(fcolor, falpha);; 2057}; 2058 ; 2059////////////////////////////////////////////////////////////////////////////////; 2060/// Set Fill Style of error e (-1 = Global and x errors).; 2061 ; 2062v",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:68963,Availability,error,error,68963,"019{; 2020 if (e == -1); 2021 taf->TAttFill::Copy(*this);; 2022 else if (e >= 0 && e < fNYErrors); 2023 taf->TAttFill::Copy(fAttFill[e]);; 2024}; 2025 ; 2026////////////////////////////////////////////////////////////////////////////////; 2027/// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).; 2028 ; 2029void TGraphMultiErrors::SetAttLine(Int_t e, TAttLine *taf); 2030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMultiErrors::SetFillColor(Int_t e, Color_t fcolor); 2041{; 2042 if (e == -1); 2043 SetFillColor(fcolor);; 2044 else if (e >= 0 && e < fNYErrors); 2045 fAttFill[e].SetFillColor(fcolor);; 2046}; 2047 ; 2048////////////////////////////////////////////////////////////////////////////////; 2049/// Set Fill Color and Alpha of error e (-1 = Global and x errors).; 2050 ; 2051void TGraphMultiErrors::SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha); 2052{; 2053 if (e == -1); 2054 SetFillColorAlpha(fcolor, falpha);; 2055 else if (e >= 0 && e < fNYErrors); 2056 fAttFill[e].SetFillColorAlpha(fcolor, falpha);; 2057}; 2058 ; 2059////////////////////////////////////////////////////////////////////////////////; 2060/// Set Fill Style of error e (-1 = Global and x errors).; 2061 ; 2062void TGraphMultiErrors::SetFillStyle(Int_t e, Style_t fstyle); 2063{; 2064 if (e == -1); 2065 SetFillStyle(fstyle);; 2066 else if (e >= 0 && e < fNYErrors); 2067 fAttFill[e].SetFillStyle(fstyle);; 2068}; 2069 ; 2070////////////////////////////////////////////////////////////////////////////////; 2071/// Set Line Color of error e (-1 = Global and x errors).; 2072 ; 2073void TGraphMultiErrors::SetLineColor(Int_t e, Color_t lcolor); 2074{; 2075 if (e == -1); 2076 SetLine",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:68990,Availability,error,errors,68990,"019{; 2020 if (e == -1); 2021 taf->TAttFill::Copy(*this);; 2022 else if (e >= 0 && e < fNYErrors); 2023 taf->TAttFill::Copy(fAttFill[e]);; 2024}; 2025 ; 2026////////////////////////////////////////////////////////////////////////////////; 2027/// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).; 2028 ; 2029void TGraphMultiErrors::SetAttLine(Int_t e, TAttLine *taf); 2030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMultiErrors::SetFillColor(Int_t e, Color_t fcolor); 2041{; 2042 if (e == -1); 2043 SetFillColor(fcolor);; 2044 else if (e >= 0 && e < fNYErrors); 2045 fAttFill[e].SetFillColor(fcolor);; 2046}; 2047 ; 2048////////////////////////////////////////////////////////////////////////////////; 2049/// Set Fill Color and Alpha of error e (-1 = Global and x errors).; 2050 ; 2051void TGraphMultiErrors::SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha); 2052{; 2053 if (e == -1); 2054 SetFillColorAlpha(fcolor, falpha);; 2055 else if (e >= 0 && e < fNYErrors); 2056 fAttFill[e].SetFillColorAlpha(fcolor, falpha);; 2057}; 2058 ; 2059////////////////////////////////////////////////////////////////////////////////; 2060/// Set Fill Style of error e (-1 = Global and x errors).; 2061 ; 2062void TGraphMultiErrors::SetFillStyle(Int_t e, Style_t fstyle); 2063{; 2064 if (e == -1); 2065 SetFillStyle(fstyle);; 2066 else if (e >= 0 && e < fNYErrors); 2067 fAttFill[e].SetFillStyle(fstyle);; 2068}; 2069 ; 2070////////////////////////////////////////////////////////////////////////////////; 2071/// Set Line Color of error e (-1 = Global and x errors).; 2072 ; 2073void TGraphMultiErrors::SetLineColor(Int_t e, Color_t lcolor); 2074{; 2075 if (e == -1); 2076 SetLine",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:69381,Availability,error,error,69381,"030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMultiErrors::SetFillColor(Int_t e, Color_t fcolor); 2041{; 2042 if (e == -1); 2043 SetFillColor(fcolor);; 2044 else if (e >= 0 && e < fNYErrors); 2045 fAttFill[e].SetFillColor(fcolor);; 2046}; 2047 ; 2048////////////////////////////////////////////////////////////////////////////////; 2049/// Set Fill Color and Alpha of error e (-1 = Global and x errors).; 2050 ; 2051void TGraphMultiErrors::SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha); 2052{; 2053 if (e == -1); 2054 SetFillColorAlpha(fcolor, falpha);; 2055 else if (e >= 0 && e < fNYErrors); 2056 fAttFill[e].SetFillColorAlpha(fcolor, falpha);; 2057}; 2058 ; 2059////////////////////////////////////////////////////////////////////////////////; 2060/// Set Fill Style of error e (-1 = Global and x errors).; 2061 ; 2062void TGraphMultiErrors::SetFillStyle(Int_t e, Style_t fstyle); 2063{; 2064 if (e == -1); 2065 SetFillStyle(fstyle);; 2066 else if (e >= 0 && e < fNYErrors); 2067 fAttFill[e].SetFillStyle(fstyle);; 2068}; 2069 ; 2070////////////////////////////////////////////////////////////////////////////////; 2071/// Set Line Color of error e (-1 = Global and x errors).; 2072 ; 2073void TGraphMultiErrors::SetLineColor(Int_t e, Color_t lcolor); 2074{; 2075 if (e == -1); 2076 SetLineColor(lcolor);; 2077 else if (e >= 0 && e < fNYErrors); 2078 fAttLine[e].SetLineColor(lcolor);; 2079}; 2080 ; 2081////////////////////////////////////////////////////////////////////////////////; 2082/// Set Line Color and Alpha of error e (-1 = Global and x errors).; 2083 ; 2084void TGraphMultiErrors::SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha); 2085{; 2086 if (e == -1); 2087 SetLineColorAlpha(lcol",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:69408,Availability,error,errors,69408,"030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMultiErrors::SetFillColor(Int_t e, Color_t fcolor); 2041{; 2042 if (e == -1); 2043 SetFillColor(fcolor);; 2044 else if (e >= 0 && e < fNYErrors); 2045 fAttFill[e].SetFillColor(fcolor);; 2046}; 2047 ; 2048////////////////////////////////////////////////////////////////////////////////; 2049/// Set Fill Color and Alpha of error e (-1 = Global and x errors).; 2050 ; 2051void TGraphMultiErrors::SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha); 2052{; 2053 if (e == -1); 2054 SetFillColorAlpha(fcolor, falpha);; 2055 else if (e >= 0 && e < fNYErrors); 2056 fAttFill[e].SetFillColorAlpha(fcolor, falpha);; 2057}; 2058 ; 2059////////////////////////////////////////////////////////////////////////////////; 2060/// Set Fill Style of error e (-1 = Global and x errors).; 2061 ; 2062void TGraphMultiErrors::SetFillStyle(Int_t e, Style_t fstyle); 2063{; 2064 if (e == -1); 2065 SetFillStyle(fstyle);; 2066 else if (e >= 0 && e < fNYErrors); 2067 fAttFill[e].SetFillStyle(fstyle);; 2068}; 2069 ; 2070////////////////////////////////////////////////////////////////////////////////; 2071/// Set Line Color of error e (-1 = Global and x errors).; 2072 ; 2073void TGraphMultiErrors::SetLineColor(Int_t e, Color_t lcolor); 2074{; 2075 if (e == -1); 2076 SetLineColor(lcolor);; 2077 else if (e >= 0 && e < fNYErrors); 2078 fAttLine[e].SetLineColor(lcolor);; 2079}; 2080 ; 2081////////////////////////////////////////////////////////////////////////////////; 2082/// Set Line Color and Alpha of error e (-1 = Global and x errors).; 2083 ; 2084void TGraphMultiErrors::SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha); 2085{; 2086 if (e == -1); 2087 SetLineColorAlpha(lcol",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:69752,Availability,error,error,69752,"41{; 2042 if (e == -1); 2043 SetFillColor(fcolor);; 2044 else if (e >= 0 && e < fNYErrors); 2045 fAttFill[e].SetFillColor(fcolor);; 2046}; 2047 ; 2048////////////////////////////////////////////////////////////////////////////////; 2049/// Set Fill Color and Alpha of error e (-1 = Global and x errors).; 2050 ; 2051void TGraphMultiErrors::SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha); 2052{; 2053 if (e == -1); 2054 SetFillColorAlpha(fcolor, falpha);; 2055 else if (e >= 0 && e < fNYErrors); 2056 fAttFill[e].SetFillColorAlpha(fcolor, falpha);; 2057}; 2058 ; 2059////////////////////////////////////////////////////////////////////////////////; 2060/// Set Fill Style of error e (-1 = Global and x errors).; 2061 ; 2062void TGraphMultiErrors::SetFillStyle(Int_t e, Style_t fstyle); 2063{; 2064 if (e == -1); 2065 SetFillStyle(fstyle);; 2066 else if (e >= 0 && e < fNYErrors); 2067 fAttFill[e].SetFillStyle(fstyle);; 2068}; 2069 ; 2070////////////////////////////////////////////////////////////////////////////////; 2071/// Set Line Color of error e (-1 = Global and x errors).; 2072 ; 2073void TGraphMultiErrors::SetLineColor(Int_t e, Color_t lcolor); 2074{; 2075 if (e == -1); 2076 SetLineColor(lcolor);; 2077 else if (e >= 0 && e < fNYErrors); 2078 fAttLine[e].SetLineColor(lcolor);; 2079}; 2080 ; 2081////////////////////////////////////////////////////////////////////////////////; 2082/// Set Line Color and Alpha of error e (-1 = Global and x errors).; 2083 ; 2084void TGraphMultiErrors::SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha); 2085{; 2086 if (e == -1); 2087 SetLineColorAlpha(lcolor, lalpha);; 2088 else if (e >= 0 && e < fNYErrors); 2089 fAttLine[e].SetLineColorAlpha(lcolor, lalpha);; 2090}; 2091 ; 2092////////////////////////////////////////////////////////////////////////////////; 2093/// Set Line Style of error e (-1 = Global and x errors).; 2094 ; 2095void TGraphMultiErrors::SetLineStyle(Int_t e, Style_t lstyle); 2096{; 2097 if (e == -1); 2098 Se",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:69779,Availability,error,errors,69779,"41{; 2042 if (e == -1); 2043 SetFillColor(fcolor);; 2044 else if (e >= 0 && e < fNYErrors); 2045 fAttFill[e].SetFillColor(fcolor);; 2046}; 2047 ; 2048////////////////////////////////////////////////////////////////////////////////; 2049/// Set Fill Color and Alpha of error e (-1 = Global and x errors).; 2050 ; 2051void TGraphMultiErrors::SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha); 2052{; 2053 if (e == -1); 2054 SetFillColorAlpha(fcolor, falpha);; 2055 else if (e >= 0 && e < fNYErrors); 2056 fAttFill[e].SetFillColorAlpha(fcolor, falpha);; 2057}; 2058 ; 2059////////////////////////////////////////////////////////////////////////////////; 2060/// Set Fill Style of error e (-1 = Global and x errors).; 2061 ; 2062void TGraphMultiErrors::SetFillStyle(Int_t e, Style_t fstyle); 2063{; 2064 if (e == -1); 2065 SetFillStyle(fstyle);; 2066 else if (e >= 0 && e < fNYErrors); 2067 fAttFill[e].SetFillStyle(fstyle);; 2068}; 2069 ; 2070////////////////////////////////////////////////////////////////////////////////; 2071/// Set Line Color of error e (-1 = Global and x errors).; 2072 ; 2073void TGraphMultiErrors::SetLineColor(Int_t e, Color_t lcolor); 2074{; 2075 if (e == -1); 2076 SetLineColor(lcolor);; 2077 else if (e >= 0 && e < fNYErrors); 2078 fAttLine[e].SetLineColor(lcolor);; 2079}; 2080 ; 2081////////////////////////////////////////////////////////////////////////////////; 2082/// Set Line Color and Alpha of error e (-1 = Global and x errors).; 2083 ; 2084void TGraphMultiErrors::SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha); 2085{; 2086 if (e == -1); 2087 SetLineColorAlpha(lcolor, lalpha);; 2088 else if (e >= 0 && e < fNYErrors); 2089 fAttLine[e].SetLineColorAlpha(lcolor, lalpha);; 2090}; 2091 ; 2092////////////////////////////////////////////////////////////////////////////////; 2093/// Set Line Style of error e (-1 = Global and x errors).; 2094 ; 2095void TGraphMultiErrors::SetLineStyle(Int_t e, Style_t lstyle); 2096{; 2097 if (e == -1); 2098 Se",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:70133,Availability,error,error,70133,"color, Float_t falpha); 2052{; 2053 if (e == -1); 2054 SetFillColorAlpha(fcolor, falpha);; 2055 else if (e >= 0 && e < fNYErrors); 2056 fAttFill[e].SetFillColorAlpha(fcolor, falpha);; 2057}; 2058 ; 2059////////////////////////////////////////////////////////////////////////////////; 2060/// Set Fill Style of error e (-1 = Global and x errors).; 2061 ; 2062void TGraphMultiErrors::SetFillStyle(Int_t e, Style_t fstyle); 2063{; 2064 if (e == -1); 2065 SetFillStyle(fstyle);; 2066 else if (e >= 0 && e < fNYErrors); 2067 fAttFill[e].SetFillStyle(fstyle);; 2068}; 2069 ; 2070////////////////////////////////////////////////////////////////////////////////; 2071/// Set Line Color of error e (-1 = Global and x errors).; 2072 ; 2073void TGraphMultiErrors::SetLineColor(Int_t e, Color_t lcolor); 2074{; 2075 if (e == -1); 2076 SetLineColor(lcolor);; 2077 else if (e >= 0 && e < fNYErrors); 2078 fAttLine[e].SetLineColor(lcolor);; 2079}; 2080 ; 2081////////////////////////////////////////////////////////////////////////////////; 2082/// Set Line Color and Alpha of error e (-1 = Global and x errors).; 2083 ; 2084void TGraphMultiErrors::SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha); 2085{; 2086 if (e == -1); 2087 SetLineColorAlpha(lcolor, lalpha);; 2088 else if (e >= 0 && e < fNYErrors); 2089 fAttLine[e].SetLineColorAlpha(lcolor, lalpha);; 2090}; 2091 ; 2092////////////////////////////////////////////////////////////////////////////////; 2093/// Set Line Style of error e (-1 = Global and x errors).; 2094 ; 2095void TGraphMultiErrors::SetLineStyle(Int_t e, Style_t lstyle); 2096{; 2097 if (e == -1); 2098 SetLineStyle(lstyle);; 2099 else if (e >= 0 && e < fNYErrors); 2100 fAttLine[e].SetLineStyle(lstyle);; 2101}; 2102 ; 2103////////////////////////////////////////////////////////////////////////////////; 2104/// Set Line Width of error e (-1 = Global and x errors).; 2105 ; 2106void TGraphMultiErrors::SetLineWidth(Int_t e, Width_t lwidth); 2107{; 2108 if (e == -1); 2109 SetLine",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:70160,Availability,error,errors,70160,"color, Float_t falpha); 2052{; 2053 if (e == -1); 2054 SetFillColorAlpha(fcolor, falpha);; 2055 else if (e >= 0 && e < fNYErrors); 2056 fAttFill[e].SetFillColorAlpha(fcolor, falpha);; 2057}; 2058 ; 2059////////////////////////////////////////////////////////////////////////////////; 2060/// Set Fill Style of error e (-1 = Global and x errors).; 2061 ; 2062void TGraphMultiErrors::SetFillStyle(Int_t e, Style_t fstyle); 2063{; 2064 if (e == -1); 2065 SetFillStyle(fstyle);; 2066 else if (e >= 0 && e < fNYErrors); 2067 fAttFill[e].SetFillStyle(fstyle);; 2068}; 2069 ; 2070////////////////////////////////////////////////////////////////////////////////; 2071/// Set Line Color of error e (-1 = Global and x errors).; 2072 ; 2073void TGraphMultiErrors::SetLineColor(Int_t e, Color_t lcolor); 2074{; 2075 if (e == -1); 2076 SetLineColor(lcolor);; 2077 else if (e >= 0 && e < fNYErrors); 2078 fAttLine[e].SetLineColor(lcolor);; 2079}; 2080 ; 2081////////////////////////////////////////////////////////////////////////////////; 2082/// Set Line Color and Alpha of error e (-1 = Global and x errors).; 2083 ; 2084void TGraphMultiErrors::SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha); 2085{; 2086 if (e == -1); 2087 SetLineColorAlpha(lcolor, lalpha);; 2088 else if (e >= 0 && e < fNYErrors); 2089 fAttLine[e].SetLineColorAlpha(lcolor, lalpha);; 2090}; 2091 ; 2092////////////////////////////////////////////////////////////////////////////////; 2093/// Set Line Style of error e (-1 = Global and x errors).; 2094 ; 2095void TGraphMultiErrors::SetLineStyle(Int_t e, Style_t lstyle); 2096{; 2097 if (e == -1); 2098 SetLineStyle(lstyle);; 2099 else if (e >= 0 && e < fNYErrors); 2100 fAttLine[e].SetLineStyle(lstyle);; 2101}; 2102 ; 2103////////////////////////////////////////////////////////////////////////////////; 2104/// Set Line Width of error e (-1 = Global and x errors).; 2105 ; 2106void TGraphMultiErrors::SetLineWidth(Int_t e, Width_t lwidth); 2107{; 2108 if (e == -1); 2109 SetLine",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:70551,Availability,error,error,70551,"le); 2063{; 2064 if (e == -1); 2065 SetFillStyle(fstyle);; 2066 else if (e >= 0 && e < fNYErrors); 2067 fAttFill[e].SetFillStyle(fstyle);; 2068}; 2069 ; 2070////////////////////////////////////////////////////////////////////////////////; 2071/// Set Line Color of error e (-1 = Global and x errors).; 2072 ; 2073void TGraphMultiErrors::SetLineColor(Int_t e, Color_t lcolor); 2074{; 2075 if (e == -1); 2076 SetLineColor(lcolor);; 2077 else if (e >= 0 && e < fNYErrors); 2078 fAttLine[e].SetLineColor(lcolor);; 2079}; 2080 ; 2081////////////////////////////////////////////////////////////////////////////////; 2082/// Set Line Color and Alpha of error e (-1 = Global and x errors).; 2083 ; 2084void TGraphMultiErrors::SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha); 2085{; 2086 if (e == -1); 2087 SetLineColorAlpha(lcolor, lalpha);; 2088 else if (e >= 0 && e < fNYErrors); 2089 fAttLine[e].SetLineColorAlpha(lcolor, lalpha);; 2090}; 2091 ; 2092////////////////////////////////////////////////////////////////////////////////; 2093/// Set Line Style of error e (-1 = Global and x errors).; 2094 ; 2095void TGraphMultiErrors::SetLineStyle(Int_t e, Style_t lstyle); 2096{; 2097 if (e == -1); 2098 SetLineStyle(lstyle);; 2099 else if (e >= 0 && e < fNYErrors); 2100 fAttLine[e].SetLineStyle(lstyle);; 2101}; 2102 ; 2103////////////////////////////////////////////////////////////////////////////////; 2104/// Set Line Width of error e (-1 = Global and x errors).; 2105 ; 2106void TGraphMultiErrors::SetLineWidth(Int_t e, Width_t lwidth); 2107{; 2108 if (e == -1); 2109 SetLineWidth(lwidth);; 2110 else if (e >= 0 && e < fNYErrors); 2111 fAttLine[e].SetLineWidth(lwidth);; 2112}; QuantFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; Riostream.h; sizesize_t size(const MatrixT &matr",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:70578,Availability,error,errors,70578,"le); 2063{; 2064 if (e == -1); 2065 SetFillStyle(fstyle);; 2066 else if (e >= 0 && e < fNYErrors); 2067 fAttFill[e].SetFillStyle(fstyle);; 2068}; 2069 ; 2070////////////////////////////////////////////////////////////////////////////////; 2071/// Set Line Color of error e (-1 = Global and x errors).; 2072 ; 2073void TGraphMultiErrors::SetLineColor(Int_t e, Color_t lcolor); 2074{; 2075 if (e == -1); 2076 SetLineColor(lcolor);; 2077 else if (e >= 0 && e < fNYErrors); 2078 fAttLine[e].SetLineColor(lcolor);; 2079}; 2080 ; 2081////////////////////////////////////////////////////////////////////////////////; 2082/// Set Line Color and Alpha of error e (-1 = Global and x errors).; 2083 ; 2084void TGraphMultiErrors::SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha); 2085{; 2086 if (e == -1); 2087 SetLineColorAlpha(lcolor, lalpha);; 2088 else if (e >= 0 && e < fNYErrors); 2089 fAttLine[e].SetLineColorAlpha(lcolor, lalpha);; 2090}; 2091 ; 2092////////////////////////////////////////////////////////////////////////////////; 2093/// Set Line Style of error e (-1 = Global and x errors).; 2094 ; 2095void TGraphMultiErrors::SetLineStyle(Int_t e, Style_t lstyle); 2096{; 2097 if (e == -1); 2098 SetLineStyle(lstyle);; 2099 else if (e >= 0 && e < fNYErrors); 2100 fAttLine[e].SetLineStyle(lstyle);; 2101}; 2102 ; 2103////////////////////////////////////////////////////////////////////////////////; 2104/// Set Line Width of error e (-1 = Global and x errors).; 2105 ; 2106void TGraphMultiErrors::SetLineWidth(Int_t e, Width_t lwidth); 2107{; 2108 if (e == -1); 2109 SetLineWidth(lwidth);; 2110 else if (e >= 0 && e < fNYErrors); 2111 fAttLine[e].SetLineWidth(lwidth);; 2112}; QuantFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; Riostream.h; sizesize_t size(const MatrixT &matr",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:70922,Availability,error,error,70922,"74{; 2075 if (e == -1); 2076 SetLineColor(lcolor);; 2077 else if (e >= 0 && e < fNYErrors); 2078 fAttLine[e].SetLineColor(lcolor);; 2079}; 2080 ; 2081////////////////////////////////////////////////////////////////////////////////; 2082/// Set Line Color and Alpha of error e (-1 = Global and x errors).; 2083 ; 2084void TGraphMultiErrors::SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha); 2085{; 2086 if (e == -1); 2087 SetLineColorAlpha(lcolor, lalpha);; 2088 else if (e >= 0 && e < fNYErrors); 2089 fAttLine[e].SetLineColorAlpha(lcolor, lalpha);; 2090}; 2091 ; 2092////////////////////////////////////////////////////////////////////////////////; 2093/// Set Line Style of error e (-1 = Global and x errors).; 2094 ; 2095void TGraphMultiErrors::SetLineStyle(Int_t e, Style_t lstyle); 2096{; 2097 if (e == -1); 2098 SetLineStyle(lstyle);; 2099 else if (e >= 0 && e < fNYErrors); 2100 fAttLine[e].SetLineStyle(lstyle);; 2101}; 2102 ; 2103////////////////////////////////////////////////////////////////////////////////; 2104/// Set Line Width of error e (-1 = Global and x errors).; 2105 ; 2106void TGraphMultiErrors::SetLineWidth(Int_t e, Width_t lwidth); 2107{; 2108 if (e == -1); 2109 SetLineWidth(lwidth);; 2110 else if (e >= 0 && e < fNYErrors); 2111 fAttLine[e].SetLineWidth(lwidth);; 2112}; QuantFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; Riostream.h; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Style_tshort Style_tDefinition RtypesCore.h:82; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Color_tshort Color_tDefinition RtypesCore.h:85; Char_tchar Char_tDefinition RtypesCore.h:37; Width_tshort Width_tDefinition RtypesCore.h:84; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconste",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:70949,Availability,error,errors,70949,"74{; 2075 if (e == -1); 2076 SetLineColor(lcolor);; 2077 else if (e >= 0 && e < fNYErrors); 2078 fAttLine[e].SetLineColor(lcolor);; 2079}; 2080 ; 2081////////////////////////////////////////////////////////////////////////////////; 2082/// Set Line Color and Alpha of error e (-1 = Global and x errors).; 2083 ; 2084void TGraphMultiErrors::SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha); 2085{; 2086 if (e == -1); 2087 SetLineColorAlpha(lcolor, lalpha);; 2088 else if (e >= 0 && e < fNYErrors); 2089 fAttLine[e].SetLineColorAlpha(lcolor, lalpha);; 2090}; 2091 ; 2092////////////////////////////////////////////////////////////////////////////////; 2093/// Set Line Style of error e (-1 = Global and x errors).; 2094 ; 2095void TGraphMultiErrors::SetLineStyle(Int_t e, Style_t lstyle); 2096{; 2097 if (e == -1); 2098 SetLineStyle(lstyle);; 2099 else if (e >= 0 && e < fNYErrors); 2100 fAttLine[e].SetLineStyle(lstyle);; 2101}; 2102 ; 2103////////////////////////////////////////////////////////////////////////////////; 2104/// Set Line Width of error e (-1 = Global and x errors).; 2105 ; 2106void TGraphMultiErrors::SetLineWidth(Int_t e, Width_t lwidth); 2107{; 2108 if (e == -1); 2109 SetLineWidth(lwidth);; 2110 else if (e >= 0 && e < fNYErrors); 2111 fAttLine[e].SetLineWidth(lwidth);; 2112}; QuantFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; Riostream.h; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Style_tshort Style_tDefinition RtypesCore.h:82; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Color_tshort Color_tDefinition RtypesCore.h:85; Char_tchar Char_tDefinition RtypesCore.h:37; Width_tshort Width_tDefinition RtypesCore.h:84; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconste",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:76593,Availability,error,error,76593," for a Beta distribution.Definition TEfficiency.cxx:1348; TEfficiency::Normalstatic Double_t Normal(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Returns the confidence limits for the efficiency supposing that the efficiency follows a normal distr...Definition TEfficiency.cxx:2952; TEfficiency::Wilsonstatic Double_t Wilson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Wilson interval.Definition TEfficiency.cxx:3873; TEfficiency::CheckConsistencystatic Bool_t CheckConsistency(const TH1 &pass, const TH1 &total, Option_t *opt="""")Checks the consistence of the given histograms.Definition TEfficiency.cxx:1576; TEfficiency::ClopperPearsonstatic Double_t ClopperPearson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Clopper-Pearson interval.Definition TEfficiency.cxx:2016; TF11-Dim function classDefinition TF1.h:233; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::fEyLSumDouble_t * fEyLSum! Array of summed Y low errors for fittingDefinition TGraphMultiErrors.h:39; TGraphMultiErrors::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Doubl",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:76619,Availability,error,error,76619," for a Beta distribution.Definition TEfficiency.cxx:1348; TEfficiency::Normalstatic Double_t Normal(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Returns the confidence limits for the efficiency supposing that the efficiency follows a normal distr...Definition TEfficiency.cxx:2952; TEfficiency::Wilsonstatic Double_t Wilson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Wilson interval.Definition TEfficiency.cxx:3873; TEfficiency::CheckConsistencystatic Bool_t CheckConsistency(const TH1 &pass, const TH1 &total, Option_t *opt="""")Checks the consistence of the given histograms.Definition TEfficiency.cxx:1576; TEfficiency::ClopperPearsonstatic Double_t ClopperPearson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Clopper-Pearson interval.Definition TEfficiency.cxx:2016; TF11-Dim function classDefinition TF1.h:233; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::fEyLSumDouble_t * fEyLSum! Array of summed Y low errors for fittingDefinition TGraphMultiErrors.h:39; TGraphMultiErrors::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Doubl",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:76739,Availability,error,errors,76739,"ouble_t level, Bool_t bUpper)Returns the confidence limits for the efficiency supposing that the efficiency follows a normal distr...Definition TEfficiency.cxx:2952; TEfficiency::Wilsonstatic Double_t Wilson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Wilson interval.Definition TEfficiency.cxx:3873; TEfficiency::CheckConsistencystatic Bool_t CheckConsistency(const TH1 &pass, const TH1 &total, Option_t *opt="""")Checks the consistence of the given histograms.Definition TEfficiency.cxx:1576; TEfficiency::ClopperPearsonstatic Double_t ClopperPearson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Clopper-Pearson interval.Definition TEfficiency.cxx:2016; TF11-Dim function classDefinition TF1.h:233; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::fEyLSumDouble_t * fEyLSum! Array of summed Y low errors for fittingDefinition TGraphMultiErrors.h:39; TGraphMultiErrors::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:76990,Availability,error,errors,76990,"ool_t bUpper)Calculates the boundaries for the frequentist Wilson interval.Definition TEfficiency.cxx:3873; TEfficiency::CheckConsistencystatic Bool_t CheckConsistency(const TH1 &pass, const TH1 &total, Option_t *opt="""")Checks the consistence of the given histograms.Definition TEfficiency.cxx:1576; TEfficiency::ClopperPearsonstatic Double_t ClopperPearson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Clopper-Pearson interval.Definition TEfficiency.cxx:2016; TF11-Dim function classDefinition TF1.h:233; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::fEyLSumDouble_t * fEyLSum! Array of summed Y low errors for fittingDefinition TGraphMultiErrors.h:39; TGraphMultiErrors::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::Set",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:77174,Availability,error,error,77174,"y(const TH1 &pass, const TH1 &total, Option_t *opt="""")Checks the consistence of the given histograms.Definition TEfficiency.cxx:1576; TEfficiency::ClopperPearsonstatic Double_t ClopperPearson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Clopper-Pearson interval.Definition TEfficiency.cxx:2016; TF11-Dim function classDefinition TF1.h:233; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::fEyLSumDouble_t * fEyLSum! Array of summed Y low errors for fittingDefinition TGraphMultiErrors.h:39; TGraphMultiErrors::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraph",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:77454,Availability,error,error,77454,"aries for the frequentist Clopper-Pearson interval.Definition TEfficiency.cxx:2016; TF11-Dim function classDefinition TF1.h:233; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::fEyLSumDouble_t * fEyLSum! Array of summed Y low errors for fittingDefinition TGraphMultiErrors.h:39; TGraphMultiErrors::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMult",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:77907,Availability,error,error,77907,"Return the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullpt",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:78097,Availability,error,error,78097," to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:78124,Availability,error,errors,78124," to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:78370,Availability,error,error,78370,"efinition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e,",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:78731,Availability,error,errors,78731,"Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(cons",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:78903,Availability,error,error,78903,"ine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:79088,Availability,error,error,79088,"t_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiEr",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:79398,Availability,error,error,79398,"onst overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:79540,Availability,error,errors,79540,", Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors:",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:79575,Availability,error,errors,79575,", Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors:",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:79905,Availability,error,errors,79905,"nst Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const override",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:80555,Availability,error,errors,80555,"summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:80970,Availability,error,errors,80970,"hMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGrap",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:81085,Availability,error,errors,81085,"aphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiEr",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:81178,Availability,error,errors,81178,"yAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point array",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:81342,Availability,error,error,81342,"48; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::SetLineWidthvirtual void SetLineWidth(Int_t e, W",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:81496,Availability,error,error,81496,"finition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::SetLineWidthvirtual void SetLineWidth(Int_t e, Width_t lwidth)Set Line Width of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2106; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo di",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:81523,Availability,error,errors,81523,"finition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::SetLineWidthvirtual void SetLineWidth(Int_t e, Width_t lwidth)Set Line Width of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2106; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo di",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:81689,Availability,error,errors,81689,"finition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::SetLineWidthvirtual void SetLineWidth(Int_t e, Width_t lwidth)Set Line Width of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2106; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMulti",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:81995,Availability,error,errorsDefinition,81995,"s.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::SetLineWidthvirtual void SetLineWidth(Int_t e, Width_t lwidth)Set Line Width of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2106; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiError",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:82329,Availability,error,error,82329,"AttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::SetLineWidthvirtual void SetLineWidth(Int_t e, Width_t lwidth)Set Line Width of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2106; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:82356,Availability,error,errors,82356,"AttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::SetLineWidthvirtual void SetLineWidth(Int_t e, Width_t lwidth)Set Line Width of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2106; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:82485,Availability,error,errors,82485,"etLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::SetLineWidthvirtual void SetLineWidth(Int_t e, Width_t lwidth)Set Line Width of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2106; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::SetFillColorvirtual void SetFillColor(Int_t e, Color_t fcolor)Se",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:83065,Availability,error,errors,83065,"erovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::SetLineWidthvirtual void SetLineWidth(Int_t e, Width_t lwidth)Set Line Width of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2106; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::SetFillColorvirtual void SetFillColor(Int_t e, Color_t fcolor)Set Fill Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2040; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = G",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:83286,Availability,error,error,83286,"GraphMultiErrors::SetLineWidthvirtual void SetLineWidth(Int_t e, Width_t lwidth)Set Line Width of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2106; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::SetFillColorvirtual void SetFillColor(Int_t e, Color_t fcolor)Set Fill Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2040; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiEr",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:83313,Availability,error,errors,83313,"GraphMultiErrors::SetLineWidthvirtual void SetLineWidth(Int_t e, Width_t lwidth)Set Line Width of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2106; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::SetFillColorvirtual void SetFillColor(Int_t e, Color_t fcolor)Set Fill Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2040; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiEr",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:83459,Availability,error,error,83459,"fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::SetFillColorvirtual void SetFillColor(Int_t e, Color_t fcolor)Set Fill Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2040; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:83486,Availability,error,errors,83486,"fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::SetFillColorvirtual void SetFillColor(Int_t e, Color_t fcolor)Set Fill Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2040; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:83718,Availability,error,error,83718," void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::SetFillColorvirtual void SetFillColor(Int_t e, Color_t fcolor)Set Fill Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2040; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMulti",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:84013,Availability,error,error,84013,"ale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::SetFillColorvirtual void SetFillColor(Int_t e, Color_t fcolor)Set Fill Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2040; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetFillStylevirtual void SetFillStyle(Int_t e, Style_t fstyle)Set Fill Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2062; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:84073,Availability,error,errors,84073,"ale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::SetFillColorvirtual void SetFillColor(Int_t e, Color_t fcolor)Set Fill Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2040; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetFillStylevirtual void SetFillStyle(Int_t e, Style_t fstyle)Set Fill Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2062; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:84189,Availability,error,errors,84189,"LineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::SetFillColorvirtual void SetFillColor(Int_t e, Color_t fcolor)Set Fill Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2040; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetFillStylevirtual void SetFillStyle(Int_t e, Style_t fstyle)Set Fill Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2062; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFi",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:84317,Availability,error,errors,84317," errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::SetFillColorvirtual void SetFillColor(Int_t e, Color_t fcolor)Set Fill Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2040; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetFillStylevirtual void SetFillStyle(Int_t e, Style_t fstyle)Set Fill Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2062; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x err",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:84506,Availability,error,error,84506,"Global and x errors).Definition TGraphMultiErrors.cxx:2040; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetFillStylevirtual void SetFillStyle(Int_t e, Style_t fstyle)Set Fill Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2062; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Defini",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:84793,Availability,error,error,84793,"ors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetFillStylevirtual void SetFillStyle(Int_t e, Style_t fstyle)Set Fill Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2062; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedP",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:84820,Availability,error,errors,84820,"ors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetFillStylevirtual void SetFillStyle(Int_t e, Style_t fstyle)Set Fill Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2062; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedP",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:84961,Availability,error,error,84961,"ltiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetFillStylevirtual void SetFillStyle(Int_t e, Style_t fstyle)Set Fill Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2062; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values.Definition TGraphMultiErrors.cxx:885; TGraphMultiErrors::Ctor",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:85249,Availability,error,error,85249,"tiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetFillStylevirtual void SetFillStyle(Int_t e, Style_t fstyle)Set Fill Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2062; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values.Definition TGraphMultiErrors.cxx:885; TGraphMultiErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set Note: This function should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvi",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:85309,Availability,error,errors,85309,"tiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetFillStylevirtual void SetFillStyle(Int_t e, Style_t fstyle)Set Fill Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2062; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values.Definition TGraphMultiErrors.cxx:885; TGraphMultiErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set Note: This function should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvi",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:85448,Availability,error,error,85448,"ultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetFillStylevirtual void SetFillStyle(Int_t e, Style_t fstyle)Set Fill Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2062; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values.Definition TGraphMultiErrors.cxx:885; TGraphMultiErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set Note: This function should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvirtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetLineColorvi",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:85605,Availability,error,errors,85605,"ors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetFillStylevirtual void SetFillStyle(Int_t e, Style_t fstyle)Set Fill Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2062; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values.Definition TGraphMultiErrors.cxx:885; TGraphMultiErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set Note: This function should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvirtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073; TGraphM",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:86155,Availability,error,errorsDefinition,86155,"s.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values.Definition TGraphMultiErrors.cxx:885; TGraphMultiErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set Note: This function should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvirtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMult",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:86473,Availability,error,error,86473,"_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values.Definition TGraphMultiErrors.cxx:885; TGraphMultiErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set Note: This function should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvirtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiError",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:86500,Availability,error,errors,86500,"_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values.Definition TGraphMultiErrors.cxx:885; TGraphMultiErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set Note: This function should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvirtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiError",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:87108,Availability,error,errors,87108,"tiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvirtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::Classstatic TClass * Class(); TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGrap",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:87231,Availability,error,errors,87231,":36; TGraphMultiErrors::SetPointEYvirtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::Classstatic TClass * Class(); TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGraph.h:46; TGraph::SetPointvirtual void",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:87347,Availability,error,error,87347,"or point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::Classstatic TClass * Class(); TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGraph.h:46; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::fMaxSizeInt_t fMa",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:87729,Availability,error,errors,87729," i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::Classstatic TClass * Class(); TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGraph.h:46; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::fMaxSizeInt_t fMaxSize!Current dimension of arrays fX and fYDefinition TGraph.h:45; TGraph::SaveHistogramAndFunctionsvoid SaveHistogramAndFunctions(std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option)Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes.Definition TGraph.cxx",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:87910,Availability,error,error,87910,"907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::Classstatic TClass * Class(); TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGraph.h:46; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::fMaxSizeInt_t fMaxSize!Current dimension of arrays fX and fYDefinition TGraph.h:45; TGraph::SaveHistogramAndFunctionsvoid SaveHistogramAndFunctions(std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option)Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes.Definition TGraph.cxx:2199; TGraph::fHistogramTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:50; TGraph::UpdateArraysvirtual void UpdateArrays(const std::vector< Int_t > &sorting_indices, Int",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:92728,Availability,error,error,92728,"7; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TStyle::GetErrorXFloat_t GetErrorX() constDefinition TStyle.h:186; TVectorTTVectorT.Definition TVectorT.h:27; TVectorT::GetNrowsInt_t GetNrows() constDefinition TVectorT.h:73; TVectorT::GetLwbInt_t GetLwb() constDefinition TVectorT.h:71; bool; double; int; ROOT::Math::normal_quantile_cdouble normal_quantile_c(double z, double sigma)Inverse ( ) of the cumulative distribution function of the upper tail ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:94305,Availability,mask,mask,94305,"efinition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TStyle::GetErrorXFloat_t GetErrorX() constDefinition TStyle.h:186; TVectorTTVectorT.Definition TVectorT.h:27; TVectorT::GetNrowsInt_t GetNrows() constDefinition TVectorT.h:73; TVectorT::GetLwbInt_t GetLwb() constDefinition TVectorT.h:71; bool; double; int; ROOT::Math::normal_quantile_cdouble normal_quantile_c(double z, double sigma)Inverse ( ) of the cumulative distribution function of the upper tail of the normal (Gaussian) distri...Definition QuantFuncMathCore.cxx:126; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; mTMarker mDefinition textangle.C:8; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. histhistsrcTGraphMultiErrors.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:25881,Deployability,release,release,25881,"HSum;; 709 fAttFill.resize(0);; 710 fAttLine.resize(0);; 711}; 712 ; 713////////////////////////////////////////////////////////////////////////////////; 714/// Should be called from ctors after `fNpoints` has been set; 715/// Note: This function should be called only from the constructor; 716/// since it does not delete previously existing arrays; 717 ; 718Bool_t TGraphMultiErrors::CtorAllocate(); 719{; 720 if (!fNpoints || !fNYErrors) {; 721 fExL = fExH = nullptr;; 722 fEyL.resize(0);; 723 fEyH.resize(0);; 724 return kFALSE;; 725 }; 726 ; 727 fExL = new Double_t[fMaxSize];; 728 fExH = new Double_t[fMaxSize];; 729 fEyL.resize(fNYErrors, TArrayD(fMaxSize));; 730 fEyH.resize(fNYErrors, TArrayD(fMaxSize));; 731 fEyLSum = new Double_t[fMaxSize];; 732 fEyHSum = new Double_t[fMaxSize];; 733 fAttFill.resize(fNYErrors);; 734 fAttLine.resize(fNYErrors);; 735 ; 736 Int_t n = fMaxSize * sizeof(Double_t);; 737 memset(fExL, 0, n);; 738 memset(fExH, 0, n);; 739 memset(fEyLSum, 0, n);; 740 memset(fEyHSum, 0, n);; 741 ; 742 return kTRUE;; 743}; 744 ; 745////////////////////////////////////////////////////////////////////////////////; 746/// Copy and release.; 747 ; 748void TGraphMultiErrors::CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin); 749{; 750 CopyPoints(newarrays, ibegin, iend, obegin);; 751 if (newarrays) {; 752 delete[] fX;; 753 fX = newarrays[0];; 754 delete[] fY;; 755 fY = newarrays[1];; 756 ; 757 delete[] fExL;; 758 fExL = newarrays[2];; 759 delete[] fExH;; 760 fExH = newarrays[3];; 761 ; 762 if (fEyLSum); 763 delete[] fEyLSum;; 764 fEyLSum = newarrays[4];; 765 if (fEyHSum); 766 delete[] fEyHSum;; 767 fEyHSum = newarrays[5];; 768 ; 769 delete[] newarrays;; 770 }; 771}; 772 ; 773////////////////////////////////////////////////////////////////////////////////; 774/// Copy errors from `fE***` to `arrays[***]`; 775/// or to `f***` Copy points.; 776 ; 777Bool_t TGraphMultiErrors::CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obeg",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:80254,Deployability,release,release,80254,"ultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors fro",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:34395,Energy Efficiency,adapt,adapted,34395,";; 967 ; 968 if (f->Eval(x, y - eyL) < f->Eval(x, y + eyH)) {; 969 eyLNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 970 eyHNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 971 } else {; 972 eyHNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 973 eyLNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 974 }; 975 ; 976 // systematic errors and error on x doesn't change; 977 SetPointEY(i, 0, eyLNew, eyHNew);; 978 }; 979 ; 980 if (gPad); 981 gPad->Modified();; 982}; 983 ; 984////////////////////////////////////////////////////////////////////////////////; 985/// This function is only kept for backward compatibility.; 986/// You should rather use the Divide method.; 987/// It calls `Divide(pass,total,""cl=0.683 b(1,1) mode"")` which is equivalent to the; 988/// former BayesDivide method.; 989 ; 990void TGraphMultiErrors::BayesDivide(const TH1 *pass, const TH1 *total, Option_t *); 991{; 992 Divide(pass, total, ""cl=0.683 b(1,1) mode"");; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// This function was adapted from the TGraphAsymmErrors class.; 997/// See TGraphAsymmErrors::Divide for the documentation; 998///; 999/// Only the first error dimension is affected.; 1000 ; 1001void TGraphMultiErrors::Divide(const TH1 *pass, const TH1 *total, Option_t *opt); 1002{; 1003 // check pointers; 1004 if (!pass || !total) {; 1005 Error(""Divide"", ""one of the passed pointers is zero"");; 1006 return;; 1007 }; 1008 ; 1009 // check dimension of histograms; only 1-dimensional ones are accepted; 1010 if ((pass->GetDimension() > 1) || (total->GetDimension() > 1)) {; 1011 Error(""Divide"", ""passed histograms are not one-dimensional"");; 1012 return;; 1013 }; 1014 ; 1015 // check whether histograms are filled with weights -> use number of effective; 1016 // entries; 1017 Bool_t bEffective = false;; 1018 // compare sum of weights with sum of squares of weights; 1019 // re-compute here to be sure to get the right values; 1020 Double_t psumw = 0;; 1021 Double_t p",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:63210,Energy Efficiency,allocate,allocate,63210," eyL2, eyH2);; 1826 if (fNYErrors > 2); 1827 SetPointEY(ipoint, 2, eyL3, eyH3);; 1828 gPad->Modified();; 1829}; 1830 ; 1831////////////////////////////////////////////////////////////////////////////////; 1832/// Set ex and ey values for point `i`.; 1833 ; 1834void TGraphMultiErrors::SetPointError(Int_t i, Int_t ne, Double_t exL, Double_t exH, const Double_t *eyL,; 1835 const Double_t *eyH); 1836{; 1837 SetPointEX(i, exL, exH);; 1838 SetPointEY(i, ne, eyL, eyH);; 1839}; 1840 ; 1841////////////////////////////////////////////////////////////////////////////////; 1842/// Set ex values for point `i`.; 1843 ; 1844void TGraphMultiErrors::SetPointEX(Int_t i, Double_t exL, Double_t exH); 1845{; 1846 SetPointEXlow(i, exL);; 1847 SetPointEXhigh(i, exH);; 1848}; 1849 ; 1850////////////////////////////////////////////////////////////////////////////////; 1851/// Set exL value for point `i`.; 1852 ; 1853void TGraphMultiErrors::SetPointEXlow(Int_t i, Double_t exL); 1854{; 1855 if (i < 0); 1856 return;; 1857 ; 1858 if (i >= fNpoints) {; 1859 // re-allocate the object; 1860 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1861 }; 1862 ; 1863 fExL[i] = exL;; 1864}; 1865 ; 1866////////////////////////////////////////////////////////////////////////////////; 1867/// Set exH value for point `i`.; 1868 ; 1869void TGraphMultiErrors::SetPointEXhigh(Int_t i, Double_t exH); 1870{; 1871 if (i < 0); 1872 return;; 1873 ; 1874 if (i >= fNpoints) {; 1875 // re-allocate the object; 1876 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1877 }; 1878 ; 1879 fExH[i] = exH;; 1880}; 1881 ; 1882////////////////////////////////////////////////////////////////////////////////; 1883/// Set ey values for point `i`.; 1884 ; 1885void TGraphMultiErrors::SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH); 1886{; 1887 SetPointEYlow(i, ne, eyL);; 1888 SetPointEYhigh(i, ne, eyH);; 1889}; 1890 ; 1891////////////////////////////////////////////////////////////////////////////////; 1892/// Set eyL values for poi",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:63608,Energy Efficiency,allocate,allocate,63608,"6{; 1837 SetPointEX(i, exL, exH);; 1838 SetPointEY(i, ne, eyL, eyH);; 1839}; 1840 ; 1841////////////////////////////////////////////////////////////////////////////////; 1842/// Set ex values for point `i`.; 1843 ; 1844void TGraphMultiErrors::SetPointEX(Int_t i, Double_t exL, Double_t exH); 1845{; 1846 SetPointEXlow(i, exL);; 1847 SetPointEXhigh(i, exH);; 1848}; 1849 ; 1850////////////////////////////////////////////////////////////////////////////////; 1851/// Set exL value for point `i`.; 1852 ; 1853void TGraphMultiErrors::SetPointEXlow(Int_t i, Double_t exL); 1854{; 1855 if (i < 0); 1856 return;; 1857 ; 1858 if (i >= fNpoints) {; 1859 // re-allocate the object; 1860 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1861 }; 1862 ; 1863 fExL[i] = exL;; 1864}; 1865 ; 1866////////////////////////////////////////////////////////////////////////////////; 1867/// Set exH value for point `i`.; 1868 ; 1869void TGraphMultiErrors::SetPointEXhigh(Int_t i, Double_t exH); 1870{; 1871 if (i < 0); 1872 return;; 1873 ; 1874 if (i >= fNpoints) {; 1875 // re-allocate the object; 1876 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1877 }; 1878 ; 1879 fExH[i] = exH;; 1880}; 1881 ; 1882////////////////////////////////////////////////////////////////////////////////; 1883/// Set ey values for point `i`.; 1884 ; 1885void TGraphMultiErrors::SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH); 1886{; 1887 SetPointEYlow(i, ne, eyL);; 1888 SetPointEYhigh(i, ne, eyH);; 1889}; 1890 ; 1891////////////////////////////////////////////////////////////////////////////////; 1892/// Set eyL values for point `i`.; 1893 ; 1894void TGraphMultiErrors::SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL); 1895{; 1896 for (Int_t j = 0; j < fNYErrors; j++) {; 1897 if (j < ne); 1898 SetPointEYlow(i, j, eyL[j]);; 1899 else; 1900 SetPointEYlow(i, j, 0.);; 1901 }; 1902}; 1903 ; 1904////////////////////////////////////////////////////////////////////////////////; 1905/// Set eyH values for point `i`.; 190",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:65433,Energy Efficiency,allocate,allocate,65433,"; 1900 SetPointEYlow(i, j, 0.);; 1901 }; 1902}; 1903 ; 1904////////////////////////////////////////////////////////////////////////////////; 1905/// Set eyH values for point `i`.; 1906 ; 1907void TGraphMultiErrors::SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH); 1908{; 1909 for (Int_t j = 0; j < fNYErrors; j++) {; 1910 if (j < ne); 1911 SetPointEYhigh(i, j, eyH[j]);; 1912 else; 1913 SetPointEYhigh(i, j, 0.);; 1914 }; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Set error e ey values for point `i`.; 1919 ; 1920void TGraphMultiErrors::SetPointEY(Int_t i, Int_t e, Double_t eyL, Double_t eyH); 1921{; 1922 SetPointEYlow(i, e, eyL);; 1923 SetPointEYhigh(i, e, eyH);; 1924}; 1925 ; 1926////////////////////////////////////////////////////////////////////////////////; 1927/// Set error e eyL value for point `i`.; 1928 ; 1929void TGraphMultiErrors::SetPointEYlow(Int_t i, Int_t e, Double_t eyL); 1930{; 1931 if (i < 0 || e < 0); 1932 return;; 1933 ; 1934 if (i >= fNpoints); 1935 // re-allocate the object; 1936 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1937 ; 1938 while (e >= fNYErrors); 1939 AddYError(fNpoints);; 1940 ; 1941 fEyL[e][i] = eyL;; 1942 if (fEyLSum); 1943 fEyLSum[i] = GetErrorYlow(i);; 1944 else; 1945 CalcYErrorsSum();; 1946}; 1947 ; 1948////////////////////////////////////////////////////////////////////////////////; 1949/// Set error e eyH value for point `i`.; 1950 ; 1951void TGraphMultiErrors::SetPointEYhigh(Int_t i, Int_t e, Double_t eyH); 1952{; 1953 if (i < 0 || e < 0); 1954 return;; 1955 ; 1956 if (i >= fNpoints); 1957 // re-allocate the object; 1958 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1959 ; 1960 while (e >= fNYErrors); 1961 AddYError(fNpoints);; 1962 ; 1963 fEyH[e][i] = eyH;; 1964 if (fEyHSum); 1965 fEyHSum[i] = GetErrorYhigh(i);; 1966 else; 1967 CalcYErrorsSum();; 1968}; 1969 ; 1970////////////////////////////////////////////////////////////////////////////////; 1971/// Set error e e",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:66003,Energy Efficiency,allocate,allocate,66003,"i`.; 1919 ; 1920void TGraphMultiErrors::SetPointEY(Int_t i, Int_t e, Double_t eyL, Double_t eyH); 1921{; 1922 SetPointEYlow(i, e, eyL);; 1923 SetPointEYhigh(i, e, eyH);; 1924}; 1925 ; 1926////////////////////////////////////////////////////////////////////////////////; 1927/// Set error e eyL value for point `i`.; 1928 ; 1929void TGraphMultiErrors::SetPointEYlow(Int_t i, Int_t e, Double_t eyL); 1930{; 1931 if (i < 0 || e < 0); 1932 return;; 1933 ; 1934 if (i >= fNpoints); 1935 // re-allocate the object; 1936 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1937 ; 1938 while (e >= fNYErrors); 1939 AddYError(fNpoints);; 1940 ; 1941 fEyL[e][i] = eyL;; 1942 if (fEyLSum); 1943 fEyLSum[i] = GetErrorYlow(i);; 1944 else; 1945 CalcYErrorsSum();; 1946}; 1947 ; 1948////////////////////////////////////////////////////////////////////////////////; 1949/// Set error e eyH value for point `i`.; 1950 ; 1951void TGraphMultiErrors::SetPointEYhigh(Int_t i, Int_t e, Double_t eyH); 1952{; 1953 if (i < 0 || e < 0); 1954 return;; 1955 ; 1956 if (i >= fNpoints); 1957 // re-allocate the object; 1958 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1959 ; 1960 while (e >= fNYErrors); 1961 AddYError(fNpoints);; 1962 ; 1963 fEyH[e][i] = eyH;; 1964 if (fEyHSum); 1965 fEyHSum[i] = GetErrorYhigh(i);; 1966 else; 1967 CalcYErrorsSum();; 1968}; 1969 ; 1970////////////////////////////////////////////////////////////////////////////////; 1971/// Set error e ey values.; 1972 ; 1973void TGraphMultiErrors::SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH); 1974{; 1975 SetEYlow(e, np, eyL);; 1976 SetEYhigh(e, np, eyH);; 1977}; 1978 ; 1979////////////////////////////////////////////////////////////////////////////////; 1980/// Set error e eyL values.; 1981 ; 1982void TGraphMultiErrors::SetEYlow(Int_t e, Int_t np, const Double_t *eyL); 1983{; 1984 for (Int_t i = 0; i < fNpoints; i++) {; 1985 if (i < np); 1986 SetPointEYlow(i, e, eyL[i]);; 1987 else; 1988 SetPointEYlow(i, e, 0.);; 1989 }; 1990}; 1991 ; 1992",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:78552,Energy Efficiency,adapt,adapted,78552,"ors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErro",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:92604,Integrability,message,message,92604,"etDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TStyle::GetErrorXFloat_t GetErrorX() constDefinition TStyle.h:186; TVectorTTVectorT.Definition TVectorT.h:27; TVectorT::GetNrowsInt_t GetNrows() constDefinition TVectorT.h:73; TVectorT::GetLwbInt_t GetLwb() constDefinition TVectorT.h:71; bool; double; int; ROOT::Math::norm",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:92734,Integrability,message,message,92734,"7; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TStyle::GetErrorXFloat_t GetErrorX() constDefinition TStyle.h:186; TVectorTTVectorT.Definition TVectorT.h:27; TVectorT::GetNrowsInt_t GetNrows() constDefinition TVectorT.h:73; TVectorT::GetLwbInt_t GetLwb() constDefinition TVectorT.h:71; bool; double; int; ROOT::Math::normal_quantile_cdouble normal_quantile_c(double z, double sigma)Inverse ( ) of the cumulative distribution function of the upper tail ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:92861,Integrability,message,message,92861,"52; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TStyle::GetErrorXFloat_t GetErrorX() constDefinition TStyle.h:186; TVectorTTVectorT.Definition TVectorT.h:27; TVectorT::GetNrowsInt_t GetNrows() constDefinition TVectorT.h:73; TVectorT::GetLwbInt_t GetLwb() constDefinition TVectorT.h:71; bool; double; int; ROOT::Math::normal_quantile_cdouble normal_quantile_c(double z, double sigma)Inverse ( ) of the cumulative distribution function of the upper tail of the normal (Gaussian) distri...Definition QuantFuncMathCore.cxx:126; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:1",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:34395,Modifiability,adapt,adapted,34395,";; 967 ; 968 if (f->Eval(x, y - eyL) < f->Eval(x, y + eyH)) {; 969 eyLNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 970 eyHNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 971 } else {; 972 eyHNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 973 eyLNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 974 }; 975 ; 976 // systematic errors and error on x doesn't change; 977 SetPointEY(i, 0, eyLNew, eyHNew);; 978 }; 979 ; 980 if (gPad); 981 gPad->Modified();; 982}; 983 ; 984////////////////////////////////////////////////////////////////////////////////; 985/// This function is only kept for backward compatibility.; 986/// You should rather use the Divide method.; 987/// It calls `Divide(pass,total,""cl=0.683 b(1,1) mode"")` which is equivalent to the; 988/// former BayesDivide method.; 989 ; 990void TGraphMultiErrors::BayesDivide(const TH1 *pass, const TH1 *total, Option_t *); 991{; 992 Divide(pass, total, ""cl=0.683 b(1,1) mode"");; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// This function was adapted from the TGraphAsymmErrors class.; 997/// See TGraphAsymmErrors::Divide for the documentation; 998///; 999/// Only the first error dimension is affected.; 1000 ; 1001void TGraphMultiErrors::Divide(const TH1 *pass, const TH1 *total, Option_t *opt); 1002{; 1003 // check pointers; 1004 if (!pass || !total) {; 1005 Error(""Divide"", ""one of the passed pointers is zero"");; 1006 return;; 1007 }; 1008 ; 1009 // check dimension of histograms; only 1-dimensional ones are accepted; 1010 if ((pass->GetDimension() > 1) || (total->GetDimension() > 1)) {; 1011 Error(""Divide"", ""passed histograms are not one-dimensional"");; 1012 return;; 1013 }; 1014 ; 1015 // check whether histograms are filled with weights -> use number of effective; 1016 // entries; 1017 Bool_t bEffective = false;; 1018 // compare sum of weights with sum of squares of weights; 1019 // re-compute here to be sure to get the right values; 1020 Double_t psumw = 0;; 1021 Double_t p",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:78552,Modifiability,adapt,adapted,78552,"ors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErro",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:1162,Performance,perform,performed,1162,"to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Simon Spies 18/02/19; 3 ; 4/*************************************************************************; 5 * Copyright (C) 2018-2019, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TStyle.h""; 14#include ""TVirtualPad.h""; 15#include ""TEfficiency.h""; 16#include ""Riostream.h""; 17 ; 18#include ""TArrayD.h""; 19#include ""TVector.h""; 20#include ""TH1.h""; 21#include ""TF1.h""; 22#include ""TMath.h""; 23#include ""Math/QuantFuncMathCore.h""; 24 ; 25#include ""TGraphMultiErrors.h""; 26 ; 27ClassImp(TGraphMultiErrors); 28 ; 29/** \class TGraphMultiErrors; 30 \ingroup Graphs; 31TGraph with asymmetric error bars and multiple y error dimensions.; 32 ; 33The TGraphMultiErrors painting is performed thanks to the TGraphPainter; 34class. All details about the various painting options are given in this class.; 35 ; 36The picture below gives an example:; 37 ; 38Begin_Macro(source); 39{; 40 auto c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; 41 c1->SetGrid();; 42 c1->GetFrame()->SetBorderSize(12);; 43 const Int_t np = 5;; 44 Double_t x[np] = {0, 1, 2, 3, 4};; 45 Double_t y[np] = {0, 2, 4, 1, 3};; 46 Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; 47 Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; 48 Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; 49 Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 2};; 50 Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; 51 Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; 52 auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; 53 gme->AddYError(np, eylsys, eyhsys);; 54 gme->SetMarkerStyle(20);; 55 gme->SetLineColor(kRed);; 56 gme->GetAttLine(0)->SetLineColor(kRed)",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:28616,Performance,perform,perform,28616,"/////////////////////////////; 800/// Set zero values for point arrays in the range `[begin, end]`.; 801 ; 802void TGraphMultiErrors::FillZero(Int_t begin, Int_t end, Bool_t from_ctor); 803{; 804 if (!from_ctor); 805 TGraph::FillZero(begin, end, from_ctor);; 806 ; 807 Int_t n = (end - begin) * sizeof(Double_t);; 808 memset(fExL + begin, 0, n);; 809 memset(fExH + begin, 0, n);; 810 memset(fEyLSum + begin, 0, n);; 811 memset(fEyHSum + begin, 0, n);; 812 ; 813 for (Int_t j = 0; j < fNYErrors; j++) {; 814 memset(fEyL[j].GetArray() + begin, 0, n);; 815 memset(fEyH[j].GetArray() + begin, 0, n);; 816 }; 817}; 818 ; 819////////////////////////////////////////////////////////////////////////////////; 820/// Recalculates the summed y error arrays.; 821 ; 822void TGraphMultiErrors::CalcYErrorsSum() const; 823{; 824 if (!fEyLSum); 825 fEyLSum = new Double_t[fNpoints];; 826 if (!fEyHSum); 827 fEyHSum = new Double_t[fNpoints];; 828 ; 829 for (Int_t i = 0; i < fNpoints; i++) {; 830 fEyLSum[i] = GetErrorYlow(i);; 831 fEyHSum[i] = GetErrorYhigh(i);; 832 }; 833}; 834 ; 835////////////////////////////////////////////////////////////////////////////////; 836/// Protected function to perform the merge operation of a graph with multiple asymmetric errors.; 837 ; 838Bool_t TGraphMultiErrors::DoMerge(const TGraph *tg); 839{; 840 if (tg->GetN() == 0); 841 return kFALSE;; 842 ; 843 if (tg->IsA() == TGraphMultiErrors::Class()) {; 844 auto tgme = (TGraphMultiErrors *)tg;; 845 ; 846 for (Int_t i = 0; i < tgme->GetN(); i++) {; 847 Int_t ipoint = GetN();; 848 Double_t x, y;; 849 tgme->GetPoint(i, x, y);; 850 SetPoint(ipoint, x, y);; 851 SetPointEX(ipoint, tgme->GetErrorXlow(i), tgme->GetErrorXhigh(i));; 852 for (Int_t j = 0; j < tgme->GetNYErrors(); j++); 853 SetPointEY(ipoint, j, tgme->GetErrorYlow(i, j), tgme->GetErrorYhigh(i, j));; 854 }; 855 ; 856 return kTRUE;; 857 } else {; 858 Warning(""DoMerge"", ""Merging a %s is not compatible with a TGraphMultiErrors - Errors will be ignored"",; 859 tg->Is",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:36389,Performance,perform,performed,36389,"; 1024 psumw += pass->GetBinContent(i);; 1025 psumw2 += pass->GetSumw2()->At(i);; 1026 }; 1027 } else {; 1028 psumw = pass->GetSumOfWeights();; 1029 psumw2 = psumw;; 1030 }; 1031 if (TMath::Abs(psumw - psumw2) > 1e-6); 1032 bEffective = true;; 1033 ; 1034 Double_t tsumw = 0;; 1035 Double_t tsumw2 = 0;; 1036 if (total->GetSumw2()->fN > 0) {; 1037 for (int i = 0; i < total->GetNbinsX(); ++i) {; 1038 tsumw += total->GetBinContent(i);; 1039 tsumw2 += total->GetSumw2()->At(i);; 1040 }; 1041 } else {; 1042 tsumw = total->GetSumOfWeights();; 1043 tsumw2 = tsumw;; 1044 }; 1045 if (TMath::Abs(tsumw - tsumw2) > 1e-6); 1046 bEffective = true;; 1047 ; 1048 // we do not want to ignore the weights; 1049 // if (bEffective && (pass->GetSumw2()->fN == 0 || total->GetSumw2()->fN == 0) ) {; 1050 // Warning(""Divide"",""histogram have been computed with weights but the sum of weight squares are not stored in the; 1051 // histogram. Error calculation is performed ignoring the weights""); bEffective = false;; 1052 // }; 1053 ; 1054 // parse option; 1055 TString option = opt;; 1056 option.ToLower();; 1057 ; 1058 Bool_t bVerbose = false;; 1059 // pointer to function returning the boundaries of the confidence interval; 1060 //(is only used in the frequentist cases.); 1061 // Double_t (*pBound)(Int_t,Int_t,Double_t,Bool_t) = &TEfficiency::ClopperPearson; // default method; 1062 Double_t (*pBound)(Double_t, Double_t, Double_t, Bool_t) = &TEfficiency::ClopperPearson; // default method; 1063 // confidence level; 1064 Double_t conf = 0.682689492137;; 1065 // values for bayesian statistics; 1066 Bool_t bIsBayesian = false;; 1067 Double_t alpha = 1;; 1068 Double_t beta = 1;; 1069 ; 1070 // verbose mode; 1071 if (option.Contains(""v"")) {; 1072 option.ReplaceAll(""v"", """");; 1073 bVerbose = true;; 1074 if (bEffective); 1075 Info(""Divide"", ""weight will be considered in the Histogram Ratio"");; 1076 }; 1077 ; 1078 // confidence level; 1079 if (option.Contains(""cl="")) {; 1080 Double_t level = -1;; 1081 // cover",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:87665,Performance,perform,perform,87665," i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::Classstatic TClass * Class(); TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGraph.h:46; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::fMaxSizeInt_t fMaxSize!Current dimension of arrays fX and fYDefinition TGraph.h:45; TGraph::SaveHistogramAndFunctionsvoid SaveHistogramAndFunctions(std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option)Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes.Definition TGraph.cxx",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:89934,Performance,perform,perform,89934,"he sorted values.Definition TGraph.cxx:2592; TGraph::IsATClass * IsA() const overrideDefinition TGraph.h:203; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::fYDouble_t * fY[fNpoints] array of Y pointsDefinition TGraph.h:48; TGraph::CtorAllocateBool_t CtorAllocate()In constructors set fNpoints than call this method.Definition TGraph.cxx:805; TGraph::ComputeRangevirtual void ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) constCompute the x/y range of the points in this graph.Definition TGraph.cxx:731; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; TGraph::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""y"")Multiply the values of a TGraph by a constant c1.Definition TGraph.cxx:2259; TGraph::SwapValuesstatic void SwapValues(Double_t *arr, Int_t pos1, Int_t pos2)Swap values.Definition TGraph.cxx:2611; TGraph::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::SetNamevoid SetName(const char *name="""") overrideSet graph name.Definition TGraph.cxx:2381; TGraph::SwapPointsvirtual void SwapPoints(Int_t pos1, Int_t pos2)Swap points.Definition TGraph.cxx:2583; TGraph::FillZerovirtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE)Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes.Definition TGraph.cxx:1102; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::SetTitlevoid SetTitle(const char *title="""") overrideChange (i.e.Definition TGraph.cxx:2397; TGraph::SetNameTitlevoid SetNameTitle(const char *name="""", const char *title="""") overrideSet graph name and title.Definition TGraph.cxx:2417; TGraph::Setvirtual void Set(Int_t n)Set number of points in the graph Existing coordinates are preserved New coordinates above fNpoints a...Definition TGraph.cxx:2277; TGraph::GetPoin",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:859,Availability,error,error,859,". ROOT: hist/hist/inc/TGraphMultiErrors.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphMultiErrors.h. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Simon Spies 18/02/19; 3 ; 4/*************************************************************************; 5 * Copyright (C) 2018-2019, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGraphMultiErrors; 13#define ROOT_TGraphMultiErrors; 14 ; 15//////////////////////////////////////////////////////////////////////////; 16// //; 17// TGraphMultiErrors //; 18// //; 19// a Graph with asymmetric error bars and multiple y errors //; 20// //; 21//////////////////////////////////////////////////////////////////////////; 22 ; 23#include ""TGraph.h""; 24#include <vector>; 25 ; 26class TArrayF;; 27class TArrayD;; 28 ; 29class TGraphMultiErrors : public TGraph {; 30 ; 31protected:; 32 Int_t fNYErrors; ///< The amount of different y-errors; 33 Int_t fSumErrorsMode; ///< How y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum =; 34 ///< Absolute Addition; 35 Double_t *fExL; ///<[fNpoints] array of X low errors; 36 Double_t *fExH; ///<[fNpoints] array of X high errors; 37 std::vector<TArrayD> fEyL; ///< Two dimensional array of Y low errors; 38 std::vector<TArrayD> fEyH; ///< Two dimensional array of Y high errors; 39 mutable Double_t *fEyLSum = nullptr; ///<! Array of summed Y low errors for fitting; 40 mutable Double_t *fEyHSum = nullptr; ///<! Array of summed Y high errors for fitting; 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) ov",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:885,Availability,error,errors,885,". ROOT: hist/hist/inc/TGraphMultiErrors.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphMultiErrors.h. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Simon Spies 18/02/19; 3 ; 4/*************************************************************************; 5 * Copyright (C) 2018-2019, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGraphMultiErrors; 13#define ROOT_TGraphMultiErrors; 14 ; 15//////////////////////////////////////////////////////////////////////////; 16// //; 17// TGraphMultiErrors //; 18// //; 19// a Graph with asymmetric error bars and multiple y errors //; 20// //; 21//////////////////////////////////////////////////////////////////////////; 22 ; 23#include ""TGraph.h""; 24#include <vector>; 25 ; 26class TArrayF;; 27class TArrayD;; 28 ; 29class TGraphMultiErrors : public TGraph {; 30 ; 31protected:; 32 Int_t fNYErrors; ///< The amount of different y-errors; 33 Int_t fSumErrorsMode; ///< How y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum =; 34 ///< Absolute Addition; 35 Double_t *fExL; ///<[fNpoints] array of X low errors; 36 Double_t *fExH; ///<[fNpoints] array of X high errors; 37 std::vector<TArrayD> fEyL; ///< Two dimensional array of Y low errors; 38 std::vector<TArrayD> fEyH; ///< Two dimensional array of Y high errors; 39 mutable Double_t *fEyLSum = nullptr; ///<! Array of summed Y low errors for fitting; 40 mutable Double_t *fEyHSum = nullptr; ///<! Array of summed Y high errors for fitting; 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) ov",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:1193,Availability,error,errors,1193,"h""; 24#include <vector>; 25 ; 26class TArrayF;; 27class TArrayD;; 28 ; 29class TGraphMultiErrors : public TGraph {; 30 ; 31protected:; 32 Int_t fNYErrors; ///< The amount of different y-errors; 33 Int_t fSumErrorsMode; ///< How y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum =; 34 ///< Absolute Addition; 35 Double_t *fExL; ///<[fNpoints] array of X low errors; 36 Double_t *fExH; ///<[fNpoints] array of X high errors; 37 std::vector<TArrayD> fEyL; ///< Two dimensional array of Y low errors; 38 std::vector<TArrayD> fEyH; ///< Two dimensional array of Y high errors; 39 mutable Double_t *fEyLSum = nullptr; ///<! Array of summed Y low errors for fitting; 40 mutable Double_t *fEyHSum = nullptr; ///<! Array of summed Y high errors for fitting; 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) ov",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:1237,Availability,error,errors,1237,"h""; 24#include <vector>; 25 ; 26class TArrayF;; 27class TArrayD;; 28 ; 29class TGraphMultiErrors : public TGraph {; 30 ; 31protected:; 32 Int_t fNYErrors; ///< The amount of different y-errors; 33 Int_t fSumErrorsMode; ///< How y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum =; 34 ///< Absolute Addition; 35 Double_t *fExL; ///<[fNpoints] array of X low errors; 36 Double_t *fExH; ///<[fNpoints] array of X high errors; 37 std::vector<TArrayD> fEyL; ///< Two dimensional array of Y low errors; 38 std::vector<TArrayD> fEyH; ///< Two dimensional array of Y high errors; 39 mutable Double_t *fEyLSum = nullptr; ///<! Array of summed Y low errors for fitting; 40 mutable Double_t *fEyHSum = nullptr; ///<! Array of summed Y high errors for fitting; 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) ov",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:1391,Availability,error,errors,1391,"h""; 24#include <vector>; 25 ; 26class TArrayF;; 27class TArrayD;; 28 ; 29class TGraphMultiErrors : public TGraph {; 30 ; 31protected:; 32 Int_t fNYErrors; ///< The amount of different y-errors; 33 Int_t fSumErrorsMode; ///< How y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum =; 34 ///< Absolute Addition; 35 Double_t *fExL; ///<[fNpoints] array of X low errors; 36 Double_t *fExH; ///<[fNpoints] array of X high errors; 37 std::vector<TArrayD> fEyL; ///< Two dimensional array of Y low errors; 38 std::vector<TArrayD> fEyH; ///< Two dimensional array of Y high errors; 39 mutable Double_t *fEyLSum = nullptr; ///<! Array of summed Y low errors for fitting; 40 mutable Double_t *fEyHSum = nullptr; ///<! Array of summed Y high errors for fitting; 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) ov",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:1449,Availability,error,errors,1449,"h""; 24#include <vector>; 25 ; 26class TArrayF;; 27class TArrayD;; 28 ; 29class TGraphMultiErrors : public TGraph {; 30 ; 31protected:; 32 Int_t fNYErrors; ///< The amount of different y-errors; 33 Int_t fSumErrorsMode; ///< How y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum =; 34 ///< Absolute Addition; 35 Double_t *fExL; ///<[fNpoints] array of X low errors; 36 Double_t *fExH; ///<[fNpoints] array of X high errors; 37 std::vector<TArrayD> fEyL; ///< Two dimensional array of Y low errors; 38 std::vector<TArrayD> fEyH; ///< Two dimensional array of Y high errors; 39 mutable Double_t *fEyLSum = nullptr; ///<! Array of summed Y low errors for fitting; 40 mutable Double_t *fEyHSum = nullptr; ///<! Array of summed Y high errors for fitting; 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) ov",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:1523,Availability,error,errors,1523,"h""; 24#include <vector>; 25 ; 26class TArrayF;; 27class TArrayD;; 28 ; 29class TGraphMultiErrors : public TGraph {; 30 ; 31protected:; 32 Int_t fNYErrors; ///< The amount of different y-errors; 33 Int_t fSumErrorsMode; ///< How y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum =; 34 ///< Absolute Addition; 35 Double_t *fExL; ///<[fNpoints] array of X low errors; 36 Double_t *fExH; ///<[fNpoints] array of X high errors; 37 std::vector<TArrayD> fEyL; ///< Two dimensional array of Y low errors; 38 std::vector<TArrayD> fEyH; ///< Two dimensional array of Y high errors; 39 mutable Double_t *fEyLSum = nullptr; ///<! Array of summed Y low errors for fitting; 40 mutable Double_t *fEyHSum = nullptr; ///<! Array of summed Y high errors for fitting; 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) ov",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:1598,Availability,error,errors,1598,"h""; 24#include <vector>; 25 ; 26class TArrayF;; 27class TArrayD;; 28 ; 29class TGraphMultiErrors : public TGraph {; 30 ; 31protected:; 32 Int_t fNYErrors; ///< The amount of different y-errors; 33 Int_t fSumErrorsMode; ///< How y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum =; 34 ///< Absolute Addition; 35 Double_t *fExL; ///<[fNpoints] array of X low errors; 36 Double_t *fExH; ///<[fNpoints] array of X high errors; 37 std::vector<TArrayD> fEyL; ///< Two dimensional array of Y low errors; 38 std::vector<TArrayD> fEyH; ///< Two dimensional array of Y high errors; 39 mutable Double_t *fEyLSum = nullptr; ///<! Array of summed Y low errors for fitting; 40 mutable Double_t *fEyHSum = nullptr; ///<! Array of summed Y high errors for fitting; 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) ov",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:1674,Availability,error,errors,1674,"h""; 24#include <vector>; 25 ; 26class TArrayF;; 27class TArrayD;; 28 ; 29class TGraphMultiErrors : public TGraph {; 30 ; 31protected:; 32 Int_t fNYErrors; ///< The amount of different y-errors; 33 Int_t fSumErrorsMode; ///< How y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum =; 34 ///< Absolute Addition; 35 Double_t *fExL; ///<[fNpoints] array of X low errors; 36 Double_t *fExH; ///<[fNpoints] array of X high errors; 37 std::vector<TArrayD> fEyL; ///< Two dimensional array of Y low errors; 38 std::vector<TArrayD> fEyH; ///< Two dimensional array of Y high errors; 39 mutable Double_t *fEyLSum = nullptr; ///<! Array of summed Y low errors for fitting; 40 mutable Double_t *fEyHSum = nullptr; ///<! Array of summed Y high errors for fitting; 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) ov",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:1763,Availability,error,errors,1763,"h""; 24#include <vector>; 25 ; 26class TArrayF;; 27class TArrayD;; 28 ; 29class TGraphMultiErrors : public TGraph {; 30 ; 31protected:; 32 Int_t fNYErrors; ///< The amount of different y-errors; 33 Int_t fSumErrorsMode; ///< How y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum =; 34 ///< Absolute Addition; 35 Double_t *fExL; ///<[fNpoints] array of X low errors; 36 Double_t *fExH; ///<[fNpoints] array of X high errors; 37 std::vector<TArrayD> fEyL; ///< Two dimensional array of Y low errors; 38 std::vector<TArrayD> fEyH; ///< Two dimensional array of Y high errors; 39 mutable Double_t *fEyLSum = nullptr; ///<! Array of summed Y low errors for fitting; 40 mutable Double_t *fEyHSum = nullptr; ///<! Array of summed Y high errors for fitting; 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) ov",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:1863,Availability,error,errors,1863,"h""; 24#include <vector>; 25 ; 26class TArrayF;; 27class TArrayD;; 28 ; 29class TGraphMultiErrors : public TGraph {; 30 ; 31protected:; 32 Int_t fNYErrors; ///< The amount of different y-errors; 33 Int_t fSumErrorsMode; ///< How y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum =; 34 ///< Absolute Addition; 35 Double_t *fExL; ///<[fNpoints] array of X low errors; 36 Double_t *fExH; ///<[fNpoints] array of X high errors; 37 std::vector<TArrayD> fEyL; ///< Two dimensional array of Y low errors; 38 std::vector<TArrayD> fEyH; ///< Two dimensional array of Y high errors; 39 mutable Double_t *fEyLSum = nullptr; ///<! Array of summed Y low errors for fitting; 40 mutable Double_t *fEyHSum = nullptr; ///<! Array of summed Y high errors for fitting; 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) ov",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:1951,Availability,error,errors,1951,"h""; 24#include <vector>; 25 ; 26class TArrayF;; 27class TArrayD;; 28 ; 29class TGraphMultiErrors : public TGraph {; 30 ; 31protected:; 32 Int_t fNYErrors; ///< The amount of different y-errors; 33 Int_t fSumErrorsMode; ///< How y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum =; 34 ///< Absolute Addition; 35 Double_t *fExL; ///<[fNpoints] array of X low errors; 36 Double_t *fExH; ///<[fNpoints] array of X high errors; 37 std::vector<TArrayD> fEyL; ///< Two dimensional array of Y low errors; 38 std::vector<TArrayD> fEyH; ///< Two dimensional array of Y high errors; 39 mutable Double_t *fEyLSum = nullptr; ///<! Array of summed Y low errors for fitting; 40 mutable Double_t *fEyHSum = nullptr; ///<! Array of summed Y high errors for fitting; 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) ov",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:2632,Availability,error,errors,2632,"= nullptr; ///<! Array of summed Y low errors for fitting; 40 mutable Double_t *fEyHSum = nullptr; ///<! Array of summed Y high errors for fitting; 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) override;; 45 Bool_t CtorAllocate();; 46 ; 47 void CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;; 48 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;; 49 void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE) override;; 50 ; 51 void CalcYErrorsSum() const;; 52 Bool_t DoMerge(const TGraph *tg) override;; 53 void SwapPoints(Int_t pos1, Int_t pos2) override;; 54 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 55 ; 56public:; 57 enum ESummationModes {; 58 kOnlyFirst = 0, ///< Only take errors from first dimension; 59 kSquareSum = 1, ///< Calculate the square sum of all errors; 60 kAbsSum = 2 ///< Calculate the absolute sum of all errors; 61 };; 62 ; 63 TGraphMultiErrors();; 64 TGraphMultiErrors(const Char_t *name, const Char_t *title);; 65 TGraphMultiErrors(Int_t np, Int_t ne = 1);; 66 TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne = 1);; 67 ; 68 TGraphMultiErrors(Int_t np, const Float_t *x, const Float_t *y, const Float_t *exL = nullptr,; 69 const Float_t *exH = nullptr, const Float_t *eyL = nullptr, const Float_t *eyH = nullptr,; 70 Int_t m = kOnlyFirst);; 71 TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, const Float_t *x, const Float_t *y,; 72 const Float_t *exL = nullptr, const Float_t *exH = nullptr, const Float_t *eyL = nullptr,; 73 const Float_t *eyH = nullptr, Int_t m = kOnlyFirst);; 74 TGraphMultiErrors(Int_t np, const Double_t *x, const Double_t *y, const Double_t *exL = nullptr,; 75 const Double_t *exH = nul",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:2717,Availability,error,errors,2717,"um = nullptr; ///<! Array of summed Y high errors for fitting; 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) override;; 45 Bool_t CtorAllocate();; 46 ; 47 void CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;; 48 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;; 49 void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE) override;; 50 ; 51 void CalcYErrorsSum() const;; 52 Bool_t DoMerge(const TGraph *tg) override;; 53 void SwapPoints(Int_t pos1, Int_t pos2) override;; 54 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 55 ; 56public:; 57 enum ESummationModes {; 58 kOnlyFirst = 0, ///< Only take errors from first dimension; 59 kSquareSum = 1, ///< Calculate the square sum of all errors; 60 kAbsSum = 2 ///< Calculate the absolute sum of all errors; 61 };; 62 ; 63 TGraphMultiErrors();; 64 TGraphMultiErrors(const Char_t *name, const Char_t *title);; 65 TGraphMultiErrors(Int_t np, Int_t ne = 1);; 66 TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne = 1);; 67 ; 68 TGraphMultiErrors(Int_t np, const Float_t *x, const Float_t *y, const Float_t *exL = nullptr,; 69 const Float_t *exH = nullptr, const Float_t *eyL = nullptr, const Float_t *eyH = nullptr,; 70 Int_t m = kOnlyFirst);; 71 TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, const Float_t *x, const Float_t *y,; 72 const Float_t *exL = nullptr, const Float_t *exH = nullptr, const Float_t *eyL = nullptr,; 73 const Float_t *eyH = nullptr, Int_t m = kOnlyFirst);; 74 TGraphMultiErrors(Int_t np, const Double_t *x, const Double_t *y, const Double_t *exL = nullptr,; 75 const Double_t *exH = nullptr, const Double_t *eyL = nullptr, const Double_t *eyH = nullptr,; 76 Int_t m = kOn",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:2779,Availability,error,errors,2779," 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) override;; 45 Bool_t CtorAllocate();; 46 ; 47 void CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;; 48 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;; 49 void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE) override;; 50 ; 51 void CalcYErrorsSum() const;; 52 Bool_t DoMerge(const TGraph *tg) override;; 53 void SwapPoints(Int_t pos1, Int_t pos2) override;; 54 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 55 ; 56public:; 57 enum ESummationModes {; 58 kOnlyFirst = 0, ///< Only take errors from first dimension; 59 kSquareSum = 1, ///< Calculate the square sum of all errors; 60 kAbsSum = 2 ///< Calculate the absolute sum of all errors; 61 };; 62 ; 63 TGraphMultiErrors();; 64 TGraphMultiErrors(const Char_t *name, const Char_t *title);; 65 TGraphMultiErrors(Int_t np, Int_t ne = 1);; 66 TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne = 1);; 67 ; 68 TGraphMultiErrors(Int_t np, const Float_t *x, const Float_t *y, const Float_t *exL = nullptr,; 69 const Float_t *exH = nullptr, const Float_t *eyL = nullptr, const Float_t *eyH = nullptr,; 70 Int_t m = kOnlyFirst);; 71 TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, const Float_t *x, const Float_t *y,; 72 const Float_t *exL = nullptr, const Float_t *exH = nullptr, const Float_t *eyL = nullptr,; 73 const Float_t *eyH = nullptr, Int_t m = kOnlyFirst);; 74 TGraphMultiErrors(Int_t np, const Double_t *x, const Double_t *y, const Double_t *exL = nullptr,; 75 const Double_t *exH = nullptr, const Double_t *eyL = nullptr, const Double_t *eyH = nullptr,; 76 Int_t m = kOnlyFirst);; 77 TGraphMultiErrors(const Char_t *name, const Char",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:11243,Availability,error,error,11243,"le_t exH, const Double_t *eyL, const Double_t *eyH);; 175 ; 176 virtual void SetPointEX(Int_t i, Double_t exL, Double_t exH);; 177 virtual void SetPointEXlow(Int_t i, Double_t exL);; 178 virtual void SetPointEXhigh(Int_t i, Double_t exH);; 179 virtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH);; 180 virtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL);; 181 virtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH);; 182 virtual void SetPointEY(Int_t i, Int_t e, Double_t eyL, Double_t eyH);; 183 virtual void SetPointEYlow(Int_t i, Int_t e, Double_t eyL);; 184 virtual void SetPointEYhigh(Int_t i, Int_t e, Double_t eyH);; 185 ; 186 virtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH);; 187 virtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL);; 188 virtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH);; 189 ; 190 virtual void SetSumErrorsMode(Int_t m);; 191 ; 192 virtual void SetAttFill(Int_t e, TAttFill *taf);; 193 virtual void SetAttLine(Int_t e, TAttLine *tal);; 194 ; 195 using TAttFill::SetFillColor;; 196 using TAttFill::SetFillColorAlpha;; 197 using TAttFill::SetFillStyle;; 198 ; 199 virtual void SetFillColor(Int_t e, Color_t fcolor);; 200 virtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha);; 201 virtual void SetFillStyle(Int_t e, Style_t fstyle);; 202 ; 203 using TAttLine::SetLineColor;; 204 using TAttLine::SetLineColorAlpha;; 205 using TAttLine::SetLineStyle;; 206 using TAttLine::SetLineWidth;; 207 ; 208 virtual void SetLineColor(Int_t e, Color_t lcolor);; 209 virtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha);; 210 virtual void SetLineStyle(Int_t e, Style_t lstyle);; 211 virtual void SetLineWidth(Int_t e, Width_t lwidth);; 212 ; 213 ClassDefOverride(TGraphMultiErrors, 1) // A Graph with asymmetric error bars and multiple y error dimensions; 214};; 215 ; 216#endif // ROOT_TGraphMultiErrors; f#define f(i)Definition RSha256.",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:11269,Availability,error,error,11269,"le_t exH, const Double_t *eyL, const Double_t *eyH);; 175 ; 176 virtual void SetPointEX(Int_t i, Double_t exL, Double_t exH);; 177 virtual void SetPointEXlow(Int_t i, Double_t exL);; 178 virtual void SetPointEXhigh(Int_t i, Double_t exH);; 179 virtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH);; 180 virtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL);; 181 virtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH);; 182 virtual void SetPointEY(Int_t i, Int_t e, Double_t eyL, Double_t eyH);; 183 virtual void SetPointEYlow(Int_t i, Int_t e, Double_t eyL);; 184 virtual void SetPointEYhigh(Int_t i, Int_t e, Double_t eyH);; 185 ; 186 virtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH);; 187 virtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL);; 188 virtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH);; 189 ; 190 virtual void SetSumErrorsMode(Int_t m);; 191 ; 192 virtual void SetAttFill(Int_t e, TAttFill *taf);; 193 virtual void SetAttLine(Int_t e, TAttLine *tal);; 194 ; 195 using TAttFill::SetFillColor;; 196 using TAttFill::SetFillColorAlpha;; 197 using TAttFill::SetFillStyle;; 198 ; 199 virtual void SetFillColor(Int_t e, Color_t fcolor);; 200 virtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha);; 201 virtual void SetFillStyle(Int_t e, Style_t fstyle);; 202 ; 203 using TAttLine::SetLineColor;; 204 using TAttLine::SetLineColorAlpha;; 205 using TAttLine::SetLineStyle;; 206 using TAttLine::SetLineWidth;; 207 ; 208 virtual void SetLineColor(Int_t e, Color_t lcolor);; 209 virtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha);; 210 virtual void SetLineStyle(Int_t e, Style_t lstyle);; 211 virtual void SetLineWidth(Int_t e, Width_t lwidth);; 212 ; 213 ClassDefOverride(TGraphMultiErrors, 1) // A Graph with asymmetric error bars and multiple y error dimensions; 214};; 215 ; 216#endif // ROOT_TGraphMultiErrors; f#define f(i)Definition RSha256.",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:14975,Availability,error,error,14975,"lStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLineLine Attributes class.Definition TAttLine.h:18; TAttLine::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorAlphavirtual void SetLineColorAlpha(Color_t lcolor, Float_t lalpha)Set a transparent line color.Definition TAttLine.cxx:305; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttLine::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TF11-Dim function classDefinition TF1.h:233; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::fEyLSumDouble_t * fEyLSum! Array of summed Y low errors for fittingDefinition TGraphMultiErrors.h:39; TGraphMultiErrors::GetSumErrorsModeInt_t GetSumErrorsMode() constDefinition TGraphMultiErrors.h:165; TGraphMultiErrors::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.De",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:15001,Availability,error,error,15001,"lStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLineLine Attributes class.Definition TAttLine.h:18; TAttLine::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorAlphavirtual void SetLineColorAlpha(Color_t lcolor, Float_t lalpha)Set a transparent line color.Definition TAttLine.cxx:305; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttLine::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TF11-Dim function classDefinition TF1.h:233; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::fEyLSumDouble_t * fEyLSum! Array of summed Y low errors for fittingDefinition TGraphMultiErrors.h:39; TGraphMultiErrors::GetSumErrorsModeInt_t GetSumErrorsMode() constDefinition TGraphMultiErrors.h:165; TGraphMultiErrors::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.De",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:15121,Availability,error,errors,15121,"ne::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorAlphavirtual void SetLineColorAlpha(Color_t lcolor, Float_t lalpha)Set a transparent line color.Definition TAttLine.cxx:305; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttLine::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TF11-Dim function classDefinition TF1.h:233; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::fEyLSumDouble_t * fEyLSum! Array of summed Y low errors for fittingDefinition TGraphMultiErrors.h:39; TGraphMultiErrors::GetSumErrorsModeInt_t GetSumErrorsMode() constDefinition TGraphMultiErrors.h:165; TGraphMultiErrors::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t ey",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:15473,Availability,error,errors,15473,"th(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorAlphavirtual void SetLineColorAlpha(Color_t lcolor, Float_t lalpha)Set a transparent line color.Definition TAttLine.cxx:305; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttLine::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TF11-Dim function classDefinition TF1.h:233; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::fEyLSumDouble_t * fEyLSum! Array of summed Y low errors for fittingDefinition TGraphMultiErrors.h:39; TGraphMultiErrors::GetSumErrorsModeInt_t GetSumErrorsMode() constDefinition TGraphMultiErrors.h:165; TGraphMultiErrors::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::Set",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:15657,Availability,error,error,15657,"ent line color.Definition TAttLine.cxx:305; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttLine::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TF11-Dim function classDefinition TF1.h:233; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::fEyLSumDouble_t * fEyLSum! Array of summed Y low errors for fittingDefinition TGraphMultiErrors.h:39; TGraphMultiErrors::GetSumErrorsModeInt_t GetSumErrorsMode() constDefinition TGraphMultiErrors.h:165; TGraphMultiErrors::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraph",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:15937,Availability,error,error,15937," classDefinition TF1.h:233; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::fEyLSumDouble_t * fEyLSum! Array of summed Y low errors for fittingDefinition TGraphMultiErrors.h:39; TGraphMultiErrors::GetSumErrorsModeInt_t GetSumErrorsMode() constDefinition TGraphMultiErrors.h:165; TGraphMultiErrors::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMult",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:16390,Availability,error,error,16390,"Return the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullpt",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:16580,Availability,error,error,16580," to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:16607,Availability,error,errors,16607," to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:16853,Availability,error,error,16853,"efinition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e,",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:17214,Availability,error,errors,17214,"Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(cons",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:17386,Availability,error,error,17386,"ine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:17571,Availability,error,error,17571,"t_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiEr",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:17881,Availability,error,error,17881,"onst overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:18023,Availability,error,errors,18023,", Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors:",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:18058,Availability,error,errors,18058,", Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors:",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:18388,Availability,error,errors,18388,"nst Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const override",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:19038,Availability,error,errors,19038,"summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::ESummationModesESummationModesDefinition TGraphMultiErrors.h:57; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Li",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:19537,Availability,error,errors,19537,"t TGraphMultiErrors &tgme)TGraphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::ESummationModesESummationModesDefinition TGraphMultiErrors.h:57; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGrap",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:19652,Availability,error,errors,19652,"Errors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::ESummationModesESummationModesDefinition TGraphMultiErrors.h:57; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiEr",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:19745,Availability,error,errors,19745,"py and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::ESummationModesESummationModesDefinition TGraphMultiErrors.h:57; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point array",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:19909,Availability,error,error,19909,"option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::ESummationModesESummationModesDefinition TGraphMultiErrors.h:57; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional a",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:20063,Availability,error,error,20063,"rsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::ESummationModesESummationModesDefinition TGraphMultiErrors.h:57; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttL",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:20090,Availability,error,errors,20090,"rsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::ESummationModesESummationModesDefinition TGraphMultiErrors.h:57; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttL",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:20256,Availability,error,errors,20256,"ineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::ESummationModesESummationModesDefinition TGraphMultiErrors.h:57; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYl",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:20562,Availability,error,errorsDefinition,20562,"s.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:20879,Availability,error,errors,20879,"virtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMul",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:21459,Availability,error,errors,21459,"nt i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiError",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:21680,Availability,error,error,21680,"lZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGrap",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:21707,Availability,error,errors,21707,"lZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphMultiErrors.cxx:802; TGraphMultiErrors::fEyHstd::vector< TArrayD > fEyHTwo dimensional array of Y high errors.Definition TGraphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGrap",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:21939,Availability,error,error,21939,"raphMultiErrors.h:38; TGraphMultiErrors::GetLineStylevirtual Style_t GetLineStyle() constReturn the line style.Definition TAttLine.h:34; TGraphMultiErrors::SetPointEXvirtual void SetPointEX(Int_t i, Double_t exL, Double_t exH)Set ex values for point i.Definition TGraphMultiErrors.cxx:1844; TGraphMultiErrors::SetPointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMulti",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:22234,Availability,error,error,22234,"PointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::GetNYErrorsInt_t GetNYErrors() constDefinition TGraphMultiErrors.h:166; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:22294,Availability,error,errors,22294,"PointEYlowvirtual void SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL)Set eyL values for point i.Definition TGraphMultiErrors.cxx:1894; TGraphMultiErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::GetNYErrorsInt_t GetNYErrors() constDefinition TGraphMultiErrors.h:166; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:22410,Availability,error,errors,22410,"e_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::GetNYErrorsInt_t GetNYErrors() constDefinition TGraphMultiErrors.h:166; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:22538,Availability,error,errors,22538,"s.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::GetNYErrorsInt_t GetNYErrors() constDefinition TGraphMultiErrors.h:166; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual voi",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:22727,Availability,error,error,22727,"Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::GetNYErrorsInt_t GetNYErrors() constDefinition TGraphMultiErrors.h:166; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:23009,Availability,error,error,23009,"phMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::GetNYErrorsInt_t GetNYErrors() constDefinition TGraphMultiErrors.h:166; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fExL, fExH, fEyL and fEyH ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:23388,Availability,error,error,23388,"mDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::GetNYErrorsInt_t GetNYErrors() constDefinition TGraphMultiErrors.h:166; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values.Definition TGraphMultiErrors.cxx:885; TGraphMultiErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set Note: This function should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvi",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:23448,Availability,error,errors,23448,"mDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::GetNYErrorsInt_t GetNYErrors() constDefinition TGraphMultiErrors.h:166; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values.Definition TGraphMultiErrors.cxx:885; TGraphMultiErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set Note: This function should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvi",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:23587,Availability,error,error,23587,"on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::GetNYErrorsInt_t GetNYErrors() constDefinition TGraphMultiErrors.h:166; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values.Definition TGraphMultiErrors.cxx:885; TGraphMultiErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set Note: This function should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvirtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetPointEXlowv",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:23744,Availability,error,errors,23744,"eleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition TGraphMultiErrors.cxx:1995; TGraphMultiErrors::GetNYErrorsInt_t GetNYErrors() constDefinition TGraphMultiErrors.h:166; TGraphMultiErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphMultiErrors.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values.Definition TGraphMultiErrors.cxx:885; TGraphMultiErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set Note: This function should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvirtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighv",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:24294,Availability,error,errorsDefinition,24294,"s.cxx:869; TGraphMultiErrors::SetAttFillvirtual void SetAttFill(Int_t e, TAttFill *taf)Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2018; TGraphMultiErrors::SetEYlowvirtual void SetEYlow(Int_t e, Int_t np, const Double_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values.Definition TGraphMultiErrors.cxx:885; TGraphMultiErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set Note: This function should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvirtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:25074,Availability,error,errors,25074,"aphMultiErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set Note: This function should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvirtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:25197,Availability,error,errors,25197,"ction should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvirtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TVectorTTVectorT.Definition TVectorT.h:27; bool; double; int; yDouble_t y[n]Defin",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:25313,Availability,error,error,25313,"igh errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvirtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TVectorTTVectorT.Definition TVectorT.h:27; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; mTMarker mDefinition textangle.C:8. hi",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:25695,Availability,error,errors,25695,"yL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TVectorTTVectorT.Definition TVectorT.h:27; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; mTMarker mDefinition textangle.C:8. histhistincTGraphMultiErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:25827,Availability,error,error,25827,"yL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TVectorTTVectorT.Definition TVectorT.h:27; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; mTMarker mDefinition textangle.C:8. histhistincTGraphMultiErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:18737,Deployability,release,release,18737,"ultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::ESummationModesESummationModesDefinition TGraphMultiErrors.h:57; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition T",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:17035,Energy Efficiency,adapt,adapted,17035,"ors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErro",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:17035,Modifiability,adapt,adapted,17035,"ors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErro",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:25631,Performance,perform,perform,25631,"yL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TVectorTTVectorT.Definition TVectorT.h:27; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; mTMarker mDefinition textangle.C:8. histhistincTGraphMultiErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:2135,Availability,error,error,2135,"tualPadEditor.h""; 38#include ""TVirtualX.h""; 39#include ""TRegexp.h""; 40#include ""strlcpy.h""; 41#include ""snprintf.h""; 42#include <memory>; 43 ; 44Int_t TGraphPainter::fgMaxPointsPerLine = 50;; 45 ; 46static Int_t gHighlightPoint = -1; // highlight point of graph; 47static TGraph *gHighlightGraph = nullptr; // pointer to graph with highlight point; 48static std::unique_ptr<TMarker> gHighlightMarker; // highlight marker; 49 ; 50ClassImp(TGraphPainter);; 51 ; 52 ; 53////////////////////////////////////////////////////////////////////////////////; 54 ; 55/*! \class TGraphPainter; 56 \ingroup Histpainter; 57 \brief The graph painter class. Implements all graphs' drawing's options.; 58 ; 59- [Introduction](\ref GrP0); 60- [Graphs' plotting options](\ref GrP1); 61- [Exclusion graphs](\ref GrP2); 62- [Graphs with error bars](\ref GrP3); 63 - [TGraphErrors](\ref GrP3a); 64 - [TGraphAsymmErrors](\ref GrP3b); 65 - [TGraphBentErrors](\ref GrP3c); 66 - [TGraphMultiErrors](\ref GrP3d); 67- [TGraphPolar options](\ref GrP4); 68- [Colors automatically picked in palette](\ref GrP5); 69- [Reverse graphs' axis](\ref GrP6); 70- [Graphs in logarithmic scale](\ref GrP7); 71- [Highlight mode for graph](\ref GrP8); 72 ; 73 ; 74\anchor GrP0; 75### Introduction; 76 ; 77Graphs are drawn via the painter `TGraphPainter` class. This class; 78implements techniques needed to display the various kind of; 79graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`.; 80 ; 81To draw a graph `graph` it's enough to do:; 82 ; 83 graph->Draw(""AL"");; 84 ; 85The option `AL` in the `Draw()` method means:; 86 ; 871. The axis should be drawn (option `A`),; 882. The graph should be drawn as a simple line (option `L`).; 89 ; 90 By default a graph is drawn in the current pad in the current coordinate system.; 91To define a suitable coordinate system and draw the axis the option; 92`A` must be specified.; 93 ; 94`TGraphPainter` offers many options to paint the various kind of graphs.; 95 ; 96",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:7677,Availability,error,error,7677," gr->Draw(""AB"");; 190 c47->cd(2); gr->Draw(""AB1"");; 191}; 192End_Macro; 193 ; 194\anchor GrP2; 195### Exclusion graphs; 196 ; 197When a graph is painted with the option `C` or `L` it is; 198possible to draw a filled area on one side of the line. This is useful to show; 199exclusion zones.; 200 ; 201This drawing mode is activated when the absolute value of the graph line; 202width (set by `SetLineWidth()`) is greater than 99. In that; 203case the line width number is interpreted as:; 204 ; 205 100*ff+ll = ffll; 206 ; 207- The two digits number `ll` represent the normal line width; 208- The two digits number `ff` represent the filled area width.; 209- The sign of ""ffll"" allows to flip the filled area from one side of the line to the other.; 210 ; 211The current fill area attributes are used to draw the hatched zone.; 212 ; 213Begin_Macro(source); 214../../../tutorials/graphs/exclusiongraph.C; 215End_Macro; 216 ; 217\anchor GrP3; 218### Graphs with error bars; 219Three classes are available to handle graphs with error bars:; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interestin",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:7710,Availability,avail,available,7710," gr->Draw(""AB"");; 190 c47->cd(2); gr->Draw(""AB1"");; 191}; 192End_Macro; 193 ; 194\anchor GrP2; 195### Exclusion graphs; 196 ; 197When a graph is painted with the option `C` or `L` it is; 198possible to draw a filled area on one side of the line. This is useful to show; 199exclusion zones.; 200 ; 201This drawing mode is activated when the absolute value of the graph line; 202width (set by `SetLineWidth()`) is greater than 99. In that; 203case the line width number is interpreted as:; 204 ; 205 100*ff+ll = ffll; 206 ; 207- The two digits number `ll` represent the normal line width; 208- The two digits number `ff` represent the filled area width.; 209- The sign of ""ffll"" allows to flip the filled area from one side of the line to the other.; 210 ; 211The current fill area attributes are used to draw the hatched zone.; 212 ; 213Begin_Macro(source); 214../../../tutorials/graphs/exclusiongraph.C; 215End_Macro; 216 ; 217\anchor GrP3; 218### Graphs with error bars; 219Three classes are available to handle graphs with error bars:; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interestin",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:7742,Availability,error,error,7742," gr->Draw(""AB"");; 190 c47->cd(2); gr->Draw(""AB1"");; 191}; 192End_Macro; 193 ; 194\anchor GrP2; 195### Exclusion graphs; 196 ; 197When a graph is painted with the option `C` or `L` it is; 198possible to draw a filled area on one side of the line. This is useful to show; 199exclusion zones.; 200 ; 201This drawing mode is activated when the absolute value of the graph line; 202width (set by `SetLineWidth()`) is greater than 99. In that; 203case the line width number is interpreted as:; 204 ; 205 100*ff+ll = ffll; 206 ; 207- The two digits number `ll` represent the normal line width; 208- The two digits number `ff` represent the filled area width.; 209- The sign of ""ffll"" allows to flip the filled area from one side of the line to the other.; 210 ; 211The current fill area attributes are used to draw the hatched zone.; 212 ; 213Begin_Macro(source); 214../../../tutorials/graphs/exclusiongraph.C; 215End_Macro; 216 ; 217\anchor GrP3; 218### Graphs with error bars; 219Three classes are available to handle graphs with error bars:; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interestin",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:7880,Availability,error,error,7880,"line. This is useful to show; 199exclusion zones.; 200 ; 201This drawing mode is activated when the absolute value of the graph line; 202width (set by `SetLineWidth()`) is greater than 99. In that; 203case the line width number is interpreted as:; 204 ; 205 100*ff+ll = ffll; 206 ; 207- The two digits number `ll` represent the normal line width; 208- The two digits number `ff` represent the filled area width.; 209- The sign of ""ffll"" allows to flip the filled area from one side of the line to the other.; 210 ; 211The current fill area attributes are used to draw the hatched zone.; 212 ; 213Begin_Macro(source); 214../../../tutorials/graphs/exclusiongraph.C; 215End_Macro; 216 ; 217\anchor GrP3; 218### Graphs with error bars; 219Three classes are available to handle graphs with error bars:; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It make",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:8087,Availability,error,error,8087,"line. This is useful to show; 199exclusion zones.; 200 ; 201This drawing mode is activated when the absolute value of the graph line; 202width (set by `SetLineWidth()`) is greater than 99. In that; 203case the line width number is interpreted as:; 204 ; 205 100*ff+ll = ffll; 206 ; 207- The two digits number `ll` represent the normal line width; 208- The two digits number `ff` represent the filled area width.; 209- The sign of ""ffll"" allows to flip the filled area from one side of the line to the other.; 210 ; 211The current fill area attributes are used to draw the hatched zone.; 212 ; 213Begin_Macro(source); 214../../../tutorials/graphs/exclusiongraph.C; 215End_Macro; 216 ; 217\anchor GrP3; 218### Graphs with error bars; 219Three classes are available to handle graphs with error bars:; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It make",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:8192,Availability,error,error,8192,"width number is interpreted as:; 204 ; 205 100*ff+ll = ffll; 206 ; 207- The two digits number `ll` represent the normal line width; 208- The two digits number `ff` represent the filled area width.; 209- The sign of ""ffll"" allows to flip the filled area from one side of the line to the other.; 210 ; 211The current fill area attributes are used to draw the hatched zone.; 212 ; 213Begin_Macro(source); 214../../../tutorials/graphs/exclusiongraph.C; 215End_Macro; 216 ; 217\anchor GrP3; 218### Graphs with error bars; 219Three classes are available to handle graphs with error bars:; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forc",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:8320,Availability,error,error,8320,"e width; 208- The two digits number `ff` represent the filled area width.; 209- The sign of ""ffll"" allows to flip the filled area from one side of the line to the other.; 210 ; 211The current fill area attributes are used to draw the hatched zone.; 212 ; 213Begin_Macro(source); 214../../../tutorials/graphs/exclusiongraph.C; 215End_Macro; 216 ; 217\anchor GrP3; 218### Graphs with error bars; 219Three classes are available to handle graphs with error bars:; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Er",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:8414,Availability,error,error,8414,"ip the filled area from one side of the line to the other.; 210 ; 211The current fill area attributes are used to draw the hatched zone.; 212 ; 213Begin_Macro(source); 214../../../tutorials/graphs/exclusiongraph.C; 215End_Macro; 216 ; 217\anchor GrP3; 218### Graphs with error bars; 219Three classes are available to handle graphs with error bars:; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bar",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:8462,Availability,error,errors,8462," area attributes are used to draw the hatched zone.; 212 ; 213Begin_Macro(source); 214../../../tutorials/graphs/exclusiongraph.C; 215End_Macro; 216 ; 217\anchor GrP3; 218### Graphs with error bars; 219Three classes are available to handle graphs with error bars:; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertica",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:8488,Availability,error,errors,8488," area attributes are used to draw the hatched zone.; 212 ; 213Begin_Macro(source); 214../../../tutorials/graphs/exclusiongraph.C; 215End_Macro; 216 ; 217\anchor GrP3; 218### Graphs with error bars; 219Three classes are available to handle graphs with error bars:; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertica",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:8517,Availability,error,errors,8517," area attributes are used to draw the hatched zone.; 212 ; 213Begin_Macro(source); 214../../../tutorials/graphs/exclusiongraph.C; 215End_Macro; 216 ; 217\anchor GrP3; 218### Graphs with error bars; 219Three classes are available to handle graphs with error bars:; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertica",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:8644,Availability,error,error,8644,"nd_Macro; 216 ; 217\anchor GrP3; 218### Graphs with error bars; 219Three classes are available to handle graphs with error bars:; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This ",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:8752,Availability,error,errors,8752,":; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls ",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:8805,Availability,error,errors,8805,":; 220`TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; 221The following drawing options are specific to graphs with error bars:; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls ",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:9130,Availability,error,error,9130,"ars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGr",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:9175,Availability,error,error,9175,"the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; ",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:9397,Availability,error,error,9397,"2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; 250along X and the bottom and up errors are the same along Y.; 251 ; 252Begin_Macro(source); 253{; 254 auto c4 = new TCanvas(""c4"",""c4"",200,10,600,4",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:9494,Availability,error,error,9494," have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; 250along X and the bottom and up errors are the same along Y.; 251 ; 252Begin_Macro(source); 253{; 254 auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; 255 double x[] = {0, 1, 2, 3, 4};; 256 double y[] = {0, 2, 4, 1, 3};; 257 double ex[] =",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:9768,Availability,error,error,9768,"tical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; 250along X and the bottom and up errors are the same along Y.; 251 ; 252Begin_Macro(source); 253{; 254 auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; 255 double x[] = {0, 1, 2, 3, 4};; 256 double y[] = {0, 2, 4, 1, 3};; 257 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 258 double ey[] = {1, 0.5, 1, 0.5, 1};; 259 auto ge = new TGraphErrors(5, x, y, ex, ey);; 260 ge->SetTitle(""A graph with errors"");; 261 ge->Draw(""ap"");; 262}; 263End_Macro; 264 ; 265The option ""0"" shows the error bars for data points outside range.; 266 ;",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:9808,Availability,error,error,9808,"ic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; 250along X and the bottom and up errors are the same along Y.; 251 ; 252Begin_Macro(source); 253{; 254 auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; 255 double x[] = {0, 1, 2, 3, 4};; 256 double y[] = {0, 2, 4, 1, 3};; 257 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 258 double ey[] = {1, 0.5, 1, 0.5, 1};; 259 auto ge = new TGraphErrors(5, x, y, ex, ey);; 260 ge->SetTitle(""A graph with errors"");; 261 ge->Draw(""ap"");; 262}; 263End_Macro; 264 ; 265The option ""0"" shows the error bars for data points outside range.; 266 ; 267Begin_Macro(source); 268{; 269 auto c48 = new TCanvas(""c4",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:9916,Availability,error,error,9916,"tional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; 250along X and the bottom and up errors are the same along Y.; 251 ; 252Begin_Macro(source); 253{; 254 auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; 255 double x[] = {0, 1, 2, 3, 4};; 256 double y[] = {0, 2, 4, 1, 3};; 257 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 258 double ey[] = {1, 0.5, 1, 0.5, 1};; 259 auto ge = new TGraphErrors(5, x, y, ex, ey);; 260 ge->SetTitle(""A graph with errors"");; 261 ge->Draw(""ap"");; 262}; 263End_Macro; 264 ; 265The option ""0"" shows the error bars for data points outside range.; 266 ; 267Begin_Macro(source); 268{; 269 auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; 270 float x[] = {1,2,3};; 271 float err_x[] = {0,0,0};; 27",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:10105,Availability,error,error,10105,"n a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; 250along X and the bottom and up errors are the same along Y.; 251 ; 252Begin_Macro(source); 253{; 254 auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; 255 double x[] = {0, 1, 2, 3, 4};; 256 double y[] = {0, 2, 4, 1, 3};; 257 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 258 double ey[] = {1, 0.5, 1, 0.5, 1};; 259 auto ge = new TGraphErrors(5, x, y, ex, ey);; 260 ge->SetTitle(""A graph with errors"");; 261 ge->Draw(""ap"");; 262}; 263End_Macro; 264 ; 265The option ""0"" shows the error bars for data points outside range.; 266 ; 267Begin_Macro(source); 268{; 269 auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; 270 float x[] = {1,2,3};; 271 float err_x[] = {0,0,0};; 272 float err_y[] = {5,5,5};; 273 float y[] = {1,4,9};; 274 auto tg = new TGraphErrors(3,x,y,err_x,err_y);; 275 c48->Divide(2,1);; 276 c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Dr",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:10121,Availability,error,errors,10121,"r the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; 250along X and the bottom and up errors are the same along Y.; 251 ; 252Begin_Macro(source); 253{; 254 auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; 255 double x[] = {0, 1, 2, 3, 4};; 256 double y[] = {0, 2, 4, 1, 3};; 257 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 258 double ey[] = {1, 0.5, 1, 0.5, 1};; 259 auto ge = new TGraphErrors(5, x, y, ex, ey);; 260 ge->SetTitle(""A graph with errors"");; 261 ge->Draw(""ap"");; 262}; 263End_Macro; 264 ; 265The option ""0"" shows the error bars for data points outside range.; 266 ; 267Begin_Macro(source); 268{; 269 auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; 270 float x[] = {1,2,3};; 271 float err_x[] = {0,0,0};; 272 float err_y[] = {5,5,5};; 273 float y[] = {1,4,9};; 274 auto tg = new TGraphErrors(3,x,y,err_x,err_y);; 275 c48->Divide(2,1);; 276 c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; 277 c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; 278}; 279End_Macro; 280 ; 281The option ""3"" shows the errors a",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:10196,Availability,error,errors,10196,"r the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; 250along X and the bottom and up errors are the same along Y.; 251 ; 252Begin_Macro(source); 253{; 254 auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; 255 double x[] = {0, 1, 2, 3, 4};; 256 double y[] = {0, 2, 4, 1, 3};; 257 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 258 double ey[] = {1, 0.5, 1, 0.5, 1};; 259 auto ge = new TGraphErrors(5, x, y, ex, ey);; 260 ge->SetTitle(""A graph with errors"");; 261 ge->Draw(""ap"");; 262}; 263End_Macro; 264 ; 265The option ""0"" shows the error bars for data points outside range.; 266 ; 267Begin_Macro(source); 268{; 269 auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; 270 float x[] = {1,2,3};; 271 float err_x[] = {0,0,0};; 272 float err_y[] = {5,5,5};; 273 float y[] = {1,4,9};; 274 auto tg = new TGraphErrors(3,x,y,err_x,err_y);; 275 c48->Divide(2,1);; 276 c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; 277 c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; 278}; 279End_Macro; 280 ; 281The option ""3"" shows the errors a",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:10250,Availability,error,errors,10250,"r the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; 250along X and the bottom and up errors are the same along Y.; 251 ; 252Begin_Macro(source); 253{; 254 auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; 255 double x[] = {0, 1, 2, 3, 4};; 256 double y[] = {0, 2, 4, 1, 3};; 257 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 258 double ey[] = {1, 0.5, 1, 0.5, 1};; 259 auto ge = new TGraphErrors(5, x, y, ex, ey);; 260 ge->SetTitle(""A graph with errors"");; 261 ge->Draw(""ap"");; 262}; 263End_Macro; 264 ; 265The option ""0"" shows the error bars for data points outside range.; 266 ; 267Begin_Macro(source); 268{; 269 auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; 270 float x[] = {1,2,3};; 271 float err_x[] = {0,0,0};; 272 float err_y[] = {5,5,5};; 273 float y[] = {1,4,9};; 274 auto tg = new TGraphErrors(3,x,y,err_x,err_y);; 275 c48->Divide(2,1);; 276 c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; 277 c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; 278}; 279End_Macro; 280 ; 281The option ""3"" shows the errors a",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:10607,Availability,error,errors,10607,"an be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; 250along X and the bottom and up errors are the same along Y.; 251 ; 252Begin_Macro(source); 253{; 254 auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; 255 double x[] = {0, 1, 2, 3, 4};; 256 double y[] = {0, 2, 4, 1, 3};; 257 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 258 double ey[] = {1, 0.5, 1, 0.5, 1};; 259 auto ge = new TGraphErrors(5, x, y, ex, ey);; 260 ge->SetTitle(""A graph with errors"");; 261 ge->Draw(""ap"");; 262}; 263End_Macro; 264 ; 265The option ""0"" shows the error bars for data points outside range.; 266 ; 267Begin_Macro(source); 268{; 269 auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; 270 float x[] = {1,2,3};; 271 float err_x[] = {0,0,0};; 272 float err_y[] = {5,5,5};; 273 float y[] = {1,4,9};; 274 auto tg = new TGraphErrors(3,x,y,err_x,err_y);; 275 c48->Divide(2,1);; 276 c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; 277 c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; 278}; 279End_Macro; 280 ; 281The option ""3"" shows the errors as a band.; 282 ; 283Begin_Macro(source); 284{; 285 auto c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; 286 double x[] = {0, 1, 2, 3, 4};; 287 double y[] = {0, 2, 4, 1, 3};; 288 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 289 double ey[] = {1, 0.5, 1, 0.5, 1};; 290 auto ge = new TGraphErrors(5, x, y, ex, ey);; 291 ge->SetTitle(""Errors as a band"");; 292 ge->SetFillColor(4);; 293 ge->SetFillStyle(3010);; 294 ge->Draw(""a3"");; 295}",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:10693,Availability,error,error,10693,"an be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; 250along X and the bottom and up errors are the same along Y.; 251 ; 252Begin_Macro(source); 253{; 254 auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; 255 double x[] = {0, 1, 2, 3, 4};; 256 double y[] = {0, 2, 4, 1, 3};; 257 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 258 double ey[] = {1, 0.5, 1, 0.5, 1};; 259 auto ge = new TGraphErrors(5, x, y, ex, ey);; 260 ge->SetTitle(""A graph with errors"");; 261 ge->Draw(""ap"");; 262}; 263End_Macro; 264 ; 265The option ""0"" shows the error bars for data points outside range.; 266 ; 267Begin_Macro(source); 268{; 269 auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; 270 float x[] = {1,2,3};; 271 float err_x[] = {0,0,0};; 272 float err_y[] = {5,5,5};; 273 float y[] = {1,4,9};; 274 auto tg = new TGraphErrors(3,x,y,err_x,err_y);; 275 c48->Divide(2,1);; 276 c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; 277 c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; 278}; 279End_Macro; 280 ; 281The option ""3"" shows the errors as a band.; 282 ; 283Begin_Macro(source); 284{; 285 auto c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; 286 double x[] = {0, 1, 2, 3, 4};; 287 double y[] = {0, 2, 4, 1, 3};; 288 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 289 double ey[] = {1, 0.5, 1, 0.5, 1};; 290 auto ge = new TGraphErrors(5, x, y, ex, ey);; 291 ge->SetTitle(""Errors as a band"");; 292 ge->SetFillColor(4);; 293 ge->SetFillStyle(3010);; 294 ge->Draw(""a3"");; 295}",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:11189,Availability,error,errors,11189,"=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; 250along X and the bottom and up errors are the same along Y.; 251 ; 252Begin_Macro(source); 253{; 254 auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; 255 double x[] = {0, 1, 2, 3, 4};; 256 double y[] = {0, 2, 4, 1, 3};; 257 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 258 double ey[] = {1, 0.5, 1, 0.5, 1};; 259 auto ge = new TGraphErrors(5, x, y, ex, ey);; 260 ge->SetTitle(""A graph with errors"");; 261 ge->Draw(""ap"");; 262}; 263End_Macro; 264 ; 265The option ""0"" shows the error bars for data points outside range.; 266 ; 267Begin_Macro(source); 268{; 269 auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; 270 float x[] = {1,2,3};; 271 float err_x[] = {0,0,0};; 272 float err_y[] = {5,5,5};; 273 float y[] = {1,4,9};; 274 auto tg = new TGraphErrors(3,x,y,err_x,err_y);; 275 c48->Divide(2,1);; 276 c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; 277 c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; 278}; 279End_Macro; 280 ; 281The option ""3"" shows the errors as a band.; 282 ; 283Begin_Macro(source); 284{; 285 auto c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; 286 double x[] = {0, 1, 2, 3, 4};; 287 double y[] = {0, 2, 4, 1, 3};; 288 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 289 double ey[] = {1, 0.5, 1, 0.5, 1};; 290 auto ge = new TGraphErrors(5, x, y, ex, ey);; 291 ge->SetTitle(""Errors as a band"");; 292 ge->SetFillColor(4);; 293 ge->SetFillStyle(3010);; 294 ge->Draw(""a3"");; 295}; 296End_Macro; 297 ; 298The option ""4"" is similar to the option ""3"" except that the band; 299is smoothed. As the following picture shows, this option should be; 300used carefully because the smoothing algorithm may show some (huge); 301""bouncing"" effects. In some cases it looks nicer than option ""3""; 302(because it is smooth) but it can be m",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:12522,Availability,error,errors,12522,"2, 0.3, 0.4, 0.5};; 289 double ey[] = {1, 0.5, 1, 0.5, 1};; 290 auto ge = new TGraphErrors(5, x, y, ex, ey);; 291 ge->SetTitle(""Errors as a band"");; 292 ge->SetFillColor(4);; 293 ge->SetFillStyle(3010);; 294 ge->Draw(""a3"");; 295}; 296End_Macro; 297 ; 298The option ""4"" is similar to the option ""3"" except that the band; 299is smoothed. As the following picture shows, this option should be; 300used carefully because the smoothing algorithm may show some (huge); 301""bouncing"" effects. In some cases it looks nicer than option ""3""; 302(because it is smooth) but it can be misleading.; 303 ; 304Begin_Macro(source); 305{; 306 auto c42 = new TCanvas(""c42"",""c42"",200,10,600,400);; 307 double x[] = {0, 1, 2, 3, 4};; 308 double y[] = {0, 2, 4, 1, 3};; 309 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 310 double ey[] = {1, 0.5, 1, 0.5, 1};; 311 auto ge = new TGraphErrors(5, x, y, ex, ey);; 312 ge->SetTitle(""Errors as a smooth band"");; 313 ge->SetFillColor(6);; 314 ge->SetFillStyle(3005);; 315 ge->Draw(""a4"");; 316}; 317End_Macro; 318 ; 319The following example shows how the option ""[]"" can be used to superimpose; 320systematic errors on top of a graph with statistical errors.; 321 ; 322Begin_Macro(source); 323{; 324 auto c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; 325 c43->DrawFrame(0., -0.5, 6., 2);; 326 ; 327 double x[5] = {1, 2, 3, 4, 5};; 328 double zero[5] = {0, 0, 0, 0, 0};; 329 ; 330 // data set (1) with stat and sys errors; 331 double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; 332 double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 333 double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};; 334 ; 335 // data set (2) with stat and sys errors; 336 double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; 337 double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 338 double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};; 339 ; 340 // Now draw data set (1); 341 ; 342 // We first have to draw it only with the stat errors; 343 auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; 344 graph1->SetMarkerSt",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:12564,Availability,error,errors,12564,"2, 0.3, 0.4, 0.5};; 289 double ey[] = {1, 0.5, 1, 0.5, 1};; 290 auto ge = new TGraphErrors(5, x, y, ex, ey);; 291 ge->SetTitle(""Errors as a band"");; 292 ge->SetFillColor(4);; 293 ge->SetFillStyle(3010);; 294 ge->Draw(""a3"");; 295}; 296End_Macro; 297 ; 298The option ""4"" is similar to the option ""3"" except that the band; 299is smoothed. As the following picture shows, this option should be; 300used carefully because the smoothing algorithm may show some (huge); 301""bouncing"" effects. In some cases it looks nicer than option ""3""; 302(because it is smooth) but it can be misleading.; 303 ; 304Begin_Macro(source); 305{; 306 auto c42 = new TCanvas(""c42"",""c42"",200,10,600,400);; 307 double x[] = {0, 1, 2, 3, 4};; 308 double y[] = {0, 2, 4, 1, 3};; 309 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 310 double ey[] = {1, 0.5, 1, 0.5, 1};; 311 auto ge = new TGraphErrors(5, x, y, ex, ey);; 312 ge->SetTitle(""Errors as a smooth band"");; 313 ge->SetFillColor(6);; 314 ge->SetFillStyle(3005);; 315 ge->Draw(""a4"");; 316}; 317End_Macro; 318 ; 319The following example shows how the option ""[]"" can be used to superimpose; 320systematic errors on top of a graph with statistical errors.; 321 ; 322Begin_Macro(source); 323{; 324 auto c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; 325 c43->DrawFrame(0., -0.5, 6., 2);; 326 ; 327 double x[5] = {1, 2, 3, 4, 5};; 328 double zero[5] = {0, 0, 0, 0, 0};; 329 ; 330 // data set (1) with stat and sys errors; 331 double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; 332 double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 333 double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};; 334 ; 335 // data set (2) with stat and sys errors; 336 double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; 337 double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 338 double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};; 339 ; 340 // Now draw data set (1); 341 ; 342 // We first have to draw it only with the stat errors; 343 auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; 344 graph1->SetMarkerSt",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:12829,Availability,error,errors,12829,"hould be; 300used carefully because the smoothing algorithm may show some (huge); 301""bouncing"" effects. In some cases it looks nicer than option ""3""; 302(because it is smooth) but it can be misleading.; 303 ; 304Begin_Macro(source); 305{; 306 auto c42 = new TCanvas(""c42"",""c42"",200,10,600,400);; 307 double x[] = {0, 1, 2, 3, 4};; 308 double y[] = {0, 2, 4, 1, 3};; 309 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 310 double ey[] = {1, 0.5, 1, 0.5, 1};; 311 auto ge = new TGraphErrors(5, x, y, ex, ey);; 312 ge->SetTitle(""Errors as a smooth band"");; 313 ge->SetFillColor(6);; 314 ge->SetFillStyle(3005);; 315 ge->Draw(""a4"");; 316}; 317End_Macro; 318 ; 319The following example shows how the option ""[]"" can be used to superimpose; 320systematic errors on top of a graph with statistical errors.; 321 ; 322Begin_Macro(source); 323{; 324 auto c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; 325 c43->DrawFrame(0., -0.5, 6., 2);; 326 ; 327 double x[5] = {1, 2, 3, 4, 5};; 328 double zero[5] = {0, 0, 0, 0, 0};; 329 ; 330 // data set (1) with stat and sys errors; 331 double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; 332 double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 333 double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};; 334 ; 335 // data set (2) with stat and sys errors; 336 double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; 337 double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 338 double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};; 339 ; 340 // Now draw data set (1); 341 ; 342 // We first have to draw it only with the stat errors; 343 auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; 344 graph1->SetMarkerStyle(20);; 345 graph1->Draw(""P"");; 346 ; 347 // Now we have to somehow depict the sys errors; 348 ; 349 auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; 350 graph1_sys->Draw(""[]"");; 351 ; 352 // Now draw data set (2); 353 ; 354 // We first have to draw it only with the stat errors; 355 auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; 356 graph2->SetMarkerSt",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:13041,Availability,error,errors,13041,"= new TCanvas(""c42"",""c42"",200,10,600,400);; 307 double x[] = {0, 1, 2, 3, 4};; 308 double y[] = {0, 2, 4, 1, 3};; 309 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 310 double ey[] = {1, 0.5, 1, 0.5, 1};; 311 auto ge = new TGraphErrors(5, x, y, ex, ey);; 312 ge->SetTitle(""Errors as a smooth band"");; 313 ge->SetFillColor(6);; 314 ge->SetFillStyle(3005);; 315 ge->Draw(""a4"");; 316}; 317End_Macro; 318 ; 319The following example shows how the option ""[]"" can be used to superimpose; 320systematic errors on top of a graph with statistical errors.; 321 ; 322Begin_Macro(source); 323{; 324 auto c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; 325 c43->DrawFrame(0., -0.5, 6., 2);; 326 ; 327 double x[5] = {1, 2, 3, 4, 5};; 328 double zero[5] = {0, 0, 0, 0, 0};; 329 ; 330 // data set (1) with stat and sys errors; 331 double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; 332 double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 333 double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};; 334 ; 335 // data set (2) with stat and sys errors; 336 double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; 337 double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 338 double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};; 339 ; 340 // Now draw data set (1); 341 ; 342 // We first have to draw it only with the stat errors; 343 auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; 344 graph1->SetMarkerStyle(20);; 345 graph1->Draw(""P"");; 346 ; 347 // Now we have to somehow depict the sys errors; 348 ; 349 auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; 350 graph1_sys->Draw(""[]"");; 351 ; 352 // Now draw data set (2); 353 ; 354 // We first have to draw it only with the stat errors; 355 auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; 356 graph2->SetMarkerStyle(24);; 357 graph2->Draw(""P"");; 358 ; 359 // Now we have to somehow depict the sys errors; 360 ; 361 auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; 362 graph2_sys->Draw(""[]"");; 363}; 364End_Macro; 365 ; 366\anchor GrP3b; 367#### TGraph",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:13302,Availability,error,errors,13302,", 2, 3, 4, 5};; 328 double zero[5] = {0, 0, 0, 0, 0};; 329 ; 330 // data set (1) with stat and sys errors; 331 double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; 332 double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 333 double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};; 334 ; 335 // data set (2) with stat and sys errors; 336 double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; 337 double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 338 double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};; 339 ; 340 // Now draw data set (1); 341 ; 342 // We first have to draw it only with the stat errors; 343 auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; 344 graph1->SetMarkerStyle(20);; 345 graph1->Draw(""P"");; 346 ; 347 // Now we have to somehow depict the sys errors; 348 ; 349 auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; 350 graph1_sys->Draw(""[]"");; 351 ; 352 // Now draw data set (2); 353 ; 354 // We first have to draw it only with the stat errors; 355 auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; 356 graph2->SetMarkerStyle(24);; 357 graph2->Draw(""P"");; 358 ; 359 // Now we have to somehow depict the sys errors; 360 ; 361 auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; 362 graph2_sys->Draw(""[]"");; 363}; 364End_Macro; 365 ; 366\anchor GrP3b; 367#### TGraphAsymmErrors; 368A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; 369defined along X and Y are not symmetric: The left and right errors are; 370different along X and the bottom and up errors are different along Y.; 371 ; 372Begin_Macro(source); 373{; 374 auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; 375 double ax[] = {0, 1, 2, 3, 4};; 376 double ay[] = {0, 2, 4, 1, 3};; 377 double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 378 double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; 379 double aeyl[] = {1, 0.5, 1, 0.5, 1};; 380 double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; 381 auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; 382 gae->SetTitle(""Not symmetric errors"");; 383 gae",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:13482,Availability,error,errors,13482,", 2, 3, 4, 5};; 328 double zero[5] = {0, 0, 0, 0, 0};; 329 ; 330 // data set (1) with stat and sys errors; 331 double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; 332 double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 333 double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};; 334 ; 335 // data set (2) with stat and sys errors; 336 double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; 337 double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 338 double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};; 339 ; 340 // Now draw data set (1); 341 ; 342 // We first have to draw it only with the stat errors; 343 auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; 344 graph1->SetMarkerStyle(20);; 345 graph1->Draw(""P"");; 346 ; 347 // Now we have to somehow depict the sys errors; 348 ; 349 auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; 350 graph1_sys->Draw(""[]"");; 351 ; 352 // Now draw data set (2); 353 ; 354 // We first have to draw it only with the stat errors; 355 auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; 356 graph2->SetMarkerStyle(24);; 357 graph2->Draw(""P"");; 358 ; 359 // Now we have to somehow depict the sys errors; 360 ; 361 auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; 362 graph2_sys->Draw(""[]"");; 363}; 364End_Macro; 365 ; 366\anchor GrP3b; 367#### TGraphAsymmErrors; 368A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; 369defined along X and Y are not symmetric: The left and right errors are; 370different along X and the bottom and up errors are different along Y.; 371 ; 372Begin_Macro(source); 373{; 374 auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; 375 double ax[] = {0, 1, 2, 3, 4};; 376 double ay[] = {0, 2, 4, 1, 3};; 377 double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 378 double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; 379 double aeyl[] = {1, 0.5, 1, 0.5, 1};; 380 double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; 381 auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; 382 gae->SetTitle(""Not symmetric errors"");; 383 gae",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:13685,Availability,error,errors,13685,", 2, 3, 4, 5};; 328 double zero[5] = {0, 0, 0, 0, 0};; 329 ; 330 // data set (1) with stat and sys errors; 331 double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; 332 double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 333 double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};; 334 ; 335 // data set (2) with stat and sys errors; 336 double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; 337 double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 338 double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};; 339 ; 340 // Now draw data set (1); 341 ; 342 // We first have to draw it only with the stat errors; 343 auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; 344 graph1->SetMarkerStyle(20);; 345 graph1->Draw(""P"");; 346 ; 347 // Now we have to somehow depict the sys errors; 348 ; 349 auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; 350 graph1_sys->Draw(""[]"");; 351 ; 352 // Now draw data set (2); 353 ; 354 // We first have to draw it only with the stat errors; 355 auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; 356 graph2->SetMarkerStyle(24);; 357 graph2->Draw(""P"");; 358 ; 359 // Now we have to somehow depict the sys errors; 360 ; 361 auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; 362 graph2_sys->Draw(""[]"");; 363}; 364End_Macro; 365 ; 366\anchor GrP3b; 367#### TGraphAsymmErrors; 368A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; 369defined along X and Y are not symmetric: The left and right errors are; 370different along X and the bottom and up errors are different along Y.; 371 ; 372Begin_Macro(source); 373{; 374 auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; 375 double ax[] = {0, 1, 2, 3, 4};; 376 double ay[] = {0, 2, 4, 1, 3};; 377 double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 378 double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; 379 double aeyl[] = {1, 0.5, 1, 0.5, 1};; 380 double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; 381 auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; 382 gae->SetTitle(""Not symmetric errors"");; 383 gae",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:13864,Availability,error,errors,13864,", 2, 3, 4, 5};; 328 double zero[5] = {0, 0, 0, 0, 0};; 329 ; 330 // data set (1) with stat and sys errors; 331 double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; 332 double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 333 double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};; 334 ; 335 // data set (2) with stat and sys errors; 336 double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; 337 double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 338 double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};; 339 ; 340 // Now draw data set (1); 341 ; 342 // We first have to draw it only with the stat errors; 343 auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; 344 graph1->SetMarkerStyle(20);; 345 graph1->Draw(""P"");; 346 ; 347 // Now we have to somehow depict the sys errors; 348 ; 349 auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; 350 graph1_sys->Draw(""[]"");; 351 ; 352 // Now draw data set (2); 353 ; 354 // We first have to draw it only with the stat errors; 355 auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; 356 graph2->SetMarkerStyle(24);; 357 graph2->Draw(""P"");; 358 ; 359 // Now we have to somehow depict the sys errors; 360 ; 361 auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; 362 graph2_sys->Draw(""[]"");; 363}; 364End_Macro; 365 ; 366\anchor GrP3b; 367#### TGraphAsymmErrors; 368A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; 369defined along X and Y are not symmetric: The left and right errors are; 370different along X and the bottom and up errors are different along Y.; 371 ; 372Begin_Macro(source); 373{; 374 auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; 375 double ax[] = {0, 1, 2, 3, 4};; 376 double ay[] = {0, 2, 4, 1, 3};; 377 double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 378 double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; 379 double aeyl[] = {1, 0.5, 1, 0.5, 1};; 380 double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; 381 auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; 382 gae->SetTitle(""Not symmetric errors"");; 383 gae",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:14102,Availability,error,errors,14102,", 2, 3, 4, 5};; 328 double zero[5] = {0, 0, 0, 0, 0};; 329 ; 330 // data set (1) with stat and sys errors; 331 double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; 332 double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 333 double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};; 334 ; 335 // data set (2) with stat and sys errors; 336 double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; 337 double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 338 double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};; 339 ; 340 // Now draw data set (1); 341 ; 342 // We first have to draw it only with the stat errors; 343 auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; 344 graph1->SetMarkerStyle(20);; 345 graph1->Draw(""P"");; 346 ; 347 // Now we have to somehow depict the sys errors; 348 ; 349 auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; 350 graph1_sys->Draw(""[]"");; 351 ; 352 // Now draw data set (2); 353 ; 354 // We first have to draw it only with the stat errors; 355 auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; 356 graph2->SetMarkerStyle(24);; 357 graph2->Draw(""P"");; 358 ; 359 // Now we have to somehow depict the sys errors; 360 ; 361 auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; 362 graph2_sys->Draw(""[]"");; 363}; 364End_Macro; 365 ; 366\anchor GrP3b; 367#### TGraphAsymmErrors; 368A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; 369defined along X and Y are not symmetric: The left and right errors are; 370different along X and the bottom and up errors are different along Y.; 371 ; 372Begin_Macro(source); 373{; 374 auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; 375 double ax[] = {0, 1, 2, 3, 4};; 376 double ay[] = {0, 2, 4, 1, 3};; 377 double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 378 double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; 379 double aeyl[] = {1, 0.5, 1, 0.5, 1};; 380 double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; 381 auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; 382 gae->SetTitle(""Not symmetric errors"");; 383 gae",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:14173,Availability,error,errors,14173,", 2, 3, 4, 5};; 328 double zero[5] = {0, 0, 0, 0, 0};; 329 ; 330 // data set (1) with stat and sys errors; 331 double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; 332 double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 333 double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};; 334 ; 335 // data set (2) with stat and sys errors; 336 double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; 337 double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 338 double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};; 339 ; 340 // Now draw data set (1); 341 ; 342 // We first have to draw it only with the stat errors; 343 auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; 344 graph1->SetMarkerStyle(20);; 345 graph1->Draw(""P"");; 346 ; 347 // Now we have to somehow depict the sys errors; 348 ; 349 auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; 350 graph1_sys->Draw(""[]"");; 351 ; 352 // Now draw data set (2); 353 ; 354 // We first have to draw it only with the stat errors; 355 auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; 356 graph2->SetMarkerStyle(24);; 357 graph2->Draw(""P"");; 358 ; 359 // Now we have to somehow depict the sys errors; 360 ; 361 auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; 362 graph2_sys->Draw(""[]"");; 363}; 364End_Macro; 365 ; 366\anchor GrP3b; 367#### TGraphAsymmErrors; 368A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; 369defined along X and Y are not symmetric: The left and right errors are; 370different along X and the bottom and up errors are different along Y.; 371 ; 372Begin_Macro(source); 373{; 374 auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; 375 double ax[] = {0, 1, 2, 3, 4};; 376 double ay[] = {0, 2, 4, 1, 3};; 377 double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 378 double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; 379 double aeyl[] = {1, 0.5, 1, 0.5, 1};; 380 double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; 381 auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; 382 gae->SetTitle(""Not symmetric errors"");; 383 gae",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:14228,Availability,error,errors,14228,", 2, 3, 4, 5};; 328 double zero[5] = {0, 0, 0, 0, 0};; 329 ; 330 // data set (1) with stat and sys errors; 331 double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; 332 double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 333 double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};; 334 ; 335 // data set (2) with stat and sys errors; 336 double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; 337 double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 338 double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};; 339 ; 340 // Now draw data set (1); 341 ; 342 // We first have to draw it only with the stat errors; 343 auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; 344 graph1->SetMarkerStyle(20);; 345 graph1->Draw(""P"");; 346 ; 347 // Now we have to somehow depict the sys errors; 348 ; 349 auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; 350 graph1_sys->Draw(""[]"");; 351 ; 352 // Now draw data set (2); 353 ; 354 // We first have to draw it only with the stat errors; 355 auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; 356 graph2->SetMarkerStyle(24);; 357 graph2->Draw(""P"");; 358 ; 359 // Now we have to somehow depict the sys errors; 360 ; 361 auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; 362 graph2_sys->Draw(""[]"");; 363}; 364End_Macro; 365 ; 366\anchor GrP3b; 367#### TGraphAsymmErrors; 368A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; 369defined along X and Y are not symmetric: The left and right errors are; 370different along X and the bottom and up errors are different along Y.; 371 ; 372Begin_Macro(source); 373{; 374 auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; 375 double ax[] = {0, 1, 2, 3, 4};; 376 double ay[] = {0, 2, 4, 1, 3};; 377 double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 378 double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; 379 double aeyl[] = {1, 0.5, 1, 0.5, 1};; 380 double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; 381 auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; 382 gae->SetTitle(""Not symmetric errors"");; 383 gae",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:14713,Availability,error,errors,14713,"Style(24);; 357 graph2->Draw(""P"");; 358 ; 359 // Now we have to somehow depict the sys errors; 360 ; 361 auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; 362 graph2_sys->Draw(""[]"");; 363}; 364End_Macro; 365 ; 366\anchor GrP3b; 367#### TGraphAsymmErrors; 368A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; 369defined along X and Y are not symmetric: The left and right errors are; 370different along X and the bottom and up errors are different along Y.; 371 ; 372Begin_Macro(source); 373{; 374 auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; 375 double ax[] = {0, 1, 2, 3, 4};; 376 double ay[] = {0, 2, 4, 1, 3};; 377 double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 378 double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; 379 double aeyl[] = {1, 0.5, 1, 0.5, 1};; 380 double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; 381 auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; 382 gae->SetTitle(""Not symmetric errors"");; 383 gae->SetFillColor(2);; 384 gae->SetFillStyle(3001);; 385 gae->Draw(""a2"");; 386 gae->Draw(""p"");; 387}; 388End_Macro; 389 ; 390 ; 391\anchor GrP3c; 392#### TGraphBentErrors; 393A `TGraphBentErrors` is like a `TGraphAsymmErrors`.; 394An extra parameter allows to bend the error bars to better see them; 395when several graphs are drawn on the same plot.; 396 ; 397Begin_Macro(source); 398{; 399 auto c45 = new TCanvas(""c45"",""c45"",200,10,600,400);; 400 const Int_t n = 10;; 401 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 402 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 403 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 404 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 405 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 406 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 407 Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 408 Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; 409 Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 410 Double_t eyhd[n] = {.0,.0",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:14997,Availability,error,error,14997," 367#### TGraphAsymmErrors; 368A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; 369defined along X and Y are not symmetric: The left and right errors are; 370different along X and the bottom and up errors are different along Y.; 371 ; 372Begin_Macro(source); 373{; 374 auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; 375 double ax[] = {0, 1, 2, 3, 4};; 376 double ay[] = {0, 2, 4, 1, 3};; 377 double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 378 double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; 379 double aeyl[] = {1, 0.5, 1, 0.5, 1};; 380 double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; 381 auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; 382 gae->SetTitle(""Not symmetric errors"");; 383 gae->SetFillColor(2);; 384 gae->SetFillStyle(3001);; 385 gae->Draw(""a2"");; 386 gae->Draw(""p"");; 387}; 388End_Macro; 389 ; 390 ; 391\anchor GrP3c; 392#### TGraphBentErrors; 393A `TGraphBentErrors` is like a `TGraphAsymmErrors`.; 394An extra parameter allows to bend the error bars to better see them; 395when several graphs are drawn on the same plot.; 396 ; 397Begin_Macro(source); 398{; 399 auto c45 = new TCanvas(""c45"",""c45"",200,10,600,400);; 400 const Int_t n = 10;; 401 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 402 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 403 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 404 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 405 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 406 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 407 Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 408 Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; 409 Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 410 Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; 411 auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; 412 gr->SetTitle(""A graph with bend errors"");; 413 gr->SetMarkerColor(4);; 414 gr->SetMarkerStyle(21);; 415 gr->Draw(""ALP"");; 416",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:15923,Availability,error,errors,15923,"o bend the error bars to better see them; 395when several graphs are drawn on the same plot.; 396 ; 397Begin_Macro(source); 398{; 399 auto c45 = new TCanvas(""c45"",""c45"",200,10,600,400);; 400 const Int_t n = 10;; 401 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 402 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 403 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 404 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 405 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 406 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 407 Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 408 Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; 409 Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 410 Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; 411 auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; 412 gr->SetTitle(""A graph with bend errors"");; 413 gr->SetMarkerColor(4);; 414 gr->SetMarkerStyle(21);; 415 gr->Draw(""ALP"");; 416}; 417End_Macro; 418 ; 419 ; 420\anchor GrP3d; 421#### TGraphMultiErrors; 422A `TGraphMultiErrors` works basically the same way like a `TGraphAsymmErrors`.; 423It has the possibility to define more than one type / dimension of y-Errors.; 424This is useful if you want to plot statistic and systematic errors at once.; 425 ; 426To be able to define different drawing options for the multiple error dimensions; 427the option string can consist of multiple blocks separated by semicolons.; 428The painting method assigns these blocks to the error dimensions. The first block; 429is always used for the general draw options and options concerning the x-Errors.; 430In case there are less than NErrorDimensions + 1 blocks in the option string; 431the first block is also used for the first error dimension which is reserved for; 432statistical errors. The remaining blocks are assigned to the remaining dimensions.; 433 ; 434In addition to the draw options of options of `TGra",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:16317,Availability,error,errors,16317,"] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 403 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 404 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 405 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 406 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 407 Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 408 Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; 409 Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 410 Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; 411 auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; 412 gr->SetTitle(""A graph with bend errors"");; 413 gr->SetMarkerColor(4);; 414 gr->SetMarkerStyle(21);; 415 gr->Draw(""ALP"");; 416}; 417End_Macro; 418 ; 419 ; 420\anchor GrP3d; 421#### TGraphMultiErrors; 422A `TGraphMultiErrors` works basically the same way like a `TGraphAsymmErrors`.; 423It has the possibility to define more than one type / dimension of y-Errors.; 424This is useful if you want to plot statistic and systematic errors at once.; 425 ; 426To be able to define different drawing options for the multiple error dimensions; 427the option string can consist of multiple blocks separated by semicolons.; 428The painting method assigns these blocks to the error dimensions. The first block; 429is always used for the general draw options and options concerning the x-Errors.; 430In case there are less than NErrorDimensions + 1 blocks in the option string; 431the first block is also used for the first error dimension which is reserved for; 432statistical errors. The remaining blocks are assigned to the remaining dimensions.; 433 ; 434In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:; 435 ; 436| Option | Block | Description |; 437|----------|----------------|-------------------------------------------------------------------|; 438| ""X0"" | First one only | Do not draw errors for points with x = 0 |; 439| ""Y0"" | First one only | Do not draw er",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:16407,Availability,error,error,16407,"n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 405 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 406 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 407 Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 408 Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; 409 Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 410 Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; 411 auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; 412 gr->SetTitle(""A graph with bend errors"");; 413 gr->SetMarkerColor(4);; 414 gr->SetMarkerStyle(21);; 415 gr->Draw(""ALP"");; 416}; 417End_Macro; 418 ; 419 ; 420\anchor GrP3d; 421#### TGraphMultiErrors; 422A `TGraphMultiErrors` works basically the same way like a `TGraphAsymmErrors`.; 423It has the possibility to define more than one type / dimension of y-Errors.; 424This is useful if you want to plot statistic and systematic errors at once.; 425 ; 426To be able to define different drawing options for the multiple error dimensions; 427the option string can consist of multiple blocks separated by semicolons.; 428The painting method assigns these blocks to the error dimensions. The first block; 429is always used for the general draw options and options concerning the x-Errors.; 430In case there are less than NErrorDimensions + 1 blocks in the option string; 431the first block is also used for the first error dimension which is reserved for; 432statistical errors. The remaining blocks are assigned to the remaining dimensions.; 433 ; 434In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:; 435 ; 436| Option | Block | Description |; 437|----------|----------------|-------------------------------------------------------------------|; 438| ""X0"" | First one only | Do not draw errors for points with x = 0 |; 439| ""Y0"" | First one only | Do not draw errors for points with y = 0 |; 440| ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:16554,Availability,error,error,16554,"h[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 407 Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 408 Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; 409 Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 410 Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; 411 auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; 412 gr->SetTitle(""A graph with bend errors"");; 413 gr->SetMarkerColor(4);; 414 gr->SetMarkerStyle(21);; 415 gr->Draw(""ALP"");; 416}; 417End_Macro; 418 ; 419 ; 420\anchor GrP3d; 421#### TGraphMultiErrors; 422A `TGraphMultiErrors` works basically the same way like a `TGraphAsymmErrors`.; 423It has the possibility to define more than one type / dimension of y-Errors.; 424This is useful if you want to plot statistic and systematic errors at once.; 425 ; 426To be able to define different drawing options for the multiple error dimensions; 427the option string can consist of multiple blocks separated by semicolons.; 428The painting method assigns these blocks to the error dimensions. The first block; 429is always used for the general draw options and options concerning the x-Errors.; 430In case there are less than NErrorDimensions + 1 blocks in the option string; 431the first block is also used for the first error dimension which is reserved for; 432statistical errors. The remaining blocks are assigned to the remaining dimensions.; 433 ; 434In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:; 435 ; 436| Option | Block | Description |; 437|----------|----------------|-------------------------------------------------------------------|; 438| ""X0"" | First one only | Do not draw errors for points with x = 0 |; 439| ""Y0"" | First one only | Do not draw errors for points with y = 0 |; 440| ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:16801,Availability,error,error,16801,"n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; 411 auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; 412 gr->SetTitle(""A graph with bend errors"");; 413 gr->SetMarkerColor(4);; 414 gr->SetMarkerStyle(21);; 415 gr->Draw(""ALP"");; 416}; 417End_Macro; 418 ; 419 ; 420\anchor GrP3d; 421#### TGraphMultiErrors; 422A `TGraphMultiErrors` works basically the same way like a `TGraphAsymmErrors`.; 423It has the possibility to define more than one type / dimension of y-Errors.; 424This is useful if you want to plot statistic and systematic errors at once.; 425 ; 426To be able to define different drawing options for the multiple error dimensions; 427the option string can consist of multiple blocks separated by semicolons.; 428The painting method assigns these blocks to the error dimensions. The first block; 429is always used for the general draw options and options concerning the x-Errors.; 430In case there are less than NErrorDimensions + 1 blocks in the option string; 431the first block is also used for the first error dimension which is reserved for; 432statistical errors. The remaining blocks are assigned to the remaining dimensions.; 433 ; 434In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:; 435 ; 436| Option | Block | Description |; 437|----------|----------------|-------------------------------------------------------------------|; 438| ""X0"" | First one only | Do not draw errors for points with x = 0 |; 439| ""Y0"" | First one only | Do not draw errors for points with y = 0 |; 440| ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; 441| ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |; 442 ; 443 ; 444Per default the Fill and Line Styles of the Graph are being ",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:16855,Availability,error,errors,16855,"n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; 411 auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; 412 gr->SetTitle(""A graph with bend errors"");; 413 gr->SetMarkerColor(4);; 414 gr->SetMarkerStyle(21);; 415 gr->Draw(""ALP"");; 416}; 417End_Macro; 418 ; 419 ; 420\anchor GrP3d; 421#### TGraphMultiErrors; 422A `TGraphMultiErrors` works basically the same way like a `TGraphAsymmErrors`.; 423It has the possibility to define more than one type / dimension of y-Errors.; 424This is useful if you want to plot statistic and systematic errors at once.; 425 ; 426To be able to define different drawing options for the multiple error dimensions; 427the option string can consist of multiple blocks separated by semicolons.; 428The painting method assigns these blocks to the error dimensions. The first block; 429is always used for the general draw options and options concerning the x-Errors.; 430In case there are less than NErrorDimensions + 1 blocks in the option string; 431the first block is also used for the first error dimension which is reserved for; 432statistical errors. The remaining blocks are assigned to the remaining dimensions.; 433 ; 434In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:; 435 ; 436| Option | Block | Description |; 437|----------|----------------|-------------------------------------------------------------------|; 438| ""X0"" | First one only | Do not draw errors for points with x = 0 |; 439| ""Y0"" | First one only | Do not draw errors for points with y = 0 |; 440| ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; 441| ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |; 442 ; 443 ; 444Per default the Fill and Line Styles of the Graph are being ",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:17217,Availability,error,errors,17217,"imension of y-Errors.; 424This is useful if you want to plot statistic and systematic errors at once.; 425 ; 426To be able to define different drawing options for the multiple error dimensions; 427the option string can consist of multiple blocks separated by semicolons.; 428The painting method assigns these blocks to the error dimensions. The first block; 429is always used for the general draw options and options concerning the x-Errors.; 430In case there are less than NErrorDimensions + 1 blocks in the option string; 431the first block is also used for the first error dimension which is reserved for; 432statistical errors. The remaining blocks are assigned to the remaining dimensions.; 433 ; 434In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:; 435 ; 436| Option | Block | Description |; 437|----------|----------------|-------------------------------------------------------------------|; 438| ""X0"" | First one only | Do not draw errors for points with x = 0 |; 439| ""Y0"" | First one only | Do not draw errors for points with y = 0 |; 440| ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; 441| ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |; 442 ; 443 ; 444Per default the Fill and Line Styles of the Graph are being used for all error; 445dimensions. To use the specific ones add the draw option ""S"" to the first block.; 446 ; 447Begin_Macro(source); 448{; 449 auto c47 = new TCanvas(""c47"",""c47"",200,10,600,400);; 450 double ax[] = {0, 1, 2, 3, 4};; 451 double ay[] = {0, 2, 4, 1, 3};; 452 double aexl[] = {0.3, 0.3, 0.3, 0.3, 0.3};; 453 double aexh[] = {0.3, 0.3, 0.3, 0.3, 0.3};; 454 double* aeylstat = new double[5] {1, 0.5, 1, 0.5, 1};; 455 double* aeyhstat = new double[5] {0",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:17290,Availability,error,errors,17290,"imension of y-Errors.; 424This is useful if you want to plot statistic and systematic errors at once.; 425 ; 426To be able to define different drawing options for the multiple error dimensions; 427the option string can consist of multiple blocks separated by semicolons.; 428The painting method assigns these blocks to the error dimensions. The first block; 429is always used for the general draw options and options concerning the x-Errors.; 430In case there are less than NErrorDimensions + 1 blocks in the option string; 431the first block is also used for the first error dimension which is reserved for; 432statistical errors. The remaining blocks are assigned to the remaining dimensions.; 433 ; 434In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:; 435 ; 436| Option | Block | Description |; 437|----------|----------------|-------------------------------------------------------------------|; 438| ""X0"" | First one only | Do not draw errors for points with x = 0 |; 439| ""Y0"" | First one only | Do not draw errors for points with y = 0 |; 440| ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; 441| ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |; 442 ; 443 ; 444Per default the Fill and Line Styles of the Graph are being used for all error; 445dimensions. To use the specific ones add the draw option ""S"" to the first block.; 446 ; 447Begin_Macro(source); 448{; 449 auto c47 = new TCanvas(""c47"",""c47"",200,10,600,400);; 450 double ax[] = {0, 1, 2, 3, 4};; 451 double ay[] = {0, 2, 4, 1, 3};; 452 double aexl[] = {0.3, 0.3, 0.3, 0.3, 0.3};; 453 double aexh[] = {0.3, 0.3, 0.3, 0.3, 0.3};; 454 double* aeylstat = new double[5] {1, 0.5, 1, 0.5, 1};; 455 double* aeyhstat = new double[5] {0",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:17478,Availability,error,errors,17478,"imension of y-Errors.; 424This is useful if you want to plot statistic and systematic errors at once.; 425 ; 426To be able to define different drawing options for the multiple error dimensions; 427the option string can consist of multiple blocks separated by semicolons.; 428The painting method assigns these blocks to the error dimensions. The first block; 429is always used for the general draw options and options concerning the x-Errors.; 430In case there are less than NErrorDimensions + 1 blocks in the option string; 431the first block is also used for the first error dimension which is reserved for; 432statistical errors. The remaining blocks are assigned to the remaining dimensions.; 433 ; 434In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:; 435 ; 436| Option | Block | Description |; 437|----------|----------------|-------------------------------------------------------------------|; 438| ""X0"" | First one only | Do not draw errors for points with x = 0 |; 439| ""Y0"" | First one only | Do not draw errors for points with y = 0 |; 440| ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; 441| ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |; 442 ; 443 ; 444Per default the Fill and Line Styles of the Graph are being used for all error; 445dimensions. To use the specific ones add the draw option ""S"" to the first block.; 446 ; 447Begin_Macro(source); 448{; 449 auto c47 = new TCanvas(""c47"",""c47"",200,10,600,400);; 450 double ax[] = {0, 1, 2, 3, 4};; 451 double ay[] = {0, 2, 4, 1, 3};; 452 double aexl[] = {0.3, 0.3, 0.3, 0.3, 0.3};; 453 double aexh[] = {0.3, 0.3, 0.3, 0.3, 0.3};; 454 double* aeylstat = new double[5] {1, 0.5, 1, 0.5, 1};; 455 double* aeyhstat = new double[5] {0",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:17644,Availability,error,error,17644,"eneral draw options and options concerning the x-Errors.; 430In case there are less than NErrorDimensions + 1 blocks in the option string; 431the first block is also used for the first error dimension which is reserved for; 432statistical errors. The remaining blocks are assigned to the remaining dimensions.; 433 ; 434In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:; 435 ; 436| Option | Block | Description |; 437|----------|----------------|-------------------------------------------------------------------|; 438| ""X0"" | First one only | Do not draw errors for points with x = 0 |; 439| ""Y0"" | First one only | Do not draw errors for points with y = 0 |; 440| ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; 441| ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |; 442 ; 443 ; 444Per default the Fill and Line Styles of the Graph are being used for all error; 445dimensions. To use the specific ones add the draw option ""S"" to the first block.; 446 ; 447Begin_Macro(source); 448{; 449 auto c47 = new TCanvas(""c47"",""c47"",200,10,600,400);; 450 double ax[] = {0, 1, 2, 3, 4};; 451 double ay[] = {0, 2, 4, 1, 3};; 452 double aexl[] = {0.3, 0.3, 0.3, 0.3, 0.3};; 453 double aexh[] = {0.3, 0.3, 0.3, 0.3, 0.3};; 454 double* aeylstat = new double[5] {1, 0.5, 1, 0.5, 1};; 455 double* aeyhstat = new double[5] {0.5, 1, 0.5, 1, 0.5};; 456 double* aeylsys = new double[5] {0.5, 0.4, 0.8, 0.3, 1.2};; 457 double* aeyhsys = new double[5] {0.6, 0.7, 0.6, 0.4, 0.8};; 458 ; 459 TGraphMultiErrors* gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", 5, ax, ay, aexl, aexh, aeylstat, aeyhstat);; 460 gme->AddYError(5, aeylsys, aeyhsys);; 461 gme->SetMarkerStyle(20);; 462 gme->SetLineColor(kRe",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:17780,Availability,error,error,17780,"on string; 431the first block is also used for the first error dimension which is reserved for; 432statistical errors. The remaining blocks are assigned to the remaining dimensions.; 433 ; 434In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:; 435 ; 436| Option | Block | Description |; 437|----------|----------------|-------------------------------------------------------------------|; 438| ""X0"" | First one only | Do not draw errors for points with x = 0 |; 439| ""Y0"" | First one only | Do not draw errors for points with y = 0 |; 440| ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; 441| ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |; 442 ; 443 ; 444Per default the Fill and Line Styles of the Graph are being used for all error; 445dimensions. To use the specific ones add the draw option ""S"" to the first block.; 446 ; 447Begin_Macro(source); 448{; 449 auto c47 = new TCanvas(""c47"",""c47"",200,10,600,400);; 450 double ax[] = {0, 1, 2, 3, 4};; 451 double ay[] = {0, 2, 4, 1, 3};; 452 double aexl[] = {0.3, 0.3, 0.3, 0.3, 0.3};; 453 double aexh[] = {0.3, 0.3, 0.3, 0.3, 0.3};; 454 double* aeylstat = new double[5] {1, 0.5, 1, 0.5, 1};; 455 double* aeyhstat = new double[5] {0.5, 1, 0.5, 1, 0.5};; 456 double* aeylsys = new double[5] {0.5, 0.4, 0.8, 0.3, 1.2};; 457 double* aeyhsys = new double[5] {0.6, 0.7, 0.6, 0.4, 0.8};; 458 ; 459 TGraphMultiErrors* gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", 5, ax, ay, aexl, aexh, aeylstat, aeyhstat);; 460 gme->AddYError(5, aeylsys, aeyhsys);; 461 gme->SetMarkerStyle(20);; 462 gme->SetLineColor(kRed);; 463 gme->GetAttLine(0)->SetLineColor(kRed);; 464 gme->GetAttLine(1)->SetLineColor(kBlue);; 465 gme->GetAttFill(1)->SetFillSt",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:19214,Availability,error,error,19214,"tat = new double[5] {0.5, 1, 0.5, 1, 0.5};; 456 double* aeylsys = new double[5] {0.5, 0.4, 0.8, 0.3, 1.2};; 457 double* aeyhsys = new double[5] {0.6, 0.7, 0.6, 0.4, 0.8};; 458 ; 459 TGraphMultiErrors* gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", 5, ax, ay, aexl, aexh, aeylstat, aeyhstat);; 460 gme->AddYError(5, aeylsys, aeyhsys);; 461 gme->SetMarkerStyle(20);; 462 gme->SetLineColor(kRed);; 463 gme->GetAttLine(0)->SetLineColor(kRed);; 464 gme->GetAttLine(1)->SetLineColor(kBlue);; 465 gme->GetAttFill(1)->SetFillStyle(0);; 466 ; 467 gme->Draw(""a p s ; ; 5 s=0.5"");; 468}; 469End_Macro; 470 ; 471 ; 472\anchor GrP4; 473### TGraphPolar options; 474 ; 475The drawing options for the polar graphs are the following:; 476 ; 477| Option | Description |; 478|----------|-------------------------------------------------------------------|; 479| ""O"" | Polar labels are drawn orthogonally to the polargram radius. |; 480| ""P"" | Polymarker are drawn at each point position. |; 481| ""E"" | Draw error bars. |; 482| ""F"" | Draw fill area (closed polygon). |; 483| ""A"" | Force axis redrawing even if a polargram already exists. |; 484| ""N"" | Disable the display of the polar labels. |; 485 ; 486 ; 487Begin_Macro(source); 488{; 489 auto c46 = new TCanvas(""c46"",""c46"",500,500);; 490 auto grP1 = new TGraphPolar();; 491 grP1->SetTitle(""TGraphPolar example"");; 492 ; 493 grP1->SetPoint(0, (1*TMath::Pi())/4., 0.05);; 494 grP1->SetPoint(1, (2*TMath::Pi())/4., 0.10);; 495 grP1->SetPoint(2, (3*TMath::Pi())/4., 0.15);; 496 grP1->SetPoint(3, (4*TMath::Pi())/4., 0.20);; 497 grP1->SetPoint(4, (5*TMath::Pi())/4., 0.25);; 498 grP1->SetPoint(5, (6*TMath::Pi())/4., 0.30);; 499 grP1->SetPoint(6, (7*TMath::Pi())/4., 0.35);; 500 grP1->SetPoint(7, (8*TMath::Pi())/4., 0.40);; 501 ; 502 grP1->SetMarkerStyle(20);; 503 grP1->SetMarkerSize(1.);; 504 grP1->SetMarkerColor(4);; 505 grP1->SetLineColor(4);; 506 grP1->Draw(""ALP"");; 507 ; 508 // Update, otherwise GetPolargram returns 0; 509 c46->Update();; 510 gr",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:90089,Availability,error,error,90089,""")) yrevlog = kTRUE; // along Y; 2483 ; 2484 if (option3) {; 2485 xline.resize(2*theNpoints);; 2486 yline.resize(2*theNpoints);; 2487 if (xline.empty() || yline.empty()) {; 2488 Error(""PaintGraphAsymmErrors"", ""too many points, out of memory"");; 2489 return;; 2490 }; 2491 if1 = 1;; 2492 if2 = 2*theNpoints;; 2493 }; 2494 ; 2495 theGraph->TAttLine::Modify();; 2496 ; 2497 TArrow arrow;; 2498 arrow.SetLineWidth(theGraph->GetLineWidth());; 2499 arrow.SetLineColor(theGraph->GetLineColor());; 2500 arrow.SetFillColor(theGraph->GetFillColor());; 2501 ; 2502 TBox box;; 2503 Double_t x1b,y1b,x2b,y2b;; 2504 box.SetLineWidth(theGraph->GetLineWidth());; 2505 box.SetLineColor(theGraph->GetLineColor());; 2506 box.SetFillColor(theGraph->GetFillColor());; 2507 box.SetFillStyle(theGraph->GetFillStyle());; 2508 ; 2509 Double_t symbolsize = theGraph->GetMarkerSize();; 2510 Double_t sbase = symbolsize*kBASEMARKER;; 2511 Int_t mark = TAttMarker::GetMarkerStyleBase(theGraph->GetMarkerStyle());; 2512 Double_t cx = 0;; 2513 Double_t cy = 0;; 2514 if (mark >= 20 && mark <= 49) {; 2515 cx = cxx[mark-20];; 2516 cy = cyy[mark-20];; 2517 }; 2518 ; 2519 // Define the offset of the error bars due to the symbol size; 2520 Double_t s2x = gPad->PixeltoX(Int_t(0.5*sbase)) - gPad->PixeltoX(0);; 2521 Double_t s2y = -gPad->PixeltoY(Int_t(0.5*sbase)) + gPad->PixeltoY(0);; 2522 Int_t dxend = Int_t(gStyle->GetEndErrorSize());; 2523 Double_t tx = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 2524 Double_t ty = -gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 2525 Float_t asize = 0.6*symbolsize*kBASEMARKER/gPad->GetWh();; 2526 ; 2527 gPad->SetBit(TGraph::kClipFrame, theGraph->TestBit(TGraph::kClipFrame));; 2528 ; 2529 // special flags to turn off error bar drawing in case the marker cover it; 2530 Bool_t DrawXLeft, DrawXRight, DrawYUp, DrawYLow;; 2531 // loop over all the graph points; 2532 Double_t x, y, exl, exh, eyl, eyh, xl1, xl2, xr1, xr2, yup, yup1, yup2, ylow, ylow1, ylow2;; 2533 for (Int_t i=0;i<theNpoints;i++",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:90647,Availability,error,error,90647,,MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:93121,Availability,error,error,93121,"xl2 = gPad->GetUxmax()+gPad->GetUxmin()-TMath::Log10(; 2562 TMath::Power(10,-(TMath::Log10(theX[i])-gPad->GetUxmax()-gPad->GetUxmin())); 2563 - exh);; 2564 xr1 = x - s2x*cx;; 2565 xr2 = gPad->GetUxmax()+gPad->GetUxmin()-TMath::Log10(; 2566 TMath::Power(10,-(TMath::Log10(theX[i])-gPad->GetUxmax()-gPad->GetUxmin())); 2567 + exl);; 2568 tx = -tx;; 2569 } else {; 2570 xl1 = x - s2x*cx;; 2571 xl2 = gPad->XtoPad(theX[i] - exl);; 2572 xr1 = x + s2x*cx;; 2573 xr2 = gPad->XtoPad(theX[i] + exh);; 2574 if (xl1 < xl2) DrawXLeft = kFALSE;; 2575 if (xr1 > xr2) DrawXRight = kFALSE;; 2576 }; 2577 ; 2578 if (yrevlog) {; 2579 yup1 = y - s2y*cy;; 2580 yup2 = gPad->GetUymax()+gPad->GetUymin()-TMath::Log10(; 2581 TMath::Power(10,-(TMath::Log10(theY[i])-gPad->GetUymax()-gPad->GetUymin())); 2582 + eyl);; 2583 ylow1 = y + s2y*cy;; 2584 ylow2 = gPad->GetUymax()+gPad->GetUymin()-TMath::Log10(; 2585 TMath::Power(10,-(TMath::Log10(theY[i])-gPad->GetUymax()-gPad->GetUymin())); 2586 - eyh);; 2587 } else {; 2588 yup1 = y + s2y*cy;; 2589 yup2 = gPad->YtoPad(theY[i] + eyh);; 2590 ylow1 = y - s2y*cy;; 2591 ylow2 = gPad->YtoPad(theY[i] - eyl);; 2592 if (yup2 < yup1) DrawYUp = kFALSE;; 2593 if (ylow2 > ylow1) DrawYLow = kFALSE;; 2594 }; 2595 yup = yup2;; 2596 ylow = ylow2;; 2597 if (yup2 > gPad->GetUymax()) yup2 = gPad->GetUymax();; 2598 if (ylow2 < gPad->GetUymin()) ylow2 = gPad->GetUymin();; 2599 ; 2600 // draw the error rectangles; 2601 if (option2) {; 2602 x1b = xl2;; 2603 y1b = ylow2;; 2604 x2b = xr2;; 2605 y2b = yup2;; 2606 if (x1b < gPad->GetUxmin()) x1b = gPad->GetUxmin();; 2607 if (x1b > gPad->GetUxmax()) x1b = gPad->GetUxmax();; 2608 if (y1b < gPad->GetUymin()) y1b = gPad->GetUymin();; 2609 if (y1b > gPad->GetUymax()) y1b = gPad->GetUymax();; 2610 if (x2b < gPad->GetUxmin()) x2b = gPad->GetUxmin();; 2611 if (x2b > gPad->GetUxmax()) x2b = gPad->GetUxmax();; 2612 if (y2b < gPad->GetUymin()) y2b = gPad->GetUymin();; 2613 if (y2b > gPad->GetUymax()) y2b = gPad->GetUymax();; 2614 if (option5) box.",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:104328,Availability,error,error,104328,"9 if (Option3[j] && DrawErrors[j]) {; 2900 yline[j].resize(2 * NPointsInside);; 2901 ; 2902 if (yline[j].empty()) {; 2903 Error(""PaintGraphMultiErrors"", ""too many points, out of memory"");; 2904 return;; 2905 }; 2906 }; 2907 }; 2908 ; 2909 tg->TAttLine::Modify();; 2910 ; 2911 TArrow arrow;; 2912 arrow.SetLineWidth(tg->GetLineWidth());; 2913 arrow.SetLineColor(tg->GetLineColor());; 2914 arrow.SetFillColor(tg->GetFillColor());; 2915 ; 2916 TBox box;; 2917 Double_t x1b, y1b, x2b, y2b;; 2918 box.SetLineWidth(tg->GetLineWidth());; 2919 box.SetLineColor(tg->GetLineColor());; 2920 box.SetFillColor(tg->GetFillColor());; 2921 box.SetFillStyle(tg->GetFillStyle());; 2922 ; 2923 Double_t symbolsize = tg->GetMarkerSize();; 2924 Double_t sbase = symbolsize * kBASEMARKER;; 2925 Int_t mark = TAttMarker::GetMarkerStyleBase(tg->GetMarkerStyle());; 2926 Double_t cx = 0.;; 2927 Double_t cy = 0.;; 2928 ; 2929 if (mark >= 20 && mark <= 49) {; 2930 cx = cxx[mark - 20];; 2931 cy = cyy[mark - 20];; 2932 }; 2933 ; 2934 // Define the offset of the error bars due to the symbol size; 2935 Double_t s2x = gPad->PixeltoX(Int_t(0.5 * sbase)) - gPad->PixeltoX(0);; 2936 Double_t s2y = -gPad->PixeltoY(Int_t(0.5 * sbase)) + gPad->PixeltoY(0);; 2937 auto dxend = Int_t(gStyle->GetEndErrorSize());; 2938 Double_t tx = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 2939 Double_t ty = -gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 2940 Float_t asize = 0.6 * symbolsize * kBASEMARKER / gPad->GetWh();; 2941 ; 2942 gPad->SetBit(TGraph::kClipFrame, tg->TestBit(TGraph::kClipFrame));; 2943 ; 2944 // loop over all the graph points; 2945 Double_t xl1, xl2, xr1, xr2, yup1, yup2, ylow1, ylow2;; 2946 for (Int_t i = 0; i < theNpoints; i++) {; 2947 x = gPad->XtoPad(theX[i]);; 2948 y = gPad->YtoPad(theY[i]);; 2949 ; 2950 Bool_t isOutside =; 2951 (x < gPad->GetUxmin()) || (x > gPad->GetUxmax()) || (y < gPad->GetUymin()) || (y > gPad->GetUymax());; 2952 ; 2953 if ((isOutside && !AnyOption0) || (!Draw0PointsX && theX[i] == 0.) || (",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:105862,Availability,error,error,105862," ty = -gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 2940 Float_t asize = 0.6 * symbolsize * kBASEMARKER / gPad->GetWh();; 2941 ; 2942 gPad->SetBit(TGraph::kClipFrame, tg->TestBit(TGraph::kClipFrame));; 2943 ; 2944 // loop over all the graph points; 2945 Double_t xl1, xl2, xr1, xr2, yup1, yup2, ylow1, ylow2;; 2946 for (Int_t i = 0; i < theNpoints; i++) {; 2947 x = gPad->XtoPad(theX[i]);; 2948 y = gPad->YtoPad(theY[i]);; 2949 ; 2950 Bool_t isOutside =; 2951 (x < gPad->GetUxmin()) || (x > gPad->GetUxmax()) || (y < gPad->GetUymin()) || (y > gPad->GetUymax());; 2952 ; 2953 if ((isOutside && !AnyOption0) || (!Draw0PointsX && theX[i] == 0.) || (!Draw0PointsY && theY[i] == 0.)); 2954 continue;; 2955 ; 2956 if (AnyOption3) {; 2957 if (isOutside) {; 2958 if (x < gPad->GetUxmin()); 2959 x = gPad->GetUxmin();; 2960 if (x > gPad->GetUxmax()); 2961 x = gPad->GetUxmax();; 2962 if (y < gPad->GetUymin()); 2963 y = gPad->GetUymin();; 2964 if (y > gPad->GetUymax()); 2965 y = gPad->GetUymax();; 2966 }; 2967 ; 2968 xline[if1 - 1] = x;; 2969 xline[if2 - 1] = x;; 2970 ; 2971 if1++;; 2972 if2--;; 2973 }; 2974 ; 2975 for (Int_t j = 0; j < NYErrors; j++) {; 2976 if (!DrawErrors[j]); 2977 continue;; 2978 ; 2979 // draw the error rectangles; 2980 if (Option2[j] && (!isOutside || Option0[j])) {; 2981 if (IndividualStyles) {; 2982 box.SetLineWidth(tg->GetLineWidth(j));; 2983 box.SetLineColor(tg->GetLineColor(j));; 2984 box.SetFillColor(tg->GetFillColor(j));; 2985 box.SetFillStyle(tg->GetFillStyle(j));; 2986 }; 2987 ; 2988 x1b = gPad->XtoPad(theX[i] - Scale[j] * theExL[i]);; 2989 y1b = gPad->YtoPad(theY[i] - theEyL[j][i]);; 2990 x2b = gPad->XtoPad(theX[i] + Scale[j] * theExH[i]);; 2991 y2b = gPad->YtoPad(theY[i] + theEyH[j][i]);; 2992 if (x1b < gPad->GetUxmin()); 2993 x1b = gPad->GetUxmin();; 2994 if (x1b > gPad->GetUxmax()); 2995 x1b = gPad->GetUxmax();; 2996 if (y1b < gPad->GetUymin()); 2997 y1b = gPad->GetUymin();; 2998 if (y1b > gPad->GetUymax()); 2999 y1b = gPad->GetUymax();; 3000 if (x2b < gP",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:115620,Availability,error,error,115620,"M"")) yrevlog = kTRUE; // along Y; 3240 ; 3241 if (option3) {; 3242 xline.resize(2*theNpoints);; 3243 yline.resize(2*theNpoints);; 3244 if (xline.empty() || yline.empty()) {; 3245 Error(""PaintGraphBentErrors"", ""too many points, out of memory"");; 3246 return;; 3247 }; 3248 if1 = 1;; 3249 if2 = 2*theNpoints;; 3250 }; 3251 ; 3252 theGraph->TAttLine::Modify();; 3253 ; 3254 TArrow arrow;; 3255 arrow.SetLineWidth(theGraph->GetLineWidth());; 3256 arrow.SetLineColor(theGraph->GetLineColor());; 3257 arrow.SetFillColor(theGraph->GetFillColor());; 3258 ; 3259 TBox box;; 3260 Double_t x1b,y1b,x2b,y2b;; 3261 box.SetLineWidth(theGraph->GetLineWidth());; 3262 box.SetLineColor(theGraph->GetLineColor());; 3263 box.SetFillColor(theGraph->GetFillColor());; 3264 box.SetFillStyle(theGraph->GetFillStyle());; 3265 ; 3266 Double_t symbolsize = theGraph->GetMarkerSize();; 3267 Double_t sbase = symbolsize*kBASEMARKER;; 3268 Int_t mark = TAttMarker::GetMarkerStyleBase(theGraph->GetMarkerStyle());; 3269 Double_t cx = 0;; 3270 Double_t cy = 0;; 3271 if (mark >= 20 && mark <= 49) {; 3272 cx = cxx[mark-20];; 3273 cy = cyy[mark-20];; 3274 }; 3275 ; 3276 // define the offset of the error bars due to the symbol size; 3277 Double_t s2x = gPad->PixeltoX(Int_t(0.5*sbase)) - gPad->PixeltoX(0);; 3278 Double_t s2y = -gPad->PixeltoY(Int_t(0.5*sbase)) + gPad->PixeltoY(0);; 3279 Int_t dxend = Int_t(gStyle->GetEndErrorSize());; 3280 Double_t tx = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 3281 Double_t ty = -gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 3282 Float_t asize = 0.6*symbolsize*kBASEMARKER/gPad->GetWh();; 3283 ; 3284 gPad->SetBit(TGraph::kClipFrame, theGraph->TestBit(TGraph::kClipFrame));; 3285 ; 3286 // special flags to turn off error bar drawing in case the marker cover it; 3287 Bool_t DrawXLeft, DrawXRight, DrawYUp, DrawYLow;; 3288 // loop over all the graph points; 3289 Double_t x, y, exl, exh, eyl, eyh, xl1, xl2, xr1, xr2, yup, yup1, yup2, ylow, ylow1, ylow2;; 3290 Double_t bxl, bxh, byl, byh, bs",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:116178,Availability,error,error,116178,,MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:119658,Availability,error,error,119658,"s2x*cx;; 3341 xr2 = gPad->XtoPad(theX[i] + exh);; 3342 if (xl1 < xl2) DrawXLeft = kFALSE;; 3343 if (xr1 > xr2) DrawXRight = kFALSE;; 3344 }; 3345 ; 3346 if (yrevlog) {; 3347 yup1 = y - s2y*cy;; 3348 yup2 = gPad->GetUymax()+gPad->GetUymin()-TMath::Log10(; 3349 TMath::Power(10,-(TMath::Log10(theY[i])-gPad->GetUymax()-gPad->GetUymin())); 3350 + eyl);; 3351 ylow1 = y + s2y*cy;; 3352 ylow2 = gPad->GetUymax()+gPad->GetUymin()-TMath::Log10(; 3353 TMath::Power(10,-(TMath::Log10(theY[i])-gPad->GetUymax()-gPad->GetUymin())); 3354 - eyh);; 3355 bxl = gPad->GetUymax()+gPad->GetUymin()-TMath::Log10(; 3356 TMath::Power(10,-(TMath::Log10(theY[i])-gPad->GetUymax()-gPad->GetUymin())); 3357 - theEXlowd[i]);; 3358 bxh = gPad->GetUymax()+gPad->GetUymin()-TMath::Log10(; 3359 TMath::Power(10,-(TMath::Log10(theY[i])-gPad->GetUymax()-gPad->GetUymin())); 3360 - theEXhighd[i]);; 3361 } else {; 3362 yup1 = y + s2y*cy;; 3363 yup2 = gPad->YtoPad(theY[i] + eyh);; 3364 ylow1 = y - s2y*cy;; 3365 ylow2 = gPad->YtoPad(theY[i] - eyl);; 3366 if (yup2 < yup1) DrawYUp = kFALSE;; 3367 if (ylow2 > ylow1) DrawYLow = kFALSE;; 3368 }; 3369 yup = yup2;; 3370 ylow = ylow2;; 3371 if (yup2 > gPad->GetUymax()) yup2 = gPad->GetUymax();; 3372 if (ylow2 < gPad->GetUymin()) ylow2 = gPad->GetUymin();; 3373 ; 3374 if (xrevlog) {bs = bxl; bxl = bxh; bxh = bs;}; 3375 if (yrevlog) {bs = byl; byl = byh; byh = bs;}; 3376 ; 3377 // draw the error rectangles; 3378 if (option2) {; 3379 x1b = xl2;; 3380 y1b = ylow2;; 3381 x2b = xr2;; 3382 y2b = yup2;; 3383 if (x1b < gPad->GetUxmin()) x1b = gPad->GetUxmin();; 3384 if (x1b > gPad->GetUxmax()) x1b = gPad->GetUxmax();; 3385 if (y1b < gPad->GetUymin()) y1b = gPad->GetUymin();; 3386 if (y1b > gPad->GetUymax()) y1b = gPad->GetUymax();; 3387 if (x2b < gPad->GetUxmin()) x2b = gPad->GetUxmin();; 3388 if (x2b > gPad->GetUxmax()) x2b = gPad->GetUxmax();; 3389 if (y2b < gPad->GetUymin()) y2b = gPad->GetUymin();; 3390 if (y2b > gPad->GetUymax()) y2b = gPad->GetUymax();; 3391 if (option5) box.",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:127114,Availability,error,error,127114," (option3) {; 3553 xline.resize(2*theNpoints);; 3554 yline.resize(2*theNpoints);; 3555 if (xline.empty() || yline.empty()) {; 3556 Error(""PaintGraphErrors"", ""too many points, out of memory"");; 3557 return;; 3558 }; 3559 if1 = 1;; 3560 if2 = 2*theNpoints;; 3561 }; 3562 ; 3563 theGraph->TAttLine::Modify();; 3564 ; 3565 TArrow arrow;; 3566 arrow.SetLineWidth(theGraph->GetLineWidth());; 3567 arrow.SetLineStyle(theGraph->GetLineStyle());; 3568 arrow.SetLineColor(theGraph->GetLineColor());; 3569 arrow.SetFillColor(theGraph->GetFillColor());; 3570 ; 3571 TBox box;; 3572 Double_t x1b,y1b,x2b,y2b;; 3573 box.SetLineWidth(theGraph->GetLineWidth());; 3574 box.SetLineColor(theGraph->GetLineColor());; 3575 box.SetFillColor(theGraph->GetFillColor());; 3576 box.SetFillStyle(theGraph->GetFillStyle());; 3577 ; 3578 Double_t symbolsize = theGraph->GetMarkerSize();; 3579 Double_t sbase = symbolsize*kBASEMARKER;; 3580 Int_t mark = TAttMarker::GetMarkerStyleBase(theGraph->GetMarkerStyle());; 3581 Double_t cx = 0;; 3582 Double_t cy = 0;; 3583 if (mark >= 20 && mark <= 49) {; 3584 cx = cxx[mark-20];; 3585 cy = cyy[mark-20];; 3586 }; 3587 ; 3588 // define the offset of the error bars due to the symbol size; 3589 Double_t s2x = gPad->PixeltoX(Int_t(0.5*sbase)) - gPad->PixeltoX(0);; 3590 Double_t s2y = -gPad->PixeltoY(Int_t(0.5*sbase)) + gPad->PixeltoY(0);; 3591 Int_t dxend = Int_t(gStyle->GetEndErrorSize());; 3592 Double_t tx = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 3593 Double_t ty = -gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 3594 Float_t asize = 0.6*symbolsize*kBASEMARKER/gPad->GetWh();; 3595 ; 3596 gPad->SetBit(TGraph::kClipFrame, theGraph->TestBit(TGraph::kClipFrame));; 3597 ; 3598 // special flags to turn off error bar drawing in case the marker cover it; 3599 Bool_t DrawXLeft, DrawXRight, DrawYUp, DrawYLow;; 3600 // loop over all the graph points; 3601 Double_t x, y, ex, ey, xl1, xl2, xr1, xr2, yup, yup1, yup2, ylow, ylow1, ylow2;; 3602 for (Int_t i=0;i<theNpoints;i++) {; 3603 Dr",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:127672,Availability,error,error,127672,,MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:130066,Availability,error,error,130066,";; 3628 xl2 = gPad->GetUxmax()+gPad->GetUxmin()-TMath::Log10(; 3629 TMath::Power(10,-(TMath::Log10(theX[i])-gPad->GetUxmax()-gPad->GetUxmin())); 3630 - ex);; 3631 xr1 = x - s2x*cx;; 3632 xr2 = gPad->GetUxmax()+gPad->GetUxmin()-TMath::Log10(; 3633 TMath::Power(10,-(TMath::Log10(theX[i])-gPad->GetUxmax()-gPad->GetUxmin())); 3634 + ex);; 3635 tx = -tx;; 3636 } else {; 3637 xl1 = x - s2x*cx;; 3638 xl2 = gPad->XtoPad(theX[i] - ex);; 3639 xr1 = x + s2x*cx;; 3640 xr2 = gPad->XtoPad(theX[i] + ex);; 3641 if (xl1 < xl2) DrawXLeft = kFALSE;; 3642 if (xr1 > xr2) DrawXRight = kFALSE;; 3643 }; 3644 ; 3645 if (yrevlog) {; 3646 yup1 = y - s2y*cy;; 3647 yup2 = gPad->GetUymax()+gPad->GetUymin()-TMath::Log10(; 3648 TMath::Power(10,-(TMath::Log10(theY[i])-gPad->GetUymax()-gPad->GetUymin())); 3649 + ey);; 3650 ylow1 = y + s2y*cy;; 3651 ylow2 = gPad->GetUymax()+gPad->GetUymin()-TMath::Log10(; 3652 TMath::Power(10,-(TMath::Log10(theY[i])-gPad->GetUymax()-gPad->GetUymin())); 3653 - ey);; 3654 } else {; 3655 yup1 = y + s2y*cy;; 3656 yup2 = gPad->YtoPad(theY[i] + ey);; 3657 ylow1 = y - s2y*cy;; 3658 ylow2 = gPad->YtoPad(theY[i] - ey);; 3659 if (yup2 < yup1) DrawYUp = kFALSE;; 3660 if (ylow2 > ylow1) DrawYLow = kFALSE;; 3661 }; 3662 yup = yup2;; 3663 ylow = ylow2;; 3664 if (yup2 > gPad->GetUymax()) yup2 = gPad->GetUymax();; 3665 if (ylow2 < gPad->GetUymin()) ylow2 = gPad->GetUymin();; 3666 ; 3667 // draw the error rectangles; 3668 if (option2) {; 3669 x1b = xl2;; 3670 x2b = xr2;; 3671 y1b = ylow2;; 3672 y2b = yup2;; 3673 if (x1b < gPad->GetUxmin()) x1b = gPad->GetUxmin();; 3674 if (x1b > gPad->GetUxmax()) x1b = gPad->GetUxmax();; 3675 if (y1b < gPad->GetUymin()) y1b = gPad->GetUymin();; 3676 if (y1b > gPad->GetUymax()) y1b = gPad->GetUymax();; 3677 if (x2b < gPad->GetUxmin()) x2b = gPad->GetUxmin();; 3678 if (x2b > gPad->GetUxmax()) x2b = gPad->GetUxmax();; 3679 if (y2b < gPad->GetUymin()) y2b = gPad->GetUymin();; 3680 if (y2b > gPad->GetUymax()) y2b = gPad->GetUymax();; 3681 if (option5) box.",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:135498,Availability,error,errors,135498,"polargram; 3818 if (thePolargram) if (!gPad->FindObject(thePolargram->GetName())) thePolargram=nullptr;; 3819 if (!thePolargram) {; 3820 // Find any other Polargram in the Pad; 3821 TListIter padObjIter(gPad->GetListOfPrimitives());; 3822 while (TObject* AnyObj = padObjIter.Next()) {; 3823 if (TString(AnyObj->ClassName()).CompareTo(""TGraphPolargram"",; 3824 TString::kExact)==0); 3825 thePolargram = (TGraphPolargram*)AnyObj;; 3826 theGraphPolar->SetPolargram(thePolargram);; 3827 }; 3828 }; 3829 }; 3830 ; 3831 // Get new polargram range if necessary.; 3832 if (!thePolargram) {; 3833 // Get range, initialize with first/last value; 3834 rwrmin = theY[0]; rwrmax = theY[theNpoints-1];; 3835 rwtmin = theX[0]; rwtmax = theX[theNpoints-1];; 3836 ; 3837 for (ipt = 0; ipt < theNpoints; ipt++) {; 3838 // Check for errors if available; 3839 if (theEX) {; 3840 if (theX[ipt] -theEX[ipt] < rwtmin) rwtmin = theX[ipt]-theEX[ipt];; 3841 if (theX[ipt] +theEX[ipt] > rwtmax) rwtmax = theX[ipt]+theEX[ipt];; 3842 } else {; 3843 if (theX[ipt] < rwtmin) rwtmin=theX[ipt];; 3844 if (theX[ipt] > rwtmax) rwtmax=theX[ipt];; 3845 }; 3846 if (theEY) {; 3847 if (theY[ipt] -theEY[ipt] < rwrmin) rwrmin = theY[ipt]-theEY[ipt];; 3848 if (theY[ipt] +theEY[ipt] > rwrmax) rwrmax = theY[ipt]+theEY[ipt];; 3849 } else {; 3850 if (theY[ipt] < rwrmin) rwrmin=theY[ipt];; 3851 if (theY[ipt] > rwrmax) rwrmax=theY[ipt];; 3852 }; 3853 }; 3854 // Add radial and Polar margins.; 3855 if (rwrmin == rwrmax) rwrmax += 1.;; 3856 if (rwtmin == rwtmax) rwtmax += 1.;; 3857 Double_t dr = (rwrmax-rwrmin);; 3858 Double_t dt = (rwtmax-rwtmin);; 3859 rwrmax += 0.1*dr;; 3860 rwrmin -= 0.1*dr;; 3861 ; 3862 // Assume equally spaced points for full 2*Pi.; 3863 rwtmax += dt/theNpoints;; 3864 } else {; 3865 rwrmin = thePolargram->GetRMin();; 3866 rwrmax = thePolargram->GetRMax();; 3867 rwtmin = thePolargram->GetTMin();; 3868 rwtmax = thePolargram->GetTMax();; 3869 }; 3870 ; 3871 if ((!thePolargram) || theGraphPolar->GetOptionAxis()) {; 3",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:135508,Availability,avail,available,135508,"polargram; 3818 if (thePolargram) if (!gPad->FindObject(thePolargram->GetName())) thePolargram=nullptr;; 3819 if (!thePolargram) {; 3820 // Find any other Polargram in the Pad; 3821 TListIter padObjIter(gPad->GetListOfPrimitives());; 3822 while (TObject* AnyObj = padObjIter.Next()) {; 3823 if (TString(AnyObj->ClassName()).CompareTo(""TGraphPolargram"",; 3824 TString::kExact)==0); 3825 thePolargram = (TGraphPolargram*)AnyObj;; 3826 theGraphPolar->SetPolargram(thePolargram);; 3827 }; 3828 }; 3829 }; 3830 ; 3831 // Get new polargram range if necessary.; 3832 if (!thePolargram) {; 3833 // Get range, initialize with first/last value; 3834 rwrmin = theY[0]; rwrmax = theY[theNpoints-1];; 3835 rwtmin = theX[0]; rwtmax = theX[theNpoints-1];; 3836 ; 3837 for (ipt = 0; ipt < theNpoints; ipt++) {; 3838 // Check for errors if available; 3839 if (theEX) {; 3840 if (theX[ipt] -theEX[ipt] < rwtmin) rwtmin = theX[ipt]-theEX[ipt];; 3841 if (theX[ipt] +theEX[ipt] > rwtmax) rwtmax = theX[ipt]+theEX[ipt];; 3842 } else {; 3843 if (theX[ipt] < rwtmin) rwtmin=theX[ipt];; 3844 if (theX[ipt] > rwtmax) rwtmax=theX[ipt];; 3845 }; 3846 if (theEY) {; 3847 if (theY[ipt] -theEY[ipt] < rwrmin) rwrmin = theY[ipt]-theEY[ipt];; 3848 if (theY[ipt] +theEY[ipt] > rwrmax) rwrmax = theY[ipt]+theEY[ipt];; 3849 } else {; 3850 if (theY[ipt] < rwrmin) rwrmin=theY[ipt];; 3851 if (theY[ipt] > rwrmax) rwrmax=theY[ipt];; 3852 }; 3853 }; 3854 // Add radial and Polar margins.; 3855 if (rwrmin == rwrmax) rwrmax += 1.;; 3856 if (rwtmin == rwtmax) rwtmax += 1.;; 3857 Double_t dr = (rwrmax-rwrmin);; 3858 Double_t dt = (rwtmax-rwtmin);; 3859 rwrmax += 0.1*dr;; 3860 rwrmin -= 0.1*dr;; 3861 ; 3862 // Assume equally spaced points for full 2*Pi.; 3863 rwtmax += dt/theNpoints;; 3864 } else {; 3865 rwrmin = thePolargram->GetRMin();; 3866 rwrmax = thePolargram->GetRMax();; 3867 rwtmin = thePolargram->GetTMin();; 3868 rwtmax = thePolargram->GetTMax();; 3869 }; 3870 ; 3871 if ((!thePolargram) || theGraphPolar->GetOptionAxis()) {; 3",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:137479,Availability,error,error,137479,"Npoints;; 3864 } else {; 3865 rwrmin = thePolargram->GetRMin();; 3866 rwrmax = thePolargram->GetRMax();; 3867 rwtmin = thePolargram->GetTMin();; 3868 rwtmax = thePolargram->GetTMax();; 3869 }; 3870 ; 3871 if ((!thePolargram) || theGraphPolar->GetOptionAxis()) {; 3872 // Draw Polar coord system; 3873 thePolargram = new TGraphPolargram(""Polargram"",rwrmin,rwrmax,rwtmin,rwtmax);; 3874 theGraphPolar->SetPolargram(thePolargram);; 3875 if (opt.Contains(""O"")) thePolargram->SetBit(TGraphPolargram::kLabelOrtho);; 3876 else thePolargram->ResetBit(TGraphPolargram::kLabelOrtho);; 3877 if (nolabel) thePolargram->Draw(""N"");; 3878 else thePolargram->Draw("""");; 3879 theGraphPolar->SetOptionAxis(kFALSE); //Prevent redrawing; 3880 }; 3881 ; 3882 // Convert points to polar.; 3883 Double_t *theXpol = theGraphPolar->GetXpol();; 3884 Double_t *theYpol = theGraphPolar->GetYpol();; 3885 ; 3886 // Project theta in [0,2*Pi] and radius in [0,1].; 3887 Double_t radiusNDC = rwrmax-rwrmin;; 3888 Double_t thetaNDC = (rwtmax-rwtmin)/(2*TMath::Pi());; 3889 ; 3890 // Draw the error bars.; 3891 // Y errors are lines, but X errors are pieces of circles.; 3892 if (opt.Contains(""E"")) {; 3893 Double_t c=1;; 3894 if (thePolargram->IsDegree()) {c=180/TMath::Pi();}; 3895 if (thePolargram->IsGrad()) {c=100/TMath::Pi();}; 3896 if (theEY) {; 3897 for (i=0; i<theNpoints; i++) {; 3898 Double_t eymin, eymax, exmin,exmax;; 3899 exmin = (theY[i]-theEY[i]-rwrmin)/radiusNDC*; 3900 TMath::Cos(c*(theX[i]-rwtmin)/thetaNDC);; 3901 eymin = (theY[i]-theEY[i]-rwrmin)/radiusNDC*; 3902 TMath::Sin(c*(theX[i]-rwtmin)/thetaNDC);; 3903 exmax = (theY[i]+theEY[i]-rwrmin)/radiusNDC*; 3904 TMath::Cos(c*(theX[i]-rwtmin)/thetaNDC);; 3905 eymax = (theY[i]+theEY[i]-rwrmin)/radiusNDC*; 3906 TMath::Sin(c*(theX[i]-rwtmin)/thetaNDC);; 3907 theGraphPolar->TAttLine::Modify();; 3908 if (exmin != exmax || eymin != eymax) gPad->PaintLine(exmin,eymin,exmax,eymax);; 3909 }; 3910 }; 3911 if (theEX) {; 3912 for (i=0; i<theNpoints; i++) {; 3913 Double_",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:137502,Availability,error,errors,137502,");; 3867 rwtmin = thePolargram->GetTMin();; 3868 rwtmax = thePolargram->GetTMax();; 3869 }; 3870 ; 3871 if ((!thePolargram) || theGraphPolar->GetOptionAxis()) {; 3872 // Draw Polar coord system; 3873 thePolargram = new TGraphPolargram(""Polargram"",rwrmin,rwrmax,rwtmin,rwtmax);; 3874 theGraphPolar->SetPolargram(thePolargram);; 3875 if (opt.Contains(""O"")) thePolargram->SetBit(TGraphPolargram::kLabelOrtho);; 3876 else thePolargram->ResetBit(TGraphPolargram::kLabelOrtho);; 3877 if (nolabel) thePolargram->Draw(""N"");; 3878 else thePolargram->Draw("""");; 3879 theGraphPolar->SetOptionAxis(kFALSE); //Prevent redrawing; 3880 }; 3881 ; 3882 // Convert points to polar.; 3883 Double_t *theXpol = theGraphPolar->GetXpol();; 3884 Double_t *theYpol = theGraphPolar->GetYpol();; 3885 ; 3886 // Project theta in [0,2*Pi] and radius in [0,1].; 3887 Double_t radiusNDC = rwrmax-rwrmin;; 3888 Double_t thetaNDC = (rwtmax-rwtmin)/(2*TMath::Pi());; 3889 ; 3890 // Draw the error bars.; 3891 // Y errors are lines, but X errors are pieces of circles.; 3892 if (opt.Contains(""E"")) {; 3893 Double_t c=1;; 3894 if (thePolargram->IsDegree()) {c=180/TMath::Pi();}; 3895 if (thePolargram->IsGrad()) {c=100/TMath::Pi();}; 3896 if (theEY) {; 3897 for (i=0; i<theNpoints; i++) {; 3898 Double_t eymin, eymax, exmin,exmax;; 3899 exmin = (theY[i]-theEY[i]-rwrmin)/radiusNDC*; 3900 TMath::Cos(c*(theX[i]-rwtmin)/thetaNDC);; 3901 eymin = (theY[i]-theEY[i]-rwrmin)/radiusNDC*; 3902 TMath::Sin(c*(theX[i]-rwtmin)/thetaNDC);; 3903 exmax = (theY[i]+theEY[i]-rwrmin)/radiusNDC*; 3904 TMath::Cos(c*(theX[i]-rwtmin)/thetaNDC);; 3905 eymax = (theY[i]+theEY[i]-rwrmin)/radiusNDC*; 3906 TMath::Sin(c*(theX[i]-rwtmin)/thetaNDC);; 3907 theGraphPolar->TAttLine::Modify();; 3908 if (exmin != exmax || eymin != eymax) gPad->PaintLine(exmin,eymin,exmax,eymax);; 3909 }; 3910 }; 3911 if (theEX) {; 3912 for (i=0; i<theNpoints; i++) {; 3913 Double_t rad = (theY[i]-rwrmin)/radiusNDC;; 3914 Double_t phimin = c*(theX[i]-theEX[i]-rwtmin)/thetaNDC*180/T",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:137526,Availability,error,errors,137526,");; 3867 rwtmin = thePolargram->GetTMin();; 3868 rwtmax = thePolargram->GetTMax();; 3869 }; 3870 ; 3871 if ((!thePolargram) || theGraphPolar->GetOptionAxis()) {; 3872 // Draw Polar coord system; 3873 thePolargram = new TGraphPolargram(""Polargram"",rwrmin,rwrmax,rwtmin,rwtmax);; 3874 theGraphPolar->SetPolargram(thePolargram);; 3875 if (opt.Contains(""O"")) thePolargram->SetBit(TGraphPolargram::kLabelOrtho);; 3876 else thePolargram->ResetBit(TGraphPolargram::kLabelOrtho);; 3877 if (nolabel) thePolargram->Draw(""N"");; 3878 else thePolargram->Draw("""");; 3879 theGraphPolar->SetOptionAxis(kFALSE); //Prevent redrawing; 3880 }; 3881 ; 3882 // Convert points to polar.; 3883 Double_t *theXpol = theGraphPolar->GetXpol();; 3884 Double_t *theYpol = theGraphPolar->GetYpol();; 3885 ; 3886 // Project theta in [0,2*Pi] and radius in [0,1].; 3887 Double_t radiusNDC = rwrmax-rwrmin;; 3888 Double_t thetaNDC = (rwtmax-rwtmin)/(2*TMath::Pi());; 3889 ; 3890 // Draw the error bars.; 3891 // Y errors are lines, but X errors are pieces of circles.; 3892 if (opt.Contains(""E"")) {; 3893 Double_t c=1;; 3894 if (thePolargram->IsDegree()) {c=180/TMath::Pi();}; 3895 if (thePolargram->IsGrad()) {c=100/TMath::Pi();}; 3896 if (theEY) {; 3897 for (i=0; i<theNpoints; i++) {; 3898 Double_t eymin, eymax, exmin,exmax;; 3899 exmin = (theY[i]-theEY[i]-rwrmin)/radiusNDC*; 3900 TMath::Cos(c*(theX[i]-rwtmin)/thetaNDC);; 3901 eymin = (theY[i]-theEY[i]-rwrmin)/radiusNDC*; 3902 TMath::Sin(c*(theX[i]-rwtmin)/thetaNDC);; 3903 exmax = (theY[i]+theEY[i]-rwrmin)/radiusNDC*; 3904 TMath::Cos(c*(theX[i]-rwtmin)/thetaNDC);; 3905 eymax = (theY[i]+theEY[i]-rwrmin)/radiusNDC*; 3906 TMath::Sin(c*(theX[i]-rwtmin)/thetaNDC);; 3907 theGraphPolar->TAttLine::Modify();; 3908 if (exmin != exmax || eymin != eymax) gPad->PaintLine(exmin,eymin,exmax,eymax);; 3909 }; 3910 }; 3911 if (theEX) {; 3912 for (i=0; i<theNpoints; i++) {; 3913 Double_t rad = (theY[i]-rwrmin)/radiusNDC;; 3914 Double_t phimin = c*(theX[i]-theEX[i]-rwtmin)/thetaNDC*180/T",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:151856,Availability,error,errors,151856," 4272 theGraph->GetXaxis()->GetXmin(),; 4273 theGraph->GetXaxis()->GetXmax(),; 4274 theHist->GetNdivisions(""X""),; 4275 optax.Data(), -GL);; 4276 theReversedXaxis->SetLabelOffset(LOX - theGraph->GetXaxis()->GetLabelSize());; 4277 }; 4278 theReversedXaxis->SetLabelFont(theGraph->GetXaxis()->GetLabelFont());; 4279 theReversedXaxis->SetLabelSize(theGraph->GetXaxis()->GetLabelSize());; 4280 theReversedXaxis->SetLabelColor(theGraph->GetXaxis()->GetLabelColor());; 4281 theReversedXaxis->SetTickLength(TLX);; 4282 theReversedXaxis->Paint();; 4283 }; 4284 ; 4285 // Reverse X coordinates; 4286 if (gPad->GetLogx()) {; 4287 for (i=0; i<N; i++) rX[i] = TMath::Power(10,gPad->GetUxmax()+gPad->GetUxmin()-TMath::Log10(X[i]));; 4288 opt.Append(""-N"");; 4289 } else {; 4290 for (i=0; i<N; i++) rX[i] = dX-X[i];; 4291 }; 4292 ; 4293 // Reverse X asymmetric errors; 4294 if (rEXhigh && EXlow) for (i=0; i<N; i++) rEXhigh[i] = EXlow[i];; 4295 if (rEXlow && EXhigh) for (i=0; i<N; i++) rEXlow[i] = EXhigh[i];; 4296 ; 4297 // Reverse X bent parameters; 4298 if (rEXhighd && EXlowd) for (i=0; i<N; i++) rEXhighd[i] = EXlowd[i];; 4299 if (rEXlowd && EXhighd) for (i=0; i<N; i++) rEXlowd[i] = EXhighd[i];; 4300 }; 4301 ; 4302 // Reserve the TGraph along the Y axis; 4303 if (lry) {; 4304 opt.ReplaceAll(""ry"", """");; 4305 if (axis) {; 4306 // Reverse the Y axis; 4307 Double_t GL = 0.;; 4308 gPad->Update();; 4309 TString optax = ""-SDH"";; 4310 if (gPad->GetGridy()) {; 4311 if (gPad->GetLogx()) {; 4312 GL = (TMath::Log10(XA2) - TMath::Log10(XA1)) / (gPad->GetX2() - gPad->GetX1());; 4313 } else {; 4314 GL = (XA2 - XA1) / (gPad->GetX2() - gPad->GetX1());; 4315 }; 4316 optax.Append(""W"");; 4317 }; 4318 Double_t xpos;; 4319 if (lyp) xpos = gPad->GetUxmax();; 4320 else xpos = gPad->GetUxmin();; 4321 if (gPad->GetLogx()) xpos = TMath::Power(10,xpos);; 4322 TGaxis *theReversedYaxis;; 4323 if (gPad->GetLogy()) {; 4324 optax.Append(""G"");; 4325 theReversedYaxis = new TGaxis(xpos,; 4326 TMath::Power(10,gPad->GetUymax()),; 4",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:154217,Availability,error,errors,154217,"),; 4342 optax.Data(), GL);; 4343 }; 4344 theReversedYaxis->SetLabelFont(theGraph->GetYaxis()->GetLabelFont());; 4345 theReversedYaxis->SetLabelSize(theGraph->GetYaxis()->GetLabelSize());; 4346 theReversedYaxis->SetLabelColor(theGraph->GetYaxis()->GetLabelColor());; 4347 theReversedYaxis->SetTickLength(-TLY);; 4348 theReversedYaxis->SetLabelOffset(LOY-TLY);; 4349 theReversedYaxis->Paint();; 4350 }; 4351 ; 4352 // Reverse Y coordinates; 4353 if (gPad->GetLogy()) {; 4354 for (i=0; i<N; i++) rY[i] = TMath::Power(10,gPad->GetUymax()+gPad->GetUymin()-TMath::Log10(Y[i]));; 4355 opt.Append(""-M"");; 4356 } else {; 4357 for (i=0; i<N; i++) rY[i] = dY-Y[i];; 4358 }; 4359 ; 4360 // Reverse Y asymmetric errors; 4361 if (rEYhigh && EYlow) for (i=0; i<N; i++) rEYhigh[i] = EYlow[i];; 4362 if (rEYlow && EYhigh) for (i=0; i<N; i++) rEYlow[i] = EYhigh[i];; 4363 ; 4364 // Reverse Y bent parameters; 4365 if (rEYhighd && EYlowd) for (i=0; i<N; i++) rEYhighd[i] = EYlowd[i];; 4366 if (rEYlowd && EYhighd) for (i=0; i<N; i++) rEYlowd[i] = EYhighd[i];; 4367 }; 4368 ; 4369 if (lrx) {; 4370 if (rEYlowd) for (i=0; i<N; i++) rEYlowd[i] = -rEYlowd[i];; 4371 if (rEYhighd) for (i=0; i<N; i++) rEYhighd[i] = -rEYhighd[i];; 4372 }; 4373 if (lry) {; 4374 if (rEXlowd) for (i=0; i<N; i++) rEXlowd[i] = -rEXlowd[i];; 4375 if (rEXhighd) for (i=0; i<N; i++) rEXhighd[i] = -rEXhighd[i];; 4376 }; 4377 ; 4378 PaintHelper(theReversedGraph,opt.Data());; 4379 ; 4380 theHist->GetXaxis()->SetLabelOffset(LOX);; 4381 theHist->GetXaxis()->SetTickLength(TLX);; 4382 theHist->GetYaxis()->SetLabelOffset(LOY);; 4383 theHist->GetYaxis()->SetTickLength(TLY);; 4384 theHist->GetXaxis()->SetAxisColor(XACOL);; 4385 theHist->GetYaxis()->SetAxisColor(YACOL);; 4386}; 4387 ; 4388 ; 4389////////////////////////////////////////////////////////////////////////////////; 4390/// Paint a scatter plot; 4391 ; 4392void TGraphPainter::PaintScatter(TScatter *theScatter, Option_t* chopt); 4393{; 4394 ; 4395 Int_t optionAxis;; 4396 ; 4397 TString o",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:161221,Availability,error,errors,161221,"elSize(h->GetZaxis()->GetLabelSize());; 4520 palette->SetTitleOffset(h->GetZaxis()->GetTitleOffset());; 4521 palette->SetTitleSize(h->GetZaxis()->GetTitleSize());; 4522 palette->SetNdivisions(h->GetZaxis()->GetNdivisions());; 4523 palette->SetTitle(h->GetZaxis()->GetTitle());; 4524 palette->SetTitleColor(h->GetZaxis()->GetTitleColor());; 4525 palette->SetTitleFont(h->GetZaxis()->GetTitleFont());; 4526 ; 4527 functions->AddFirst(palette);; 4528 }; 4529 if (palette) palette->Paint();; 4530 }; 4531 ; 4532 // Draw markers; 4533 auto nbcol = gStyle->GetNumberOfColors();; 4534 int logx = gPad->GetLogx();; 4535 int logy = gPad->GetLogy();; 4536 int logz = gPad->GetLogz();; 4537 if (theColor && logz) {; 4538 if (minc>0) minc = log10(minc);; 4539 if (maxc>0) maxc = log10(maxc);; 4540 }; 4541 theScatter->SetMarkerColor(theScatter->GetMarkerColor());; 4542 theScatter->TAttMarker::Modify();; 4543 double x,y,c,ms;; 4544 int nc;; 4545 for (int i=0; i<n; i++) {; 4546 if (theColor) {; 4547 if (logz) {; 4548 if (theColor[i]>0) c = log10(theColor[i]);; 4549 else continue;; 4550 } else {; 4551 c = theColor[i];; 4552 }; 4553 if (c<minc) continue;; 4554 if (c>maxc) continue;; 4555 nc = TMath::Nint(((c-minc)/(maxc-minc))*(nbcol-1));; 4556 if (nc > nbcol-1) nc = nbcol-1;; 4557 theScatter->SetMarkerColor(gStyle->GetColorPalette(nc));; 4558 }; 4559 if (theSize) {; 4560 ms = (MaxMarkerSize-MinMarkerSize)*((theSize[i]-mins)/(maxs-mins))+MinMarkerSize;; 4561 theScatter->SetMarkerSize(ms);; 4562 }; 4563 if (theColor || theSize) theScatter->TAttMarker::Modify();; 4564 if (logx) {; 4565 if (theX[i]>0) x = log10(theX[i]);; 4566 else break;; 4567 } else {; 4568 x = theX[i];; 4569 }; 4570 if (logy) {; 4571 if (theY[i]>0) y = log10(theY[i]);; 4572 else break;; 4573 } else {; 4574 y = theY[i];; 4575 }; 4576 gPad->PaintPolyMarker(1,&x,&y);; 4577 }; 4578}; 4579 ; 4580 ; 4581////////////////////////////////////////////////////////////////////////////////; 4582/// Paint a simple graph, without errors bars.",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:196840,Availability,error,error,196840,"etLabelOffsetvoid SetLabelOffset(Float_t labeloffset)Definition TGaxis.h:106; TGaxis::SetLabelColorvoid SetLabelColor(Int_t labelcolor)Definition TGaxis.h:104; TGaxis::SetTickLengthvoid SetTickLength(Float_t ticklength)Definition TGaxis.h:123; TGaxis::SetMoreLogLabelsvirtual void SetMoreLogLabels(Bool_t more=kTRUE)Set the kMoreLogLabels bit flag.Definition TGaxis.cxx:2914; TGaxis::SetTickSizevoid SetTickSize(Float_t ticksize)Definition TGaxis.h:122; TGaxis::Paintvoid Paint(Option_t *chopt="""") overrideDraw this axis with its current attributes.Definition TGaxis.cxx:986; TGaxis::SetLabelSizevoid SetLabelSize(Float_t labelsize)Definition TGaxis.h:107; TGraphAsymmErrors::Classstatic TClass * Class(); TGraphBentErrors::Classstatic TClass * Class(); TGraphErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraphErrors.h:69; TGraphErrors::Classstatic TClass * Class(); TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::Classstatic TClass * Class(); TGraphPainterThe graph painter class.Definition TGraphPainter.h:31; TGraphPainter::PaintGraphPolarvoid PaintGraphPolar(TGraph *theGraph, Option_t *option)Paint this TGraphPolar with its current attributes.Definition TGraphPainter.cxx:3789; TGraphPainter::PaintGraphvoid PaintGraph(TGraph *theGraph, Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt) overrideControl function to draw a graph.Definition TGraphPainter.cxx:1283; TGraphPainter::PaintGraphErrorsvoid PaintGraphErrors(TGraph *theGraph, Option_t *option)Paint this TGraphErrors with its current attributes.Definition TGraphPainter.cxx:3499; TGraphPainter::PaintGraphAsymmErrorsvoid PaintGraphAsymmErrors(TGraph *theGraph, Option_t *option)Paint this TGraphAsymmErrors with its current attributes.Definition TGraphPainter.cxx:2429; TGraphPainter::PaintGraphMultiErrorsvoid PaintGraphMultiErrors",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:196866,Availability,error,error,196866,"etLabelOffsetvoid SetLabelOffset(Float_t labeloffset)Definition TGaxis.h:106; TGaxis::SetLabelColorvoid SetLabelColor(Int_t labelcolor)Definition TGaxis.h:104; TGaxis::SetTickLengthvoid SetTickLength(Float_t ticklength)Definition TGaxis.h:123; TGaxis::SetMoreLogLabelsvirtual void SetMoreLogLabels(Bool_t more=kTRUE)Set the kMoreLogLabels bit flag.Definition TGaxis.cxx:2914; TGaxis::SetTickSizevoid SetTickSize(Float_t ticksize)Definition TGaxis.h:122; TGaxis::Paintvoid Paint(Option_t *chopt="""") overrideDraw this axis with its current attributes.Definition TGaxis.cxx:986; TGaxis::SetLabelSizevoid SetLabelSize(Float_t labelsize)Definition TGaxis.h:107; TGraphAsymmErrors::Classstatic TClass * Class(); TGraphBentErrors::Classstatic TClass * Class(); TGraphErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraphErrors.h:69; TGraphErrors::Classstatic TClass * Class(); TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::Classstatic TClass * Class(); TGraphPainterThe graph painter class.Definition TGraphPainter.h:31; TGraphPainter::PaintGraphPolarvoid PaintGraphPolar(TGraph *theGraph, Option_t *option)Paint this TGraphPolar with its current attributes.Definition TGraphPainter.cxx:3789; TGraphPainter::PaintGraphvoid PaintGraph(TGraph *theGraph, Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt) overrideControl function to draw a graph.Definition TGraphPainter.cxx:1283; TGraphPainter::PaintGraphErrorsvoid PaintGraphErrors(TGraph *theGraph, Option_t *option)Paint this TGraphErrors with its current attributes.Definition TGraphPainter.cxx:3499; TGraphPainter::PaintGraphAsymmErrorsvoid PaintGraphAsymmErrors(TGraph *theGraph, Option_t *option)Paint this TGraphAsymmErrors with its current attributes.Definition TGraphPainter.cxx:2429; TGraphPainter::PaintGraphMultiErrorsvoid PaintGraphMultiErrors",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:201361,Availability,error,errors,201361,"ter::gxworkstd::vector< Double_t > gxworkDefinition TGraphPainter.h:69; TGraphPainter::gyworkstd::vector< Double_t > gyworkDefinition TGraphPainter.h:69; TGraphPainter::PaintScattervoid PaintScatter(TScatter *theScatter, Option_t *option) overridePaint a scatter plot.Definition TGraphPainter.cxx:4392; TGraphPainter::Smoothvoid Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype)Smooth a curve given by N points.Definition TGraphPainter.cxx:4938; TGraphPainter::gyworklstd::vector< Double_t > gyworklInternal buffers for coordinates. Used for graphs painting.Definition TGraphPainter.h:69; TGraphPainter::SetHighlightvoid SetHighlight(TGraph *theGraph) overrideSet highlight (enable/disable) mode for theGraph.Definition TGraphPainter.cxx:1120; TGraphPainter::GetHighlightPointvirtual Int_t GetHighlightPoint(TGraph *theGraph) constReturn the highlighted point for theGraph.Definition TGraphPainter.cxx:1110; TGraphPainter::PaintGraphSimplevoid PaintGraphSimple(TGraph *theGraph, Option_t *option)Paint a simple graph, without errors bars.Definition TGraphPainter.cxx:4584; TGraphPainter::PaintGraphQQvoid PaintGraphQQ(TGraph *theGraph, Option_t *option)Paint this graphQQ. No options for the time being.Definition TGraphPainter.cxx:4084; TGraphPainter::~TGraphPainter~TGraphPainter() overrideDestructor.Definition TGraphPainter.cxx:675; TGraphPainter::SetMaxPointsPerLinestatic void SetMaxPointsPerLine(Int_t maxp=50)Static function to set fgMaxPointsPerLine for graph painting.Definition TGraphPainter.cxx:5407; TGraphPainter::PaintGraphBentErrorsvoid PaintGraphBentErrors(TGraph *theGraph, Option_t *option)Paint this TGraphBentErrors with its current attributes.Definition TGraphPainter.cxx:3182; TGraphPainter::TGraphPainterTGraphPainter()Default constructor.Definition TGraphPainter.cxx:667; TGraphPainter::PaintHelpervoid PaintHelper(TGraph *theGraph, Option_t *option) overridePaint a any kind of TGraph.Definition TGraphPainter.cxx:1211; TGraphPolarTo draw a p",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:211317,Availability,error,error,211317,"rideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCannotPick@ kCannotPickif object in a pad cannot be pickedDefinition TObject.h:67; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPaletteAxisThe palette painting class.Definition TPaletteAxis.h:28; TPaletteAxis::Paintvoid Paint(Option_t *option="""") overridePaint the palette.Definition TPaletteAxis.cxx:433; TPaletteAxis::SetNdivisionsvirtual void SetNdivisions(Int_t ndiv=10)Definition TPaletteAxis.h:57; TPaletteAxis::SetTitlevirtual void SetTitle(const char *title="""")Definition TPaletteAxis.h:68; TPaletteAxis::kHasView@ kHasViewDefinition TPaletteAxis.h:36; TPaletteAxis::SetTitleColorvirtual void SetTitleColor(Int_t co",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:3599,Deployability,update,updated,3599,"2 ; 73 ; 74\anchor GrP0; 75### Introduction; 76 ; 77Graphs are drawn via the painter `TGraphPainter` class. This class; 78implements techniques needed to display the various kind of; 79graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`.; 80 ; 81To draw a graph `graph` it's enough to do:; 82 ; 83 graph->Draw(""AL"");; 84 ; 85The option `AL` in the `Draw()` method means:; 86 ; 871. The axis should be drawn (option `A`),; 882. The graph should be drawn as a simple line (option `L`).; 89 ; 90 By default a graph is drawn in the current pad in the current coordinate system.; 91To define a suitable coordinate system and draw the axis the option; 92`A` must be specified.; 93 ; 94`TGraphPainter` offers many options to paint the various kind of graphs.; 95 ; 96It is separated from the graph classes so that one can have graphs without the; 97graphics overhead, for example in a batch program.; 98 ; 99When a displayed graph is modified, there is no need to call `Draw()` again; the; 100image will be refreshed the next time the pad will be updated. A pad is updated; 101after one of these three actions:; 102 ; 1031. a carriage return on the ROOT command line,; 1042. a click inside the pad,; 1053. a call to `TPad::Update`.; 106 ; 107\anchor GrP1; 108### Graphs' plotting options; 109Graphs can be drawn with the following options:; 110 ; 111| Option | Description |; 112|----------|-------------------------------------------------------------------|; 113| ""A"" | Produce a new plot with Axis around the graph |; 114| ""I"" | Combine with option 'A' it draws invisible axis |; 115| ""L"" | A simple polyline is drawn |; 116| ""F"" | A fill area is drawn ('CF' draw a smoothed fill area) |; 117| ""C"" | A smooth Curve is drawn |; 118| ""*"" | A Star is plotted at each point |; 119| ""P"" | The current marker is plotted at each point |; 120| ""B"" | A Bar chart is drawn |; 121| ""1"" | When a graph is drawn as a bar chart, this option makes the bars start from the bottom of the pad",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:3617,Deployability,update,updated,3617," class; 78implements techniques needed to display the various kind of; 79graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`.; 80 ; 81To draw a graph `graph` it's enough to do:; 82 ; 83 graph->Draw(""AL"");; 84 ; 85The option `AL` in the `Draw()` method means:; 86 ; 871. The axis should be drawn (option `A`),; 882. The graph should be drawn as a simple line (option `L`).; 89 ; 90 By default a graph is drawn in the current pad in the current coordinate system.; 91To define a suitable coordinate system and draw the axis the option; 92`A` must be specified.; 93 ; 94`TGraphPainter` offers many options to paint the various kind of graphs.; 95 ; 96It is separated from the graph classes so that one can have graphs without the; 97graphics overhead, for example in a batch program.; 98 ; 99When a displayed graph is modified, there is no need to call `Draw()` again; the; 100image will be refreshed the next time the pad will be updated. A pad is updated; 101after one of these three actions:; 102 ; 1031. a carriage return on the ROOT command line,; 1042. a click inside the pad,; 1053. a call to `TPad::Update`.; 106 ; 107\anchor GrP1; 108### Graphs' plotting options; 109Graphs can be drawn with the following options:; 110 ; 111| Option | Description |; 112|----------|-------------------------------------------------------------------|; 113| ""A"" | Produce a new plot with Axis around the graph |; 114| ""I"" | Combine with option 'A' it draws invisible axis |; 115| ""L"" | A simple polyline is drawn |; 116| ""F"" | A fill area is drawn ('CF' draw a smoothed fill area) |; 117| ""C"" | A smooth Curve is drawn |; 118| ""*"" | A Star is plotted at each point |; 119| ""P"" | The current marker is plotted at each point |; 120| ""B"" | A Bar chart is drawn |; 121| ""1"" | When a graph is drawn as a bar chart, this option makes the bars start from the bottom of the pad. By default they start at 0. |; 122| ""X+"" | The X-axis is drawn on the top side of the plot. |; 123| ""Y+"" | The",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:30521,Deployability,release,released,30521,"//must be o and not dist in case of TMultiGraph; 786 }; 787 }; 788 ; 789 return distance;; 790}; 791 ; 792 ; 793////////////////////////////////////////////////////////////////////////////////; 794/// Display a panel with all histogram drawing options.; 795 ; 796void TGraphPainter::DrawPanelHelper(TGraph *theGraph); 797{; 798 ; 799 if (!gPad) {; 800 Error(""DrawPanel"", ""need to draw graph first"");; 801 return;; 802 }; 803 TVirtualPadEditor *editor = TVirtualPadEditor::GetPadEditor();; 804 editor->Show();; 805 gROOT->ProcessLine(TString::Format(""((TCanvas*)0x%zx)->Selected((TVirtualPad*)0x%zx,(TObject*)0x%zx,1)"",; 806 (size_t)gPad->GetCanvas(), (size_t)gPad, (size_t)theGraph));; 807}; 808 ; 809 ; 810////////////////////////////////////////////////////////////////////////////////; 811/// Execute action corresponding to one event.; 812///; 813/// This member function is called when a graph is clicked with the locator.; 814///; 815/// If the left mouse button is clicked on one of the line end points, this point; 816/// follows the cursor until button is released.; 817///; 818/// If the middle mouse button clicked, the line is moved parallel to itself; 819/// until the button is released.; 820 ; 821void TGraphPainter::ExecuteEventHelper(TGraph *theGraph, Int_t event, Int_t px, Int_t py); 822{; 823 ; 824 if (!gPad) return;; 825 ; 826 Int_t i, d;; 827 Double_t xmin, xmax, ymin, ymax, dx, dy, dxr, dyr;; 828 const Int_t kMaxDiff = 10;//3;; 829 static Bool_t middle, badcase;; 830 static Int_t ipoint, pxp, pyp;; 831 static Int_t px1,px2,py1,py2;; 832 static Int_t pxold, pyold, px1old, py1old, px2old, py2old;; 833 static Int_t dpx, dpy;; 834 static std::vector<Int_t> x, y;; 835 Bool_t opaque = gPad->OpaqueMoving();; 836 ; 837 if (!theGraph->IsEditable() || theGraph->InheritsFrom(TGraphPolar::Class())) {; 838 gPad->SetCursor(kHand);; 839 return;; 840 }; 841 if (!gPad->IsEditable()) return;; 842 Int_t theNpoints = theGraph->GetN();; 843 Double_t *theX = theGraph->GetX();; 844 Doubl",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:30648,Deployability,release,released,30648,"///////////////////////////////////////////////////////; 794/// Display a panel with all histogram drawing options.; 795 ; 796void TGraphPainter::DrawPanelHelper(TGraph *theGraph); 797{; 798 ; 799 if (!gPad) {; 800 Error(""DrawPanel"", ""need to draw graph first"");; 801 return;; 802 }; 803 TVirtualPadEditor *editor = TVirtualPadEditor::GetPadEditor();; 804 editor->Show();; 805 gROOT->ProcessLine(TString::Format(""((TCanvas*)0x%zx)->Selected((TVirtualPad*)0x%zx,(TObject*)0x%zx,1)"",; 806 (size_t)gPad->GetCanvas(), (size_t)gPad, (size_t)theGraph));; 807}; 808 ; 809 ; 810////////////////////////////////////////////////////////////////////////////////; 811/// Execute action corresponding to one event.; 812///; 813/// This member function is called when a graph is clicked with the locator.; 814///; 815/// If the left mouse button is clicked on one of the line end points, this point; 816/// follows the cursor until button is released.; 817///; 818/// If the middle mouse button clicked, the line is moved parallel to itself; 819/// until the button is released.; 820 ; 821void TGraphPainter::ExecuteEventHelper(TGraph *theGraph, Int_t event, Int_t px, Int_t py); 822{; 823 ; 824 if (!gPad) return;; 825 ; 826 Int_t i, d;; 827 Double_t xmin, xmax, ymin, ymax, dx, dy, dxr, dyr;; 828 const Int_t kMaxDiff = 10;//3;; 829 static Bool_t middle, badcase;; 830 static Int_t ipoint, pxp, pyp;; 831 static Int_t px1,px2,py1,py2;; 832 static Int_t pxold, pyold, px1old, py1old, px2old, py2old;; 833 static Int_t dpx, dpy;; 834 static std::vector<Int_t> x, y;; 835 Bool_t opaque = gPad->OpaqueMoving();; 836 ; 837 if (!theGraph->IsEditable() || theGraph->InheritsFrom(TGraphPolar::Class())) {; 838 gPad->SetCursor(kHand);; 839 return;; 840 }; 841 if (!gPad->IsEditable()) return;; 842 Int_t theNpoints = theGraph->GetN();; 843 Double_t *theX = theGraph->GetX();; 844 Double_t *theY = theGraph->GetY();; 845 ; 846 switch (event) {; 847 ; 848 case kButton1Down:; 849 badcase = kFALSE;; 850 gVirtualX->SetLineCol",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:37448,Deployability,update,update,37448,">DrawLine(pxp+4, pyp+4, pxp-4, pyp+4);; 964 gVirtualX->DrawLine(pxp-4, pyp+4, pxp-4, pyp-4);; 965 } else {; 966 if (px1old) gVirtualX->DrawLine(px1old, py1old, pxold, pyold);; 967 if (px2old) gVirtualX->DrawLine(pxold, pyold, px2old, py2old);; 968 gVirtualX->DrawLine(pxold-4, pyold-4, pxold+4, pyold-4);; 969 gVirtualX->DrawLine(pxold+4, pyold-4, pxold+4, pyold+4);; 970 gVirtualX->DrawLine(pxold+4, pyold+4, pxold-4, pyold+4);; 971 gVirtualX->DrawLine(pxold-4, pyold+4, pxold-4, pyold-4);; 972 pxold = px;; 973 pxold = TMath::Max(pxold, px1);; 974 pxold = TMath::Min(pxold, px2);; 975 pyold = py;; 976 pyold = TMath::Max(pyold, py2);; 977 pyold = TMath::Min(pyold, py1);; 978 if (px1old) gVirtualX->DrawLine(px1old, py1old, pxold, pyold);; 979 if (px2old) gVirtualX->DrawLine(pxold, pyold, px2old, py2old);; 980 gVirtualX->DrawLine(pxold-4, pyold-4, pxold+4, pyold-4);; 981 gVirtualX->DrawLine(pxold+4, pyold-4, pxold+4, pyold+4);; 982 gVirtualX->DrawLine(pxold+4, pyold+4, pxold-4, pyold+4);; 983 gVirtualX->DrawLine(pxold-4, pyold+4, pxold-4, pyold-4);; 984 }; 985 } else {; 986 xmin = gPad->GetUxmin();; 987 xmax = gPad->GetUxmax();; 988 ymin = gPad->GetUymin();; 989 ymax = gPad->GetUymax();; 990 dx = xmax-xmin;; 991 dy = ymax-ymin;; 992 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 993 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 994 ; 995 if (theGraph->GetHistogram()) {; 996 // Range() could change the size of the pad pixmap and therefore should; 997 // be called before the other paint routines; 998 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 999 ymin - dyr*gPad->GetBottomMargin(),; 1000 xmax + dxr*gPad->GetRightMargin(),; 1001 ymax + dyr*gPad->GetTopMargin());; 1002 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 1003 }; 1004 if (middle) {; 1005 dpx += px - pxold;; 1006 dpy += py - pyold;; 1007 pxold = px;; 1008 pyold = py;; 1009 for(i=0;i<theNpoints;i++) {; 1010 if (badcase) continue; //do not update if big zoom and points moved; 1011 if (!x.",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:39391,Deployability,update,update,39391,"aph->InheritsFrom(""TCutG"")) {; 1024 //make sure first and last point are the same; 1025 if (ipoint == 0) {; 1026 theX[theNpoints-1] = theX[0];; 1027 theY[theNpoints-1] = theY[0];; 1028 }; 1029 if (ipoint == theNpoints-1) {; 1030 theX[0] = theX[theNpoints-1];; 1031 theY[0] = theY[theNpoints-1];; 1032 }; 1033 }; 1034 }; 1035 badcase = kFALSE;; 1036 gPad->Modified(kTRUE);; 1037 //gPad->Update();; 1038 }; 1039 break;; 1040 ; 1041 case kButton1Up:; 1042 ; 1043 if (gROOT->IsEscaped()) {; 1044 gROOT->SetEscape(kFALSE);; 1045 x.clear();; 1046 y.clear();; 1047 break;; 1048 }; 1049 ; 1050 // Compute x,y range; 1051 xmin = gPad->GetUxmin();; 1052 xmax = gPad->GetUxmax();; 1053 ymin = gPad->GetUymin();; 1054 ymax = gPad->GetUymax();; 1055 dx = xmax-xmin;; 1056 dy = ymax-ymin;; 1057 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 1058 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 1059 ; 1060 if (theGraph->GetHistogram()) {; 1061 // Range() could change the size of the pad pixmap and therefore should; 1062 // be called before the other paint routines; 1063 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 1064 ymin - dyr*gPad->GetBottomMargin(),; 1065 xmax + dxr*gPad->GetRightMargin(),; 1066 ymax + dyr*gPad->GetTopMargin());; 1067 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 1068 }; 1069 if (middle) {; 1070 for(i=0;i<theNpoints;i++) {; 1071 if (badcase) continue; //do not update if big zoom and points moved; 1072 if (!x.empty()) theX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 1073 if (!y.empty()) theY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 1074 }; 1075 } else {; 1076 theX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 1077 theY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 1078 if (theGraph->InheritsFrom(""TCutG"")) {; 1079 //make sure first and last point are the same; 1080 if (ipoint == 0) {; 1081 theX[theNpoints-1] = theX[0];; 1082 theY[theNpoints-1] = theY[0];; 1083 }; 1084 if (ipoint == theNpoints-1) {; 1085 theX[0] = theX[th",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:172499,Deployability,continuous,continuous,172499,"= 0 && parmin >= parmax) continue;; 4898 if (print_ferrors) {; 4899 snprintf(textstats,50,""%-8s = %s%s #pm %s%s "",fit->GetParName(ipar),""%"",stats->GetFitFormat(),""%"",stats->GetFitFormat());; 4900 snprintf(t,64,textstats,fit->GetParameter(ipar); 4901 ,fit->GetParError(ipar));; 4902 } else {; 4903 snprintf(textstats,50,""%-8s = %s%s "",fit->GetParName(ipar),""%"",stats->GetFitFormat());; 4904 snprintf(t,64,textstats,fit->GetParameter(ipar));; 4905 }; 4906 t[63] = 0;; 4907 stats->AddText(t);; 4908 }; 4909 }; 4910 ; 4911 if (!done) functions->Add(stats);; 4912 stats->Paint();; 4913}; 4914 ; 4915 ; 4916////////////////////////////////////////////////////////////////////////////////; 4917/// Smooth a curve given by N points.; 4918///; 4919/// The original code is from an underlaying routine for Draw based on the; 4920/// CERN GD3 routine TVIPTE:; 4921///; 4922/// Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; 4923///; 4924/// This method draws a smooth tangentially continuous curve through; 4925/// the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)).; 4926/// The curve is approximated by a polygonal arc of short vectors.; 4927/// The data points can represent open curves, P(1) != P(N) or closed; 4928/// curves P(2) == P(N). If a tangential discontinuity at P(I) is; 4929/// required, then set P(I)=P(I+1). Loops are also allowed.; 4930///; 4931/// Reference Marlow and Powell, Harwell report No.R.7092.1972; 4932/// MCCONALOGUE, Computer Journal VOL.13, NO4, NOV1970P p392 6; 4933///; 4934/// - npoints : Number of data points.; 4935/// - x : Abscissa; 4936/// - y : Ordinate; 4937 ; 4938void TGraphPainter::Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype); 4939{; 4940 ; 4941 Int_t i, k, kp, km, npointsMax, banksize, n2, npt;; 4942 Int_t maxiterations, finished;; 4943 Int_t jtype, ktype, closed;; 4944 Double_t sxmin, sxmax, symin, symax;; 4945 Double_t delta;; 4946 Double_t xorg, yorg;; 4947 Double_t ratio_signs, xratio, yratio;",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:176984,Deployability,continuous,continuous,176984,"symin)) closed = 1;; 5023 if (sxmin == sxmax) {; 5024 xratio = 1;; 5025 } else {; 5026 if (six > 1) ratio_signs = siy/six;; 5027 else ratio_signs = 20;; 5028 xratio = ratio_signs/(sxmax-sxmin);; 5029 }; 5030 if (symin == symax) yratio = 1;; 5031 else yratio = 1/(symax-symin);; 5032 ; 5033 qlx[0] = x[0];; 5034 qly[0] = y[0];; 5035 for (i=0;i<npoints;i++) {; 5036 x[i] = (x[i]-sxmin)*xratio;; 5037 y[i] = (y[i]-symin)*yratio;; 5038 }; 5039 ; 5040 // ""finished"" is minus one if we must draw a straight line from P(k-1); 5041 // to P(k). ""finished"" is one if the last call to PaintPolyLine has < n2; 5042 // points. ""finished"" is zero otherwise. npt counts the X and Y; 5043 // coordinates in work . When npt=n2 a call to IPL is made.; 5044 ; 5045 finished = 0;; 5046 npt = 1;; 5047 k = 1;; 5048 ; 5049 // Convert coordinates back to original system; 5050 ; 5051 // Separate the set of data points into arcs P(k-1),P(k).; 5052 // Calculate the direction cosines. first consider whether; 5053 // there is a continuous tangent at the endpoints.; 5054 ; 5055 if (!closed) {; 5056 if (x[0] != x[npoints-1] || y[0] != y[npoints-1]) goto L40;; 5057 if (x[npoints-2] == x[npoints-1] && y[npoints-2] == y[npoints-1]) goto L40;; 5058 if (x[0] == x[1] && y[0] == y[1]) goto L40;; 5059 }; 5060 flgic = kFALSE;; 5061 flgis = kTRUE;; 5062 ; 5063 // flgic is true if the curve is open and false if it is closed.; 5064 // flgis is true in the main loop, but is false if there is; 5065 // a deviation from the main loop.; 5066 ; 5067 km = npoints - 1;; 5068 ; 5069 // Calculate direction cosines at P(1) using P(N-1),P(1),P(2).; 5070 ; 5071 goto L100;; 5072L40:; 5073 flgic = kTRUE;; 5074 flgis = kFALSE;; 5075 ; 5076 // Skip excessive consecutive equal points.; 5077 ; 5078L50:; 5079 if (k >= npoints) {; 5080 finished = 1; // Prepare to clear out remaining short vectors before returning; 5081 if (npt > 1) goto L310;; 5082 goto L390;; 5083 }; 5084 k++;; 5085 if (x[k-1] == x[k-2] && y[k-1] == y[k-2]) goto L50;; 508",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:205579,Deployability,continuous,continuous,205579,"aph.h:148; TGraph::IsEditablevirtual Bool_t IsEditable() constDefinition TGraph.h:166; TGraph::kClipFrame@ kClipFrameClip to the frame boundary.Definition TGraph.h:76; TGraph::kNoStats@ kNoStatsDon't draw stats box.Definition TGraph.h:75; TGraph::GetMinimumDouble_t GetMinimum() constDefinition TGraph.h:152; TGraph::GetEYlowvirtual Double_t * GetEYlow() constDefinition TGraph.h:146; TGraph::GetEXvirtual Double_t * GetEX() constDefinition TGraph.h:141; TGraph::GetMaximumDouble_t GetMaximum() constDefinition TGraph.h:151; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::GetEXlowdvirtual Double_t * GetEXlowd() constDefinition TGraph.h:147; TGraph::ComputeRangevirtual void ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) constCompute the x/y range of the points in this graph.Definition TGraph.cxx:731; TGraph::GetEYlowdvirtual Double_t * GetEYlowd() constDefinition TGraph.h:149; TGraph::Zerovoid Zero(Int_t &k, Double_t AZ, Double_t BZ, Double_t E2, Double_t &X, Double_t &Y, Int_t maxiterations)Find zero of a continuous function.Definition TGraph.cxx:2717; TGraph::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TGraph.h:126; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TGraph::IsHighlightvirtual Bool_t IsHighlight() constDefinition TGraph.h:167; TGraph::GetEYhighdvirtual Double_t * GetEYhighd() constDefinition TGraph.h:150; TGraph::GetXaxisTAxis * GetXaxis() constGet x axis of the graph.Definition TGraph.cxx:1566; TGraph::GetEXhighvirtual Double_t * GetEXhigh() constDefinition TGraph.h:143; TGraph::GetEYhighvirtual Double_t * GetEYhigh() constDefinition TGraph.h:145; TGraph::GetYaxisTAxis * GetYaxis() constGet y axis of the graph.Definition TGraph.cxx:1575; TGraph::GetHistogramvirtual TH1F * GetHistogram() constReturns a pointer to the histogram used to draw the axis Takes into account the two following cases.Definition TGraph.cxx:1428; TGraph::GetEYvirtual Double_t * GetEY() constDefinition TGraph.h:14",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:222854,Energy Efficiency,power,power,222854,"Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; arrowDefinition RArrowDS.hxx:17; lTLine lDefinition textangle.C:4; DrawMarkerm DrawMarker(0.1, 0.1). histhistpaintersrcTGraphPainter.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:37033,Integrability,rout,routines,37033,">DrawLine(pxp+4, pyp+4, pxp-4, pyp+4);; 964 gVirtualX->DrawLine(pxp-4, pyp+4, pxp-4, pyp-4);; 965 } else {; 966 if (px1old) gVirtualX->DrawLine(px1old, py1old, pxold, pyold);; 967 if (px2old) gVirtualX->DrawLine(pxold, pyold, px2old, py2old);; 968 gVirtualX->DrawLine(pxold-4, pyold-4, pxold+4, pyold-4);; 969 gVirtualX->DrawLine(pxold+4, pyold-4, pxold+4, pyold+4);; 970 gVirtualX->DrawLine(pxold+4, pyold+4, pxold-4, pyold+4);; 971 gVirtualX->DrawLine(pxold-4, pyold+4, pxold-4, pyold-4);; 972 pxold = px;; 973 pxold = TMath::Max(pxold, px1);; 974 pxold = TMath::Min(pxold, px2);; 975 pyold = py;; 976 pyold = TMath::Max(pyold, py2);; 977 pyold = TMath::Min(pyold, py1);; 978 if (px1old) gVirtualX->DrawLine(px1old, py1old, pxold, pyold);; 979 if (px2old) gVirtualX->DrawLine(pxold, pyold, px2old, py2old);; 980 gVirtualX->DrawLine(pxold-4, pyold-4, pxold+4, pyold-4);; 981 gVirtualX->DrawLine(pxold+4, pyold-4, pxold+4, pyold+4);; 982 gVirtualX->DrawLine(pxold+4, pyold+4, pxold-4, pyold+4);; 983 gVirtualX->DrawLine(pxold-4, pyold+4, pxold-4, pyold-4);; 984 }; 985 } else {; 986 xmin = gPad->GetUxmin();; 987 xmax = gPad->GetUxmax();; 988 ymin = gPad->GetUymin();; 989 ymax = gPad->GetUymax();; 990 dx = xmax-xmin;; 991 dy = ymax-ymin;; 992 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 993 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 994 ; 995 if (theGraph->GetHistogram()) {; 996 // Range() could change the size of the pad pixmap and therefore should; 997 // be called before the other paint routines; 998 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 999 ymin - dyr*gPad->GetBottomMargin(),; 1000 xmax + dxr*gPad->GetRightMargin(),; 1001 ymax + dyr*gPad->GetTopMargin());; 1002 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 1003 }; 1004 if (middle) {; 1005 dpx += px - pxold;; 1006 dpy += py - pyold;; 1007 pxold = px;; 1008 pyold = py;; 1009 for(i=0;i<theNpoints;i++) {; 1010 if (badcase) continue; //do not update if big zoom and points moved; 1011 if (!x.",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:39060,Integrability,rout,routines,39060,"aph->InheritsFrom(""TCutG"")) {; 1024 //make sure first and last point are the same; 1025 if (ipoint == 0) {; 1026 theX[theNpoints-1] = theX[0];; 1027 theY[theNpoints-1] = theY[0];; 1028 }; 1029 if (ipoint == theNpoints-1) {; 1030 theX[0] = theX[theNpoints-1];; 1031 theY[0] = theY[theNpoints-1];; 1032 }; 1033 }; 1034 }; 1035 badcase = kFALSE;; 1036 gPad->Modified(kTRUE);; 1037 //gPad->Update();; 1038 }; 1039 break;; 1040 ; 1041 case kButton1Up:; 1042 ; 1043 if (gROOT->IsEscaped()) {; 1044 gROOT->SetEscape(kFALSE);; 1045 x.clear();; 1046 y.clear();; 1047 break;; 1048 }; 1049 ; 1050 // Compute x,y range; 1051 xmin = gPad->GetUxmin();; 1052 xmax = gPad->GetUxmax();; 1053 ymin = gPad->GetUymin();; 1054 ymax = gPad->GetUymax();; 1055 dx = xmax-xmin;; 1056 dy = ymax-ymin;; 1057 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 1058 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 1059 ; 1060 if (theGraph->GetHistogram()) {; 1061 // Range() could change the size of the pad pixmap and therefore should; 1062 // be called before the other paint routines; 1063 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 1064 ymin - dyr*gPad->GetBottomMargin(),; 1065 xmax + dxr*gPad->GetRightMargin(),; 1066 ymax + dyr*gPad->GetTopMargin());; 1067 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 1068 }; 1069 if (middle) {; 1070 for(i=0;i<theNpoints;i++) {; 1071 if (badcase) continue; //do not update if big zoom and points moved; 1072 if (!x.empty()) theX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 1073 if (!y.empty()) theY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 1074 }; 1075 } else {; 1076 theX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 1077 theY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 1078 if (theGraph->InheritsFrom(""TCutG"")) {; 1079 //make sure first and last point are the same; 1080 if (ipoint == 0) {; 1081 theX[theNpoints-1] = theX[0];; 1082 theY[theNpoints-1] = theY[0];; 1083 }; 1084 if (ipoint == theNpoints-1) {; 1085 theX[0] = theX[th",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:172299,Integrability,rout,routine,172299,"al || print_ferrors) {; 4894 Double_t parmin,parmax;; 4895 for (Int_t ipar=0;ipar<fit->GetNpar();ipar++) {; 4896 fit->GetParLimits(ipar,parmin,parmax);; 4897 if (print_fval < 2 && parmin*parmax != 0 && parmin >= parmax) continue;; 4898 if (print_ferrors) {; 4899 snprintf(textstats,50,""%-8s = %s%s #pm %s%s "",fit->GetParName(ipar),""%"",stats->GetFitFormat(),""%"",stats->GetFitFormat());; 4900 snprintf(t,64,textstats,fit->GetParameter(ipar); 4901 ,fit->GetParError(ipar));; 4902 } else {; 4903 snprintf(textstats,50,""%-8s = %s%s "",fit->GetParName(ipar),""%"",stats->GetFitFormat());; 4904 snprintf(t,64,textstats,fit->GetParameter(ipar));; 4905 }; 4906 t[63] = 0;; 4907 stats->AddText(t);; 4908 }; 4909 }; 4910 ; 4911 if (!done) functions->Add(stats);; 4912 stats->Paint();; 4913}; 4914 ; 4915 ; 4916////////////////////////////////////////////////////////////////////////////////; 4917/// Smooth a curve given by N points.; 4918///; 4919/// The original code is from an underlaying routine for Draw based on the; 4920/// CERN GD3 routine TVIPTE:; 4921///; 4922/// Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; 4923///; 4924/// This method draws a smooth tangentially continuous curve through; 4925/// the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)).; 4926/// The curve is approximated by a polygonal arc of short vectors.; 4927/// The data points can represent open curves, P(1) != P(N) or closed; 4928/// curves P(2) == P(N). If a tangential discontinuity at P(I) is; 4929/// required, then set P(I)=P(I+1). Loops are also allowed.; 4930///; 4931/// Reference Marlow and Powell, Harwell report No.R.7092.1972; 4932/// MCCONALOGUE, Computer Journal VOL.13, NO4, NOV1970P p392 6; 4933///; 4934/// - npoints : Number of data points.; 4935/// - x : Abscissa; 4936/// - y : Ordinate; 4937 ; 4938void TGraphPainter::Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype); 4939{; 4940 ; 4941 Int_t i, k, kp, km, npointsMax, banksize, n2, npt;; 4942 Int_",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:172347,Integrability,rout,routine,172347,"al || print_ferrors) {; 4894 Double_t parmin,parmax;; 4895 for (Int_t ipar=0;ipar<fit->GetNpar();ipar++) {; 4896 fit->GetParLimits(ipar,parmin,parmax);; 4897 if (print_fval < 2 && parmin*parmax != 0 && parmin >= parmax) continue;; 4898 if (print_ferrors) {; 4899 snprintf(textstats,50,""%-8s = %s%s #pm %s%s "",fit->GetParName(ipar),""%"",stats->GetFitFormat(),""%"",stats->GetFitFormat());; 4900 snprintf(t,64,textstats,fit->GetParameter(ipar); 4901 ,fit->GetParError(ipar));; 4902 } else {; 4903 snprintf(textstats,50,""%-8s = %s%s "",fit->GetParName(ipar),""%"",stats->GetFitFormat());; 4904 snprintf(t,64,textstats,fit->GetParameter(ipar));; 4905 }; 4906 t[63] = 0;; 4907 stats->AddText(t);; 4908 }; 4909 }; 4910 ; 4911 if (!done) functions->Add(stats);; 4912 stats->Paint();; 4913}; 4914 ; 4915 ; 4916////////////////////////////////////////////////////////////////////////////////; 4917/// Smooth a curve given by N points.; 4918///; 4919/// The original code is from an underlaying routine for Draw based on the; 4920/// CERN GD3 routine TVIPTE:; 4921///; 4922/// Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; 4923///; 4924/// This method draws a smooth tangentially continuous curve through; 4925/// the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)).; 4926/// The curve is approximated by a polygonal arc of short vectors.; 4927/// The data points can represent open curves, P(1) != P(N) or closed; 4928/// curves P(2) == P(N). If a tangential discontinuity at P(I) is; 4929/// required, then set P(I)=P(I+1). Loops are also allowed.; 4930///; 4931/// Reference Marlow and Powell, Harwell report No.R.7092.1972; 4932/// MCCONALOGUE, Computer Journal VOL.13, NO4, NOV1970P p392 6; 4933///; 4934/// - npoints : Number of data points.; 4935/// - x : Abscissa; 4936/// - y : Ordinate; 4937 ; 4938void TGraphPainter::Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype); 4939{; 4940 ; 4941 Int_t i, k, kp, km, npointsMax, banksize, n2, npt;; 4942 Int_",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:174994,Integrability,rout,routine,174994,"2 = dy2 = 0;; 4962 xt = yt = xa = xb = ya = yb = u1 = u2 = u3 = tj = sb = 0;; 4963 ; 4964 npointsMax = npoints*10;; 4965 n2 = npointsMax-2;; 4966 banksize = n2;; 4967 ; 4968 std::vector<Double_t> qlx(npointsMax);; 4969 std::vector<Double_t> qly(npointsMax);; 4970 if (qlx.empty() || qly.empty()) {; 4971 Error(""Smooth"", ""not enough space in memory"");; 4972 return;; 4973 }; 4974 ; 4975 // Decode the type of curve (draw type).; 4976 ; 4977 loptx = kFALSE;; 4978 jtype = (drawtype%1000)-10;; 4979 if (jtype > 0) { ktype = jtype; loptx = kTRUE; }; 4980 else ktype = drawtype%1000;; 4981 ; 4982 Double_t ruxmin = gPad->GetUxmin();; 4983 Double_t ruymin = gPad->GetUymin();; 4984 if (ktype == 3) {; 4985 xorg = ruxmin;; 4986 yorg = ruymin;; 4987 } else {; 4988 xorg = TMath::Max((Double_t)0,ruxmin);; 4989 yorg = TMath::Min(TMath::Max((Double_t)0,ruymin),gPad->GetUymax());; 4990 }; 4991 ; 4992 // delta is the accuracy required in constructing the curve.; 4993 // If it is zero then the routine calculates a value otherwise; 4994 // it uses this value. (default is 0.0); 4995 ; 4996 delta = 0.00055;; 4997 maxiterations = 20;; 4998 ; 4999 // Scale data to the range 0-ratio_signs in X, 0-1 in Y; 5000 // where ratio_signs is the ratio between the number of changes; 5001 // of sign in Y divided by the number of changes of sign in X; 5002 ; 5003 sxmin = x[0];; 5004 sxmax = x[0];; 5005 symin = y[0];; 5006 symax = y[0];; 5007 Double_t six = 1;; 5008 Double_t siy = 1;; 5009 for (i=1;i<npoints;i++) {; 5010 if (i > 1) {; 5011 if ((x[i]-x[i-1])*(x[i-1]-x[i-2]) < 0) six++;; 5012 if ((y[i]-y[i-1])*(y[i-1]-y[i-2]) < 0) siy++;; 5013 }; 5014 if (x[i] < sxmin) sxmin = x[i];; 5015 if (x[i] > sxmax) sxmax = x[i];; 5016 if (y[i] < symin) symin = y[i];; 5017 if (y[i] > symax) symax = y[i];; 5018 }; 5019 closed = 0;; 5020 Double_t dx1n = TMath::Abs(x[npoints-1]-x[0]);; 5021 Double_t dy1n = TMath::Abs(y[npoints-1]-y[0]);; 5022 if (dx1n < 0.01*(sxmax-sxmin) && dy1n < 0.01*(symax-symin)) closed = 1;; 5023 if (",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:208144,Integrability,rout,routine,208144,"stancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a line.Definition TH1.cxx:2823; TH1::GetMinimumStoredvirtual Double_t GetMinimumStored() constDefinition TH1.h:293; TH1::kNoTitle@ kNoTitleDon't draw the histogram title.Definition TH1.h:170; TH1::kNoStats@ kNoStatsDon't draw stats box.Definition TH1.h:165; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetMaximumvirtual Double_t GetMaximum(Double_t maxval=FLT_MAX) constReturn maximum value smaller than maxval of bins in the range, unless the value has been overridden b...Definition TH1.cxx:8545; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::GetNdivisionsvirtual Int_t GetNdivisions(Option_t *axis=""X"") constReturn the number of divisions for ""axis"".Definition Haxis.cxx:27; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::GetMaximumStoredvirtual Double_t GetMaximumStored() constDefinition TH1.h:289; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TIterDefinition TCollection.h:235; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::PaintLinevirtual void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:399; TListIterIterator of linked list.Definition TList.h:193; TListIter::NextTObject * Next() overrideRet",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:211323,Integrability,message,message,211323,"rideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCannotPick@ kCannotPickif object in a pad cannot be pickedDefinition TObject.h:67; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPaletteAxisThe palette painting class.Definition TPaletteAxis.h:28; TPaletteAxis::Paintvoid Paint(Option_t *option="""") overridePaint the palette.Definition TPaletteAxis.cxx:433; TPaletteAxis::SetNdivisionsvirtual void SetNdivisions(Int_t ndiv=10)Definition TPaletteAxis.h:57; TPaletteAxis::SetTitlevirtual void SetTitle(const char *title="""")Definition TPaletteAxis.h:68; TPaletteAxis::kHasView@ kHasViewDefinition TPaletteAxis.h:36; TPaletteAxis::SetTitleColorvirtual void SetTitleColor(Int_t co",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:25843,Modifiability,variab,variables,25843,"ht mode and user function</a>; 648(is fully equivalent as for histogram).; 649 ; 650NOTE all parameters of user function are taken from; 651 ; 652 void TCanvas::Highlighted(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); 653 ; 654 - `pad` is pointer to pad with highlighted graph; 655 - `obj` is pointer to highlighted graph; 656 - `x` is highlighted x-th (i-th) point for graph; 657 - `y` not in use (only for 2D histogram); 658 ; 659For more complex demo please see for example `$ROOTSYS/tutorials/math/hlquantiles.C` file.; 660 ; 661*/; 662 ; 663 ; 664////////////////////////////////////////////////////////////////////////////////; 665/// Default constructor; 666 ; 667TGraphPainter::TGraphPainter(); 668{; 669}; 670 ; 671 ; 672////////////////////////////////////////////////////////////////////////////////; 673/// Destructor.; 674 ; 675TGraphPainter::~TGraphPainter(); 676{; 677}; 678 ; 679 ; 680////////////////////////////////////////////////////////////////////////////////; 681/// Compute the logarithm of variables `gxwork` and `gywork`; 682/// according to the value of Options and put the results; 683/// in the variables `gxworkl` and `gyworkl`.; 684///; 685/// npoints : Number of points in gxwork and in gywork.; 686///; 687/// - opt = 1 ComputeLogs is called from PaintGrapHist; 688/// - opt = 0 ComputeLogs is called from PaintGraph; 689 ; 690void TGraphPainter::ComputeLogs(Int_t npoints, Int_t opt); 691{; 692 if (gPad->GetLogx()) {; 693 for (Int_t i = 0; i < npoints; i++) {; 694 gxworkl[i] = (gxwork[i] > 0.) ? TMath::Log10(gxwork[i]) : gPad->GetX1();; 695 }; 696 } else {; 697 for (Int_t i = 0; i < npoints; i++); 698 gxworkl[i] = gxwork[i];; 699 }; 700 if (!opt && gPad->GetLogy()) {; 701 for (Int_t i = 0; i < npoints; i++) {; 702 gyworkl[i] = (gywork[i] > 0.) ? TMath::Log10(gywork[i]) : gPad->GetY1();; 703 }; 704 } else {; 705 for (Int_t i = 0; i < npoints; i++); 706 gyworkl[i] = gywork[i];; 707 }; 708}; 709 ; 710 ; 711//////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:25952,Modifiability,variab,variables,25952,"ht mode and user function</a>; 648(is fully equivalent as for histogram).; 649 ; 650NOTE all parameters of user function are taken from; 651 ; 652 void TCanvas::Highlighted(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); 653 ; 654 - `pad` is pointer to pad with highlighted graph; 655 - `obj` is pointer to highlighted graph; 656 - `x` is highlighted x-th (i-th) point for graph; 657 - `y` not in use (only for 2D histogram); 658 ; 659For more complex demo please see for example `$ROOTSYS/tutorials/math/hlquantiles.C` file.; 660 ; 661*/; 662 ; 663 ; 664////////////////////////////////////////////////////////////////////////////////; 665/// Default constructor; 666 ; 667TGraphPainter::TGraphPainter(); 668{; 669}; 670 ; 671 ; 672////////////////////////////////////////////////////////////////////////////////; 673/// Destructor.; 674 ; 675TGraphPainter::~TGraphPainter(); 676{; 677}; 678 ; 679 ; 680////////////////////////////////////////////////////////////////////////////////; 681/// Compute the logarithm of variables `gxwork` and `gywork`; 682/// according to the value of Options and put the results; 683/// in the variables `gxworkl` and `gyworkl`.; 684///; 685/// npoints : Number of points in gxwork and in gywork.; 686///; 687/// - opt = 1 ComputeLogs is called from PaintGrapHist; 688/// - opt = 0 ComputeLogs is called from PaintGraph; 689 ; 690void TGraphPainter::ComputeLogs(Int_t npoints, Int_t opt); 691{; 692 if (gPad->GetLogx()) {; 693 for (Int_t i = 0; i < npoints; i++) {; 694 gxworkl[i] = (gxwork[i] > 0.) ? TMath::Log10(gxwork[i]) : gPad->GetX1();; 695 }; 696 } else {; 697 for (Int_t i = 0; i < npoints; i++); 698 gxworkl[i] = gxwork[i];; 699 }; 700 if (!opt && gPad->GetLogy()) {; 701 for (Int_t i = 0; i < npoints; i++) {; 702 gyworkl[i] = (gywork[i] > 0.) ? TMath::Log10(gywork[i]) : gPad->GetY1();; 703 }; 704 } else {; 705 for (Int_t i = 0; i < npoints; i++); 706 gyworkl[i] = gywork[i];; 707 }; 708}; 709 ; 710 ; 711//////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:199899,Modifiability,variab,variables,199899,"n TGraphPainter.cxx:4820; TGraphPainter::PaintPolyLineHatchesvoid PaintPolyLineHatches(TGraph *theGraph, Int_t n, const Double_t *x, const Double_t *y)Paint a polyline with hatches on one side showing an exclusion zone.Definition TGraphPainter.cxx:4620; TGraphPainter::DrawPanelHelpervoid DrawPanelHelper(TGraph *theGraph) overrideDisplay a panel with all histogram drawing options.Definition TGraphPainter.cxx:796; TGraphPainter::GetObjectInfoHelperchar * GetObjectInfoHelper(TGraph *theGraph, Int_t px, Int_t py) const overrideDefinition TGraphPainter.cxx:1101; TGraphPainter::ExecuteEventHelpervoid ExecuteEventHelper(TGraph *theGraph, Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGraphPainter.cxx:821; TGraphPainter::HighlightPointvirtual void HighlightPoint(TGraph *theGraph, Int_t hpoint, Int_t distance)Check on highlight point.Definition TGraphPainter.cxx:1136; TGraphPainter::ComputeLogsvoid ComputeLogs(Int_t npoints, Int_t opt)Compute the logarithm of variables gxwork and gywork according to the value of Options and put the re...Definition TGraphPainter.cxx:690; TGraphPainter::gxworklstd::vector< Double_t > gxworklDefinition TGraphPainter.h:69; TGraphPainter::DistancetoPrimitiveHelperInt_t DistancetoPrimitiveHelper(TGraph *theGraph, Int_t px, Int_t py) overrideCompute distance from point px,py to a graph.Definition TGraphPainter.cxx:717; TGraphPainter::gxworkstd::vector< Double_t > gxworkDefinition TGraphPainter.h:69; TGraphPainter::gyworkstd::vector< Double_t > gyworkDefinition TGraphPainter.h:69; TGraphPainter::PaintScattervoid PaintScatter(TScatter *theScatter, Option_t *option) overridePaint a scatter plot.Definition TGraphPainter.cxx:4392; TGraphPainter::Smoothvoid Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype)Smooth a curve given by N points.Definition TGraphPainter.cxx:4938; TGraphPainter::gyworklstd::vector< Double_t > gyworklInternal buffers for coordinates. Used for graphs pa",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:211169,Modifiability,inherit,inherits,211169,"efinition TNamed.cxx:94; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCannotPick@ kCannotPickif object in a pad cannot be pickedDefinition TObject.h:67; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPaletteAxisThe palette painting class.Definition TPaletteAxis.h:28; TPaletteAxis::Paintvoid Paint(Option_t *option="""") overridePaint the palette.Definition TPaletteAxis.cxx:433; TPaletteAxis::SetNdivisionsvirtual void SetNdivisions(Int_t ndiv=10)Definition TPaletteAxis.h:57; TPaletteAxis::SetTitlevirtual v",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:215474,Modifiability,variab,variables,215474," all lines in this pavetext.Definition TPaveText.cxx:217; TPaveText::Drawvoid Draw(Option_t *option="""") overrideDraw this pavetext with its current attributes.Definition TPaveText.cxx:242; TPaveText::Paintvoid Paint(Option_t *option="""") overridePaint this pavetext with its current attributes.Definition TPaveText.cxx:419; TPaveText::GetLinevirtual TText * GetLine(Int_t number) constGet Pointer to line number in this pavetext.Definition TPaveText.cxx:284; TPave::GetNameconst char * GetName() const overrideReturns name of object.Definition TPave.h:56; TPave::SetNamevirtual void SetName(const char *name="""")Definition TPave.h:79; TPave::SetBorderSizevirtual void SetBorderSize(Int_t bordersize=4)Sets the border size of the TPave box and shadow.Definition TPave.h:77; TPave::GetX1NDCDouble_t GetX1NDC() constDefinition TPave.h:59; TPave::SetX2NDCvirtual void SetX2NDC(Double_t x2)Definition TPave.h:83; TRegexpRegular expression class.Definition TRegexp.h:31; TScatterA TScatter is able to draw four variables scatter plot on a single plot.Definition TScatter.h:32; TScatter::GetGraphTGraph * GetGraph() constGet the graph holding X and Y positions.Definition TScatter.h:58; TScatter::GetMaxMarkerSizeDouble_t GetMaxMarkerSize() constGet the largest marker size used to paint the markers.Definition TScatter.h:56; TScatter::GetSizeDouble_t * GetSize() constGet the array of marker sizes.Definition TScatter.h:54; TScatter::GetHistogramTH2F * GetHistogram() constGet the graph histogram used for drawing axis.Definition TScatter.cxx:166; TScatter::GetColorDouble_t * GetColor() constGet the array of colors.Definition TScatter.h:53; TScatter::GetMinMarkerSizeDouble_t GetMinMarkerSize() constGet the smallest marker size used to paint the markers.Definition TScatter.h:57; TStringBasic string class.Definition TString.h:139; TString::CopyTString Copy() constCopy a string.Definition TString.cxx:529; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:221205,Performance,load,load,221205,"ormat() constDefinition TStyle.h:199; TStyle::GetStatFormatconst char * GetStatFormat() constDefinition TStyle.h:263; TStyle::GetNumberOfColorsInt_t GetNumberOfColors() constReturn number of colors in the color palette.Definition TStyle.cxx:1175; TStyle::GetOptFitInt_t GetOptFit() constDefinition TStyle.h:244; TStyle::GetStatFontStyle_t GetStatFont() constDefinition TStyle.h:260; TStyle::GetTitleFontSizeFloat_t GetTitleFontSize() constDefinition TStyle.h:274; TStyle::GetTitleAlignInt_t GetTitleAlign() constDefinition TStyle.h:270; TStyle::GetAxisColorColor_t GetAxisColor(Option_t *axis=""X"") constReturn the axis color number in the axis.Definition TStyle.cxx:1089; TStyle::GetTitleWFloat_t GetTitleW() constDefinition TStyle.h:282; TTextBase class for several text objects.Definition TText.h:22; TViewSee TView3D.Definition TView.h:25; TVirtualPadEditorAbstract base class used by ROOT graphics editor.Definition TVirtualPadEditor.h:27; TVirtualPadEditor::GetPadEditorstatic TVirtualPadEditor * GetPadEditor(Bool_t load=kTRUE)Returns the pad editor dialog. Static method.Definition TVirtualPadEditor.cxx:74; TVirtualPadEditor::Showvirtual void Show()Definition TVirtualPadEditor.h:49; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; bool; double; int; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probab",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:66132,Safety,risk,risky,66132,"9 ; 1760 first = 1;; 1761 last = npoints;; 1762 nbins = last - first + 1;; 1763 ; 1764 // Draw the Axis with a fixed number of division: 510; 1765 ; 1766 Double_t baroffset = gStyle->GetBarOffset();; 1767 Double_t barwidth = gStyle->GetBarWidth();; 1768 Double_t rwxmin = gPad->GetUxmin();; 1769 Double_t rwxmax = gPad->GetUxmax();; 1770 Double_t rwymin = gPad->GetUymin();; 1771 Double_t rwymax = gPad->GetUymax();; 1772 Double_t uxmin = gPad->PadtoX(rwxmin);; 1773 Double_t uxmax = gPad->PadtoX(rwxmax);; 1774 Double_t rounding = (uxmax-uxmin)*1.e-5;; 1775 drawborder = gStyle->GetDrawBorder();; 1776 if (optionAxis) {; 1777 Int_t nx1, nx2, ndivx, ndivy, ndiv;; 1778 choptaxis[0] = 0;; 1779 Double_t rwmin = rwxmin;; 1780 Double_t rwmax = rwxmax;; 1781 ndivx = gStyle->GetNdivisions(""X"");; 1782 ndivy = gStyle->GetNdivisions(""Y"");; 1783 if (ndivx > 1000) {; 1784 nx2 = ndivx/100;; 1785 nx1 = TMath::Max(1, ndivx%100);; 1786 ndivx = 100*nx2 + Int_t(Double_t(nx1)*gPad->GetAbsWNDC());; 1787 }; 1788 ndiv =TMath::Abs(ndivx);; 1789 // coverity [Calling risky function]; 1790 if (ndivx < 0) strlcat(choptaxis, ""N"",10);; 1791 if (gPad->GetGridx()) {; 1792 // coverity [Calling risky function]; 1793 strlcat(choptaxis, ""W"",10);; 1794 }; 1795 if (gPad->GetLogx()) {; 1796 rwmin = TMath::Power(10,rwxmin);; 1797 rwmax = TMath::Power(10,rwxmax);; 1798 // coverity [Calling risky function]; 1799 strlcat(choptaxis, ""G"",10);; 1800 }; 1801 TGaxis axis;; 1802 axis.SetLineColor(gStyle->GetAxisColor(""X""));; 1803 axis.SetTextColor(gStyle->GetLabelColor(""X""));; 1804 axis.SetTextFont(gStyle->GetLabelFont(""X""));; 1805 axis.SetLabelSize(gStyle->GetLabelSize(""X""));; 1806 axis.SetLabelOffset(gStyle->GetLabelOffset(""X""));; 1807 axis.SetTickSize(gStyle->GetTickLength(""X""));; 1808 ; 1809 axis.PaintAxis(rwxmin,rwymin,rwxmax,rwymin,rwmin,rwmax,ndiv,choptaxis);; 1810 ; 1811 choptaxis[0] = 0;; 1812 rwmin = rwymin;; 1813 rwmax = rwymax;; 1814 if (ndivy < 0) {; 1815 nx2 = ndivy/100;; 1816 nx1 = TMath::Max(1, ndivy%100);",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:66254,Safety,risk,risky,66254,"9 ; 1760 first = 1;; 1761 last = npoints;; 1762 nbins = last - first + 1;; 1763 ; 1764 // Draw the Axis with a fixed number of division: 510; 1765 ; 1766 Double_t baroffset = gStyle->GetBarOffset();; 1767 Double_t barwidth = gStyle->GetBarWidth();; 1768 Double_t rwxmin = gPad->GetUxmin();; 1769 Double_t rwxmax = gPad->GetUxmax();; 1770 Double_t rwymin = gPad->GetUymin();; 1771 Double_t rwymax = gPad->GetUymax();; 1772 Double_t uxmin = gPad->PadtoX(rwxmin);; 1773 Double_t uxmax = gPad->PadtoX(rwxmax);; 1774 Double_t rounding = (uxmax-uxmin)*1.e-5;; 1775 drawborder = gStyle->GetDrawBorder();; 1776 if (optionAxis) {; 1777 Int_t nx1, nx2, ndivx, ndivy, ndiv;; 1778 choptaxis[0] = 0;; 1779 Double_t rwmin = rwxmin;; 1780 Double_t rwmax = rwxmax;; 1781 ndivx = gStyle->GetNdivisions(""X"");; 1782 ndivy = gStyle->GetNdivisions(""Y"");; 1783 if (ndivx > 1000) {; 1784 nx2 = ndivx/100;; 1785 nx1 = TMath::Max(1, ndivx%100);; 1786 ndivx = 100*nx2 + Int_t(Double_t(nx1)*gPad->GetAbsWNDC());; 1787 }; 1788 ndiv =TMath::Abs(ndivx);; 1789 // coverity [Calling risky function]; 1790 if (ndivx < 0) strlcat(choptaxis, ""N"",10);; 1791 if (gPad->GetGridx()) {; 1792 // coverity [Calling risky function]; 1793 strlcat(choptaxis, ""W"",10);; 1794 }; 1795 if (gPad->GetLogx()) {; 1796 rwmin = TMath::Power(10,rwxmin);; 1797 rwmax = TMath::Power(10,rwxmax);; 1798 // coverity [Calling risky function]; 1799 strlcat(choptaxis, ""G"",10);; 1800 }; 1801 TGaxis axis;; 1802 axis.SetLineColor(gStyle->GetAxisColor(""X""));; 1803 axis.SetTextColor(gStyle->GetLabelColor(""X""));; 1804 axis.SetTextFont(gStyle->GetLabelFont(""X""));; 1805 axis.SetLabelSize(gStyle->GetLabelSize(""X""));; 1806 axis.SetLabelOffset(gStyle->GetLabelOffset(""X""));; 1807 axis.SetTickSize(gStyle->GetTickLength(""X""));; 1808 ; 1809 axis.PaintAxis(rwxmin,rwymin,rwxmax,rwymin,rwmin,rwmax,ndiv,choptaxis);; 1810 ; 1811 choptaxis[0] = 0;; 1812 rwmin = rwymin;; 1813 rwmax = rwymax;; 1814 if (ndivy < 0) {; 1815 nx2 = ndivy/100;; 1816 nx1 = TMath::Max(1, ndivy%100);",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:66446,Safety,risk,risky,66446,"9 ; 1760 first = 1;; 1761 last = npoints;; 1762 nbins = last - first + 1;; 1763 ; 1764 // Draw the Axis with a fixed number of division: 510; 1765 ; 1766 Double_t baroffset = gStyle->GetBarOffset();; 1767 Double_t barwidth = gStyle->GetBarWidth();; 1768 Double_t rwxmin = gPad->GetUxmin();; 1769 Double_t rwxmax = gPad->GetUxmax();; 1770 Double_t rwymin = gPad->GetUymin();; 1771 Double_t rwymax = gPad->GetUymax();; 1772 Double_t uxmin = gPad->PadtoX(rwxmin);; 1773 Double_t uxmax = gPad->PadtoX(rwxmax);; 1774 Double_t rounding = (uxmax-uxmin)*1.e-5;; 1775 drawborder = gStyle->GetDrawBorder();; 1776 if (optionAxis) {; 1777 Int_t nx1, nx2, ndivx, ndivy, ndiv;; 1778 choptaxis[0] = 0;; 1779 Double_t rwmin = rwxmin;; 1780 Double_t rwmax = rwxmax;; 1781 ndivx = gStyle->GetNdivisions(""X"");; 1782 ndivy = gStyle->GetNdivisions(""Y"");; 1783 if (ndivx > 1000) {; 1784 nx2 = ndivx/100;; 1785 nx1 = TMath::Max(1, ndivx%100);; 1786 ndivx = 100*nx2 + Int_t(Double_t(nx1)*gPad->GetAbsWNDC());; 1787 }; 1788 ndiv =TMath::Abs(ndivx);; 1789 // coverity [Calling risky function]; 1790 if (ndivx < 0) strlcat(choptaxis, ""N"",10);; 1791 if (gPad->GetGridx()) {; 1792 // coverity [Calling risky function]; 1793 strlcat(choptaxis, ""W"",10);; 1794 }; 1795 if (gPad->GetLogx()) {; 1796 rwmin = TMath::Power(10,rwxmin);; 1797 rwmax = TMath::Power(10,rwxmax);; 1798 // coverity [Calling risky function]; 1799 strlcat(choptaxis, ""G"",10);; 1800 }; 1801 TGaxis axis;; 1802 axis.SetLineColor(gStyle->GetAxisColor(""X""));; 1803 axis.SetTextColor(gStyle->GetLabelColor(""X""));; 1804 axis.SetTextFont(gStyle->GetLabelFont(""X""));; 1805 axis.SetLabelSize(gStyle->GetLabelSize(""X""));; 1806 axis.SetLabelOffset(gStyle->GetLabelOffset(""X""));; 1807 axis.SetTickSize(gStyle->GetTickLength(""X""));; 1808 ; 1809 axis.PaintAxis(rwxmin,rwymin,rwxmax,rwymin,rwmin,rwmax,ndiv,choptaxis);; 1810 ; 1811 choptaxis[0] = 0;; 1812 rwmin = rwymin;; 1813 rwmax = rwymax;; 1814 if (ndivy < 0) {; 1815 nx2 = ndivy/100;; 1816 nx1 = TMath::Max(1, ndivy%100);",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:67175,Safety,risk,risky,67175,"dx()) {; 1792 // coverity [Calling risky function]; 1793 strlcat(choptaxis, ""W"",10);; 1794 }; 1795 if (gPad->GetLogx()) {; 1796 rwmin = TMath::Power(10,rwxmin);; 1797 rwmax = TMath::Power(10,rwxmax);; 1798 // coverity [Calling risky function]; 1799 strlcat(choptaxis, ""G"",10);; 1800 }; 1801 TGaxis axis;; 1802 axis.SetLineColor(gStyle->GetAxisColor(""X""));; 1803 axis.SetTextColor(gStyle->GetLabelColor(""X""));; 1804 axis.SetTextFont(gStyle->GetLabelFont(""X""));; 1805 axis.SetLabelSize(gStyle->GetLabelSize(""X""));; 1806 axis.SetLabelOffset(gStyle->GetLabelOffset(""X""));; 1807 axis.SetTickSize(gStyle->GetTickLength(""X""));; 1808 ; 1809 axis.PaintAxis(rwxmin,rwymin,rwxmax,rwymin,rwmin,rwmax,ndiv,choptaxis);; 1810 ; 1811 choptaxis[0] = 0;; 1812 rwmin = rwymin;; 1813 rwmax = rwymax;; 1814 if (ndivy < 0) {; 1815 nx2 = ndivy/100;; 1816 nx1 = TMath::Max(1, ndivy%100);; 1817 ndivy = 100*nx2 + Int_t(Double_t(nx1)*gPad->GetAbsHNDC());; 1818 // coverity [Calling risky function]; 1819 strlcat(choptaxis, ""N"",10);; 1820 }; 1821 ndiv =TMath::Abs(ndivy);; 1822 if (gPad->GetGridy()) {; 1823 // coverity [Calling risky function]; 1824 strlcat(choptaxis, ""W"",10);; 1825 }; 1826 if (gPad->GetLogy()) {; 1827 rwmin = TMath::Power(10,rwymin);; 1828 rwmax = TMath::Power(10,rwymax);; 1829 // coverity [Calling risky function]; 1830 strlcat(choptaxis,""G"",10);; 1831 }; 1832 axis.SetLineColor(gStyle->GetAxisColor(""Y""));; 1833 axis.SetTextColor(gStyle->GetLabelColor(""Y""));; 1834 axis.SetTextFont(gStyle->GetLabelFont(""Y""));; 1835 axis.SetLabelSize(gStyle->GetLabelSize(""Y""));; 1836 axis.SetLabelOffset(gStyle->GetLabelOffset(""Y""));; 1837 axis.SetTickSize(gStyle->GetTickLength(""Y""));; 1838 ; 1839 axis.PaintAxis(rwxmin,rwymin,rwxmin,rwymax,rwmin,rwmax,ndiv,choptaxis);; 1840 }; 1841 ; 1842 ; 1843 // Set attributes; 1844 theGraph->TAttLine::Modify();; 1845 theGraph->TAttFill::Modify();; 1846 theGraph->TAttMarker::Modify();; 1847 ; 1848 // Min-Max scope; 1849 ; 1850 if (!optionRot) {wmin = x[0]; wmax = x[1];}; 1851",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:67321,Safety,risk,risky,67321,"dx()) {; 1792 // coverity [Calling risky function]; 1793 strlcat(choptaxis, ""W"",10);; 1794 }; 1795 if (gPad->GetLogx()) {; 1796 rwmin = TMath::Power(10,rwxmin);; 1797 rwmax = TMath::Power(10,rwxmax);; 1798 // coverity [Calling risky function]; 1799 strlcat(choptaxis, ""G"",10);; 1800 }; 1801 TGaxis axis;; 1802 axis.SetLineColor(gStyle->GetAxisColor(""X""));; 1803 axis.SetTextColor(gStyle->GetLabelColor(""X""));; 1804 axis.SetTextFont(gStyle->GetLabelFont(""X""));; 1805 axis.SetLabelSize(gStyle->GetLabelSize(""X""));; 1806 axis.SetLabelOffset(gStyle->GetLabelOffset(""X""));; 1807 axis.SetTickSize(gStyle->GetTickLength(""X""));; 1808 ; 1809 axis.PaintAxis(rwxmin,rwymin,rwxmax,rwymin,rwmin,rwmax,ndiv,choptaxis);; 1810 ; 1811 choptaxis[0] = 0;; 1812 rwmin = rwymin;; 1813 rwmax = rwymax;; 1814 if (ndivy < 0) {; 1815 nx2 = ndivy/100;; 1816 nx1 = TMath::Max(1, ndivy%100);; 1817 ndivy = 100*nx2 + Int_t(Double_t(nx1)*gPad->GetAbsHNDC());; 1818 // coverity [Calling risky function]; 1819 strlcat(choptaxis, ""N"",10);; 1820 }; 1821 ndiv =TMath::Abs(ndivy);; 1822 if (gPad->GetGridy()) {; 1823 // coverity [Calling risky function]; 1824 strlcat(choptaxis, ""W"",10);; 1825 }; 1826 if (gPad->GetLogy()) {; 1827 rwmin = TMath::Power(10,rwymin);; 1828 rwmax = TMath::Power(10,rwymax);; 1829 // coverity [Calling risky function]; 1830 strlcat(choptaxis,""G"",10);; 1831 }; 1832 axis.SetLineColor(gStyle->GetAxisColor(""Y""));; 1833 axis.SetTextColor(gStyle->GetLabelColor(""Y""));; 1834 axis.SetTextFont(gStyle->GetLabelFont(""Y""));; 1835 axis.SetLabelSize(gStyle->GetLabelSize(""Y""));; 1836 axis.SetLabelOffset(gStyle->GetLabelOffset(""Y""));; 1837 axis.SetTickSize(gStyle->GetTickLength(""Y""));; 1838 ; 1839 axis.PaintAxis(rwxmin,rwymin,rwxmin,rwymax,rwmin,rwmax,ndiv,choptaxis);; 1840 }; 1841 ; 1842 ; 1843 // Set attributes; 1844 theGraph->TAttLine::Modify();; 1845 theGraph->TAttFill::Modify();; 1846 theGraph->TAttMarker::Modify();; 1847 ; 1848 // Min-Max scope; 1849 ; 1850 if (!optionRot) {wmin = x[0]; wmax = x[1];}; 1851",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:67513,Safety,risk,risky,67513,"dx()) {; 1792 // coverity [Calling risky function]; 1793 strlcat(choptaxis, ""W"",10);; 1794 }; 1795 if (gPad->GetLogx()) {; 1796 rwmin = TMath::Power(10,rwxmin);; 1797 rwmax = TMath::Power(10,rwxmax);; 1798 // coverity [Calling risky function]; 1799 strlcat(choptaxis, ""G"",10);; 1800 }; 1801 TGaxis axis;; 1802 axis.SetLineColor(gStyle->GetAxisColor(""X""));; 1803 axis.SetTextColor(gStyle->GetLabelColor(""X""));; 1804 axis.SetTextFont(gStyle->GetLabelFont(""X""));; 1805 axis.SetLabelSize(gStyle->GetLabelSize(""X""));; 1806 axis.SetLabelOffset(gStyle->GetLabelOffset(""X""));; 1807 axis.SetTickSize(gStyle->GetTickLength(""X""));; 1808 ; 1809 axis.PaintAxis(rwxmin,rwymin,rwxmax,rwymin,rwmin,rwmax,ndiv,choptaxis);; 1810 ; 1811 choptaxis[0] = 0;; 1812 rwmin = rwymin;; 1813 rwmax = rwymax;; 1814 if (ndivy < 0) {; 1815 nx2 = ndivy/100;; 1816 nx1 = TMath::Max(1, ndivy%100);; 1817 ndivy = 100*nx2 + Int_t(Double_t(nx1)*gPad->GetAbsHNDC());; 1818 // coverity [Calling risky function]; 1819 strlcat(choptaxis, ""N"",10);; 1820 }; 1821 ndiv =TMath::Abs(ndivy);; 1822 if (gPad->GetGridy()) {; 1823 // coverity [Calling risky function]; 1824 strlcat(choptaxis, ""W"",10);; 1825 }; 1826 if (gPad->GetLogy()) {; 1827 rwmin = TMath::Power(10,rwymin);; 1828 rwmax = TMath::Power(10,rwymax);; 1829 // coverity [Calling risky function]; 1830 strlcat(choptaxis,""G"",10);; 1831 }; 1832 axis.SetLineColor(gStyle->GetAxisColor(""Y""));; 1833 axis.SetTextColor(gStyle->GetLabelColor(""Y""));; 1834 axis.SetTextFont(gStyle->GetLabelFont(""Y""));; 1835 axis.SetLabelSize(gStyle->GetLabelSize(""Y""));; 1836 axis.SetLabelOffset(gStyle->GetLabelOffset(""Y""));; 1837 axis.SetTickSize(gStyle->GetTickLength(""Y""));; 1838 ; 1839 axis.PaintAxis(rwxmin,rwymin,rwxmin,rwymax,rwmin,rwmax,ndiv,choptaxis);; 1840 }; 1841 ; 1842 ; 1843 // Set attributes; 1844 theGraph->TAttLine::Modify();; 1845 theGraph->TAttFill::Modify();; 1846 theGraph->TAttMarker::Modify();; 1847 ; 1848 // Min-Max scope; 1849 ; 1850 if (!optionRot) {wmin = x[0]; wmax = x[1];}; 1851",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:164455,Safety,avoid,avoid,164455,"= TMath::Min(1.,(Double_t)iw/(Double_t)ih);; 4643 Double_t hndc = TMath::Min(1.,(Double_t)ih/(Double_t)iw);; 4644 Double_t rh = hndc/(Double_t)ih;; 4645 Double_t rw = wndc/(Double_t)iw;; 4646 Double_t x1ndc = (Double_t)ix1*rw;; 4647 Double_t y1ndc = (Double_t)iy1*rh;; 4648 Double_t x2ndc = (Double_t)ix2*rw;; 4649 Double_t y2ndc = (Double_t)iy2*rh;; 4650 ; 4651 // Ratios to convert user space in TRUE normalized space (NDC); 4652 Double_t rx1,ry1,rx2,ry2;; 4653 gPad->GetRange(rx1,ry1,rx2,ry2);; 4654 Double_t rx = (x2ndc-x1ndc)/(rx2-rx1);; 4655 Double_t ry = (y2ndc-y1ndc)/(ry2-ry1);; 4656 ; 4657 // The first part of the filled area is made of the graph points.; 4658 // Make sure that two adjacent points are different.; 4659 xf[0] = rx*(x[0]-rx1)+x1ndc;; 4660 yf[0] = ry*(y[0]-ry1)+y1ndc;; 4661 nf = 0;; 4662 for (i=1; i<n; i++) {; 4663 if (x[i]==x[i-1] && y[i]==y[i-1]) continue;; 4664 nf++;; 4665 xf[nf] = rx*(x[i]-rx1)+x1ndc;; 4666 if (xf[i]==xf[i-1]) xf[i] += 0.000001; // add an epsilon to avoid exact vertical lines.; 4667 yf[nf] = ry*(y[i]-ry1)+y1ndc;; 4668 }; 4669 ; 4670 // For each graph points a shifted points is computed to build up; 4671 // the second part of the filled area. First and last points are; 4672 // treated as special cases, outside of the loop.; 4673 if (xf[1]==xf[0]) {; 4674 a = TMath::PiOver2();; 4675 } else {; 4676 a = TMath::ATan((yf[1]-yf[0])/(xf[1]-xf[0]));; 4677 }; 4678 if (xf[0]<=xf[1]) {; 4679 xt[0] = xf[0]-w*TMath::Sin(a);; 4680 yt[0] = yf[0]+w*TMath::Cos(a);; 4681 } else {; 4682 xt[0] = xf[0]+w*TMath::Sin(a);; 4683 yt[0] = yf[0]-w*TMath::Cos(a);; 4684 }; 4685 ; 4686 if (xf[nf]==xf[nf-1]) {; 4687 a = TMath::PiOver2();; 4688 } else {; 4689 a = TMath::ATan((yf[nf]-yf[nf-1])/(xf[nf]-xf[nf-1]));; 4690 }; 4691 if (xf[nf]>=xf[nf-1]) {; 4692 xt[nf] = xf[nf]-w*TMath::Sin(a);; 4693 yt[nf] = yf[nf]+w*TMath::Cos(a);; 4694 } else {; 4695 xt[nf] = xf[nf]+w*TMath::Sin(a);; 4696 yt[nf] = yf[nf]-w*TMath::Cos(a);; 4697 }; 4698 ; 4699 Double_t xi0,yi0,xi1,yi1,",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:186508,Safety,avoid,avoid,186508,"79 npt = 1;; 5380 qlx[0] = sxmin + xt/xratio;; 5381 qly[0] = symin + yt/yratio;; 5382L320:; 5383 if (finished > 0) goto L390;; 5384 if (finished < 0) { finished = 0; goto L110;}; 5385 if (s > 0) goto L180;; 5386 goto L110;; 5387 ; 5388 // Convert coordinates back to original system; 5389 ; 5390L390:; 5391 for (i=0;i<npoints;i++) {; 5392 x[i] = sxmin + x[i]/xratio;; 5393 y[i] = symin + y[i]/yratio;; 5394 }; 5395 ; 5396}; 5397 ; 5398////////////////////////////////////////////////////////////////////////////////; 5399/// Static function to set `fgMaxPointsPerLine` for graph painting. When graphs; 5400/// are painted with lines, they are split into chunks of length `fgMaxPointsPerLine`.; 5401/// This allows to paint line with an ""infinite"" number of points. In some case; 5402/// this ""chunks painting"" technic may create artefacts at the chunk's boundaries.; 5403/// For instance when zooming deeply in a PDF file. To avoid this effect it might; 5404/// be necessary to increase the chunks' size using this function:; 5405/// `TGraphPainter::SetMaxPointsPerLine(20000)`.; 5406 ; 5407void TGraphPainter::SetMaxPointsPerLine(Int_t maxp); 5408{; 5409 fgMaxPointsPerLine = maxp;; 5410 if (maxp < 50) fgMaxPointsPerLine = 50;; 5411}; kMouseMotion@ kMouseMotionDefinition Buttons.h:23; kButton1Motion@ kButton1MotionDefinition Buttons.h:20; kButton1Up@ kButton1UpDefinition Buttons.h:19; kButton1Down@ kButton1DownDefinition Buttons.h:17; kMove@ kMoveDefinition GuiTypes.h:374; kHand@ kHandDefinition GuiTypes.h:374; kMaxPixelconst Int_t kMaxPixelMax value for an int.Definition GuiTypes.h:369; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; Int_tint Int_tDefinition RtypesCore.h:45; Char_tchar Char_tDefinition RtypesCore.h:37; Float_tfloat Float_tDefinition",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:2454,Testability,log,logarithmic,2454,"tualPadEditor.h""; 38#include ""TVirtualX.h""; 39#include ""TRegexp.h""; 40#include ""strlcpy.h""; 41#include ""snprintf.h""; 42#include <memory>; 43 ; 44Int_t TGraphPainter::fgMaxPointsPerLine = 50;; 45 ; 46static Int_t gHighlightPoint = -1; // highlight point of graph; 47static TGraph *gHighlightGraph = nullptr; // pointer to graph with highlight point; 48static std::unique_ptr<TMarker> gHighlightMarker; // highlight marker; 49 ; 50ClassImp(TGraphPainter);; 51 ; 52 ; 53////////////////////////////////////////////////////////////////////////////////; 54 ; 55/*! \class TGraphPainter; 56 \ingroup Histpainter; 57 \brief The graph painter class. Implements all graphs' drawing's options.; 58 ; 59- [Introduction](\ref GrP0); 60- [Graphs' plotting options](\ref GrP1); 61- [Exclusion graphs](\ref GrP2); 62- [Graphs with error bars](\ref GrP3); 63 - [TGraphErrors](\ref GrP3a); 64 - [TGraphAsymmErrors](\ref GrP3b); 65 - [TGraphBentErrors](\ref GrP3c); 66 - [TGraphMultiErrors](\ref GrP3d); 67- [TGraphPolar options](\ref GrP4); 68- [Colors automatically picked in palette](\ref GrP5); 69- [Reverse graphs' axis](\ref GrP6); 70- [Graphs in logarithmic scale](\ref GrP7); 71- [Highlight mode for graph](\ref GrP8); 72 ; 73 ; 74\anchor GrP0; 75### Introduction; 76 ; 77Graphs are drawn via the painter `TGraphPainter` class. This class; 78implements techniques needed to display the various kind of; 79graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`.; 80 ; 81To draw a graph `graph` it's enough to do:; 82 ; 83 graph->Draw(""AL"");; 84 ; 85The option `AL` in the `Draw()` method means:; 86 ; 871. The axis should be drawn (option `A`),; 882. The graph should be drawn as a simple line (option `L`).; 89 ; 90 By default a graph is drawn in the current pad in the current coordinate system.; 91To define a suitable coordinate system and draw the axis the option; 92`A` must be specified.; 93 ; 94`TGraphPainter` offers many options to paint the various kind of graphs.; 95 ; 96",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:22489,Testability,log,logarithmic,22489,"1 ; 542When a TGraph is drawn, the X-axis is drawn with increasing values from left to; 543right and the Y-axis from bottom to top. The two options `RX` and `RY` allow to; 544change this order. The option `RX` allows to draw the X-axis with increasing values; 545from right to left and the `RY` option allows to draw the Y-axis with increasing; 546values from top to bottom. The following example illustrate how to use these options.; 547 ; 548Begin_Macro(source); 549{; 550 auto c = new TCanvas();; 551 c->Divide(2,1);; 552 auto g = new TGraphErrors();; 553 g->SetTitle(""Simple Graph"");; 554 ; 555 g->SetPoint(0,-4,-3);; 556 g->SetPoint(1,1,1);; 557 g->SetPoint(2,2,1);; 558 g->SetPoint(3,3,4);; 559 g->SetPoint(4,5,5);; 560 ; 561 g->SetPointError(0,1.,2.);; 562 g->SetPointError(1,2,1);; 563 g->SetPointError(2,2,3);; 564 g->SetPointError(3,3,2);; 565 g->SetPointError(4,4,5);; 566 ; 567 g->GetXaxis()->SetNdivisions(520);; 568 ; 569 g->SetMarkerStyle(21);; 570 c->cd(1); gPad->SetGrid(1,1);; 571 g->Draw(""APL"");; 572 ; 573 c->cd(2); gPad->SetGrid(1,1);; 574 g->Draw(""A RX RY PL"");; 575}; 576End_Macro; 577 ; 578\anchor GrP7; 579### Graphs in logarithmic scale; 580 ; 581Like histograms, graphs can be drawn in logarithmic scale along X and Y. When; 582a pad is set to logarithmic scale with TPad::SetLogx() and/or with TPad::SetLogy(); 583the points building the graph are converted into logarithmic scale. But **only** the; 584points not the lines connecting them which stay linear. This can be clearly seen; 585on the following example:; 586 ; 587Begin_Macro(source); 588{; 589 // A graph with 3 points; 590 Double_t xmin = 750.;; 591 Double_t xmax = 1000;; 592 auto g = new TGraph(3);; 593 g->SetPoint(0,xmin,0.1);; 594 g->SetPoint(1,845,0.06504);; 595 g->SetPoint(2,xmax,0.008);; 596 ; 597 // The same graph with n points; 598 Int_t n = 10000;; 599 Double_t dx = (xmax-xmin)/n;; 600 Double_t x = xmin;; 601 auto g2 = new TGraph();; 602 for (Int_t i=0; i<n; i++) {; 603 g2->SetPoint(i, x, g->Eva",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:22557,Testability,log,logarithmic,22557,"1 ; 542When a TGraph is drawn, the X-axis is drawn with increasing values from left to; 543right and the Y-axis from bottom to top. The two options `RX` and `RY` allow to; 544change this order. The option `RX` allows to draw the X-axis with increasing values; 545from right to left and the `RY` option allows to draw the Y-axis with increasing; 546values from top to bottom. The following example illustrate how to use these options.; 547 ; 548Begin_Macro(source); 549{; 550 auto c = new TCanvas();; 551 c->Divide(2,1);; 552 auto g = new TGraphErrors();; 553 g->SetTitle(""Simple Graph"");; 554 ; 555 g->SetPoint(0,-4,-3);; 556 g->SetPoint(1,1,1);; 557 g->SetPoint(2,2,1);; 558 g->SetPoint(3,3,4);; 559 g->SetPoint(4,5,5);; 560 ; 561 g->SetPointError(0,1.,2.);; 562 g->SetPointError(1,2,1);; 563 g->SetPointError(2,2,3);; 564 g->SetPointError(3,3,2);; 565 g->SetPointError(4,4,5);; 566 ; 567 g->GetXaxis()->SetNdivisions(520);; 568 ; 569 g->SetMarkerStyle(21);; 570 c->cd(1); gPad->SetGrid(1,1);; 571 g->Draw(""APL"");; 572 ; 573 c->cd(2); gPad->SetGrid(1,1);; 574 g->Draw(""A RX RY PL"");; 575}; 576End_Macro; 577 ; 578\anchor GrP7; 579### Graphs in logarithmic scale; 580 ; 581Like histograms, graphs can be drawn in logarithmic scale along X and Y. When; 582a pad is set to logarithmic scale with TPad::SetLogx() and/or with TPad::SetLogy(); 583the points building the graph are converted into logarithmic scale. But **only** the; 584points not the lines connecting them which stay linear. This can be clearly seen; 585on the following example:; 586 ; 587Begin_Macro(source); 588{; 589 // A graph with 3 points; 590 Double_t xmin = 750.;; 591 Double_t xmax = 1000;; 592 auto g = new TGraph(3);; 593 g->SetPoint(0,xmin,0.1);; 594 g->SetPoint(1,845,0.06504);; 595 g->SetPoint(2,xmax,0.008);; 596 ; 597 // The same graph with n points; 598 Int_t n = 10000;; 599 Double_t dx = (xmax-xmin)/n;; 600 Double_t x = xmin;; 601 auto g2 = new TGraph();; 602 for (Int_t i=0; i<n; i++) {; 603 g2->SetPoint(i, x, g->Eva",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:22615,Testability,log,logarithmic,22615," with increasing; 546values from top to bottom. The following example illustrate how to use these options.; 547 ; 548Begin_Macro(source); 549{; 550 auto c = new TCanvas();; 551 c->Divide(2,1);; 552 auto g = new TGraphErrors();; 553 g->SetTitle(""Simple Graph"");; 554 ; 555 g->SetPoint(0,-4,-3);; 556 g->SetPoint(1,1,1);; 557 g->SetPoint(2,2,1);; 558 g->SetPoint(3,3,4);; 559 g->SetPoint(4,5,5);; 560 ; 561 g->SetPointError(0,1.,2.);; 562 g->SetPointError(1,2,1);; 563 g->SetPointError(2,2,3);; 564 g->SetPointError(3,3,2);; 565 g->SetPointError(4,4,5);; 566 ; 567 g->GetXaxis()->SetNdivisions(520);; 568 ; 569 g->SetMarkerStyle(21);; 570 c->cd(1); gPad->SetGrid(1,1);; 571 g->Draw(""APL"");; 572 ; 573 c->cd(2); gPad->SetGrid(1,1);; 574 g->Draw(""A RX RY PL"");; 575}; 576End_Macro; 577 ; 578\anchor GrP7; 579### Graphs in logarithmic scale; 580 ; 581Like histograms, graphs can be drawn in logarithmic scale along X and Y. When; 582a pad is set to logarithmic scale with TPad::SetLogx() and/or with TPad::SetLogy(); 583the points building the graph are converted into logarithmic scale. But **only** the; 584points not the lines connecting them which stay linear. This can be clearly seen; 585on the following example:; 586 ; 587Begin_Macro(source); 588{; 589 // A graph with 3 points; 590 Double_t xmin = 750.;; 591 Double_t xmax = 1000;; 592 auto g = new TGraph(3);; 593 g->SetPoint(0,xmin,0.1);; 594 g->SetPoint(1,845,0.06504);; 595 g->SetPoint(2,xmax,0.008);; 596 ; 597 // The same graph with n points; 598 Int_t n = 10000;; 599 Double_t dx = (xmax-xmin)/n;; 600 Double_t x = xmin;; 601 auto g2 = new TGraph();; 602 for (Int_t i=0; i<n; i++) {; 603 g2->SetPoint(i, x, g->Eval(x));; 604 x = x + dx;; 605 }; 606 ; 607 auto cv = new TCanvas(""cv"",""cv"",800,600);; 608 cv->SetLogy();; 609 cv->SetGridx();; 610 cv->SetGridy();; 611 g->Draw(""AL*"");; 612 ; 613 g2->SetMarkerColor(kRed);; 614 g2->SetMarkerStyle(1);; 615 g2->Draw(""P"");; 616}; 617 ; 618End_Macro; 619 ; 620\anchor GrP8; 621#### Highlight mode f",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:22735,Testability,log,logarithmic,22735," with increasing; 546values from top to bottom. The following example illustrate how to use these options.; 547 ; 548Begin_Macro(source); 549{; 550 auto c = new TCanvas();; 551 c->Divide(2,1);; 552 auto g = new TGraphErrors();; 553 g->SetTitle(""Simple Graph"");; 554 ; 555 g->SetPoint(0,-4,-3);; 556 g->SetPoint(1,1,1);; 557 g->SetPoint(2,2,1);; 558 g->SetPoint(3,3,4);; 559 g->SetPoint(4,5,5);; 560 ; 561 g->SetPointError(0,1.,2.);; 562 g->SetPointError(1,2,1);; 563 g->SetPointError(2,2,3);; 564 g->SetPointError(3,3,2);; 565 g->SetPointError(4,4,5);; 566 ; 567 g->GetXaxis()->SetNdivisions(520);; 568 ; 569 g->SetMarkerStyle(21);; 570 c->cd(1); gPad->SetGrid(1,1);; 571 g->Draw(""APL"");; 572 ; 573 c->cd(2); gPad->SetGrid(1,1);; 574 g->Draw(""A RX RY PL"");; 575}; 576End_Macro; 577 ; 578\anchor GrP7; 579### Graphs in logarithmic scale; 580 ; 581Like histograms, graphs can be drawn in logarithmic scale along X and Y. When; 582a pad is set to logarithmic scale with TPad::SetLogx() and/or with TPad::SetLogy(); 583the points building the graph are converted into logarithmic scale. But **only** the; 584points not the lines connecting them which stay linear. This can be clearly seen; 585on the following example:; 586 ; 587Begin_Macro(source); 588{; 589 // A graph with 3 points; 590 Double_t xmin = 750.;; 591 Double_t xmax = 1000;; 592 auto g = new TGraph(3);; 593 g->SetPoint(0,xmin,0.1);; 594 g->SetPoint(1,845,0.06504);; 595 g->SetPoint(2,xmax,0.008);; 596 ; 597 // The same graph with n points; 598 Int_t n = 10000;; 599 Double_t dx = (xmax-xmin)/n;; 600 Double_t x = xmin;; 601 auto g2 = new TGraph();; 602 for (Int_t i=0; i<n; i++) {; 603 g2->SetPoint(i, x, g->Eval(x));; 604 x = x + dx;; 605 }; 606 ; 607 auto cv = new TCanvas(""cv"",""cv"",800,600);; 608 cv->SetLogy();; 609 cv->SetGridx();; 610 cv->SetGridy();; 611 g->Draw(""AL*"");; 612 ; 613 g2->SetMarkerColor(kRed);; 614 g2->SetMarkerStyle(1);; 615 g2->Draw(""P"");; 616}; 617 ; 618End_Macro; 619 ; 620\anchor GrP8; 621#### Highlight mode f",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:25830,Testability,log,logarithm,25830,"ht mode and user function</a>; 648(is fully equivalent as for histogram).; 649 ; 650NOTE all parameters of user function are taken from; 651 ; 652 void TCanvas::Highlighted(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); 653 ; 654 - `pad` is pointer to pad with highlighted graph; 655 - `obj` is pointer to highlighted graph; 656 - `x` is highlighted x-th (i-th) point for graph; 657 - `y` not in use (only for 2D histogram); 658 ; 659For more complex demo please see for example `$ROOTSYS/tutorials/math/hlquantiles.C` file.; 660 ; 661*/; 662 ; 663 ; 664////////////////////////////////////////////////////////////////////////////////; 665/// Default constructor; 666 ; 667TGraphPainter::TGraphPainter(); 668{; 669}; 670 ; 671 ; 672////////////////////////////////////////////////////////////////////////////////; 673/// Destructor.; 674 ; 675TGraphPainter::~TGraphPainter(); 676{; 677}; 678 ; 679 ; 680////////////////////////////////////////////////////////////////////////////////; 681/// Compute the logarithm of variables `gxwork` and `gywork`; 682/// according to the value of Options and put the results; 683/// in the variables `gxworkl` and `gyworkl`.; 684///; 685/// npoints : Number of points in gxwork and in gywork.; 686///; 687/// - opt = 1 ComputeLogs is called from PaintGrapHist; 688/// - opt = 0 ComputeLogs is called from PaintGraph; 689 ; 690void TGraphPainter::ComputeLogs(Int_t npoints, Int_t opt); 691{; 692 if (gPad->GetLogx()) {; 693 for (Int_t i = 0; i < npoints; i++) {; 694 gxworkl[i] = (gxwork[i] > 0.) ? TMath::Log10(gxwork[i]) : gPad->GetX1();; 695 }; 696 } else {; 697 for (Int_t i = 0; i < npoints; i++); 698 gxworkl[i] = gxwork[i];; 699 }; 700 if (!opt && gPad->GetLogy()) {; 701 for (Int_t i = 0; i < npoints; i++) {; 702 gyworkl[i] = (gywork[i] > 0.) ? TMath::Log10(gywork[i]) : gPad->GetY1();; 703 }; 704 } else {; 705 for (Int_t i = 0; i < npoints; i++); 706 gyworkl[i] = gywork[i];; 707 }; 708}; 709 ; 710 ; 711//////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:43242,Testability,test,testing,43242,"1150 // paint highlight point as marker (recursive calls PaintHighlightPoint); 1151 gPad->Modified(kTRUE);; 1152 gPad->Update();; 1153 ; 1154 // emit Highlighted() signal; 1155 if (gPad->GetCanvas()) gPad->GetCanvas()->Highlighted(gPad, theGraph, gHighlightPoint, -1);; 1156 }; 1157 }; 1158 if (gHighlightGraph == theGraph) distanceOld = distance;; 1159}; 1160 ; 1161 ; 1162////////////////////////////////////////////////////////////////////////////////; 1163/// Paint highlight point as TMarker object (open circle); 1164 ; 1165void TGraphPainter::PaintHighlightPoint(TGraph *theGraph, Option_t * /*option*/); 1166{; 1167 // call from PaintGraphSimple; 1168 ; 1169 if ((!theGraph->IsHighlight()) || (gHighlightGraph != theGraph)) return;; 1170 ; 1171 Double_t hx, hy;; 1172 if (theGraph->GetPoint(gHighlightPoint, hx, hy) == -1) {; 1173 // special case, e.g. after interactive remove last point; 1174 if (gHighlightMarker) gHighlightMarker.reset(nullptr);; 1175 return;; 1176 }; 1177 // testing specific possibility (after zoom, draw with ""same"", log, etc.); 1178 Double_t uxmin = gPad->GetUxmin();; 1179 Double_t uxmax = gPad->GetUxmax();; 1180 Double_t uymin = gPad->GetUymin();; 1181 Double_t uymax = gPad->GetUymax();; 1182 if (gPad->GetLogx()) {; 1183 uxmin = TMath::Power(10.0, uxmin);; 1184 uxmax = TMath::Power(10.0, uxmax);; 1185 }; 1186 if (gPad->GetLogy()) {; 1187 uymin = TMath::Power(10.0, uymin);; 1188 uymax = TMath::Power(10.0, uymax);; 1189 }; 1190 if ((hx < uxmin) || (hx > uxmax)) return;; 1191 if ((hy < uymin) || (hy > uymax)) return;; 1192 ; 1193 if (!gHighlightMarker) {; 1194 gHighlightMarker = std::make_unique<TMarker>(hx, hy, 24);; 1195 gHighlightMarker->SetBit(kCannotPick);; 1196 }; 1197 gHighlightMarker->SetX(hx);; 1198 gHighlightMarker->SetY(hy);; 1199 gHighlightMarker->SetMarkerSize(theGraph->GetMarkerSize()*2.0);; 1200 if (gHighlightMarker->GetMarkerSize() < 1.0) gHighlightMarker->SetMarkerSize(1.0); // always visible; 1201 gHighlightMarker->SetMarkerColor(the",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:43302,Testability,log,log,43302,"1150 // paint highlight point as marker (recursive calls PaintHighlightPoint); 1151 gPad->Modified(kTRUE);; 1152 gPad->Update();; 1153 ; 1154 // emit Highlighted() signal; 1155 if (gPad->GetCanvas()) gPad->GetCanvas()->Highlighted(gPad, theGraph, gHighlightPoint, -1);; 1156 }; 1157 }; 1158 if (gHighlightGraph == theGraph) distanceOld = distance;; 1159}; 1160 ; 1161 ; 1162////////////////////////////////////////////////////////////////////////////////; 1163/// Paint highlight point as TMarker object (open circle); 1164 ; 1165void TGraphPainter::PaintHighlightPoint(TGraph *theGraph, Option_t * /*option*/); 1166{; 1167 // call from PaintGraphSimple; 1168 ; 1169 if ((!theGraph->IsHighlight()) || (gHighlightGraph != theGraph)) return;; 1170 ; 1171 Double_t hx, hy;; 1172 if (theGraph->GetPoint(gHighlightPoint, hx, hy) == -1) {; 1173 // special case, e.g. after interactive remove last point; 1174 if (gHighlightMarker) gHighlightMarker.reset(nullptr);; 1175 return;; 1176 }; 1177 // testing specific possibility (after zoom, draw with ""same"", log, etc.); 1178 Double_t uxmin = gPad->GetUxmin();; 1179 Double_t uxmax = gPad->GetUxmax();; 1180 Double_t uymin = gPad->GetUymin();; 1181 Double_t uymax = gPad->GetUymax();; 1182 if (gPad->GetLogx()) {; 1183 uxmin = TMath::Power(10.0, uxmin);; 1184 uxmax = TMath::Power(10.0, uxmax);; 1185 }; 1186 if (gPad->GetLogy()) {; 1187 uymin = TMath::Power(10.0, uymin);; 1188 uymax = TMath::Power(10.0, uymax);; 1189 }; 1190 if ((hx < uxmin) || (hx > uxmax)) return;; 1191 if ((hy < uymin) || (hy > uymax)) return;; 1192 ; 1193 if (!gHighlightMarker) {; 1194 gHighlightMarker = std::make_unique<TMarker>(hx, hy, 24);; 1195 gHighlightMarker->SetBit(kCannotPick);; 1196 }; 1197 gHighlightMarker->SetX(hx);; 1198 gHighlightMarker->SetY(hy);; 1199 gHighlightMarker->SetMarkerSize(theGraph->GetMarkerSize()*2.0);; 1200 if (gHighlightMarker->GetMarkerSize() < 1.0) gHighlightMarker->SetMarkerSize(1.0); // always visible; 1201 gHighlightMarker->SetMarkerColor(the",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:68851,Testability,log,log,68851,"ax = TMath::Power(10,rwymax);; 1829 // coverity [Calling risky function]; 1830 strlcat(choptaxis,""G"",10);; 1831 }; 1832 axis.SetLineColor(gStyle->GetAxisColor(""Y""));; 1833 axis.SetTextColor(gStyle->GetLabelColor(""Y""));; 1834 axis.SetTextFont(gStyle->GetLabelFont(""Y""));; 1835 axis.SetLabelSize(gStyle->GetLabelSize(""Y""));; 1836 axis.SetLabelOffset(gStyle->GetLabelOffset(""Y""));; 1837 axis.SetTickSize(gStyle->GetTickLength(""Y""));; 1838 ; 1839 axis.PaintAxis(rwxmin,rwymin,rwxmin,rwymax,rwmin,rwmax,ndiv,choptaxis);; 1840 }; 1841 ; 1842 ; 1843 // Set attributes; 1844 theGraph->TAttLine::Modify();; 1845 theGraph->TAttFill::Modify();; 1846 theGraph->TAttMarker::Modify();; 1847 ; 1848 // Min-Max scope; 1849 ; 1850 if (!optionRot) {wmin = x[0]; wmax = x[1];}; 1851 else {wmin = y[0]; wmax = y[1];}; 1852 ; 1853 if (!optionBins) delta = (wmax - wmin)/ Double_t(nbins);; 1854 ; 1855 Int_t fwidth = gPad->GetFrameLineWidth();; 1856 TFrame *frame = gPad->GetFrame();; 1857 if (frame) fwidth = frame->GetLineWidth();; 1858 if (optionOff) fwidth = 1;; 1859 Double_t dxframe = gPad->AbsPixeltoX(fwidth/2) - gPad->AbsPixeltoX(0);; 1860 Double_t vxmin = gPad->PadtoX(gPad->GetUxmin() + dxframe);; 1861 Double_t vxmax = gPad->PadtoX(gPad->GetUxmax() - dxframe);; 1862 Double_t dyframe = -gPad->AbsPixeltoY(fwidth/2) + gPad->AbsPixeltoY(0);; 1863 Double_t vymin = gPad->GetUymin() + dyframe; //y already in log scale; 1864 vxmin = TMath::Max(vxmin,wmin);; 1865 vxmax = TMath::Min(vxmax,wmax);; 1866 ; 1867 // Draw the histogram with a fill area; 1868 ; 1869 gxwork.resize(2*npoints+10);; 1870 gywork.resize(2*npoints+10);; 1871 gxworkl.resize(2*npoints+10);; 1872 gyworkl.resize(2*npoints+10);; 1873 ; 1874 if (optionFill && !optionCurve) {; 1875 fillarea = kTRUE;; 1876 if (!optionRot) {; 1877 gxwork[0] = vxmin;; 1878 if (!optionOne) gywork[0] = TMath::Min(TMath::Max((Double_t)0,gPad->GetUymin()); 1879 ,gPad->GetUymax());; 1880 else gywork[0] = gPad->GetUymin();; 1881 npt = 2;; 1882 for (j=first; j<=last;j++",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:70604,Testability,log,log,70604,"; 1865 vxmax = TMath::Min(vxmax,wmax);; 1866 ; 1867 // Draw the histogram with a fill area; 1868 ; 1869 gxwork.resize(2*npoints+10);; 1870 gywork.resize(2*npoints+10);; 1871 gxworkl.resize(2*npoints+10);; 1872 gyworkl.resize(2*npoints+10);; 1873 ; 1874 if (optionFill && !optionCurve) {; 1875 fillarea = kTRUE;; 1876 if (!optionRot) {; 1877 gxwork[0] = vxmin;; 1878 if (!optionOne) gywork[0] = TMath::Min(TMath::Max((Double_t)0,gPad->GetUymin()); 1879 ,gPad->GetUymax());; 1880 else gywork[0] = gPad->GetUymin();; 1881 npt = 2;; 1882 for (j=first; j<=last;j++) {; 1883 if (!optionBins) {; 1884 gxwork[npt-1] = gxwork[npt-2];; 1885 gxwork[npt] = wmin+((j-first+1)*delta);; 1886 if (gxwork[npt] < gxwork[0]) gxwork[npt] = gxwork[0];; 1887 ; 1888 } else {; 1889 xj1 = x[j]; xj = x[j-1];; 1890 if (xj1 < xj) {; 1891 if (j != last) Error(where, ""X must be in increasing order"");; 1892 else Error(where, ""X must have N+1 values with option N"");; 1893 goto do_cleanup;; 1894 }; 1895 gxwork[npt-1] = x[j-1]; gxwork[npt] = x[j];; 1896 }; 1897 gywork[npt-1] = y[j-1];; 1898 gywork[npt] = y[j-1];; 1899 if (gywork[npt] < vymin) {gywork[npt] = vymin; gywork[npt-1] = vymin;}; 1900 if ((gxwork[npt-1] >= uxmin-rounding && gxwork[npt-1] <= uxmax+rounding) ||; 1901 (gxwork[npt] >= uxmin-rounding && gxwork[npt] <= uxmax+rounding)) npt += 2;; 1902 if (j == last) {; 1903 gxwork[npt-1] = gxwork[npt-2];; 1904 gywork[npt-1] = gywork[0];; 1905 //make sure that the fill area does not overwrite the frame; 1906 //take into account the frame line width; 1907 if (gxwork[0 ] < vxmin) {gxwork[0 ] = vxmin; gxwork[1 ] = vxmin;}; 1908 if (gywork[0] < vymin) {gywork[0] = vymin; gywork[npt-1] = vymin;}; 1909 ; 1910 //transform to log ?; 1911 ComputeLogs(npt, optionZ);; 1912 gPad->PaintFillArea(npt,gxworkl.data(),gyworkl.data());; 1913 if (drawborder) {; 1914 if (!fillarea) gyworkl[0] = ylast;; 1915 gPad->PaintPolyLine(npt-1,gxworkl.data(),gyworkl.data(),noClip);; 1916 }; 1917 continue;; 1918 }; 1919 } //endfor (j=first;",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:88763,Testability,log,log,88763,"1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 2440 Int_t theNpoints = theGraph->GetN();; 2441 Double_t *theX = theGraph->GetX();; 2442 Double_t *theY = theGraph->GetY();; 2443 Double_t *theEXlow = theGraph->GetEXlow(); if (!theEXlow) return;; 2444 Double_t *theEYlow = theGraph->GetEYlow(); if (!theEYlow) return;; 2445 Double_t *theEXhigh = theGraph->GetEXhigh(); if (!theEXhigh) return;; 2446 Double_t *theEYhigh = theGraph->GetEYhigh(); if (!theEYhigh) return;; 2447 ; 2448 if (strchr(option,'X') || strchr(option,'x')) {PaintGraphSimple(theGraph, option); return;}; 2449 Bool_t brackets = kFALSE;; 2450 Bool_t braticks = kFALSE;; 2451 if (strstr(option,""||"") || strstr(option,""[]"")) {; 2452 brackets = kTRUE;; 2453 if (strstr(option,""[]"")) braticks = kTRUE;; 2454 }; 2455 Bool_t endLines = kTRUE;; 2456 if (strchr(option,'z')) endLines = kFALSE;; 2457 if (strchr(option,'Z')) endLines = kFALSE;; 2458 const char *arrowOpt = nullptr;; 2459 if (strchr(option,'>')) arrowOpt = "">"";; 2460 if (strstr(option,""|>"")) arrowOpt = ""|>"";; 2461 ; 2462 Bool_t axis = kFALSE;; 2463 if (strchr(option,'a')) axis = kTRUE;; 2464 if (strchr(option,'A')) axis = kTRUE;; 2465 if (axis) PaintGraphSimple(theGraph, option);; 2466 ; 2467 Bool_t option0 = kFALSE;; 2468 Bool_t option2 = kFALSE;; 2469 Bool_t option3 = kFALSE;; 2470 Bool_t option4 = kFALSE;; 2471 Bool_t option5 = kFALSE;; 2472 if (strchr(option,'0')) option0 = kTRUE;; 2473 if (strchr(option,'2')) option2 = kTRUE;; 2474 if (strchr(option,'3')) option3 = kTRUE;; 2475 if (strchr(option,'4')) {option3 = kTRUE; option4 = kTRUE;}; 2476 if (strchr(option,'5')) {option2 = kTRUE; option5 = kTRUE;}; 2477 ; 2478 // special flags in case of ""reverse plot"" and ""log scale""; 2479 Bool_t xrevlog = kFALSE;; 2480 Bool_t yrevlog = kFALSE;; 2481 if (strstr(option,""-N"")) xrevlog = kTRUE; // along X; 2482 if (strstr(option,""-M"")) yrevlog = kTRUE; // along Y; 2483 ; 2484 if (option3) {; 2485 xline.resize(2*theNpoints);; 2486 yline.resize(2*theNpoints)",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:96557,Testability,log,logx,96557,") {; 2675 if (eyh != 0. && DrawYUp) gPad->PaintLine(x,yup1,x,yup2);; 2676 if (eyl != 0. && DrawYLow) gPad->PaintLine(x,ylow1,x,ylow2);; 2677 }; 2678 if (endLines) {; 2679 if (braticks) {; 2680 if (eyh != 0. && yup2 == yup && DrawYUp) {; 2681 xb[0] = x-tx; yb[0] = yup2-ty;; 2682 xb[1] = x-tx; yb[1] = yup2;; 2683 xb[2] = x+tx; yb[2] = yup2;; 2684 xb[3] = x+tx; yb[3] = yup2-ty;; 2685 gPad->PaintPolyLine(4, xb, yb);; 2686 }; 2687 if (eyl != 0. && ylow2 == ylow && DrawYLow) {; 2688 xb[0] = x-tx; yb[0] = ylow2+ty;; 2689 xb[1] = x-tx; yb[1] = ylow2;; 2690 xb[2] = x+tx; yb[2] = ylow2;; 2691 xb[3] = x+tx; yb[3] = ylow2+ty;; 2692 gPad->PaintPolyLine(4, xb, yb);; 2693 }; 2694 } else {; 2695 if (eyh != 0. && yup2 == yup && DrawYUp) gPad->PaintLine(x-tx,yup2,x+tx,yup2);; 2696 if (eyl != 0. && ylow2 == ylow && DrawYLow) gPad->PaintLine(x-tx,ylow2,x+tx,ylow2);; 2697 }; 2698 }; 2699 }; 2700 }; 2701 }; 2702 if (!brackets && !axis) PaintGraphSimple(theGraph, option);; 2703 gPad->ResetBit(TGraph::kClipFrame);; 2704 ; 2705 if (option3) {; 2706 Int_t logx = gPad->GetLogx();; 2707 Int_t logy = gPad->GetLogy();; 2708 gPad->SetLogx(0);; 2709 gPad->SetLogy(0);; 2710 if (option4) PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""FC"");; 2711 else PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""F"");; 2712 gPad->SetLogx(logx);; 2713 gPad->SetLogy(logy);; 2714 }; 2715}; 2716 ; 2717////////////////////////////////////////////////////////////////////////////////; 2718/// [Paint this TGraphMultiErrors with its current attributes.](\ref GrP3); 2719 ; 2720void TGraphPainter::PaintGraphMultiErrors(TGraph *theGraph, Option_t *option); 2721{; 2722 if (!theGraph->InheritsFrom(TGraphMultiErrors::Class())) {; 2723 PaintHelper(theGraph, option);; 2724 return;; 2725 }; 2726 ; 2727 auto tg = (TGraphMultiErrors *)theGraph;; 2728 ; 2729 Int_t NYErrors = tg->GetNYErrors();; 2730 if (NYErrors <= 0) {; 2731 PaintGraphSimple(tg, option);; 2732 return;; 2733 }; 2734 ; 2735 TString tsOpt = ",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:96593,Testability,log,logy,96593,") {; 2675 if (eyh != 0. && DrawYUp) gPad->PaintLine(x,yup1,x,yup2);; 2676 if (eyl != 0. && DrawYLow) gPad->PaintLine(x,ylow1,x,ylow2);; 2677 }; 2678 if (endLines) {; 2679 if (braticks) {; 2680 if (eyh != 0. && yup2 == yup && DrawYUp) {; 2681 xb[0] = x-tx; yb[0] = yup2-ty;; 2682 xb[1] = x-tx; yb[1] = yup2;; 2683 xb[2] = x+tx; yb[2] = yup2;; 2684 xb[3] = x+tx; yb[3] = yup2-ty;; 2685 gPad->PaintPolyLine(4, xb, yb);; 2686 }; 2687 if (eyl != 0. && ylow2 == ylow && DrawYLow) {; 2688 xb[0] = x-tx; yb[0] = ylow2+ty;; 2689 xb[1] = x-tx; yb[1] = ylow2;; 2690 xb[2] = x+tx; yb[2] = ylow2;; 2691 xb[3] = x+tx; yb[3] = ylow2+ty;; 2692 gPad->PaintPolyLine(4, xb, yb);; 2693 }; 2694 } else {; 2695 if (eyh != 0. && yup2 == yup && DrawYUp) gPad->PaintLine(x-tx,yup2,x+tx,yup2);; 2696 if (eyl != 0. && ylow2 == ylow && DrawYLow) gPad->PaintLine(x-tx,ylow2,x+tx,ylow2);; 2697 }; 2698 }; 2699 }; 2700 }; 2701 }; 2702 if (!brackets && !axis) PaintGraphSimple(theGraph, option);; 2703 gPad->ResetBit(TGraph::kClipFrame);; 2704 ; 2705 if (option3) {; 2706 Int_t logx = gPad->GetLogx();; 2707 Int_t logy = gPad->GetLogy();; 2708 gPad->SetLogx(0);; 2709 gPad->SetLogy(0);; 2710 if (option4) PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""FC"");; 2711 else PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""F"");; 2712 gPad->SetLogx(logx);; 2713 gPad->SetLogy(logy);; 2714 }; 2715}; 2716 ; 2717////////////////////////////////////////////////////////////////////////////////; 2718/// [Paint this TGraphMultiErrors with its current attributes.](\ref GrP3); 2719 ; 2720void TGraphPainter::PaintGraphMultiErrors(TGraph *theGraph, Option_t *option); 2721{; 2722 if (!theGraph->InheritsFrom(TGraphMultiErrors::Class())) {; 2723 PaintHelper(theGraph, option);; 2724 return;; 2725 }; 2726 ; 2727 auto tg = (TGraphMultiErrors *)theGraph;; 2728 ; 2729 Int_t NYErrors = tg->GetNYErrors();; 2730 if (NYErrors <= 0) {; 2731 PaintGraphSimple(tg, option);; 2732 return;; 2733 }; 2734 ; 2735 TString tsOpt = ",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:96852,Testability,log,logx,96852," if (eyl != 0. && ylow2 == ylow && DrawYLow) {; 2688 xb[0] = x-tx; yb[0] = ylow2+ty;; 2689 xb[1] = x-tx; yb[1] = ylow2;; 2690 xb[2] = x+tx; yb[2] = ylow2;; 2691 xb[3] = x+tx; yb[3] = ylow2+ty;; 2692 gPad->PaintPolyLine(4, xb, yb);; 2693 }; 2694 } else {; 2695 if (eyh != 0. && yup2 == yup && DrawYUp) gPad->PaintLine(x-tx,yup2,x+tx,yup2);; 2696 if (eyl != 0. && ylow2 == ylow && DrawYLow) gPad->PaintLine(x-tx,ylow2,x+tx,ylow2);; 2697 }; 2698 }; 2699 }; 2700 }; 2701 }; 2702 if (!brackets && !axis) PaintGraphSimple(theGraph, option);; 2703 gPad->ResetBit(TGraph::kClipFrame);; 2704 ; 2705 if (option3) {; 2706 Int_t logx = gPad->GetLogx();; 2707 Int_t logy = gPad->GetLogy();; 2708 gPad->SetLogx(0);; 2709 gPad->SetLogy(0);; 2710 if (option4) PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""FC"");; 2711 else PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""F"");; 2712 gPad->SetLogx(logx);; 2713 gPad->SetLogy(logy);; 2714 }; 2715}; 2716 ; 2717////////////////////////////////////////////////////////////////////////////////; 2718/// [Paint this TGraphMultiErrors with its current attributes.](\ref GrP3); 2719 ; 2720void TGraphPainter::PaintGraphMultiErrors(TGraph *theGraph, Option_t *option); 2721{; 2722 if (!theGraph->InheritsFrom(TGraphMultiErrors::Class())) {; 2723 PaintHelper(theGraph, option);; 2724 return;; 2725 }; 2726 ; 2727 auto tg = (TGraphMultiErrors *)theGraph;; 2728 ; 2729 Int_t NYErrors = tg->GetNYErrors();; 2730 if (NYErrors <= 0) {; 2731 PaintGraphSimple(tg, option);; 2732 return;; 2733 }; 2734 ; 2735 TString tsOpt = option;; 2736 tsOpt.ToLower();; 2737 ; 2738 std::vector<TString> options(NYErrors + 1);; 2739 Int_t filled = 0;; 2740 ; 2741 if (tsOpt.CountChar(';') < NYErrors) {; 2742 options[0] = tsOpt.Contains("";"") ? tsOpt(0, tsOpt.First(';')) : tsOpt.Copy();; 2743 filled++;; 2744 }; 2745 ; 2746 Ssiz_t firstSemicolon;; 2747 while ((firstSemicolon = tsOpt.First(';')) != kNPOS && filled <= NYErrors) {; 2748 options[filled] = tsOpt(0, firs",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:96879,Testability,log,logy,96879," if (eyl != 0. && ylow2 == ylow && DrawYLow) {; 2688 xb[0] = x-tx; yb[0] = ylow2+ty;; 2689 xb[1] = x-tx; yb[1] = ylow2;; 2690 xb[2] = x+tx; yb[2] = ylow2;; 2691 xb[3] = x+tx; yb[3] = ylow2+ty;; 2692 gPad->PaintPolyLine(4, xb, yb);; 2693 }; 2694 } else {; 2695 if (eyh != 0. && yup2 == yup && DrawYUp) gPad->PaintLine(x-tx,yup2,x+tx,yup2);; 2696 if (eyl != 0. && ylow2 == ylow && DrawYLow) gPad->PaintLine(x-tx,ylow2,x+tx,ylow2);; 2697 }; 2698 }; 2699 }; 2700 }; 2701 }; 2702 if (!brackets && !axis) PaintGraphSimple(theGraph, option);; 2703 gPad->ResetBit(TGraph::kClipFrame);; 2704 ; 2705 if (option3) {; 2706 Int_t logx = gPad->GetLogx();; 2707 Int_t logy = gPad->GetLogy();; 2708 gPad->SetLogx(0);; 2709 gPad->SetLogy(0);; 2710 if (option4) PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""FC"");; 2711 else PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""F"");; 2712 gPad->SetLogx(logx);; 2713 gPad->SetLogy(logy);; 2714 }; 2715}; 2716 ; 2717////////////////////////////////////////////////////////////////////////////////; 2718/// [Paint this TGraphMultiErrors with its current attributes.](\ref GrP3); 2719 ; 2720void TGraphPainter::PaintGraphMultiErrors(TGraph *theGraph, Option_t *option); 2721{; 2722 if (!theGraph->InheritsFrom(TGraphMultiErrors::Class())) {; 2723 PaintHelper(theGraph, option);; 2724 return;; 2725 }; 2726 ; 2727 auto tg = (TGraphMultiErrors *)theGraph;; 2728 ; 2729 Int_t NYErrors = tg->GetNYErrors();; 2730 if (NYErrors <= 0) {; 2731 PaintGraphSimple(tg, option);; 2732 return;; 2733 }; 2734 ; 2735 TString tsOpt = option;; 2736 tsOpt.ToLower();; 2737 ; 2738 std::vector<TString> options(NYErrors + 1);; 2739 Int_t filled = 0;; 2740 ; 2741 if (tsOpt.CountChar(';') < NYErrors) {; 2742 options[0] = tsOpt.Contains("";"") ? tsOpt(0, tsOpt.First(';')) : tsOpt.Copy();; 2743 filled++;; 2744 }; 2745 ; 2746 Ssiz_t firstSemicolon;; 2747 while ((firstSemicolon = tsOpt.First(';')) != kNPOS && filled <= NYErrors) {; 2748 options[filled] = tsOpt(0, firs",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:111213,Testability,log,logx,111213,"gPad->XtoPad(theX[i] + ScaleX * theExH[i]);; 3124 if (xr1 < xr2 && !NoErrorsX && (!isOutside || Option0X)) {; 3125 if (ArrowOptX); 3126 arrow.PaintArrow(xr1, y, xr2, y, asize, ArrowOptX);; 3127 else {; 3128 if (!BracketsX); 3129 gPad->PaintLine(xr1, y, xr2, y);; 3130 if (EndLinesX) {; 3131 if (BraticksX) {; 3132 xb[0] = xr2 - tx;; 3133 yb[0] = y - ty;; 3134 xb[1] = xr2;; 3135 yb[1] = y - ty;; 3136 xb[2] = xr2;; 3137 yb[2] = y + ty;; 3138 xb[3] = xr2 - tx;; 3139 yb[3] = y + ty;; 3140 gPad->PaintPolyLine(4, xb, yb);; 3141 } else; 3142 gPad->PaintLine(xr2, y - ty, xr2, y + ty);; 3143 }; 3144 }; 3145 }; 3146 }; 3147 }; 3148 ; 3149 if (DrawMarker && !DrawAxis); 3150 PaintGraphSimple(tg, options[0].Data());; 3151 gPad->ResetBit(TGraph::kClipFrame);; 3152 ; 3153 TGraph tgDummy;; 3154 tg->TAttFill::Copy(tgDummy);; 3155 tg->TAttLine::Copy(tgDummy);; 3156 tg->TAttMarker::Copy(tgDummy);; 3157 ; 3158 for (Int_t j = 0; j < NYErrors; j++); 3159 if (Option3[j] && DrawErrors[j]) {; 3160 if (IndividualStyles) {; 3161 tg->GetAttFill(j)->Copy(tgDummy);; 3162 tg->GetAttLine(j)->Copy(tgDummy);; 3163 }; 3164 ; 3165 Int_t logx = gPad->GetLogx();; 3166 Int_t logy = gPad->GetLogy();; 3167 gPad->SetLogx(0);; 3168 gPad->SetLogy(0);; 3169 if (Option4[j]); 3170 PaintGraph(&tgDummy, 2 * NPointsInside, xline.data(), yline[j].data(), ""FC"");; 3171 else; 3172 PaintGraph(&tgDummy, 2 * NPointsInside, xline.data(), yline[j].data(), ""F"");; 3173 gPad->SetLogx(logx);; 3174 gPad->SetLogy(logy);; 3175 }; 3176 ; 3177}; 3178 ; 3179////////////////////////////////////////////////////////////////////////////////; 3180/// [Paint this TGraphBentErrors with its current attributes.](\ref GrP3); 3181 ; 3182void TGraphPainter::PaintGraphBentErrors(TGraph *theGraph, Option_t *option); 3183{; 3184 ; 3185 std::vector<Double_t> xline, yline;; 3186 Int_t if1 = 0;; 3187 Int_t if2 = 0;; 3188 Double_t xb[4], yb[4];; 3189 ; 3190 const Int_t kBASEMARKER=8;; 3191 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:111249,Testability,log,logy,111249,"gPad->XtoPad(theX[i] + ScaleX * theExH[i]);; 3124 if (xr1 < xr2 && !NoErrorsX && (!isOutside || Option0X)) {; 3125 if (ArrowOptX); 3126 arrow.PaintArrow(xr1, y, xr2, y, asize, ArrowOptX);; 3127 else {; 3128 if (!BracketsX); 3129 gPad->PaintLine(xr1, y, xr2, y);; 3130 if (EndLinesX) {; 3131 if (BraticksX) {; 3132 xb[0] = xr2 - tx;; 3133 yb[0] = y - ty;; 3134 xb[1] = xr2;; 3135 yb[1] = y - ty;; 3136 xb[2] = xr2;; 3137 yb[2] = y + ty;; 3138 xb[3] = xr2 - tx;; 3139 yb[3] = y + ty;; 3140 gPad->PaintPolyLine(4, xb, yb);; 3141 } else; 3142 gPad->PaintLine(xr2, y - ty, xr2, y + ty);; 3143 }; 3144 }; 3145 }; 3146 }; 3147 }; 3148 ; 3149 if (DrawMarker && !DrawAxis); 3150 PaintGraphSimple(tg, options[0].Data());; 3151 gPad->ResetBit(TGraph::kClipFrame);; 3152 ; 3153 TGraph tgDummy;; 3154 tg->TAttFill::Copy(tgDummy);; 3155 tg->TAttLine::Copy(tgDummy);; 3156 tg->TAttMarker::Copy(tgDummy);; 3157 ; 3158 for (Int_t j = 0; j < NYErrors; j++); 3159 if (Option3[j] && DrawErrors[j]) {; 3160 if (IndividualStyles) {; 3161 tg->GetAttFill(j)->Copy(tgDummy);; 3162 tg->GetAttLine(j)->Copy(tgDummy);; 3163 }; 3164 ; 3165 Int_t logx = gPad->GetLogx();; 3166 Int_t logy = gPad->GetLogy();; 3167 gPad->SetLogx(0);; 3168 gPad->SetLogy(0);; 3169 if (Option4[j]); 3170 PaintGraph(&tgDummy, 2 * NPointsInside, xline.data(), yline[j].data(), ""FC"");; 3171 else; 3172 PaintGraph(&tgDummy, 2 * NPointsInside, xline.data(), yline[j].data(), ""F"");; 3173 gPad->SetLogx(logx);; 3174 gPad->SetLogy(logy);; 3175 }; 3176 ; 3177}; 3178 ; 3179////////////////////////////////////////////////////////////////////////////////; 3180/// [Paint this TGraphBentErrors with its current attributes.](\ref GrP3); 3181 ; 3182void TGraphPainter::PaintGraphBentErrors(TGraph *theGraph, Option_t *option); 3183{; 3184 ; 3185 std::vector<Double_t> xline, yline;; 3186 Int_t if1 = 0;; 3187 Int_t if2 = 0;; 3188 Double_t xb[4], yb[4];; 3189 ; 3190 const Int_t kBASEMARKER=8;; 3191 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:111541,Testability,log,logx,111541,"142 gPad->PaintLine(xr2, y - ty, xr2, y + ty);; 3143 }; 3144 }; 3145 }; 3146 }; 3147 }; 3148 ; 3149 if (DrawMarker && !DrawAxis); 3150 PaintGraphSimple(tg, options[0].Data());; 3151 gPad->ResetBit(TGraph::kClipFrame);; 3152 ; 3153 TGraph tgDummy;; 3154 tg->TAttFill::Copy(tgDummy);; 3155 tg->TAttLine::Copy(tgDummy);; 3156 tg->TAttMarker::Copy(tgDummy);; 3157 ; 3158 for (Int_t j = 0; j < NYErrors; j++); 3159 if (Option3[j] && DrawErrors[j]) {; 3160 if (IndividualStyles) {; 3161 tg->GetAttFill(j)->Copy(tgDummy);; 3162 tg->GetAttLine(j)->Copy(tgDummy);; 3163 }; 3164 ; 3165 Int_t logx = gPad->GetLogx();; 3166 Int_t logy = gPad->GetLogy();; 3167 gPad->SetLogx(0);; 3168 gPad->SetLogy(0);; 3169 if (Option4[j]); 3170 PaintGraph(&tgDummy, 2 * NPointsInside, xline.data(), yline[j].data(), ""FC"");; 3171 else; 3172 PaintGraph(&tgDummy, 2 * NPointsInside, xline.data(), yline[j].data(), ""F"");; 3173 gPad->SetLogx(logx);; 3174 gPad->SetLogy(logy);; 3175 }; 3176 ; 3177}; 3178 ; 3179////////////////////////////////////////////////////////////////////////////////; 3180/// [Paint this TGraphBentErrors with its current attributes.](\ref GrP3); 3181 ; 3182void TGraphPainter::PaintGraphBentErrors(TGraph *theGraph, Option_t *option); 3183{; 3184 ; 3185 std::vector<Double_t> xline, yline;; 3186 Int_t if1 = 0;; 3187 Int_t if2 = 0;; 3188 Double_t xb[4], yb[4];; 3189 ; 3190 const Int_t kBASEMARKER=8;; 3191 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 3192 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 3193 Int_t theNpoints = theGraph->GetN();; 3194 Double_t *theX = theGraph->GetX();; 3195 Double_t *theY = theGraph->GetY();; 3196 Double_t *theEXlow = theGraph->GetEXlow(); if (!theEXlow) return;; 3197 Double_t *theEYlow = theGraph->GetEYlow(); if (!theEYlow) return;; 3198 Double_t *theEXhigh = th",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:111568,Testability,log,logy,111568,"142 gPad->PaintLine(xr2, y - ty, xr2, y + ty);; 3143 }; 3144 }; 3145 }; 3146 }; 3147 }; 3148 ; 3149 if (DrawMarker && !DrawAxis); 3150 PaintGraphSimple(tg, options[0].Data());; 3151 gPad->ResetBit(TGraph::kClipFrame);; 3152 ; 3153 TGraph tgDummy;; 3154 tg->TAttFill::Copy(tgDummy);; 3155 tg->TAttLine::Copy(tgDummy);; 3156 tg->TAttMarker::Copy(tgDummy);; 3157 ; 3158 for (Int_t j = 0; j < NYErrors; j++); 3159 if (Option3[j] && DrawErrors[j]) {; 3160 if (IndividualStyles) {; 3161 tg->GetAttFill(j)->Copy(tgDummy);; 3162 tg->GetAttLine(j)->Copy(tgDummy);; 3163 }; 3164 ; 3165 Int_t logx = gPad->GetLogx();; 3166 Int_t logy = gPad->GetLogy();; 3167 gPad->SetLogx(0);; 3168 gPad->SetLogy(0);; 3169 if (Option4[j]); 3170 PaintGraph(&tgDummy, 2 * NPointsInside, xline.data(), yline[j].data(), ""FC"");; 3171 else; 3172 PaintGraph(&tgDummy, 2 * NPointsInside, xline.data(), yline[j].data(), ""F"");; 3173 gPad->SetLogx(logx);; 3174 gPad->SetLogy(logy);; 3175 }; 3176 ; 3177}; 3178 ; 3179////////////////////////////////////////////////////////////////////////////////; 3180/// [Paint this TGraphBentErrors with its current attributes.](\ref GrP3); 3181 ; 3182void TGraphPainter::PaintGraphBentErrors(TGraph *theGraph, Option_t *option); 3183{; 3184 ; 3185 std::vector<Double_t> xline, yline;; 3186 Int_t if1 = 0;; 3187 Int_t if2 = 0;; 3188 Double_t xb[4], yb[4];; 3189 ; 3190 const Int_t kBASEMARKER=8;; 3191 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 3192 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 3193 Int_t theNpoints = theGraph->GetN();; 3194 Double_t *theX = theGraph->GetX();; 3195 Double_t *theY = theGraph->GetY();; 3196 Double_t *theEXlow = theGraph->GetEXlow(); if (!theEXlow) return;; 3197 Double_t *theEYlow = theGraph->GetEYlow(); if (!theEYlow) return;; 3198 Double_t *theEXhigh = th",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:114295,Testability,log,log,114295,"urn;; 3197 Double_t *theEYlow = theGraph->GetEYlow(); if (!theEYlow) return;; 3198 Double_t *theEXhigh = theGraph->GetEXhigh(); if (!theEXhigh) return;; 3199 Double_t *theEYhigh = theGraph->GetEYhigh(); if (!theEYhigh) return;; 3200 Double_t *theEXlowd = theGraph->GetEXlowd(); if (!theEXlowd) return;; 3201 Double_t *theEXhighd = theGraph->GetEXhighd(); if (!theEXhighd) return;; 3202 Double_t *theEYlowd = theGraph->GetEYlowd(); if (!theEYlowd) return;; 3203 Double_t *theEYhighd = theGraph->GetEYhighd(); if (!theEYhighd) return;; 3204 ; 3205 if (strchr(option,'X') || strchr(option,'x')) {PaintGraphSimple(theGraph, option); return;}; 3206 Bool_t brackets = kFALSE;; 3207 Bool_t braticks = kFALSE;; 3208 if (strstr(option,""||"") || strstr(option,""[]"")) {; 3209 brackets = kTRUE;; 3210 if (strstr(option,""[]"")) braticks = kTRUE;; 3211 }; 3212 Bool_t endLines = kTRUE;; 3213 if (strchr(option,'z')) endLines = kFALSE;; 3214 if (strchr(option,'Z')) endLines = kFALSE;; 3215 const char *arrowOpt = nullptr;; 3216 if (strchr(option,'>')) arrowOpt = "">"";; 3217 if (strstr(option,""|>"")) arrowOpt = ""|>"";; 3218 ; 3219 Bool_t axis = kFALSE;; 3220 if (strchr(option,'a')) axis = kTRUE;; 3221 if (strchr(option,'A')) axis = kTRUE;; 3222 if (axis) PaintGraphSimple(theGraph,option);; 3223 ; 3224 Bool_t option0 = kFALSE;; 3225 Bool_t option2 = kFALSE;; 3226 Bool_t option3 = kFALSE;; 3227 Bool_t option4 = kFALSE;; 3228 Bool_t option5 = kFALSE;; 3229 if (strchr(option,'0')) option0 = kTRUE;; 3230 if (strchr(option,'2')) option2 = kTRUE;; 3231 if (strchr(option,'3')) option3 = kTRUE;; 3232 if (strchr(option,'4')) {option3 = kTRUE; option4 = kTRUE;}; 3233 if (strchr(option,'5')) {option2 = kTRUE; option5 = kTRUE;}; 3234 ; 3235 // special flags in case of ""reverse plot"" and ""log scale""; 3236 Bool_t xrevlog = kFALSE;; 3237 Bool_t yrevlog = kFALSE;; 3238 if (strstr(option,""-N"")) xrevlog = kTRUE; // along X; 3239 if (strstr(option,""-M"")) yrevlog = kTRUE; // along Y; 3240 ; 3241 if (option3) {; 3242 xline.",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:123173,Testability,log,logx,123173,"wYUp) gPad->PaintLine(x,yup1,byh,yup2);; 3453 if (eyl != 0. && DrawYLow) gPad->PaintLine(x,ylow1,byl,ylow2);; 3454 }; 3455 if (endLines) {; 3456 if (braticks) {; 3457 if (eyh != 0. && yup2 == yup && DrawYUp) {; 3458 xb[0] = byh-tx; yb[0] = yup2-ty;; 3459 xb[1] = byh-tx; yb[1] = yup2;; 3460 xb[2] = byh+tx; yb[2] = yup2;; 3461 xb[3] = byh+tx; yb[3] = yup2-ty;; 3462 gPad->PaintPolyLine(4, xb, yb);; 3463 }; 3464 if (eyl != 0. && ylow2 == ylow && DrawYLow) {; 3465 xb[0] = byl-tx; yb[0] = ylow2+ty;; 3466 xb[1] = byl-tx; yb[1] = ylow2;; 3467 xb[2] = byl+tx; yb[2] = ylow2;; 3468 xb[3] = byl+tx; yb[3] = ylow2+ty;; 3469 gPad->PaintPolyLine(4, xb, yb);; 3470 }; 3471 } else {; 3472 if (eyh != 0. && yup2 == yup && DrawYUp) gPad->PaintLine(byh-tx,yup2,byh+tx,yup2);; 3473 if (eyl != 0. && ylow2 == ylow && DrawYLow) gPad->PaintLine(byl-tx,ylow2,byl+tx,ylow2);; 3474 }; 3475 }; 3476 }; 3477 }; 3478 }; 3479 ; 3480 if (!brackets && !axis) PaintGraphSimple(theGraph, option);; 3481 gPad->ResetBit(TGraph::kClipFrame);; 3482 ; 3483 if (option3) {; 3484 Int_t logx = gPad->GetLogx();; 3485 Int_t logy = gPad->GetLogy();; 3486 gPad->SetLogx(0);; 3487 gPad->SetLogy(0);; 3488 if (option4) PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""FC"");; 3489 else PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""F"");; 3490 gPad->SetLogx(logx);; 3491 gPad->SetLogy(logy);; 3492 }; 3493}; 3494 ; 3495 ; 3496////////////////////////////////////////////////////////////////////////////////; 3497/// [Paint this TGraphErrors with its current attributes.](\ref GrP3); 3498 ; 3499void TGraphPainter::PaintGraphErrors(TGraph *theGraph, Option_t *option); 3500{; 3501 ; 3502 std::vector<Double_t> xline, yline;; 3503 Int_t if1 = 0;; 3504 Int_t if2 = 0;; 3505 Double_t xb[4], yb[4];; 3506 ; 3507 const Int_t kBASEMARKER=8;; 3508 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 3509 static Float_t cyy",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:123209,Testability,log,logy,123209,"wYUp) gPad->PaintLine(x,yup1,byh,yup2);; 3453 if (eyl != 0. && DrawYLow) gPad->PaintLine(x,ylow1,byl,ylow2);; 3454 }; 3455 if (endLines) {; 3456 if (braticks) {; 3457 if (eyh != 0. && yup2 == yup && DrawYUp) {; 3458 xb[0] = byh-tx; yb[0] = yup2-ty;; 3459 xb[1] = byh-tx; yb[1] = yup2;; 3460 xb[2] = byh+tx; yb[2] = yup2;; 3461 xb[3] = byh+tx; yb[3] = yup2-ty;; 3462 gPad->PaintPolyLine(4, xb, yb);; 3463 }; 3464 if (eyl != 0. && ylow2 == ylow && DrawYLow) {; 3465 xb[0] = byl-tx; yb[0] = ylow2+ty;; 3466 xb[1] = byl-tx; yb[1] = ylow2;; 3467 xb[2] = byl+tx; yb[2] = ylow2;; 3468 xb[3] = byl+tx; yb[3] = ylow2+ty;; 3469 gPad->PaintPolyLine(4, xb, yb);; 3470 }; 3471 } else {; 3472 if (eyh != 0. && yup2 == yup && DrawYUp) gPad->PaintLine(byh-tx,yup2,byh+tx,yup2);; 3473 if (eyl != 0. && ylow2 == ylow && DrawYLow) gPad->PaintLine(byl-tx,ylow2,byl+tx,ylow2);; 3474 }; 3475 }; 3476 }; 3477 }; 3478 }; 3479 ; 3480 if (!brackets && !axis) PaintGraphSimple(theGraph, option);; 3481 gPad->ResetBit(TGraph::kClipFrame);; 3482 ; 3483 if (option3) {; 3484 Int_t logx = gPad->GetLogx();; 3485 Int_t logy = gPad->GetLogy();; 3486 gPad->SetLogx(0);; 3487 gPad->SetLogy(0);; 3488 if (option4) PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""FC"");; 3489 else PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""F"");; 3490 gPad->SetLogx(logx);; 3491 gPad->SetLogy(logy);; 3492 }; 3493}; 3494 ; 3495 ; 3496////////////////////////////////////////////////////////////////////////////////; 3497/// [Paint this TGraphErrors with its current attributes.](\ref GrP3); 3498 ; 3499void TGraphPainter::PaintGraphErrors(TGraph *theGraph, Option_t *option); 3500{; 3501 ; 3502 std::vector<Double_t> xline, yline;; 3503 Int_t if1 = 0;; 3504 Int_t if2 = 0;; 3505 Double_t xb[4], yb[4];; 3506 ; 3507 const Int_t kBASEMARKER=8;; 3508 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 3509 static Float_t cyy",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:123468,Testability,log,logx,123468,"== ylow && DrawYLow) {; 3465 xb[0] = byl-tx; yb[0] = ylow2+ty;; 3466 xb[1] = byl-tx; yb[1] = ylow2;; 3467 xb[2] = byl+tx; yb[2] = ylow2;; 3468 xb[3] = byl+tx; yb[3] = ylow2+ty;; 3469 gPad->PaintPolyLine(4, xb, yb);; 3470 }; 3471 } else {; 3472 if (eyh != 0. && yup2 == yup && DrawYUp) gPad->PaintLine(byh-tx,yup2,byh+tx,yup2);; 3473 if (eyl != 0. && ylow2 == ylow && DrawYLow) gPad->PaintLine(byl-tx,ylow2,byl+tx,ylow2);; 3474 }; 3475 }; 3476 }; 3477 }; 3478 }; 3479 ; 3480 if (!brackets && !axis) PaintGraphSimple(theGraph, option);; 3481 gPad->ResetBit(TGraph::kClipFrame);; 3482 ; 3483 if (option3) {; 3484 Int_t logx = gPad->GetLogx();; 3485 Int_t logy = gPad->GetLogy();; 3486 gPad->SetLogx(0);; 3487 gPad->SetLogy(0);; 3488 if (option4) PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""FC"");; 3489 else PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""F"");; 3490 gPad->SetLogx(logx);; 3491 gPad->SetLogy(logy);; 3492 }; 3493}; 3494 ; 3495 ; 3496////////////////////////////////////////////////////////////////////////////////; 3497/// [Paint this TGraphErrors with its current attributes.](\ref GrP3); 3498 ; 3499void TGraphPainter::PaintGraphErrors(TGraph *theGraph, Option_t *option); 3500{; 3501 ; 3502 std::vector<Double_t> xline, yline;; 3503 Int_t if1 = 0;; 3504 Int_t if2 = 0;; 3505 Double_t xb[4], yb[4];; 3506 ; 3507 const Int_t kBASEMARKER=8;; 3508 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 3509 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 3510 Int_t theNpoints = theGraph->GetN();; 3511 Double_t *theX = theGraph->GetX();; 3512 Double_t *theY = theGraph->GetY();; 3513 Double_t *theEX = theGraph->GetEX(); if (!theEX) return;; 3514 Double_t *theEY = theGraph->GetEY(); if (!theEY) return;; 3515 ; 3516 if (strchr(option,'X') || strchr(option,'",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:123495,Testability,log,logy,123495,"== ylow && DrawYLow) {; 3465 xb[0] = byl-tx; yb[0] = ylow2+ty;; 3466 xb[1] = byl-tx; yb[1] = ylow2;; 3467 xb[2] = byl+tx; yb[2] = ylow2;; 3468 xb[3] = byl+tx; yb[3] = ylow2+ty;; 3469 gPad->PaintPolyLine(4, xb, yb);; 3470 }; 3471 } else {; 3472 if (eyh != 0. && yup2 == yup && DrawYUp) gPad->PaintLine(byh-tx,yup2,byh+tx,yup2);; 3473 if (eyl != 0. && ylow2 == ylow && DrawYLow) gPad->PaintLine(byl-tx,ylow2,byl+tx,ylow2);; 3474 }; 3475 }; 3476 }; 3477 }; 3478 }; 3479 ; 3480 if (!brackets && !axis) PaintGraphSimple(theGraph, option);; 3481 gPad->ResetBit(TGraph::kClipFrame);; 3482 ; 3483 if (option3) {; 3484 Int_t logx = gPad->GetLogx();; 3485 Int_t logy = gPad->GetLogy();; 3486 gPad->SetLogx(0);; 3487 gPad->SetLogy(0);; 3488 if (option4) PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""FC"");; 3489 else PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""F"");; 3490 gPad->SetLogx(logx);; 3491 gPad->SetLogy(logy);; 3492 }; 3493}; 3494 ; 3495 ; 3496////////////////////////////////////////////////////////////////////////////////; 3497/// [Paint this TGraphErrors with its current attributes.](\ref GrP3); 3498 ; 3499void TGraphPainter::PaintGraphErrors(TGraph *theGraph, Option_t *option); 3500{; 3501 ; 3502 std::vector<Double_t> xline, yline;; 3503 Int_t if1 = 0;; 3504 Int_t if2 = 0;; 3505 Double_t xb[4], yb[4];; 3506 ; 3507 const Int_t kBASEMARKER=8;; 3508 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 3509 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 3510 Int_t theNpoints = theGraph->GetN();; 3511 Double_t *theX = theGraph->GetX();; 3512 Double_t *theY = theGraph->GetY();; 3513 Double_t *theEX = theGraph->GetEX(); if (!theEX) return;; 3514 Double_t *theEY = theGraph->GetEY(); if (!theEY) return;; 3515 ; 3516 if (strchr(option,'X') || strchr(option,'",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:125741,Testability,log,log,125741," Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 3510 Int_t theNpoints = theGraph->GetN();; 3511 Double_t *theX = theGraph->GetX();; 3512 Double_t *theY = theGraph->GetY();; 3513 Double_t *theEX = theGraph->GetEX(); if (!theEX) return;; 3514 Double_t *theEY = theGraph->GetEY(); if (!theEY) return;; 3515 ; 3516 if (strchr(option,'X') || strchr(option,'x')) {PaintGraphSimple(theGraph, option); return;}; 3517 Bool_t brackets = kFALSE;; 3518 Bool_t braticks = kFALSE;; 3519 if (strstr(option,""||"") || strstr(option,""[]"")) {; 3520 brackets = kTRUE;; 3521 if (strstr(option,""[]"")) braticks = kTRUE;; 3522 }; 3523 Bool_t endLines = kTRUE;; 3524 if (strchr(option,'z')) endLines = kFALSE;; 3525 if (strchr(option,'Z')) endLines = kFALSE;; 3526 const char *arrowOpt = nullptr;; 3527 if (strchr(option,'>')) arrowOpt = "">"";; 3528 if (strstr(option,""|>"")) arrowOpt = ""|>"";; 3529 ; 3530 Bool_t axis = kFALSE;; 3531 if (strchr(option,'a')) axis = kTRUE;; 3532 if (strchr(option,'A')) axis = kTRUE;; 3533 if (axis) PaintGraphSimple(theGraph, option);; 3534 ; 3535 Bool_t option0 = kFALSE;; 3536 Bool_t option2 = kFALSE;; 3537 Bool_t option3 = kFALSE;; 3538 Bool_t option4 = kFALSE;; 3539 Bool_t option5 = kFALSE;; 3540 if (strchr(option,'0')) option0 = kTRUE;; 3541 if (strchr(option,'2')) option2 = kTRUE;; 3542 if (strchr(option,'3')) option3 = kTRUE;; 3543 if (strchr(option,'4')) {option3 = kTRUE; option4 = kTRUE;}; 3544 if (strchr(option,'5')) {option2 = kTRUE; option5 = kTRUE;}; 3545 ; 3546 // special flags in case of ""reverse plot"" and ""log scale""; 3547 Bool_t xrevlog = kFALSE;; 3548 Bool_t yrevlog = kFALSE;; 3549 if (strstr(option,""-N"")) xrevlog = kTRUE; // along X; 3550 if (strstr(option,""-M"")) yrevlog = kTRUE; // along Y; 3551 ; 3552 if (option3) {; 3553 xline.resize(2*theNpoints);; 3554 yline.resize(2*theNpoints);; 3555 if (xline.empty() || yline.empty()) {; 3556 Error(""PaintGraphErrors"", ""too m",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:133299,Testability,log,logx,133299,"tLine(xl2,y-ty,xl2,y+ty);; 3724 if (DrawXRight) gPad->PaintLine(xr2,y-ty,xr2,y+ty);; 3725 }; 3726 }; 3727 }; 3728 }; 3729 ; 3730 if (ey != 0.) {; 3731 if (arrowOpt) {; 3732 if (DrawYUp) {; 3733 if (yup2 == yup) arrow.PaintArrow(x,yup1,x,yup2,asize,arrowOpt);; 3734 else gPad->PaintLine(x,yup1,x,yup2);; 3735 }; 3736 if (DrawYLow) {; 3737 if (ylow2 == ylow) arrow.PaintArrow(x,ylow1,x,ylow2,asize,arrowOpt);; 3738 else gPad->PaintLine(x,ylow1,x,ylow2);; 3739 }; 3740 } else {; 3741 if (!brackets) {; 3742 if (DrawYUp) gPad->PaintLine(x,yup1,x,yup2);; 3743 if (DrawYLow) gPad->PaintLine(x,ylow1,x,ylow2);; 3744 }; 3745 if (endLines) {; 3746 if (braticks) {; 3747 if (yup2 == yup && DrawYUp) {; 3748 xb[0] = x-tx; yb[0] = yup2-ty;; 3749 xb[1] = x-tx; yb[1] = yup2;; 3750 xb[2] = x+tx; yb[2] = yup2;; 3751 xb[3] = x+tx; yb[3] = yup2-ty;; 3752 gPad->PaintPolyLine(4, xb, yb);; 3753 }; 3754 if (ylow2 == ylow && DrawYLow) {; 3755 xb[0] = x-tx; yb[0] = ylow2+ty;; 3756 xb[1] = x-tx; yb[1] = ylow2;; 3757 xb[2] = x+tx; yb[2] = ylow2;; 3758 xb[3] = x+tx; yb[3] = ylow2+ty;; 3759 gPad->PaintPolyLine(4, xb, yb);; 3760 }; 3761 } else {; 3762 if (yup2 == yup && DrawYUp) gPad->PaintLine(x-tx,yup2,x+tx,yup2);; 3763 if (ylow2 == ylow && DrawYLow) gPad->PaintLine(x-tx,ylow2,x+tx,ylow2);; 3764 }; 3765 }; 3766 }; 3767 }; 3768 }; 3769 ; 3770 if (!brackets && !axis) PaintGraphSimple(theGraph, option);; 3771 gPad->ResetBit(TGraph::kClipFrame);; 3772 ; 3773 if (option3) {; 3774 Int_t logx = gPad->GetLogx();; 3775 Int_t logy = gPad->GetLogy();; 3776 gPad->SetLogx(0);; 3777 gPad->SetLogy(0);; 3778 if (option4) PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""FC"");; 3779 else PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""F"");; 3780 gPad->SetLogx(logx);; 3781 gPad->SetLogy(logy);; 3782 }; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// [Paint this TGraphPolar with its current attributes.](\ref GrP4); 3788 ; 3789v",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:133335,Testability,log,logy,133335,"tLine(xl2,y-ty,xl2,y+ty);; 3724 if (DrawXRight) gPad->PaintLine(xr2,y-ty,xr2,y+ty);; 3725 }; 3726 }; 3727 }; 3728 }; 3729 ; 3730 if (ey != 0.) {; 3731 if (arrowOpt) {; 3732 if (DrawYUp) {; 3733 if (yup2 == yup) arrow.PaintArrow(x,yup1,x,yup2,asize,arrowOpt);; 3734 else gPad->PaintLine(x,yup1,x,yup2);; 3735 }; 3736 if (DrawYLow) {; 3737 if (ylow2 == ylow) arrow.PaintArrow(x,ylow1,x,ylow2,asize,arrowOpt);; 3738 else gPad->PaintLine(x,ylow1,x,ylow2);; 3739 }; 3740 } else {; 3741 if (!brackets) {; 3742 if (DrawYUp) gPad->PaintLine(x,yup1,x,yup2);; 3743 if (DrawYLow) gPad->PaintLine(x,ylow1,x,ylow2);; 3744 }; 3745 if (endLines) {; 3746 if (braticks) {; 3747 if (yup2 == yup && DrawYUp) {; 3748 xb[0] = x-tx; yb[0] = yup2-ty;; 3749 xb[1] = x-tx; yb[1] = yup2;; 3750 xb[2] = x+tx; yb[2] = yup2;; 3751 xb[3] = x+tx; yb[3] = yup2-ty;; 3752 gPad->PaintPolyLine(4, xb, yb);; 3753 }; 3754 if (ylow2 == ylow && DrawYLow) {; 3755 xb[0] = x-tx; yb[0] = ylow2+ty;; 3756 xb[1] = x-tx; yb[1] = ylow2;; 3757 xb[2] = x+tx; yb[2] = ylow2;; 3758 xb[3] = x+tx; yb[3] = ylow2+ty;; 3759 gPad->PaintPolyLine(4, xb, yb);; 3760 }; 3761 } else {; 3762 if (yup2 == yup && DrawYUp) gPad->PaintLine(x-tx,yup2,x+tx,yup2);; 3763 if (ylow2 == ylow && DrawYLow) gPad->PaintLine(x-tx,ylow2,x+tx,ylow2);; 3764 }; 3765 }; 3766 }; 3767 }; 3768 }; 3769 ; 3770 if (!brackets && !axis) PaintGraphSimple(theGraph, option);; 3771 gPad->ResetBit(TGraph::kClipFrame);; 3772 ; 3773 if (option3) {; 3774 Int_t logx = gPad->GetLogx();; 3775 Int_t logy = gPad->GetLogy();; 3776 gPad->SetLogx(0);; 3777 gPad->SetLogy(0);; 3778 if (option4) PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""FC"");; 3779 else PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""F"");; 3780 gPad->SetLogx(logx);; 3781 gPad->SetLogy(logy);; 3782 }; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// [Paint this TGraphPolar with its current attributes.](\ref GrP4); 3788 ; 3789v",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:133594,Testability,log,logx,133594,"lyLine(4, xb, yb);; 3753 }; 3754 if (ylow2 == ylow && DrawYLow) {; 3755 xb[0] = x-tx; yb[0] = ylow2+ty;; 3756 xb[1] = x-tx; yb[1] = ylow2;; 3757 xb[2] = x+tx; yb[2] = ylow2;; 3758 xb[3] = x+tx; yb[3] = ylow2+ty;; 3759 gPad->PaintPolyLine(4, xb, yb);; 3760 }; 3761 } else {; 3762 if (yup2 == yup && DrawYUp) gPad->PaintLine(x-tx,yup2,x+tx,yup2);; 3763 if (ylow2 == ylow && DrawYLow) gPad->PaintLine(x-tx,ylow2,x+tx,ylow2);; 3764 }; 3765 }; 3766 }; 3767 }; 3768 }; 3769 ; 3770 if (!brackets && !axis) PaintGraphSimple(theGraph, option);; 3771 gPad->ResetBit(TGraph::kClipFrame);; 3772 ; 3773 if (option3) {; 3774 Int_t logx = gPad->GetLogx();; 3775 Int_t logy = gPad->GetLogy();; 3776 gPad->SetLogx(0);; 3777 gPad->SetLogy(0);; 3778 if (option4) PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""FC"");; 3779 else PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""F"");; 3780 gPad->SetLogx(logx);; 3781 gPad->SetLogy(logy);; 3782 }; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// [Paint this TGraphPolar with its current attributes.](\ref GrP4); 3788 ; 3789void TGraphPainter::PaintGraphPolar(TGraph *theGraph, Option_t* options); 3790{; 3791 ; 3792 Int_t ipt, i;; 3793 Double_t rwrmin, rwrmax, rwtmin, rwtmax;; 3794 ; 3795 TGraphPolar *theGraphPolar = (TGraphPolar*) theGraph;; 3796 ; 3797 Int_t theNpoints = theGraphPolar->GetN();; 3798 Double_t *theX = theGraphPolar->GetX();; 3799 Double_t *theY = theGraphPolar->GetY();; 3800 Double_t *theEX = theGraphPolar->GetEX();; 3801 Double_t *theEY = theGraphPolar->GetEY();; 3802 ; 3803 if (theNpoints<1) return;; 3804 TString opt = options;; 3805 opt.ToUpper();; 3806 ; 3807 Bool_t nolabel = kFALSE;; 3808 if (opt.Contains(""N"")){; 3809 nolabel = kTRUE;; 3810 opt.ReplaceAll(""N"","""");; 3811 }; 3812 ; 3813 TGraphPolargram *thePolargram = theGraphPolar->GetPolargram();; 3814 ; 3815 // Check for existing TGraphPolargram in the Pad; 3816 if (gPad) {; 3817 // Existin",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:133621,Testability,log,logy,133621,"lyLine(4, xb, yb);; 3753 }; 3754 if (ylow2 == ylow && DrawYLow) {; 3755 xb[0] = x-tx; yb[0] = ylow2+ty;; 3756 xb[1] = x-tx; yb[1] = ylow2;; 3757 xb[2] = x+tx; yb[2] = ylow2;; 3758 xb[3] = x+tx; yb[3] = ylow2+ty;; 3759 gPad->PaintPolyLine(4, xb, yb);; 3760 }; 3761 } else {; 3762 if (yup2 == yup && DrawYUp) gPad->PaintLine(x-tx,yup2,x+tx,yup2);; 3763 if (ylow2 == ylow && DrawYLow) gPad->PaintLine(x-tx,ylow2,x+tx,ylow2);; 3764 }; 3765 }; 3766 }; 3767 }; 3768 }; 3769 ; 3770 if (!brackets && !axis) PaintGraphSimple(theGraph, option);; 3771 gPad->ResetBit(TGraph::kClipFrame);; 3772 ; 3773 if (option3) {; 3774 Int_t logx = gPad->GetLogx();; 3775 Int_t logy = gPad->GetLogy();; 3776 gPad->SetLogx(0);; 3777 gPad->SetLogy(0);; 3778 if (option4) PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""FC"");; 3779 else PaintGraph(theGraph, 2*theNpoints, xline.data(), yline.data(),""F"");; 3780 gPad->SetLogx(logx);; 3781 gPad->SetLogy(logy);; 3782 }; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// [Paint this TGraphPolar with its current attributes.](\ref GrP4); 3788 ; 3789void TGraphPainter::PaintGraphPolar(TGraph *theGraph, Option_t* options); 3790{; 3791 ; 3792 Int_t ipt, i;; 3793 Double_t rwrmin, rwrmax, rwtmin, rwtmax;; 3794 ; 3795 TGraphPolar *theGraphPolar = (TGraphPolar*) theGraph;; 3796 ; 3797 Int_t theNpoints = theGraphPolar->GetN();; 3798 Double_t *theX = theGraphPolar->GetX();; 3799 Double_t *theY = theGraphPolar->GetY();; 3800 Double_t *theEX = theGraphPolar->GetEX();; 3801 Double_t *theEY = theGraphPolar->GetEY();; 3802 ; 3803 if (theNpoints<1) return;; 3804 TString opt = options;; 3805 opt.ToUpper();; 3806 ; 3807 Bool_t nolabel = kFALSE;; 3808 if (opt.Contains(""N"")){; 3809 nolabel = kTRUE;; 3810 opt.ReplaceAll(""N"","""");; 3811 }; 3812 ; 3813 TGraphPolargram *thePolargram = theGraphPolar->GetPolargram();; 3814 ; 3815 // Check for existing TGraphPolargram in the Pad; 3816 if (gPad) {; 3817 // Existin",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:159814,Testability,log,logx,159814,,MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:159848,Testability,log,logy,159848,,MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:159882,Testability,log,logz,159882,,MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:159928,Testability,log,logz,159928,,MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:160225,Testability,log,logz,160225,"etLabelSize(h->GetZaxis()->GetLabelSize());; 4520 palette->SetTitleOffset(h->GetZaxis()->GetTitleOffset());; 4521 palette->SetTitleSize(h->GetZaxis()->GetTitleSize());; 4522 palette->SetNdivisions(h->GetZaxis()->GetNdivisions());; 4523 palette->SetTitle(h->GetZaxis()->GetTitle());; 4524 palette->SetTitleColor(h->GetZaxis()->GetTitleColor());; 4525 palette->SetTitleFont(h->GetZaxis()->GetTitleFont());; 4526 ; 4527 functions->AddFirst(palette);; 4528 }; 4529 if (palette) palette->Paint();; 4530 }; 4531 ; 4532 // Draw markers; 4533 auto nbcol = gStyle->GetNumberOfColors();; 4534 int logx = gPad->GetLogx();; 4535 int logy = gPad->GetLogy();; 4536 int logz = gPad->GetLogz();; 4537 if (theColor && logz) {; 4538 if (minc>0) minc = log10(minc);; 4539 if (maxc>0) maxc = log10(maxc);; 4540 }; 4541 theScatter->SetMarkerColor(theScatter->GetMarkerColor());; 4542 theScatter->TAttMarker::Modify();; 4543 double x,y,c,ms;; 4544 int nc;; 4545 for (int i=0; i<n; i++) {; 4546 if (theColor) {; 4547 if (logz) {; 4548 if (theColor[i]>0) c = log10(theColor[i]);; 4549 else continue;; 4550 } else {; 4551 c = theColor[i];; 4552 }; 4553 if (c<minc) continue;; 4554 if (c>maxc) continue;; 4555 nc = TMath::Nint(((c-minc)/(maxc-minc))*(nbcol-1));; 4556 if (nc > nbcol-1) nc = nbcol-1;; 4557 theScatter->SetMarkerColor(gStyle->GetColorPalette(nc));; 4558 }; 4559 if (theSize) {; 4560 ms = (MaxMarkerSize-MinMarkerSize)*((theSize[i]-mins)/(maxs-mins))+MinMarkerSize;; 4561 theScatter->SetMarkerSize(ms);; 4562 }; 4563 if (theColor || theSize) theScatter->TAttMarker::Modify();; 4564 if (logx) {; 4565 if (theX[i]>0) x = log10(theX[i]);; 4566 else break;; 4567 } else {; 4568 x = theX[i];; 4569 }; 4570 if (logy) {; 4571 if (theY[i]>0) y = log10(theY[i]);; 4572 else break;; 4573 } else {; 4574 y = theY[i];; 4575 }; 4576 gPad->PaintPolyMarker(1,&x,&y);; 4577 }; 4578}; 4579 ; 4580 ; 4581////////////////////////////////////////////////////////////////////////////////; 4582/// Paint a simple graph, without errors ",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:160801,Testability,log,logx,160801,"elSize(h->GetZaxis()->GetLabelSize());; 4520 palette->SetTitleOffset(h->GetZaxis()->GetTitleOffset());; 4521 palette->SetTitleSize(h->GetZaxis()->GetTitleSize());; 4522 palette->SetNdivisions(h->GetZaxis()->GetNdivisions());; 4523 palette->SetTitle(h->GetZaxis()->GetTitle());; 4524 palette->SetTitleColor(h->GetZaxis()->GetTitleColor());; 4525 palette->SetTitleFont(h->GetZaxis()->GetTitleFont());; 4526 ; 4527 functions->AddFirst(palette);; 4528 }; 4529 if (palette) palette->Paint();; 4530 }; 4531 ; 4532 // Draw markers; 4533 auto nbcol = gStyle->GetNumberOfColors();; 4534 int logx = gPad->GetLogx();; 4535 int logy = gPad->GetLogy();; 4536 int logz = gPad->GetLogz();; 4537 if (theColor && logz) {; 4538 if (minc>0) minc = log10(minc);; 4539 if (maxc>0) maxc = log10(maxc);; 4540 }; 4541 theScatter->SetMarkerColor(theScatter->GetMarkerColor());; 4542 theScatter->TAttMarker::Modify();; 4543 double x,y,c,ms;; 4544 int nc;; 4545 for (int i=0; i<n; i++) {; 4546 if (theColor) {; 4547 if (logz) {; 4548 if (theColor[i]>0) c = log10(theColor[i]);; 4549 else continue;; 4550 } else {; 4551 c = theColor[i];; 4552 }; 4553 if (c<minc) continue;; 4554 if (c>maxc) continue;; 4555 nc = TMath::Nint(((c-minc)/(maxc-minc))*(nbcol-1));; 4556 if (nc > nbcol-1) nc = nbcol-1;; 4557 theScatter->SetMarkerColor(gStyle->GetColorPalette(nc));; 4558 }; 4559 if (theSize) {; 4560 ms = (MaxMarkerSize-MinMarkerSize)*((theSize[i]-mins)/(maxs-mins))+MinMarkerSize;; 4561 theScatter->SetMarkerSize(ms);; 4562 }; 4563 if (theColor || theSize) theScatter->TAttMarker::Modify();; 4564 if (logx) {; 4565 if (theX[i]>0) x = log10(theX[i]);; 4566 else break;; 4567 } else {; 4568 x = theX[i];; 4569 }; 4570 if (logy) {; 4571 if (theY[i]>0) y = log10(theY[i]);; 4572 else break;; 4573 } else {; 4574 y = theY[i];; 4575 }; 4576 gPad->PaintPolyMarker(1,&x,&y);; 4577 }; 4578}; 4579 ; 4580 ; 4581////////////////////////////////////////////////////////////////////////////////; 4582/// Paint a simple graph, without errors bars.",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:160920,Testability,log,logy,160920,"elSize(h->GetZaxis()->GetLabelSize());; 4520 palette->SetTitleOffset(h->GetZaxis()->GetTitleOffset());; 4521 palette->SetTitleSize(h->GetZaxis()->GetTitleSize());; 4522 palette->SetNdivisions(h->GetZaxis()->GetNdivisions());; 4523 palette->SetTitle(h->GetZaxis()->GetTitle());; 4524 palette->SetTitleColor(h->GetZaxis()->GetTitleColor());; 4525 palette->SetTitleFont(h->GetZaxis()->GetTitleFont());; 4526 ; 4527 functions->AddFirst(palette);; 4528 }; 4529 if (palette) palette->Paint();; 4530 }; 4531 ; 4532 // Draw markers; 4533 auto nbcol = gStyle->GetNumberOfColors();; 4534 int logx = gPad->GetLogx();; 4535 int logy = gPad->GetLogy();; 4536 int logz = gPad->GetLogz();; 4537 if (theColor && logz) {; 4538 if (minc>0) minc = log10(minc);; 4539 if (maxc>0) maxc = log10(maxc);; 4540 }; 4541 theScatter->SetMarkerColor(theScatter->GetMarkerColor());; 4542 theScatter->TAttMarker::Modify();; 4543 double x,y,c,ms;; 4544 int nc;; 4545 for (int i=0; i<n; i++) {; 4546 if (theColor) {; 4547 if (logz) {; 4548 if (theColor[i]>0) c = log10(theColor[i]);; 4549 else continue;; 4550 } else {; 4551 c = theColor[i];; 4552 }; 4553 if (c<minc) continue;; 4554 if (c>maxc) continue;; 4555 nc = TMath::Nint(((c-minc)/(maxc-minc))*(nbcol-1));; 4556 if (nc > nbcol-1) nc = nbcol-1;; 4557 theScatter->SetMarkerColor(gStyle->GetColorPalette(nc));; 4558 }; 4559 if (theSize) {; 4560 ms = (MaxMarkerSize-MinMarkerSize)*((theSize[i]-mins)/(maxs-mins))+MinMarkerSize;; 4561 theScatter->SetMarkerSize(ms);; 4562 }; 4563 if (theColor || theSize) theScatter->TAttMarker::Modify();; 4564 if (logx) {; 4565 if (theX[i]>0) x = log10(theX[i]);; 4566 else break;; 4567 } else {; 4568 x = theX[i];; 4569 }; 4570 if (logy) {; 4571 if (theY[i]>0) y = log10(theY[i]);; 4572 else break;; 4573 } else {; 4574 y = theY[i];; 4575 }; 4576 gPad->PaintPolyMarker(1,&x,&y);; 4577 }; 4578}; 4579 ; 4580 ; 4581////////////////////////////////////////////////////////////////////////////////; 4582/// Paint a simple graph, without errors bars.",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:199886,Testability,log,logarithm,199886,"n TGraphPainter.cxx:4820; TGraphPainter::PaintPolyLineHatchesvoid PaintPolyLineHatches(TGraph *theGraph, Int_t n, const Double_t *x, const Double_t *y)Paint a polyline with hatches on one side showing an exclusion zone.Definition TGraphPainter.cxx:4620; TGraphPainter::DrawPanelHelpervoid DrawPanelHelper(TGraph *theGraph) overrideDisplay a panel with all histogram drawing options.Definition TGraphPainter.cxx:796; TGraphPainter::GetObjectInfoHelperchar * GetObjectInfoHelper(TGraph *theGraph, Int_t px, Int_t py) const overrideDefinition TGraphPainter.cxx:1101; TGraphPainter::ExecuteEventHelpervoid ExecuteEventHelper(TGraph *theGraph, Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGraphPainter.cxx:821; TGraphPainter::HighlightPointvirtual void HighlightPoint(TGraph *theGraph, Int_t hpoint, Int_t distance)Check on highlight point.Definition TGraphPainter.cxx:1136; TGraphPainter::ComputeLogsvoid ComputeLogs(Int_t npoints, Int_t opt)Compute the logarithm of variables gxwork and gywork according to the value of Options and put the re...Definition TGraphPainter.cxx:690; TGraphPainter::gxworklstd::vector< Double_t > gxworklDefinition TGraphPainter.h:69; TGraphPainter::DistancetoPrimitiveHelperInt_t DistancetoPrimitiveHelper(TGraph *theGraph, Int_t px, Int_t py) overrideCompute distance from point px,py to a graph.Definition TGraphPainter.cxx:717; TGraphPainter::gxworkstd::vector< Double_t > gxworkDefinition TGraphPainter.h:69; TGraphPainter::gyworkstd::vector< Double_t > gyworkDefinition TGraphPainter.h:69; TGraphPainter::PaintScattervoid PaintScatter(TScatter *theScatter, Option_t *option) overridePaint a scatter plot.Definition TGraphPainter.cxx:4392; TGraphPainter::Smoothvoid Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype)Smooth a curve given by N points.Definition TGraphPainter.cxx:4938; TGraphPainter::gyworklstd::vector< Double_t > gyworklInternal buffers for coordinates. Used for graphs pa",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:223309,Testability,log,logarithm,223309,"Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; arrowDefinition RArrowDS.hxx:17; lTLine lDefinition textangle.C:4; DrawMarkerm DrawMarker(0.1, 0.1). histhistpaintersrcTGraphPainter.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:3017,Usability,simpl,simple,3017,"[Introduction](\ref GrP0); 60- [Graphs' plotting options](\ref GrP1); 61- [Exclusion graphs](\ref GrP2); 62- [Graphs with error bars](\ref GrP3); 63 - [TGraphErrors](\ref GrP3a); 64 - [TGraphAsymmErrors](\ref GrP3b); 65 - [TGraphBentErrors](\ref GrP3c); 66 - [TGraphMultiErrors](\ref GrP3d); 67- [TGraphPolar options](\ref GrP4); 68- [Colors automatically picked in palette](\ref GrP5); 69- [Reverse graphs' axis](\ref GrP6); 70- [Graphs in logarithmic scale](\ref GrP7); 71- [Highlight mode for graph](\ref GrP8); 72 ; 73 ; 74\anchor GrP0; 75### Introduction; 76 ; 77Graphs are drawn via the painter `TGraphPainter` class. This class; 78implements techniques needed to display the various kind of; 79graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`.; 80 ; 81To draw a graph `graph` it's enough to do:; 82 ; 83 graph->Draw(""AL"");; 84 ; 85The option `AL` in the `Draw()` method means:; 86 ; 871. The axis should be drawn (option `A`),; 882. The graph should be drawn as a simple line (option `L`).; 89 ; 90 By default a graph is drawn in the current pad in the current coordinate system.; 91To define a suitable coordinate system and draw the axis the option; 92`A` must be specified.; 93 ; 94`TGraphPainter` offers many options to paint the various kind of graphs.; 95 ; 96It is separated from the graph classes so that one can have graphs without the; 97graphics overhead, for example in a batch program.; 98 ; 99When a displayed graph is modified, there is no need to call `Draw()` again; the; 100image will be refreshed the next time the pad will be updated. A pad is updated; 101after one of these three actions:; 102 ; 1031. a carriage return on the ROOT command line,; 1042. a click inside the pad,; 1053. a call to `TPad::Update`.; 106 ; 107\anchor GrP1; 108### Graphs' plotting options; 109Graphs can be drawn with the following options:; 110 ; 111| Option | Description |; 112|----------|-------------------------------------------------------------------|; 1",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:4148,Usability,simpl,simple,4148," coordinate system and draw the axis the option; 92`A` must be specified.; 93 ; 94`TGraphPainter` offers many options to paint the various kind of graphs.; 95 ; 96It is separated from the graph classes so that one can have graphs without the; 97graphics overhead, for example in a batch program.; 98 ; 99When a displayed graph is modified, there is no need to call `Draw()` again; the; 100image will be refreshed the next time the pad will be updated. A pad is updated; 101after one of these three actions:; 102 ; 1031. a carriage return on the ROOT command line,; 1042. a click inside the pad,; 1053. a call to `TPad::Update`.; 106 ; 107\anchor GrP1; 108### Graphs' plotting options; 109Graphs can be drawn with the following options:; 110 ; 111| Option | Description |; 112|----------|-------------------------------------------------------------------|; 113| ""A"" | Produce a new plot with Axis around the graph |; 114| ""I"" | Combine with option 'A' it draws invisible axis |; 115| ""L"" | A simple polyline is drawn |; 116| ""F"" | A fill area is drawn ('CF' draw a smoothed fill area) |; 117| ""C"" | A smooth Curve is drawn |; 118| ""*"" | A Star is plotted at each point |; 119| ""P"" | The current marker is plotted at each point |; 120| ""B"" | A Bar chart is drawn |; 121| ""1"" | When a graph is drawn as a bar chart, this option makes the bars start from the bottom of the pad. By default they start at 0. |; 122| ""X+"" | The X-axis is drawn on the top side of the plot. |; 123| ""Y+"" | The Y-axis is drawn on the right side of the plot. |; 124| ""PFC"" | Palette Fill Color: graph's fill color is taken in the current palette. |; 125| ""PLC"" | Palette Line Color: graph's line color is taken in the current palette. |; 126| ""PMC"" | Palette Marker Color: graph's marker color is taken in the current palette. |; 127| ""RX"" | Reverse the X axis. |; 128| ""RY"" | Reverse the Y axis. |; 129 ; 130Drawing options can be combined. In the following example the graph; 131is drawn as a smooth curve (option ""C"") with m",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:20558,Usability,simpl,simplest,20558,"etPoint(0, (1*TMath::Pi())/4., 0.05);; 494 grP1->SetPoint(1, (2*TMath::Pi())/4., 0.10);; 495 grP1->SetPoint(2, (3*TMath::Pi())/4., 0.15);; 496 grP1->SetPoint(3, (4*TMath::Pi())/4., 0.20);; 497 grP1->SetPoint(4, (5*TMath::Pi())/4., 0.25);; 498 grP1->SetPoint(5, (6*TMath::Pi())/4., 0.30);; 499 grP1->SetPoint(6, (7*TMath::Pi())/4., 0.35);; 500 grP1->SetPoint(7, (8*TMath::Pi())/4., 0.40);; 501 ; 502 grP1->SetMarkerStyle(20);; 503 grP1->SetMarkerSize(1.);; 504 grP1->SetMarkerColor(4);; 505 grP1->SetLineColor(4);; 506 grP1->Draw(""ALP"");; 507 ; 508 // Update, otherwise GetPolargram returns 0; 509 c46->Update();; 510 grP1->GetPolargram()->SetToRadian();; 511}; 512End_Macro; 513 ; 514\anchor GrP5; 515### Colors automatically picked in palette; 516 ; 517\since **ROOT version 6.09/01**; 518 ; 519When several graphs are painted in the same canvas or when a multi-graph is drawn,; 520it might be useful to have an easy and automatic way to choose; 521their color. The simplest way is to pick colors in the current active color; 522palette. Palette coloring for histogram is activated thanks to the options `PFC`; 523(Palette Fill Color), `PLC` (Palette Line Color) and `PMC` (Palette Marker Color).; 524When one of these options is given to `TGraph::Draw` the graph get its color; 525from the current color palette defined by `gStyle->SetPalette(...)`. The color; 526is determined according to the number of objects having palette coloring in; 527the current pad.; 528 ; 529Begin_Macro(source); 530../../../tutorials/graphs/graphpalettecolor.C; 531End_Macro; 532 ; 533Begin_Macro(source); 534../../../tutorials/graphs/multigraphpalettecolor.C; 535End_Macro; 536 ; 537\anchor GrP6; 538### Reverse graphs' axis; 539 ; 540\since **ROOT version 6.09/03**; 541 ; 542When a TGraph is drawn, the X-axis is drawn with increasing values from left to; 543right and the Y-axis from bottom to top. The two options `RX` and `RY` allow to; 544change this order. The option `RX` allows to draw the X-axis with increa",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:22843,Usability,clear,clearly,22843,"g->SetTitle(""Simple Graph"");; 554 ; 555 g->SetPoint(0,-4,-3);; 556 g->SetPoint(1,1,1);; 557 g->SetPoint(2,2,1);; 558 g->SetPoint(3,3,4);; 559 g->SetPoint(4,5,5);; 560 ; 561 g->SetPointError(0,1.,2.);; 562 g->SetPointError(1,2,1);; 563 g->SetPointError(2,2,3);; 564 g->SetPointError(3,3,2);; 565 g->SetPointError(4,4,5);; 566 ; 567 g->GetXaxis()->SetNdivisions(520);; 568 ; 569 g->SetMarkerStyle(21);; 570 c->cd(1); gPad->SetGrid(1,1);; 571 g->Draw(""APL"");; 572 ; 573 c->cd(2); gPad->SetGrid(1,1);; 574 g->Draw(""A RX RY PL"");; 575}; 576End_Macro; 577 ; 578\anchor GrP7; 579### Graphs in logarithmic scale; 580 ; 581Like histograms, graphs can be drawn in logarithmic scale along X and Y. When; 582a pad is set to logarithmic scale with TPad::SetLogx() and/or with TPad::SetLogy(); 583the points building the graph are converted into logarithmic scale. But **only** the; 584points not the lines connecting them which stay linear. This can be clearly seen; 585on the following example:; 586 ; 587Begin_Macro(source); 588{; 589 // A graph with 3 points; 590 Double_t xmin = 750.;; 591 Double_t xmax = 1000;; 592 auto g = new TGraph(3);; 593 g->SetPoint(0,xmin,0.1);; 594 g->SetPoint(1,845,0.06504);; 595 g->SetPoint(2,xmax,0.008);; 596 ; 597 // The same graph with n points; 598 Int_t n = 10000;; 599 Double_t dx = (xmax-xmin)/n;; 600 Double_t x = xmin;; 601 auto g2 = new TGraph();; 602 for (Int_t i=0; i<n; i++) {; 603 g2->SetPoint(i, x, g->Eval(x));; 604 x = x + dx;; 605 }; 606 ; 607 auto cv = new TCanvas(""cv"",""cv"",800,600);; 608 cv->SetLogy();; 609 cv->SetGridx();; 610 cv->SetGridy();; 611 g->Draw(""AL*"");; 612 ; 613 g2->SetMarkerColor(kRed);; 614 g2->SetMarkerStyle(1);; 615 g2->Draw(""P"");; 616}; 617 ; 618End_Macro; 619 ; 620\anchor GrP8; 621#### Highlight mode for graph; 622 ; 623\since **ROOT version 6.15/01**; 624 ; 625\image html hlGraph1.gif ""Highlight mode""; 626 ; 627Highlight mode is implemented for `TGraph` (and for `TH1`) class. When; 628highlight mode is on, mouse movement over the",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:38508,Usability,clear,clear,38508,"gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 1012 if (!y.empty()) theY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 1013 }; 1014 } else {; 1015 pxold = px;; 1016 pxold = TMath::Max(pxold, px1);; 1017 pxold = TMath::Min(pxold, px2);; 1018 pyold = py;; 1019 pyold = TMath::Max(pyold, py2);; 1020 pyold = TMath::Min(pyold, py1);; 1021 theX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 1022 theY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 1023 if (theGraph->InheritsFrom(""TCutG"")) {; 1024 //make sure first and last point are the same; 1025 if (ipoint == 0) {; 1026 theX[theNpoints-1] = theX[0];; 1027 theY[theNpoints-1] = theY[0];; 1028 }; 1029 if (ipoint == theNpoints-1) {; 1030 theX[0] = theX[theNpoints-1];; 1031 theY[0] = theY[theNpoints-1];; 1032 }; 1033 }; 1034 }; 1035 badcase = kFALSE;; 1036 gPad->Modified(kTRUE);; 1037 //gPad->Update();; 1038 }; 1039 break;; 1040 ; 1041 case kButton1Up:; 1042 ; 1043 if (gROOT->IsEscaped()) {; 1044 gROOT->SetEscape(kFALSE);; 1045 x.clear();; 1046 y.clear();; 1047 break;; 1048 }; 1049 ; 1050 // Compute x,y range; 1051 xmin = gPad->GetUxmin();; 1052 xmax = gPad->GetUxmax();; 1053 ymin = gPad->GetUymin();; 1054 ymax = gPad->GetUymax();; 1055 dx = xmax-xmin;; 1056 dy = ymax-ymin;; 1057 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 1058 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 1059 ; 1060 if (theGraph->GetHistogram()) {; 1061 // Range() could change the size of the pad pixmap and therefore should; 1062 // be called before the other paint routines; 1063 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 1064 ymin - dyr*gPad->GetBottomMargin(),; 1065 xmax + dxr*gPad->GetRightMargin(),; 1066 ymax + dyr*gPad->GetTopMargin());; 1067 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 1068 }; 1069 if (middle) {; 1070 for(i=0;i<theNpoints;i++) {; 1071 if (badcase) continue; //do not update if big zoom and points moved; 1072 if (!x.empty()) theX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 1073 if (!y.em",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:38525,Usability,clear,clear,38525,"aph->InheritsFrom(""TCutG"")) {; 1024 //make sure first and last point are the same; 1025 if (ipoint == 0) {; 1026 theX[theNpoints-1] = theX[0];; 1027 theY[theNpoints-1] = theY[0];; 1028 }; 1029 if (ipoint == theNpoints-1) {; 1030 theX[0] = theX[theNpoints-1];; 1031 theY[0] = theY[theNpoints-1];; 1032 }; 1033 }; 1034 }; 1035 badcase = kFALSE;; 1036 gPad->Modified(kTRUE);; 1037 //gPad->Update();; 1038 }; 1039 break;; 1040 ; 1041 case kButton1Up:; 1042 ; 1043 if (gROOT->IsEscaped()) {; 1044 gROOT->SetEscape(kFALSE);; 1045 x.clear();; 1046 y.clear();; 1047 break;; 1048 }; 1049 ; 1050 // Compute x,y range; 1051 xmin = gPad->GetUxmin();; 1052 xmax = gPad->GetUxmax();; 1053 ymin = gPad->GetUymin();; 1054 ymax = gPad->GetUymax();; 1055 dx = xmax-xmin;; 1056 dy = ymax-ymin;; 1057 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 1058 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 1059 ; 1060 if (theGraph->GetHistogram()) {; 1061 // Range() could change the size of the pad pixmap and therefore should; 1062 // be called before the other paint routines; 1063 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 1064 ymin - dyr*gPad->GetBottomMargin(),; 1065 xmax + dxr*gPad->GetRightMargin(),; 1066 ymax + dyr*gPad->GetTopMargin());; 1067 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 1068 }; 1069 if (middle) {; 1070 for(i=0;i<theNpoints;i++) {; 1071 if (badcase) continue; //do not update if big zoom and points moved; 1072 if (!x.empty()) theX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 1073 if (!y.empty()) theY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 1074 }; 1075 } else {; 1076 theX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 1077 theY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 1078 if (theGraph->InheritsFrom(""TCutG"")) {; 1079 //make sure first and last point are the same; 1080 if (ipoint == 0) {; 1081 theX[theNpoints-1] = theX[0];; 1082 theY[theNpoints-1] = theY[0];; 1083 }; 1084 if (ipoint == theNpoints-1) {; 1085 theX[0] = theX[th",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:40088,Usability,clear,clear,40088,"r*gPad->GetLeftMargin(),; 1064 ymin - dyr*gPad->GetBottomMargin(),; 1065 xmax + dxr*gPad->GetRightMargin(),; 1066 ymax + dyr*gPad->GetTopMargin());; 1067 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 1068 }; 1069 if (middle) {; 1070 for(i=0;i<theNpoints;i++) {; 1071 if (badcase) continue; //do not update if big zoom and points moved; 1072 if (!x.empty()) theX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 1073 if (!y.empty()) theY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 1074 }; 1075 } else {; 1076 theX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 1077 theY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 1078 if (theGraph->InheritsFrom(""TCutG"")) {; 1079 //make sure first and last point are the same; 1080 if (ipoint == 0) {; 1081 theX[theNpoints-1] = theX[0];; 1082 theY[theNpoints-1] = theY[0];; 1083 }; 1084 if (ipoint == theNpoints-1) {; 1085 theX[0] = theX[theNpoints-1];; 1086 theY[0] = theY[theNpoints-1];; 1087 }; 1088 }; 1089 }; 1090 badcase = kFALSE;; 1091 x.clear();; 1092 y.clear();; 1093 gPad->Modified(kTRUE);; 1094 gVirtualX->SetLineColor(-1);; 1095 }; 1096}; 1097 ; 1098 ; 1099////////////////////////////////////////////////////////////////////////////////; 1100 ; 1101char *TGraphPainter::GetObjectInfoHelper(TGraph * /*theGraph*/, Int_t /*px*/, Int_t /*py*/) const; 1102{; 1103 return (char*)"""";; 1104}; 1105 ; 1106 ; 1107////////////////////////////////////////////////////////////////////////////////; 1108/// Return the highlighted point for theGraph; 1109 ; 1110Int_t TGraphPainter::GetHighlightPoint(TGraph *theGraph) const; 1111{; 1112 if (theGraph == gHighlightGraph) return gHighlightPoint;; 1113 else return -1;; 1114}; 1115 ; 1116 ; 1117////////////////////////////////////////////////////////////////////////////////; 1118/// Set highlight (enable/disable) mode for theGraph; 1119 ; 1120void TGraphPainter::SetHighlight(TGraph *theGraph); 1121{; 1122 gHighlightPoint = -1; // must be -1; 1123 gHighlightGraph = nullptr;; 1124 if (theGraph->IsHighli",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:40105,Usability,clear,clear,40105,"ld));; 1077 theY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 1078 if (theGraph->InheritsFrom(""TCutG"")) {; 1079 //make sure first and last point are the same; 1080 if (ipoint == 0) {; 1081 theX[theNpoints-1] = theX[0];; 1082 theY[theNpoints-1] = theY[0];; 1083 }; 1084 if (ipoint == theNpoints-1) {; 1085 theX[0] = theX[theNpoints-1];; 1086 theY[0] = theY[theNpoints-1];; 1087 }; 1088 }; 1089 }; 1090 badcase = kFALSE;; 1091 x.clear();; 1092 y.clear();; 1093 gPad->Modified(kTRUE);; 1094 gVirtualX->SetLineColor(-1);; 1095 }; 1096}; 1097 ; 1098 ; 1099////////////////////////////////////////////////////////////////////////////////; 1100 ; 1101char *TGraphPainter::GetObjectInfoHelper(TGraph * /*theGraph*/, Int_t /*px*/, Int_t /*py*/) const; 1102{; 1103 return (char*)"""";; 1104}; 1105 ; 1106 ; 1107////////////////////////////////////////////////////////////////////////////////; 1108/// Return the highlighted point for theGraph; 1109 ; 1110Int_t TGraphPainter::GetHighlightPoint(TGraph *theGraph) const; 1111{; 1112 if (theGraph == gHighlightGraph) return gHighlightPoint;; 1113 else return -1;; 1114}; 1115 ; 1116 ; 1117////////////////////////////////////////////////////////////////////////////////; 1118/// Set highlight (enable/disable) mode for theGraph; 1119 ; 1120void TGraphPainter::SetHighlight(TGraph *theGraph); 1121{; 1122 gHighlightPoint = -1; // must be -1; 1123 gHighlightGraph = nullptr;; 1124 if (theGraph->IsHighlight()) return;; 1125 ; 1126 // delete previous highlight marker; 1127 if (gHighlightMarker) gHighlightMarker.reset(nullptr);; 1128 // emit Highlighted() signal (user can check on disabled); 1129 if (gPad->GetCanvas()) gPad->GetCanvas()->Highlighted(gPad, theGraph, gHighlightPoint, -1);; 1130}; 1131 ; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Check on highlight point; 1135 ; 1136void TGraphPainter::HighlightPoint(TGraph *theGraph, Int_t hpoint, Int_t distance); 1137{; 1138 // call from Distanceto",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:60379,Usability,clear,clear,60379,"ork[0] = xlow;; 1636 gywork[0] = ylow;; 1637 gxwork[1] = xhigh;; 1638 gywork[1] = yhigh;; 1639 ComputeLogs(2, optionZ);; 1640 if (gyworkl[0] < gPad->GetUymin()) gyworkl[0] = gPad->GetUymin();; 1641 if (gyworkl[1] < gPad->GetUymin()) continue;; 1642 if (gyworkl[1] > gPad->GetUymax()) gyworkl[1] = gPad->GetUymax();; 1643 if (gyworkl[0] > gPad->GetUymax()) continue;; 1644 ; 1645 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1646 }; 1647 } else {; 1648 for (i=1;i<=npoints;i++) {; 1649 xhigh = x[i-1];; 1650 ylow = y[i-1] - dbar;; 1651 yhigh = y[i-1] + dbar;; 1652 xlow = TMath::Max((Double_t)0, gPad->GetUxmin());; 1653 gxwork[0] = xlow;; 1654 gywork[0] = ylow;; 1655 gxwork[1] = xhigh;; 1656 gywork[1] = yhigh;; 1657 ComputeLogs(2, optionZ);; 1658 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1659 }; 1660 }; 1661 theGraph->SetFillColor(FillSave);; 1662 theGraph->TAttFill::Modify();; 1663 }; 1664 gPad->ResetBit(TGraph::kClipFrame);; 1665 ; 1666 gxwork.clear();; 1667 gywork.clear();; 1668 gxworkl.clear();; 1669 gyworkl.clear();; 1670}; 1671 ; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// This is a service method used by `THistPainter`; 1675/// to paint 1D histograms. It is not used to paint TGraph.; 1676///; 1677/// Input parameters:; 1678///; 1679/// - npoints : Number of points in X or in Y.; 1680/// - x[npoints] or x[0] : x coordinates or (xmin,xmax).; 1681/// - y[npoints] or y[0] : y coordinates or (ymin,ymax).; 1682/// - chopt : Option.; 1683///; 1684/// The aspect of the histogram is done according to the value of the chopt.; 1685///; 1686/// | Option | Description |; 1687/// |--------|-----------------------------------------------------------------|; 1688/// |""R"" | Graph is drawn horizontally, parallel to X axis. (default is vertically, parallel to Y axis).If option R is selected the user must give 2 values for Y (y[0]=YMIN and y[1]=YMAX) or N values for X, one for each channel. Oth",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:60401,Usability,clear,clear,60401,"ywork[0] = ylow;; 1637 gxwork[1] = xhigh;; 1638 gywork[1] = yhigh;; 1639 ComputeLogs(2, optionZ);; 1640 if (gyworkl[0] < gPad->GetUymin()) gyworkl[0] = gPad->GetUymin();; 1641 if (gyworkl[1] < gPad->GetUymin()) continue;; 1642 if (gyworkl[1] > gPad->GetUymax()) gyworkl[1] = gPad->GetUymax();; 1643 if (gyworkl[0] > gPad->GetUymax()) continue;; 1644 ; 1645 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1646 }; 1647 } else {; 1648 for (i=1;i<=npoints;i++) {; 1649 xhigh = x[i-1];; 1650 ylow = y[i-1] - dbar;; 1651 yhigh = y[i-1] + dbar;; 1652 xlow = TMath::Max((Double_t)0, gPad->GetUxmin());; 1653 gxwork[0] = xlow;; 1654 gywork[0] = ylow;; 1655 gxwork[1] = xhigh;; 1656 gywork[1] = yhigh;; 1657 ComputeLogs(2, optionZ);; 1658 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1659 }; 1660 }; 1661 theGraph->SetFillColor(FillSave);; 1662 theGraph->TAttFill::Modify();; 1663 }; 1664 gPad->ResetBit(TGraph::kClipFrame);; 1665 ; 1666 gxwork.clear();; 1667 gywork.clear();; 1668 gxworkl.clear();; 1669 gyworkl.clear();; 1670}; 1671 ; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// This is a service method used by `THistPainter`; 1675/// to paint 1D histograms. It is not used to paint TGraph.; 1676///; 1677/// Input parameters:; 1678///; 1679/// - npoints : Number of points in X or in Y.; 1680/// - x[npoints] or x[0] : x coordinates or (xmin,xmax).; 1681/// - y[npoints] or y[0] : y coordinates or (ymin,ymax).; 1682/// - chopt : Option.; 1683///; 1684/// The aspect of the histogram is done according to the value of the chopt.; 1685///; 1686/// | Option | Description |; 1687/// |--------|-----------------------------------------------------------------|; 1688/// |""R"" | Graph is drawn horizontally, parallel to X axis. (default is vertically, parallel to Y axis).If option R is selected the user must give 2 values for Y (y[0]=YMIN and y[1]=YMAX) or N values for X, one for each channel. Otherwise the user must gi",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:60424,Usability,clear,clear,60424,"gxwork[1] = xhigh;; 1638 gywork[1] = yhigh;; 1639 ComputeLogs(2, optionZ);; 1640 if (gyworkl[0] < gPad->GetUymin()) gyworkl[0] = gPad->GetUymin();; 1641 if (gyworkl[1] < gPad->GetUymin()) continue;; 1642 if (gyworkl[1] > gPad->GetUymax()) gyworkl[1] = gPad->GetUymax();; 1643 if (gyworkl[0] > gPad->GetUymax()) continue;; 1644 ; 1645 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1646 }; 1647 } else {; 1648 for (i=1;i<=npoints;i++) {; 1649 xhigh = x[i-1];; 1650 ylow = y[i-1] - dbar;; 1651 yhigh = y[i-1] + dbar;; 1652 xlow = TMath::Max((Double_t)0, gPad->GetUxmin());; 1653 gxwork[0] = xlow;; 1654 gywork[0] = ylow;; 1655 gxwork[1] = xhigh;; 1656 gywork[1] = yhigh;; 1657 ComputeLogs(2, optionZ);; 1658 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1659 }; 1660 }; 1661 theGraph->SetFillColor(FillSave);; 1662 theGraph->TAttFill::Modify();; 1663 }; 1664 gPad->ResetBit(TGraph::kClipFrame);; 1665 ; 1666 gxwork.clear();; 1667 gywork.clear();; 1668 gxworkl.clear();; 1669 gyworkl.clear();; 1670}; 1671 ; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// This is a service method used by `THistPainter`; 1675/// to paint 1D histograms. It is not used to paint TGraph.; 1676///; 1677/// Input parameters:; 1678///; 1679/// - npoints : Number of points in X or in Y.; 1680/// - x[npoints] or x[0] : x coordinates or (xmin,xmax).; 1681/// - y[npoints] or y[0] : y coordinates or (ymin,ymax).; 1682/// - chopt : Option.; 1683///; 1684/// The aspect of the histogram is done according to the value of the chopt.; 1685///; 1686/// | Option | Description |; 1687/// |--------|-----------------------------------------------------------------|; 1688/// |""R"" | Graph is drawn horizontally, parallel to X axis. (default is vertically, parallel to Y axis).If option R is selected the user must give 2 values for Y (y[0]=YMIN and y[1]=YMAX) or N values for X, one for each channel. Otherwise the user must give, N values for Y, one",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:60447,Usability,clear,clear,60447,") gyworkl[0] = gPad->GetUymin();; 1641 if (gyworkl[1] < gPad->GetUymin()) continue;; 1642 if (gyworkl[1] > gPad->GetUymax()) gyworkl[1] = gPad->GetUymax();; 1643 if (gyworkl[0] > gPad->GetUymax()) continue;; 1644 ; 1645 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1646 }; 1647 } else {; 1648 for (i=1;i<=npoints;i++) {; 1649 xhigh = x[i-1];; 1650 ylow = y[i-1] - dbar;; 1651 yhigh = y[i-1] + dbar;; 1652 xlow = TMath::Max((Double_t)0, gPad->GetUxmin());; 1653 gxwork[0] = xlow;; 1654 gywork[0] = ylow;; 1655 gxwork[1] = xhigh;; 1656 gywork[1] = yhigh;; 1657 ComputeLogs(2, optionZ);; 1658 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1659 }; 1660 }; 1661 theGraph->SetFillColor(FillSave);; 1662 theGraph->TAttFill::Modify();; 1663 }; 1664 gPad->ResetBit(TGraph::kClipFrame);; 1665 ; 1666 gxwork.clear();; 1667 gywork.clear();; 1668 gxworkl.clear();; 1669 gyworkl.clear();; 1670}; 1671 ; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// This is a service method used by `THistPainter`; 1675/// to paint 1D histograms. It is not used to paint TGraph.; 1676///; 1677/// Input parameters:; 1678///; 1679/// - npoints : Number of points in X or in Y.; 1680/// - x[npoints] or x[0] : x coordinates or (xmin,xmax).; 1681/// - y[npoints] or y[0] : y coordinates or (ymin,ymax).; 1682/// - chopt : Option.; 1683///; 1684/// The aspect of the histogram is done according to the value of the chopt.; 1685///; 1686/// | Option | Description |; 1687/// |--------|-----------------------------------------------------------------|; 1688/// |""R"" | Graph is drawn horizontally, parallel to X axis. (default is vertically, parallel to Y axis).If option R is selected the user must give 2 values for Y (y[0]=YMIN and y[1]=YMAX) or N values for X, one for each channel. Otherwise the user must give, N values for Y, one for each channel or 2 values for X (x[0]=XMIN and x[1]=XMAX) |; 1689/// |""L"" | A simple polyline between every po",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:61518,Usability,simpl,simple,61518," ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// This is a service method used by `THistPainter`; 1675/// to paint 1D histograms. It is not used to paint TGraph.; 1676///; 1677/// Input parameters:; 1678///; 1679/// - npoints : Number of points in X or in Y.; 1680/// - x[npoints] or x[0] : x coordinates or (xmin,xmax).; 1681/// - y[npoints] or y[0] : y coordinates or (ymin,ymax).; 1682/// - chopt : Option.; 1683///; 1684/// The aspect of the histogram is done according to the value of the chopt.; 1685///; 1686/// | Option | Description |; 1687/// |--------|-----------------------------------------------------------------|; 1688/// |""R"" | Graph is drawn horizontally, parallel to X axis. (default is vertically, parallel to Y axis).If option R is selected the user must give 2 values for Y (y[0]=YMIN and y[1]=YMAX) or N values for X, one for each channel. Otherwise the user must give, N values for Y, one for each channel or 2 values for X (x[0]=XMIN and x[1]=XMAX) |; 1689/// |""L"" | A simple polyline between every points is drawn.|; 1690/// |""H"" | An Histogram with equidistant bins is drawn as a polyline.|; 1691/// |""F"" | An histogram with equidistant bins is drawn as a fill area. Contour is not drawn unless chopt='H' is also selected..|; 1692/// |""N"" | Non equidistant bins (default is equidistant). If N is the number of channels array X and Y must be dimensioned as follow: If option R is not selected (default) then the user must give (N+1) values for X (limits of channels) or N values for Y, one for each channel. Otherwise the user must give (N+1) values for Y (limits of channels). or N values for X, one for each channel |; 1693/// |""F1"" | Idem as 'F' except that fill area base line is the minimum of the pad instead of Y=0.|; 1694/// |""F2"" | Draw a Fill area polyline connecting the center of bins|; 1695/// |""C"" | A smooth Curve is drawn.|; 1696/// |""*"" | A Star is plotted at the center of each bin.|; 1697/// |""P"" | Idem wi",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:78722,Usability,simpl,simple,78722,"6 else Error(where, ""Y must have N+1 values with option N"");; 2127 return;; 2128 }; 2129 gywork[npt-1] = y[i-1] + 0.5*(y[i]-y[i-1]);; 2130 }; 2131 gxwork[npt-1] = x[i-1];; 2132 ComputeLogs(npt, optionZ);; 2133 if ((gxworkl[npt] < uxmin) || (gxworkl[npt] > uxmax)) {; 2134 if (npt > 2) {; 2135 ComputeLogs(npt, optionZ);; 2136 Smooth(theGraph, npt,gxworkl.data(),gyworkl.data(),drawtype);; 2137 }; 2138 gxwork[0] = gxwork[npt-1];; 2139 gywork[0] = gywork[npt-1];; 2140 npt = 1;; 2141 continue;; 2142 }; 2143 if (npt >= fgMaxPointsPerLine) {; 2144 ComputeLogs(fgMaxPointsPerLine, optionZ);; 2145 Smooth(theGraph, fgMaxPointsPerLine,gxworkl.data(),gyworkl.data(),drawtype);; 2146 gxwork[0] = gxwork[npt-1];; 2147 gywork[0] = gywork[npt-1];; 2148 npt = 1;; 2149 }; 2150 } //endfor (i=first; i<=last;i++); 2151 if (npt > 1) {; 2152 ComputeLogs(npt, optionZ);; 2153 Smooth(theGraph, npt,gxworkl.data(),gyworkl.data(),drawtype);; 2154 }; 2155 }; 2156 }; 2157 ; 2158 // Draw the histogram with a simple line; 2159 ; 2160 if (optionLine) {; 2161 gPad->SetBit(TGraph::kClipFrame);; 2162 wminstep = wmin + 0.5*delta;; 2163 Axis_t ax1,ax2,ay1,ay2;; 2164 gPad->GetRangeAxis(ax1,ay1,ax2,ay2);; 2165 ; 2166 if (!optionRot) {; 2167 npt = 0;; 2168 for (i=first; i<=last;i++) {; 2169 npt++;; 2170 if (!optionBins) {; 2171 gxwork[npt-1] = wmin+(i-first)*delta+0.5*delta;; 2172 } else {; 2173 xi1 = x[i]; xi = x[i-1];; 2174 if (xi1 < xi) {; 2175 if (i != last) Error(where, ""X must be in increasing order"");; 2176 else Error(where, ""X must have N+1 values with option N"");; 2177 return;; 2178 }; 2179 gxwork[npt-1] = x[i-1] + 0.5*(x[i]-x[i-1]);; 2180 }; 2181 if (gxwork[npt-1] < uxmin || gxwork[npt-1] > uxmax) { npt--; continue;}; 2182 gywork[npt-1] = y[i-1];; 2183 gywork[npt] = y[i-1]; //new; 2184 if ((gywork[npt-1] < rwymin) || ((gywork[npt-1] > rwymax) && !optionFill2)) {; 2185 if (npt > 2) {; 2186 ComputeLogs(npt, optionZ);; 2187 gPad->PaintPolyLine(npt,gxworkl.data(),gyworkl.data());; 2188 }; 2189 gxwork[0] = ",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:84472,Usability,simpl,simple,84472," gxwork[0] = xlow;; 2290 gywork[0] = ylow;; 2291 gxwork[1] = xhigh;; 2292 gywork[1] = yhigh;; 2293 ComputeLogs(2, optionZ);; 2294 if (xlow < rwxmax && xhigh > rwxmin); 2295 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 2296 if (!optionBins) {; 2297 xlow = xlow+delta;; 2298 xhigh = xhigh+delta;; 2299 } else {; 2300 if (i < last) {; 2301 xi1 = x[i]; xi = x[i-1];; 2302 if (xi1 < xi) {; 2303 Error(where, ""X must be in increasing order"");; 2304 goto do_cleanup;; 2305 }; 2306 offset = (x[i+1]-x[i])*baroffset;; 2307 dbar = (x[i+1]-x[i])*barwidth;; 2308 xlow = x[i] + offset;; 2309 xhigh = x[i] + offset + dbar;; 2310 }; 2311 }; 2312 } //endfor (i=first; i<=last;i++); 2313 } else {; 2314 ylow = wmin + offset;; 2315 yhigh = wmin + offset + dbar;; 2316 if (!optionOne) xlow = TMath::Max((Double_t)0,gPad->GetUxmin());; 2317 else xlow = gPad->GetUxmin();; 2318 for (i=first; i<=last;i++) {; 2319 xhigh = x[i-1];; 2320 gxwork[0] = xlow;; 2321 gywork[0] = ylow;; 2322 gxwork[1] = xhigh;; 2323 gywork[1] = yhigh;; 2324 ComputeLogs(2, optionZ);; 2325 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 2326 gPad->PaintBox(xlow,ylow,xhigh,yhigh);; 2327 if (!optionBins) {; 2328 ylow = ylow + delta;; 2329 yhigh = yhigh + delta;; 2330 } else {; 2331 if (i < last) {; 2332 yi1 = y[i]; yi = y[i-1];; 2333 if (yi1 < yi) {; 2334 Error(where, ""Y must be in increasing order"");; 2335 goto do_cleanup;; 2336 }; 2337 offset = (y[i+1]-y[i])*baroffset;; 2338 dbar = (y[i+1]-y[i])*barwidth;; 2339 ylow = y[i] + offset;; 2340 yhigh = y[i] + offset + dbar;; 2341 }; 2342 }; 2343 } //endfor (i=first; i<=last;i++); 2344 }; 2345 gStyle->SetDrawBorder(drawbordersav);; 2346 }; 2347 ; 2348 // Draw the histogram with a simple marker; 2349 ; 2350 optionMarker = 0;; 2351 if ((optionStar) || (optionMark)) optionMarker=1;; 2352 ; 2353 if (optionMarker) {; 2354 Double_t xm,ym;; 2355 npt = 0;; 2356 if (!optionRot) {; 2357 for (i=first; i<=last;i++) {; 2358 if (!optionBins) xm = wmin+(i-first)*delta+0.",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:86277,Usability,clear,clear,86277,"; 2381 ComputeLogs(npt, optionZ);; 2382 gPad->PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2383 }; 2384 } else {; 2385 wminstep = wmin + 0.5*delta;; 2386 for (i=first; i<=last;i++) {; 2387 if (!optionBins) ym = wminstep+(i-first)*delta+0.5*delta;; 2388 else ym = y[i-1] + 0.5*(y[i]-y[i-1]);; 2389 xm = x[i-1];; 2390 if (optionMark != 10) {; 2391 if (xm<rwxmax && xm > rwxmin) {; 2392 npt++;; 2393 gxwork[npt-1] = xm;; 2394 gywork[npt-1] = ym;; 2395 }; 2396 } else {; 2397 if (xm<rwxmax && xm >= rwxmin) {; 2398 npt++;; 2399 gxwork[npt-1] = xm;; 2400 gywork[npt-1] = ym;; 2401 }; 2402 }; 2403 if (npt >= fgMaxPointsPerLine) {; 2404 ComputeLogs(npt, optionZ);; 2405 gPad->PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2406 npt = 0;; 2407 }; 2408 }; 2409 if (npt > 0) {; 2410 ComputeLogs(npt, optionZ);; 2411 gPad->PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2412 }; 2413 }; 2414 }; 2415 ; 2416 gPad->ResetBit(TGraph::kClipFrame);; 2417 ; 2418do_cleanup:; 2419 gxwork.clear();; 2420 gywork.clear();; 2421 gxworkl.clear();; 2422 gyworkl.clear();; 2423}; 2424 ; 2425 ; 2426////////////////////////////////////////////////////////////////////////////////; 2427/// [Paint this TGraphAsymmErrors with its current attributes.](\ref GrP3); 2428 ; 2429void TGraphPainter::PaintGraphAsymmErrors(TGraph *theGraph, Option_t *option); 2430{; 2431 ; 2432 std::vector<Double_t> xline, yline;; 2433 Int_t if1 = 0;; 2434 Int_t if2 = 0;; 2435 Double_t xb[4], yb[4];; 2436 ; 2437 const Int_t kBASEMARKER=8;; 2438 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 2439 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 2440 Int_t theNpoints = theGraph->GetN();; 2441 Double_t *theX = theGraph->GetX();; 2442 Double_t *theY = theGraph->GetY();; 2443 Double_t *theEXlow = theGraph->GetEXlow(); if (!the",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:86299,Usability,clear,clear,86299,", optionZ);; 2382 gPad->PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2383 }; 2384 } else {; 2385 wminstep = wmin + 0.5*delta;; 2386 for (i=first; i<=last;i++) {; 2387 if (!optionBins) ym = wminstep+(i-first)*delta+0.5*delta;; 2388 else ym = y[i-1] + 0.5*(y[i]-y[i-1]);; 2389 xm = x[i-1];; 2390 if (optionMark != 10) {; 2391 if (xm<rwxmax && xm > rwxmin) {; 2392 npt++;; 2393 gxwork[npt-1] = xm;; 2394 gywork[npt-1] = ym;; 2395 }; 2396 } else {; 2397 if (xm<rwxmax && xm >= rwxmin) {; 2398 npt++;; 2399 gxwork[npt-1] = xm;; 2400 gywork[npt-1] = ym;; 2401 }; 2402 }; 2403 if (npt >= fgMaxPointsPerLine) {; 2404 ComputeLogs(npt, optionZ);; 2405 gPad->PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2406 npt = 0;; 2407 }; 2408 }; 2409 if (npt > 0) {; 2410 ComputeLogs(npt, optionZ);; 2411 gPad->PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2412 }; 2413 }; 2414 }; 2415 ; 2416 gPad->ResetBit(TGraph::kClipFrame);; 2417 ; 2418do_cleanup:; 2419 gxwork.clear();; 2420 gywork.clear();; 2421 gxworkl.clear();; 2422 gyworkl.clear();; 2423}; 2424 ; 2425 ; 2426////////////////////////////////////////////////////////////////////////////////; 2427/// [Paint this TGraphAsymmErrors with its current attributes.](\ref GrP3); 2428 ; 2429void TGraphPainter::PaintGraphAsymmErrors(TGraph *theGraph, Option_t *option); 2430{; 2431 ; 2432 std::vector<Double_t> xline, yline;; 2433 Int_t if1 = 0;; 2434 Int_t if2 = 0;; 2435 Double_t xb[4], yb[4];; 2436 ; 2437 const Int_t kBASEMARKER=8;; 2438 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 2439 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 2440 Int_t theNpoints = theGraph->GetN();; 2441 Double_t *theX = theGraph->GetX();; 2442 Double_t *theY = theGraph->GetY();; 2443 Double_t *theEXlow = theGraph->GetEXlow(); if (!theEXlow) return;; 2444 Do",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:86322,Usability,clear,clear,86322,">PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2383 }; 2384 } else {; 2385 wminstep = wmin + 0.5*delta;; 2386 for (i=first; i<=last;i++) {; 2387 if (!optionBins) ym = wminstep+(i-first)*delta+0.5*delta;; 2388 else ym = y[i-1] + 0.5*(y[i]-y[i-1]);; 2389 xm = x[i-1];; 2390 if (optionMark != 10) {; 2391 if (xm<rwxmax && xm > rwxmin) {; 2392 npt++;; 2393 gxwork[npt-1] = xm;; 2394 gywork[npt-1] = ym;; 2395 }; 2396 } else {; 2397 if (xm<rwxmax && xm >= rwxmin) {; 2398 npt++;; 2399 gxwork[npt-1] = xm;; 2400 gywork[npt-1] = ym;; 2401 }; 2402 }; 2403 if (npt >= fgMaxPointsPerLine) {; 2404 ComputeLogs(npt, optionZ);; 2405 gPad->PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2406 npt = 0;; 2407 }; 2408 }; 2409 if (npt > 0) {; 2410 ComputeLogs(npt, optionZ);; 2411 gPad->PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2412 }; 2413 }; 2414 }; 2415 ; 2416 gPad->ResetBit(TGraph::kClipFrame);; 2417 ; 2418do_cleanup:; 2419 gxwork.clear();; 2420 gywork.clear();; 2421 gxworkl.clear();; 2422 gyworkl.clear();; 2423}; 2424 ; 2425 ; 2426////////////////////////////////////////////////////////////////////////////////; 2427/// [Paint this TGraphAsymmErrors with its current attributes.](\ref GrP3); 2428 ; 2429void TGraphPainter::PaintGraphAsymmErrors(TGraph *theGraph, Option_t *option); 2430{; 2431 ; 2432 std::vector<Double_t> xline, yline;; 2433 Int_t if1 = 0;; 2434 Int_t if2 = 0;; 2435 Double_t xb[4], yb[4];; 2436 ; 2437 const Int_t kBASEMARKER=8;; 2438 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 2439 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 2440 Int_t theNpoints = theGraph->GetN();; 2441 Double_t *theX = theGraph->GetX();; 2442 Double_t *theY = theGraph->GetY();; 2443 Double_t *theEXlow = theGraph->GetEXlow(); if (!theEXlow) return;; 2444 Double_t *theEYlow = theG",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:86345,Usability,clear,clear,86345,"*delta;; 2386 for (i=first; i<=last;i++) {; 2387 if (!optionBins) ym = wminstep+(i-first)*delta+0.5*delta;; 2388 else ym = y[i-1] + 0.5*(y[i]-y[i-1]);; 2389 xm = x[i-1];; 2390 if (optionMark != 10) {; 2391 if (xm<rwxmax && xm > rwxmin) {; 2392 npt++;; 2393 gxwork[npt-1] = xm;; 2394 gywork[npt-1] = ym;; 2395 }; 2396 } else {; 2397 if (xm<rwxmax && xm >= rwxmin) {; 2398 npt++;; 2399 gxwork[npt-1] = xm;; 2400 gywork[npt-1] = ym;; 2401 }; 2402 }; 2403 if (npt >= fgMaxPointsPerLine) {; 2404 ComputeLogs(npt, optionZ);; 2405 gPad->PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2406 npt = 0;; 2407 }; 2408 }; 2409 if (npt > 0) {; 2410 ComputeLogs(npt, optionZ);; 2411 gPad->PaintPolyMarker(npt,gxworkl.data(),gyworkl.data());; 2412 }; 2413 }; 2414 }; 2415 ; 2416 gPad->ResetBit(TGraph::kClipFrame);; 2417 ; 2418do_cleanup:; 2419 gxwork.clear();; 2420 gywork.clear();; 2421 gxworkl.clear();; 2422 gyworkl.clear();; 2423}; 2424 ; 2425 ; 2426////////////////////////////////////////////////////////////////////////////////; 2427/// [Paint this TGraphAsymmErrors with its current attributes.](\ref GrP3); 2428 ; 2429void TGraphPainter::PaintGraphAsymmErrors(TGraph *theGraph, Option_t *option); 2430{; 2431 ; 2432 std::vector<Double_t> xline, yline;; 2433 Int_t if1 = 0;; 2434 Int_t if2 = 0;; 2435 Double_t xb[4], yb[4];; 2436 ; 2437 const Int_t kBASEMARKER=8;; 2438 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 2439 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 2440 Int_t theNpoints = theGraph->GetN();; 2441 Double_t *theX = theGraph->GetX();; 2442 Double_t *theY = theGraph->GetY();; 2443 Double_t *theEXlow = theGraph->GetEXlow(); if (!theEXlow) return;; 2444 Double_t *theEYlow = theGraph->GetEYlow(); if (!theEYlow) return;; 2445 Double_t *theEXhigh = theGraph->GetEXhigh(); if (!theEXh",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:161199,Usability,simpl,simple,161199,"elSize(h->GetZaxis()->GetLabelSize());; 4520 palette->SetTitleOffset(h->GetZaxis()->GetTitleOffset());; 4521 palette->SetTitleSize(h->GetZaxis()->GetTitleSize());; 4522 palette->SetNdivisions(h->GetZaxis()->GetNdivisions());; 4523 palette->SetTitle(h->GetZaxis()->GetTitle());; 4524 palette->SetTitleColor(h->GetZaxis()->GetTitleColor());; 4525 palette->SetTitleFont(h->GetZaxis()->GetTitleFont());; 4526 ; 4527 functions->AddFirst(palette);; 4528 }; 4529 if (palette) palette->Paint();; 4530 }; 4531 ; 4532 // Draw markers; 4533 auto nbcol = gStyle->GetNumberOfColors();; 4534 int logx = gPad->GetLogx();; 4535 int logy = gPad->GetLogy();; 4536 int logz = gPad->GetLogz();; 4537 if (theColor && logz) {; 4538 if (minc>0) minc = log10(minc);; 4539 if (maxc>0) maxc = log10(maxc);; 4540 }; 4541 theScatter->SetMarkerColor(theScatter->GetMarkerColor());; 4542 theScatter->TAttMarker::Modify();; 4543 double x,y,c,ms;; 4544 int nc;; 4545 for (int i=0; i<n; i++) {; 4546 if (theColor) {; 4547 if (logz) {; 4548 if (theColor[i]>0) c = log10(theColor[i]);; 4549 else continue;; 4550 } else {; 4551 c = theColor[i];; 4552 }; 4553 if (c<minc) continue;; 4554 if (c>maxc) continue;; 4555 nc = TMath::Nint(((c-minc)/(maxc-minc))*(nbcol-1));; 4556 if (nc > nbcol-1) nc = nbcol-1;; 4557 theScatter->SetMarkerColor(gStyle->GetColorPalette(nc));; 4558 }; 4559 if (theSize) {; 4560 ms = (MaxMarkerSize-MinMarkerSize)*((theSize[i]-mins)/(maxs-mins))+MinMarkerSize;; 4561 theScatter->SetMarkerSize(ms);; 4562 }; 4563 if (theColor || theSize) theScatter->TAttMarker::Modify();; 4564 if (logx) {; 4565 if (theX[i]>0) x = log10(theX[i]);; 4566 else break;; 4567 } else {; 4568 x = theX[i];; 4569 }; 4570 if (logy) {; 4571 if (theY[i]>0) y = log10(theY[i]);; 4572 else break;; 4573 } else {; 4574 y = theY[i];; 4575 }; 4576 gPad->PaintPolyMarker(1,&x,&y);; 4577 }; 4578}; 4579 ; 4580 ; 4581////////////////////////////////////////////////////////////////////////////////; 4582/// Paint a simple graph, without errors bars.",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:177801,Usability,clear,clear,177801,"5 if (!closed) {; 5056 if (x[0] != x[npoints-1] || y[0] != y[npoints-1]) goto L40;; 5057 if (x[npoints-2] == x[npoints-1] && y[npoints-2] == y[npoints-1]) goto L40;; 5058 if (x[0] == x[1] && y[0] == y[1]) goto L40;; 5059 }; 5060 flgic = kFALSE;; 5061 flgis = kTRUE;; 5062 ; 5063 // flgic is true if the curve is open and false if it is closed.; 5064 // flgis is true in the main loop, but is false if there is; 5065 // a deviation from the main loop.; 5066 ; 5067 km = npoints - 1;; 5068 ; 5069 // Calculate direction cosines at P(1) using P(N-1),P(1),P(2).; 5070 ; 5071 goto L100;; 5072L40:; 5073 flgic = kTRUE;; 5074 flgis = kFALSE;; 5075 ; 5076 // Skip excessive consecutive equal points.; 5077 ; 5078L50:; 5079 if (k >= npoints) {; 5080 finished = 1; // Prepare to clear out remaining short vectors before returning; 5081 if (npt > 1) goto L310;; 5082 goto L390;; 5083 }; 5084 k++;; 5085 if (x[k-1] == x[k-2] && y[k-1] == y[k-2]) goto L50;; 5086L60:; 5087 km = k-1;; 5088 if (k > npoints) {; 5089 finished = 1; // Prepare to clear out remaining short vectors before returning; 5090 if (npt > 1) goto L310;; 5091 goto L390;; 5092 }; 5093 if (k < npoints) goto L90;; 5094 if (!flgic) { kp = 2; goto L130;}; 5095 ; 5096L80:; 5097 if (flgis) goto L150;; 5098 ; 5099 // Draw a straight line from P(k-1) to P(k).; 5100 ; 5101 finished = -1;; 5102 goto L170;; 5103 ; 5104 // Test whether P(k) is a cusp.; 5105 ; 5106L90:; 5107 if (x[k-1] == x[k] && y[k-1] == y[k]) goto L80;; 5108L100:; 5109 kp = k+1;; 5110 goto L130;; 5111 ; 5112 // Branch if the next section of the curve begins at a cusp.; 5113 ; 5114L110:; 5115 if (!flgis) goto L50;; 5116 ; 5117 // Carry forward the direction cosines from the previous arc.; 5118 ; 5119L120:; 5120 co = ct;; 5121 so = st;; 5122 k++;; 5123 goto L60;; 5124 ; 5125 // Calculate the direction cosines at P(k). If k=1 then; 5126 // N-1 is used for k-1. If k=N then 2 is used for k+1.; 5127 // direction cosines at P(k) obtained from P(k-1),P(k),P(k+1).; 5128 ; 5129L130",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:178061,Usability,clear,clear,178061,"5 if (!closed) {; 5056 if (x[0] != x[npoints-1] || y[0] != y[npoints-1]) goto L40;; 5057 if (x[npoints-2] == x[npoints-1] && y[npoints-2] == y[npoints-1]) goto L40;; 5058 if (x[0] == x[1] && y[0] == y[1]) goto L40;; 5059 }; 5060 flgic = kFALSE;; 5061 flgis = kTRUE;; 5062 ; 5063 // flgic is true if the curve is open and false if it is closed.; 5064 // flgis is true in the main loop, but is false if there is; 5065 // a deviation from the main loop.; 5066 ; 5067 km = npoints - 1;; 5068 ; 5069 // Calculate direction cosines at P(1) using P(N-1),P(1),P(2).; 5070 ; 5071 goto L100;; 5072L40:; 5073 flgic = kTRUE;; 5074 flgis = kFALSE;; 5075 ; 5076 // Skip excessive consecutive equal points.; 5077 ; 5078L50:; 5079 if (k >= npoints) {; 5080 finished = 1; // Prepare to clear out remaining short vectors before returning; 5081 if (npt > 1) goto L310;; 5082 goto L390;; 5083 }; 5084 k++;; 5085 if (x[k-1] == x[k-2] && y[k-1] == y[k-2]) goto L50;; 5086L60:; 5087 km = k-1;; 5088 if (k > npoints) {; 5089 finished = 1; // Prepare to clear out remaining short vectors before returning; 5090 if (npt > 1) goto L310;; 5091 goto L390;; 5092 }; 5093 if (k < npoints) goto L90;; 5094 if (!flgic) { kp = 2; goto L130;}; 5095 ; 5096L80:; 5097 if (flgis) goto L150;; 5098 ; 5099 // Draw a straight line from P(k-1) to P(k).; 5100 ; 5101 finished = -1;; 5102 goto L170;; 5103 ; 5104 // Test whether P(k) is a cusp.; 5105 ; 5106L90:; 5107 if (x[k-1] == x[k] && y[k-1] == y[k]) goto L80;; 5108L100:; 5109 kp = k+1;; 5110 goto L130;; 5111 ; 5112 // Branch if the next section of the curve begins at a cusp.; 5113 ; 5114L110:; 5115 if (!flgis) goto L50;; 5116 ; 5117 // Carry forward the direction cosines from the previous arc.; 5118 ; 5119L120:; 5120 co = ct;; 5121 so = st;; 5122 k++;; 5123 goto L60;; 5124 ; 5125 // Calculate the direction cosines at P(k). If k=1 then; 5126 // N-1 is used for k-1. If k=N then 2 is used for k+1.; 5127 // direction cosines at P(k) obtained from P(k-1),P(k),P(k+1).; 5128 ; 5129L130",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:201339,Usability,simpl,simple,201339,"ter::gxworkstd::vector< Double_t > gxworkDefinition TGraphPainter.h:69; TGraphPainter::gyworkstd::vector< Double_t > gyworkDefinition TGraphPainter.h:69; TGraphPainter::PaintScattervoid PaintScatter(TScatter *theScatter, Option_t *option) overridePaint a scatter plot.Definition TGraphPainter.cxx:4392; TGraphPainter::Smoothvoid Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype)Smooth a curve given by N points.Definition TGraphPainter.cxx:4938; TGraphPainter::gyworklstd::vector< Double_t > gyworklInternal buffers for coordinates. Used for graphs painting.Definition TGraphPainter.h:69; TGraphPainter::SetHighlightvoid SetHighlight(TGraph *theGraph) overrideSet highlight (enable/disable) mode for theGraph.Definition TGraphPainter.cxx:1120; TGraphPainter::GetHighlightPointvirtual Int_t GetHighlightPoint(TGraph *theGraph) constReturn the highlighted point for theGraph.Definition TGraphPainter.cxx:1110; TGraphPainter::PaintGraphSimplevoid PaintGraphSimple(TGraph *theGraph, Option_t *option)Paint a simple graph, without errors bars.Definition TGraphPainter.cxx:4584; TGraphPainter::PaintGraphQQvoid PaintGraphQQ(TGraph *theGraph, Option_t *option)Paint this graphQQ. No options for the time being.Definition TGraphPainter.cxx:4084; TGraphPainter::~TGraphPainter~TGraphPainter() overrideDestructor.Definition TGraphPainter.cxx:675; TGraphPainter::SetMaxPointsPerLinestatic void SetMaxPointsPerLine(Int_t maxp=50)Static function to set fgMaxPointsPerLine for graph painting.Definition TGraphPainter.cxx:5407; TGraphPainter::PaintGraphBentErrorsvoid PaintGraphBentErrors(TGraph *theGraph, Option_t *option)Paint this TGraphBentErrors with its current attributes.Definition TGraphPainter.cxx:3182; TGraphPainter::TGraphPainterTGraphPainter()Default constructor.Definition TGraphPainter.cxx:667; TGraphPainter::PaintHelpervoid PaintHelper(TGraph *theGraph, Option_t *option) overridePaint a any kind of TGraph.Definition TGraphPainter.cxx:1211; TGraphPolarTo draw a p",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:203440,Usability,simpl,simplified,203440,"GraphPolar::GetYpolDouble_t * GetYpol()Return points in polar coordinates.Definition TGraphPolar.cxx:128; TGraphPolar::GetPolargramTGraphPolargram * GetPolargram()Definition TGraphPolar.h:39; TGraphPolar::GetOptionAxisBool_t GetOptionAxis()Definition TGraphPolar.h:42; TGraphPolar::SetPolargramvoid SetPolargram(TGraphPolargram *p)Definition TGraphPolar.h:50; TGraphPolar::SetOptionAxisvoid SetOptionAxis(Bool_t opt)Definition TGraphPolar.h:49; TGraphPolar::GetXpolDouble_t * GetXpol()Return points in polar coordinates.Definition TGraphPolar.cxx:119; TGraphPolargramTo draw polar axis.Definition TGraphPolargram.h:20; TGraphPolargram::GetRMinDouble_t GetRMin()Definition TGraphPolargram.h:77; TGraphPolargram::GetRMaxDouble_t GetRMax()Definition TGraphPolargram.h:78; TGraphPolargram::IsGradBool_t IsGrad()Definition TGraphPolargram.h:92; TGraphPolargram::IsDegreeBool_t IsDegree()Definition TGraphPolargram.h:90; TGraphPolargram::PaintCirclevoid PaintCircle(Double_t x, Double_t y, Double_t r, Double_t phimin, Double_t phimax, Double_t theta)This is simplified from TEllipse::PaintEllipse.Definition TGraphPolargram.cxx:373; TGraphPolargram::Drawvoid Draw(Option_t *options="""") overrideDraw Polargram.Definition TGraphPolargram.cxx:182; TGraphPolargram::kLabelOrtho@ kLabelOrthoDefinition TGraphPolargram.h:61; TGraphPolargram::GetTMinDouble_t GetTMin()Definition TGraphPolargram.h:80; TGraphPolargram::GetTMaxDouble_t GetTMax()Definition TGraphPolargram.h:81; TGraphQQThis class allows to draw quantile-quantile plots.Definition TGraphQQ.h:18; TGraphQQ::GetXq1Double_t GetXq1() constDefinition TGraphQQ.h:40; TGraphQQ::GetYq2Double_t GetYq2() constDefinition TGraphQQ.h:43; TGraphQQ::Classstatic TClass * Class(); TGraphQQ::GetXq2Double_t GetXq2() constDefinition TGraphQQ.h:41; TGraphQQ::GetFTF1 * GetF() constDefinition TGraphQQ.h:44; TGraphQQ::GetYq1Double_t GetYq1() constDefinition TGraphQQ.h:42; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8cxx_source.html:208845,Usability,simpl,simple,208845,"xis * GetYaxis()Definition TH1.h:325; TH1::GetNdivisionsvirtual Int_t GetNdivisions(Option_t *axis=""X"") constReturn the number of divisions for ""axis"".Definition Haxis.cxx:27; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::GetMaximumStoredvirtual Double_t GetMaximumStored() constDefinition TH1.h:289; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TIterDefinition TCollection.h:235; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::PaintLinevirtual void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:399; TListIterIterator of linked list.Definition TList.h:193; TListIter::NextTObject * Next() overrideReturn next object in the list. Returns 0 when no more objects in list.Definition TList.cxx:1109; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::FirstTObject * First() const overrideReturn the first object in the list. Returns 0 when list is empty.Definition TList.cxx:657; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::AddFirstvoid AddFirst(T",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
https://root.cern/doc/master/TGraphPainter_8h_source.html:8041,Availability,error,errors,8041,"ter::gxworkstd::vector< Double_t > gxworkDefinition TGraphPainter.h:69; TGraphPainter::gyworkstd::vector< Double_t > gyworkDefinition TGraphPainter.h:69; TGraphPainter::PaintScattervoid PaintScatter(TScatter *theScatter, Option_t *option) overridePaint a scatter plot.Definition TGraphPainter.cxx:4392; TGraphPainter::Smoothvoid Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype)Smooth a curve given by N points.Definition TGraphPainter.cxx:4938; TGraphPainter::gyworklstd::vector< Double_t > gyworklInternal buffers for coordinates. Used for graphs painting.Definition TGraphPainter.h:69; TGraphPainter::SetHighlightvoid SetHighlight(TGraph *theGraph) overrideSet highlight (enable/disable) mode for theGraph.Definition TGraphPainter.cxx:1120; TGraphPainter::GetHighlightPointvirtual Int_t GetHighlightPoint(TGraph *theGraph) constReturn the highlighted point for theGraph.Definition TGraphPainter.cxx:1110; TGraphPainter::PaintGraphSimplevoid PaintGraphSimple(TGraph *theGraph, Option_t *option)Paint a simple graph, without errors bars.Definition TGraphPainter.cxx:4584; TGraphPainter::PaintGraphQQvoid PaintGraphQQ(TGraph *theGraph, Option_t *option)Paint this graphQQ. No options for the time being.Definition TGraphPainter.cxx:4084; TGraphPainter::~TGraphPainter~TGraphPainter() overrideDestructor.Definition TGraphPainter.cxx:675; TGraphPainter::SetMaxPointsPerLinestatic void SetMaxPointsPerLine(Int_t maxp=50)Static function to set fgMaxPointsPerLine for graph painting.Definition TGraphPainter.cxx:5407; TGraphPainter::PaintGraphBentErrorsvoid PaintGraphBentErrors(TGraph *theGraph, Option_t *option)Paint this TGraphBentErrors with its current attributes.Definition TGraphPainter.cxx:3182; TGraphPainter::TGraphPainterTGraphPainter()Default constructor.Definition TGraphPainter.cxx:667; TGraphPainter::PaintHelpervoid PaintHelper(TGraph *theGraph, Option_t *option) overridePaint a any kind of TGraph.Definition TGraphPainter.cxx:1211; TGraphA TGraph is an o",MatchSource.WIKI,doc/master/TGraphPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8h_source.html
https://root.cern/doc/master/TGraphPainter_8h_source.html:9193,Integrability,interface,interface,9193,"r coordinates. Used for graphs painting.Definition TGraphPainter.h:69; TGraphPainter::SetHighlightvoid SetHighlight(TGraph *theGraph) overrideSet highlight (enable/disable) mode for theGraph.Definition TGraphPainter.cxx:1120; TGraphPainter::GetHighlightPointvirtual Int_t GetHighlightPoint(TGraph *theGraph) constReturn the highlighted point for theGraph.Definition TGraphPainter.cxx:1110; TGraphPainter::PaintGraphSimplevoid PaintGraphSimple(TGraph *theGraph, Option_t *option)Paint a simple graph, without errors bars.Definition TGraphPainter.cxx:4584; TGraphPainter::PaintGraphQQvoid PaintGraphQQ(TGraph *theGraph, Option_t *option)Paint this graphQQ. No options for the time being.Definition TGraphPainter.cxx:4084; TGraphPainter::~TGraphPainter~TGraphPainter() overrideDestructor.Definition TGraphPainter.cxx:675; TGraphPainter::SetMaxPointsPerLinestatic void SetMaxPointsPerLine(Int_t maxp=50)Static function to set fgMaxPointsPerLine for graph painting.Definition TGraphPainter.cxx:5407; TGraphPainter::PaintGraphBentErrorsvoid PaintGraphBentErrors(TGraph *theGraph, Option_t *option)Paint this TGraphBentErrors with its current attributes.Definition TGraphPainter.cxx:3182; TGraphPainter::TGraphPainterTGraphPainter()Default constructor.Definition TGraphPainter.cxx:667; TGraphPainter::PaintHelpervoid PaintHelper(TGraph *theGraph, Option_t *option) overridePaint a any kind of TGraph.Definition TGraphPainter.cxx:1211; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TScatterA TScatter is able to draw four variables scatter plot on a single plot.Definition TScatter.h:32; TVirtualGraphPainterAbstract interface to a histogram painter.Definition TVirtualGraphPainter.h:28; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16. histhistpainterincTGraphPainter.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8h_source.html
https://root.cern/doc/master/TGraphPainter_8h_source.html:6579,Modifiability,variab,variables,6579,"n TGraphPainter.cxx:4820; TGraphPainter::PaintPolyLineHatchesvoid PaintPolyLineHatches(TGraph *theGraph, Int_t n, const Double_t *x, const Double_t *y)Paint a polyline with hatches on one side showing an exclusion zone.Definition TGraphPainter.cxx:4620; TGraphPainter::DrawPanelHelpervoid DrawPanelHelper(TGraph *theGraph) overrideDisplay a panel with all histogram drawing options.Definition TGraphPainter.cxx:796; TGraphPainter::GetObjectInfoHelperchar * GetObjectInfoHelper(TGraph *theGraph, Int_t px, Int_t py) const overrideDefinition TGraphPainter.cxx:1101; TGraphPainter::ExecuteEventHelpervoid ExecuteEventHelper(TGraph *theGraph, Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGraphPainter.cxx:821; TGraphPainter::HighlightPointvirtual void HighlightPoint(TGraph *theGraph, Int_t hpoint, Int_t distance)Check on highlight point.Definition TGraphPainter.cxx:1136; TGraphPainter::ComputeLogsvoid ComputeLogs(Int_t npoints, Int_t opt)Compute the logarithm of variables gxwork and gywork according to the value of Options and put the re...Definition TGraphPainter.cxx:690; TGraphPainter::gxworklstd::vector< Double_t > gxworklDefinition TGraphPainter.h:69; TGraphPainter::DistancetoPrimitiveHelperInt_t DistancetoPrimitiveHelper(TGraph *theGraph, Int_t px, Int_t py) overrideCompute distance from point px,py to a graph.Definition TGraphPainter.cxx:717; TGraphPainter::gxworkstd::vector< Double_t > gxworkDefinition TGraphPainter.h:69; TGraphPainter::gyworkstd::vector< Double_t > gyworkDefinition TGraphPainter.h:69; TGraphPainter::PaintScattervoid PaintScatter(TScatter *theScatter, Option_t *option) overridePaint a scatter plot.Definition TGraphPainter.cxx:4392; TGraphPainter::Smoothvoid Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype)Smooth a curve given by N points.Definition TGraphPainter.cxx:4938; TGraphPainter::gyworklstd::vector< Double_t > gyworklInternal buffers for coordinates. Used for graphs pa",MatchSource.WIKI,doc/master/TGraphPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8h_source.html
https://root.cern/doc/master/TGraphPainter_8h_source.html:9098,Modifiability,variab,variables,9098,"r coordinates. Used for graphs painting.Definition TGraphPainter.h:69; TGraphPainter::SetHighlightvoid SetHighlight(TGraph *theGraph) overrideSet highlight (enable/disable) mode for theGraph.Definition TGraphPainter.cxx:1120; TGraphPainter::GetHighlightPointvirtual Int_t GetHighlightPoint(TGraph *theGraph) constReturn the highlighted point for theGraph.Definition TGraphPainter.cxx:1110; TGraphPainter::PaintGraphSimplevoid PaintGraphSimple(TGraph *theGraph, Option_t *option)Paint a simple graph, without errors bars.Definition TGraphPainter.cxx:4584; TGraphPainter::PaintGraphQQvoid PaintGraphQQ(TGraph *theGraph, Option_t *option)Paint this graphQQ. No options for the time being.Definition TGraphPainter.cxx:4084; TGraphPainter::~TGraphPainter~TGraphPainter() overrideDestructor.Definition TGraphPainter.cxx:675; TGraphPainter::SetMaxPointsPerLinestatic void SetMaxPointsPerLine(Int_t maxp=50)Static function to set fgMaxPointsPerLine for graph painting.Definition TGraphPainter.cxx:5407; TGraphPainter::PaintGraphBentErrorsvoid PaintGraphBentErrors(TGraph *theGraph, Option_t *option)Paint this TGraphBentErrors with its current attributes.Definition TGraphPainter.cxx:3182; TGraphPainter::TGraphPainterTGraphPainter()Default constructor.Definition TGraphPainter.cxx:667; TGraphPainter::PaintHelpervoid PaintHelper(TGraph *theGraph, Option_t *option) overridePaint a any kind of TGraph.Definition TGraphPainter.cxx:1211; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TScatterA TScatter is able to draw four variables scatter plot on a single plot.Definition TScatter.h:32; TVirtualGraphPainterAbstract interface to a histogram painter.Definition TVirtualGraphPainter.h:28; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16. histhistpainterincTGraphPainter.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8h_source.html
https://root.cern/doc/master/TGraphPainter_8h_source.html:6566,Testability,log,logarithm,6566,"n TGraphPainter.cxx:4820; TGraphPainter::PaintPolyLineHatchesvoid PaintPolyLineHatches(TGraph *theGraph, Int_t n, const Double_t *x, const Double_t *y)Paint a polyline with hatches on one side showing an exclusion zone.Definition TGraphPainter.cxx:4620; TGraphPainter::DrawPanelHelpervoid DrawPanelHelper(TGraph *theGraph) overrideDisplay a panel with all histogram drawing options.Definition TGraphPainter.cxx:796; TGraphPainter::GetObjectInfoHelperchar * GetObjectInfoHelper(TGraph *theGraph, Int_t px, Int_t py) const overrideDefinition TGraphPainter.cxx:1101; TGraphPainter::ExecuteEventHelpervoid ExecuteEventHelper(TGraph *theGraph, Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGraphPainter.cxx:821; TGraphPainter::HighlightPointvirtual void HighlightPoint(TGraph *theGraph, Int_t hpoint, Int_t distance)Check on highlight point.Definition TGraphPainter.cxx:1136; TGraphPainter::ComputeLogsvoid ComputeLogs(Int_t npoints, Int_t opt)Compute the logarithm of variables gxwork and gywork according to the value of Options and put the re...Definition TGraphPainter.cxx:690; TGraphPainter::gxworklstd::vector< Double_t > gxworklDefinition TGraphPainter.h:69; TGraphPainter::DistancetoPrimitiveHelperInt_t DistancetoPrimitiveHelper(TGraph *theGraph, Int_t px, Int_t py) overrideCompute distance from point px,py to a graph.Definition TGraphPainter.cxx:717; TGraphPainter::gxworkstd::vector< Double_t > gxworkDefinition TGraphPainter.h:69; TGraphPainter::gyworkstd::vector< Double_t > gyworkDefinition TGraphPainter.h:69; TGraphPainter::PaintScattervoid PaintScatter(TScatter *theScatter, Option_t *option) overridePaint a scatter plot.Definition TGraphPainter.cxx:4392; TGraphPainter::Smoothvoid Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype)Smooth a curve given by N points.Definition TGraphPainter.cxx:4938; TGraphPainter::gyworklstd::vector< Double_t > gyworklInternal buffers for coordinates. Used for graphs pa",MatchSource.WIKI,doc/master/TGraphPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8h_source.html
https://root.cern/doc/master/TGraphPainter_8h_source.html:8019,Usability,simpl,simple,8019,"ter::gxworkstd::vector< Double_t > gxworkDefinition TGraphPainter.h:69; TGraphPainter::gyworkstd::vector< Double_t > gyworkDefinition TGraphPainter.h:69; TGraphPainter::PaintScattervoid PaintScatter(TScatter *theScatter, Option_t *option) overridePaint a scatter plot.Definition TGraphPainter.cxx:4392; TGraphPainter::Smoothvoid Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype)Smooth a curve given by N points.Definition TGraphPainter.cxx:4938; TGraphPainter::gyworklstd::vector< Double_t > gyworklInternal buffers for coordinates. Used for graphs painting.Definition TGraphPainter.h:69; TGraphPainter::SetHighlightvoid SetHighlight(TGraph *theGraph) overrideSet highlight (enable/disable) mode for theGraph.Definition TGraphPainter.cxx:1120; TGraphPainter::GetHighlightPointvirtual Int_t GetHighlightPoint(TGraph *theGraph) constReturn the highlighted point for theGraph.Definition TGraphPainter.cxx:1110; TGraphPainter::PaintGraphSimplevoid PaintGraphSimple(TGraph *theGraph, Option_t *option)Paint a simple graph, without errors bars.Definition TGraphPainter.cxx:4584; TGraphPainter::PaintGraphQQvoid PaintGraphQQ(TGraph *theGraph, Option_t *option)Paint this graphQQ. No options for the time being.Definition TGraphPainter.cxx:4084; TGraphPainter::~TGraphPainter~TGraphPainter() overrideDestructor.Definition TGraphPainter.cxx:675; TGraphPainter::SetMaxPointsPerLinestatic void SetMaxPointsPerLine(Int_t maxp=50)Static function to set fgMaxPointsPerLine for graph painting.Definition TGraphPainter.cxx:5407; TGraphPainter::PaintGraphBentErrorsvoid PaintGraphBentErrors(TGraph *theGraph, Option_t *option)Paint this TGraphBentErrors with its current attributes.Definition TGraphPainter.cxx:3182; TGraphPainter::TGraphPainterTGraphPainter()Default constructor.Definition TGraphPainter.cxx:667; TGraphPainter::PaintHelpervoid PaintHelper(TGraph *theGraph, Option_t *option) overridePaint a any kind of TGraph.Definition TGraphPainter.cxx:1211; TGraphA TGraph is an o",MatchSource.WIKI,doc/master/TGraphPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8h_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:7037,Availability,down,down,7037,"4, p5, p6, p7, p8;; 198 Double_t px2, py2;; 199 p2 = p3 = p4 = p5 = p6 = p7 = p8 = kFALSE;; 200 if (!gPad->IsEditable()) return;; 201 switch (event) {; 202 case kMouseMotion:; 203 px1 = gPad->XtoAbsPixel(TMath::Cos(GetAngle()));; 204 py1 = gPad->YtoAbsPixel(TMath::Sin(GetAngle()));; 205 d1 = TMath::Abs(px1 - px) + TMath::Abs(py1-py); //simply take sum of pixels differences; 206 p1 = kFALSE;; 207 px2 = gPad->XtoAbsPixel(-1);; 208 py2 = gPad->YtoAbsPixel(1);; 209 d2 = (Int_t)(TMath::Abs(px2 - px) + TMath::Abs(py2 - py)) ;; 210 px3 = gPad->XtoAbsPixel(-1);; 211 py3 = gPad->YtoAbsPixel(-1);; 212 d3 = TMath::Abs(px3 - px) + TMath::Abs(py3 - py) ; //simply take sum of pixels differences; 213 // check if point is close to the radial axis; 214 if (d1 < kMaxDiff) {; 215 gPad->SetCursor(kMove);; 216 p1 = kTRUE;; 217 }; 218 // check if point is close to the left high axis; 219 if ( d2 < kMaxDiff) {; 220 gPad->SetCursor(kHand);; 221 p7 = kTRUE;; 222 }; 223 // check if point is close to the left down axis; 224 if ( d3 < kMaxDiff) {; 225 gPad->SetCursor(kHand);; 226 p8 = kTRUE;; 227 }; 228 // check if point is close to a main circle; 229 if (!p1 && !p7 ) {; 230 p6 = kTRUE;; 231 gPad->SetCursor(kHand);; 232 }; 233 break;; 234 ; 235 case kButton1Down:; 236 // Record initial coordinates; 237 //px4 = px;; 238 //py4 = py;; 239 ; 240 case kButton1Motion:; 241 if (p1) {; 242 px2 = gPad->AbsPixeltoX(px);; 243 py2 = gPad->AbsPixeltoY(py);; 244 if ( px2 < 0 && py2 < 0) {p2 = kTRUE;};; 245 if ( px2 < 0 && py2 > 0 ) {p3 = kTRUE;};; 246 if ( px2 > 0 && py2 > 0 ) {p4 = kTRUE;};; 247 if ( px2 > 0 && py2 < 0 ) {p5 = kTRUE;};; 248 px2 = TMath::ACos(TMath::Abs(px2));; 249 py2 = TMath::ASin(TMath::Abs(py2));; 250 if (p2) {; 251 fAxisAngle = TMath::Pi()+(px2+py2)/2;; 252 p2 = kFALSE;; 253 };; 254 if (p3) {; 255 fAxisAngle = TMath::Pi()-(px2+py2)/2;; 256 p3 = kFALSE;; 257 };; 258 if (p4) {; 259 fAxisAngle = (px2+py2)/2;; 260 p4 = kFALSE;; 261 };; 262 if (p5) {; 263 fAxisAngle = -(px2+py2)/2;; 264 p5 =",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:44888,Energy Efficiency,power,power,44888,"; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TText::PaintTextvirtual void PaintText(Double_t x, Double_t y, const char *text)Draw this text with new coordinates.Definition TText.cxx:752; bool; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::ACosDouble_t ACos(Double_t)Returns the principal value of the arc cosine of x, expressed in radians.Definition TMath.h:632; TMath::ASinDouble_t ASin(Double_t)Returns the principal value of the arc sine of x, expressed in radians.Definition TMath.h:624; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::TanDouble_t Tan(Double_t)Returns the tangent of an angle of x radians.Definition TMath.h:600; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. graf2dgrafsrcTGraphPolargram.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:23158,Performance,optimiz,optimized,23158,"rLabel());; 658 axis.SetLabelFont(GetRadialLabelFont());; 659 axis.SetLabelOffset(GetRadialOffset());; 660 axis.PaintAxis(0, 0, TMath::Cos(GetAngle()), TMath::Sin(GetAngle()),; 661 umin, umax, ndiv, chopt, 0., kFALSE);; 662 }; 663 ; 664 // Paint Circles.; 665 // First paint main circle.; 666 PaintCircle(0.,0.,1,0.,360,0);; 667 // Optimised case.; 668 if (fNdivRad>0 ) {; 669 Double_t frwrmini = 0., frwrmaxi = 0., binWidth2 =0;; 670 THLimitsFinder::Optimize(frwrmin,frwrmin+binWidth,ndivMinor,frwrmini,; 671 frwrmaxi, ndivminor,binWidth2,"""");; 672 Double_t dist2 = dist/(ndivminor);; 673 // Paint major circles.; 674 for (i=1; i<=ndivmajor+2; i++) {; 675 TAttLine::SetLineStyle(1);; 676 TAttLine::Modify();; 677 PaintCircle(0.,0.,rmajmin,0.,360,0);; 678 ; 679 //Paint minor circles.; 680 TAttLine::SetLineStyle(2);; 681 TAttLine::Modify();; 682 for (j=1; j<ndivminor+1; j++) {; 683 if (rmajmin+j*dist2<=1) PaintCircle(0.,0.,rmajmin+j*dist2,0.,360,0);; 684 }; 685 rmajmin = (frwrmin-fRwrmin)/(fRwrmax-fRwrmin)+(i-1)*dist;; 686 }; 687 // Non-optimized case.; 688 } else {; 689 ; 690 // Paint major circles.; 691 for (i=1; i<=ndivMajor; i++) {; 692 TAttLine::SetLineStyle(1);; 693 TAttLine::Modify();; 694 Double_t rmaj = i*1./ndivMajor;; 695 PaintCircle(0.,0.,rmaj,0.,360,0);; 696 ; 697 // Paint minor circles.; 698 for (j=1; j<ndivMinor; j++) {; 699 TAttLine::SetLineStyle(2);; 700 TAttLine::Modify();; 701 PaintCircle(0.,0.,rmaj- j*1./(ndivMajor*ndivMinor),0.,360,0);; 702 }; 703 }; 704 }; 705 } else {; 706 // Draw Log scale on radial axis if option activated.; 707 Int_t big = (Int_t)fRwrmax;; 708 Int_t test= 0;; 709 while (big >= 10) {; 710 big = big/10;; 711 test++;; 712 }; 713 for (i=1; i<=test; i++) {; 714 TAttLine::SetLineStyle(1);; 715 TAttLine::Modify();; 716 Double_t ecart;; 717 ecart = ((double) i)/ ((double) test);; 718 PaintCircle(0.,0.,ecart,0,360,0);; 719 TAttLine::SetLineStyle(GetLineStyle());; 720 TAttLine::Modify();; 721 Double_t a=0;; 722 Double_t b,c,d;; 723 b = TMath::Lo",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:17665,Testability,test,test,17665,"polarSize());; 507 }; 508 if (theta == 0 || theta ==TMath::Pi()) {; 509 gPad->PaintLine(1-GetTickpolarSize(),0,1+GetTickpolarSize(),0);; 510 gPad->PaintLine(-1+GetTickpolarSize(),0,-1-GetTickpolarSize(),0);; 511 }; 512 }; 513 TAttLine::SetLineStyle(1);; 514 TAttLine::Modify();; 515 gPad->PaintLine(0.,0.,costheta,sintheta);; 516 // Add minor lines w/o text.; 517 Int_t oldLineStyle = GetLineStyle();; 518 TAttLine::SetLineStyle(2); //Minor lines always in this style.; 519 TAttLine::Modify(); //Changes line attributes apart from style.; 520 for (j=1; j<ndivMinor; j++) {; 521 Double_t thetamin = theta+j*2*TMath::Pi()/(ndivMajor*ndivMinor);; 522 gPad->PaintLine(0.,0.,TMath::Cos(thetamin),TMath::Sin(thetamin));; 523 }; 524 TAttLine::SetLineStyle(oldLineStyle);; 525 TAttLine::Modify();; 526 }; 527 } else {; 528 Int_t big = (Int_t)fRwtmax;; 529 Int_t test= 1;; 530 while (big >= 10) {; 531 big = big/10;; 532 test++;; 533 }; 534 for (i=1; i<=test; i++) {; 535 Double_t txtval = pow((double)10,(double)(i-1));; 536 Double_t theta = (i-1)*2*TMath::Pi()/(double)(test);; 537 Double_t costheta = TMath::Cos(theta);; 538 Double_t sintheta = TMath::Sin(theta);; 539 Double_t tantheta = TMath::Tan(theta);; 540 Double_t costhetas = (1+fPolarOffset)*costheta;; 541 Double_t sinthetas = (1+fPolarOffset)*sintheta;; 542 Double_t corr = 0.01;; 543 ; 544 TLatex textangular;; 545 textangular.SetTextColor(GetPolarColorLabel());; 546 textangular.SetTextFont(GetPolarLabelFont());; 547 ; 548 TString form = "" "";; 549 TGaxis axis;; 550 ; 551 if (TestBit(TGraphPolargram::kLabelOrtho)) {; 552 if(!fPolarLabels && optionLabels){; 553 // Polar numbers are aligned with their axis.; 554 form.Form(""%5.3g"",txtval);; 555 axis.LabelsLimits(form.Data(),first,last);; 556 TString s = form;; 557 if (first != 0) s.Remove(0, first);; 558 textangular.SetTextAlign(FindAlign(theta));; 559 textangular.PaintLatex(costhetas,; 560 sinthetas, FindTextAngle(theta), GetPolarLabelSize(), s);; 561 }; 562 else if (fPolarLabels){; 56",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:17723,Testability,test,test,17723,"polarSize());; 507 }; 508 if (theta == 0 || theta ==TMath::Pi()) {; 509 gPad->PaintLine(1-GetTickpolarSize(),0,1+GetTickpolarSize(),0);; 510 gPad->PaintLine(-1+GetTickpolarSize(),0,-1-GetTickpolarSize(),0);; 511 }; 512 }; 513 TAttLine::SetLineStyle(1);; 514 TAttLine::Modify();; 515 gPad->PaintLine(0.,0.,costheta,sintheta);; 516 // Add minor lines w/o text.; 517 Int_t oldLineStyle = GetLineStyle();; 518 TAttLine::SetLineStyle(2); //Minor lines always in this style.; 519 TAttLine::Modify(); //Changes line attributes apart from style.; 520 for (j=1; j<ndivMinor; j++) {; 521 Double_t thetamin = theta+j*2*TMath::Pi()/(ndivMajor*ndivMinor);; 522 gPad->PaintLine(0.,0.,TMath::Cos(thetamin),TMath::Sin(thetamin));; 523 }; 524 TAttLine::SetLineStyle(oldLineStyle);; 525 TAttLine::Modify();; 526 }; 527 } else {; 528 Int_t big = (Int_t)fRwtmax;; 529 Int_t test= 1;; 530 while (big >= 10) {; 531 big = big/10;; 532 test++;; 533 }; 534 for (i=1; i<=test; i++) {; 535 Double_t txtval = pow((double)10,(double)(i-1));; 536 Double_t theta = (i-1)*2*TMath::Pi()/(double)(test);; 537 Double_t costheta = TMath::Cos(theta);; 538 Double_t sintheta = TMath::Sin(theta);; 539 Double_t tantheta = TMath::Tan(theta);; 540 Double_t costhetas = (1+fPolarOffset)*costheta;; 541 Double_t sinthetas = (1+fPolarOffset)*sintheta;; 542 Double_t corr = 0.01;; 543 ; 544 TLatex textangular;; 545 textangular.SetTextColor(GetPolarColorLabel());; 546 textangular.SetTextFont(GetPolarLabelFont());; 547 ; 548 TString form = "" "";; 549 TGaxis axis;; 550 ; 551 if (TestBit(TGraphPolargram::kLabelOrtho)) {; 552 if(!fPolarLabels && optionLabels){; 553 // Polar numbers are aligned with their axis.; 554 form.Form(""%5.3g"",txtval);; 555 axis.LabelsLimits(form.Data(),first,last);; 556 TString s = form;; 557 if (first != 0) s.Remove(0, first);; 558 textangular.SetTextAlign(FindAlign(theta));; 559 textangular.PaintLatex(costhetas,; 560 sinthetas, FindTextAngle(theta), GetPolarLabelSize(), s);; 561 }; 562 else if (fPolarLabels){; 56",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:17756,Testability,test,test,17756,"polarSize());; 507 }; 508 if (theta == 0 || theta ==TMath::Pi()) {; 509 gPad->PaintLine(1-GetTickpolarSize(),0,1+GetTickpolarSize(),0);; 510 gPad->PaintLine(-1+GetTickpolarSize(),0,-1-GetTickpolarSize(),0);; 511 }; 512 }; 513 TAttLine::SetLineStyle(1);; 514 TAttLine::Modify();; 515 gPad->PaintLine(0.,0.,costheta,sintheta);; 516 // Add minor lines w/o text.; 517 Int_t oldLineStyle = GetLineStyle();; 518 TAttLine::SetLineStyle(2); //Minor lines always in this style.; 519 TAttLine::Modify(); //Changes line attributes apart from style.; 520 for (j=1; j<ndivMinor; j++) {; 521 Double_t thetamin = theta+j*2*TMath::Pi()/(ndivMajor*ndivMinor);; 522 gPad->PaintLine(0.,0.,TMath::Cos(thetamin),TMath::Sin(thetamin));; 523 }; 524 TAttLine::SetLineStyle(oldLineStyle);; 525 TAttLine::Modify();; 526 }; 527 } else {; 528 Int_t big = (Int_t)fRwtmax;; 529 Int_t test= 1;; 530 while (big >= 10) {; 531 big = big/10;; 532 test++;; 533 }; 534 for (i=1; i<=test; i++) {; 535 Double_t txtval = pow((double)10,(double)(i-1));; 536 Double_t theta = (i-1)*2*TMath::Pi()/(double)(test);; 537 Double_t costheta = TMath::Cos(theta);; 538 Double_t sintheta = TMath::Sin(theta);; 539 Double_t tantheta = TMath::Tan(theta);; 540 Double_t costhetas = (1+fPolarOffset)*costheta;; 541 Double_t sinthetas = (1+fPolarOffset)*sintheta;; 542 Double_t corr = 0.01;; 543 ; 544 TLatex textangular;; 545 textangular.SetTextColor(GetPolarColorLabel());; 546 textangular.SetTextFont(GetPolarLabelFont());; 547 ; 548 TString form = "" "";; 549 TGaxis axis;; 550 ; 551 if (TestBit(TGraphPolargram::kLabelOrtho)) {; 552 if(!fPolarLabels && optionLabels){; 553 // Polar numbers are aligned with their axis.; 554 form.Form(""%5.3g"",txtval);; 555 axis.LabelsLimits(form.Data(),first,last);; 556 TString s = form;; 557 if (first != 0) s.Remove(0, first);; 558 textangular.SetTextAlign(FindAlign(theta));; 559 textangular.PaintLatex(costhetas,; 560 sinthetas, FindTextAngle(theta), GetPolarLabelSize(), s);; 561 }; 562 else if (fPolarLabels){; 56",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:17874,Testability,test,test,17874,"polarSize());; 507 }; 508 if (theta == 0 || theta ==TMath::Pi()) {; 509 gPad->PaintLine(1-GetTickpolarSize(),0,1+GetTickpolarSize(),0);; 510 gPad->PaintLine(-1+GetTickpolarSize(),0,-1-GetTickpolarSize(),0);; 511 }; 512 }; 513 TAttLine::SetLineStyle(1);; 514 TAttLine::Modify();; 515 gPad->PaintLine(0.,0.,costheta,sintheta);; 516 // Add minor lines w/o text.; 517 Int_t oldLineStyle = GetLineStyle();; 518 TAttLine::SetLineStyle(2); //Minor lines always in this style.; 519 TAttLine::Modify(); //Changes line attributes apart from style.; 520 for (j=1; j<ndivMinor; j++) {; 521 Double_t thetamin = theta+j*2*TMath::Pi()/(ndivMajor*ndivMinor);; 522 gPad->PaintLine(0.,0.,TMath::Cos(thetamin),TMath::Sin(thetamin));; 523 }; 524 TAttLine::SetLineStyle(oldLineStyle);; 525 TAttLine::Modify();; 526 }; 527 } else {; 528 Int_t big = (Int_t)fRwtmax;; 529 Int_t test= 1;; 530 while (big >= 10) {; 531 big = big/10;; 532 test++;; 533 }; 534 for (i=1; i<=test; i++) {; 535 Double_t txtval = pow((double)10,(double)(i-1));; 536 Double_t theta = (i-1)*2*TMath::Pi()/(double)(test);; 537 Double_t costheta = TMath::Cos(theta);; 538 Double_t sintheta = TMath::Sin(theta);; 539 Double_t tantheta = TMath::Tan(theta);; 540 Double_t costhetas = (1+fPolarOffset)*costheta;; 541 Double_t sinthetas = (1+fPolarOffset)*sintheta;; 542 Double_t corr = 0.01;; 543 ; 544 TLatex textangular;; 545 textangular.SetTextColor(GetPolarColorLabel());; 546 textangular.SetTextFont(GetPolarLabelFont());; 547 ; 548 TString form = "" "";; 549 TGaxis axis;; 550 ; 551 if (TestBit(TGraphPolargram::kLabelOrtho)) {; 552 if(!fPolarLabels && optionLabels){; 553 // Polar numbers are aligned with their axis.; 554 form.Form(""%5.3g"",txtval);; 555 axis.LabelsLimits(form.Data(),first,last);; 556 TString s = form;; 557 if (first != 0) s.Remove(0, first);; 558 textangular.SetTextAlign(FindAlign(theta));; 559 textangular.PaintLatex(costhetas,; 560 sinthetas, FindTextAngle(theta), GetPolarLabelSize(), s);; 561 }; 562 else if (fPolarLabels){; 56",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:20596,Testability,test,test,20596," 584 }; 585 ; 586 TAttLine::Modify();; 587 //Check if SetTickPolar is activated, and draw tick marks; 588 Bool_t issettickpolar = gPad->GetTicky();; 589 if (issettickpolar) {; 590 if (theta != 0 && theta !=TMath::Pi()) {; 591 gPad->PaintLine((sintheta-GetTickpolarSize())/tantheta,sintheta-GetTickpolarSize(),; 592 (sintheta+GetTickpolarSize())/tantheta,sintheta+GetTickpolarSize());; 593 }; 594 if (theta == 0 || theta ==TMath::Pi()) {; 595 gPad->PaintLine(1-GetTickpolarSize(),0,1+GetTickpolarSize(),0);; 596 gPad->PaintLine(-1+GetTickpolarSize(),0,-1-GetTickpolarSize(),0);; 597 }; 598 }; 599 TAttLine::SetLineStyle(1);; 600 TAttLine::Modify();; 601 gPad->PaintLine(0.,0.,costheta,sintheta);; 602 // Add minor lines w/o text.; 603 Int_t oldLineStyle = GetLineStyle();; 604 TAttLine::SetLineStyle(2); //Minor lines always in this style.; 605 TAttLine::Modify(); //Changes line attributes apart from style.; 606 Double_t a=0;; 607 Double_t b,c,d;; 608 b = TMath::Log(10)*test;; 609 d= 2*TMath::Pi()/(double)test;; 610 for (j=1; j<9; j++) {; 611 a=TMath::Log(j+1)-TMath::Log(j)+a;; 612 c=a/b*6.28+d*(i-1);; 613 gPad->PaintLine(0.,0.,TMath::Cos(c),TMath::Sin(c));; 614 }; 615 TAttLine::SetLineStyle(oldLineStyle);; 616 TAttLine::Modify();; 617 }; 618 }; 619}; 620 ; 621////////////////////////////////////////////////////////////////////////////////; 622/// Paint radial divisions.; 623/// Check for editable pad or create default.; 624 ; 625void TGraphPolargram::PaintRadialDivisions(Bool_t drawaxis); 626{; 627 if (!gPad) return ;; 628 ; 629 static char chopt[8] = """";; 630 Int_t i,j;; 631 Int_t ndiv = TMath::Abs(fNdivRad);; 632 Int_t ndivMajor = ndiv%100;; 633 Int_t ndivMinor = ndiv/100;; 634 Int_t ndivmajor = 0;; 635 Double_t frwrmin = 0., frwrmax = 0., binWidth = 0;; 636 ; 637 THLimitsFinder::Optimize(fRwrmin,fRwrmax,ndivMajor,frwrmin,; 638 frwrmax, ndivmajor,binWidth,"""");; 639 ; 640 if (!gPad->GetLogx()) {; 641 gPad->RangeAxis(-1,-1,1,1);; 642 gPad->Range(-1.25,-1.25,1.25,1.25);; 643 Doub",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:20632,Testability,test,test,20632," 584 }; 585 ; 586 TAttLine::Modify();; 587 //Check if SetTickPolar is activated, and draw tick marks; 588 Bool_t issettickpolar = gPad->GetTicky();; 589 if (issettickpolar) {; 590 if (theta != 0 && theta !=TMath::Pi()) {; 591 gPad->PaintLine((sintheta-GetTickpolarSize())/tantheta,sintheta-GetTickpolarSize(),; 592 (sintheta+GetTickpolarSize())/tantheta,sintheta+GetTickpolarSize());; 593 }; 594 if (theta == 0 || theta ==TMath::Pi()) {; 595 gPad->PaintLine(1-GetTickpolarSize(),0,1+GetTickpolarSize(),0);; 596 gPad->PaintLine(-1+GetTickpolarSize(),0,-1-GetTickpolarSize(),0);; 597 }; 598 }; 599 TAttLine::SetLineStyle(1);; 600 TAttLine::Modify();; 601 gPad->PaintLine(0.,0.,costheta,sintheta);; 602 // Add minor lines w/o text.; 603 Int_t oldLineStyle = GetLineStyle();; 604 TAttLine::SetLineStyle(2); //Minor lines always in this style.; 605 TAttLine::Modify(); //Changes line attributes apart from style.; 606 Double_t a=0;; 607 Double_t b,c,d;; 608 b = TMath::Log(10)*test;; 609 d= 2*TMath::Pi()/(double)test;; 610 for (j=1; j<9; j++) {; 611 a=TMath::Log(j+1)-TMath::Log(j)+a;; 612 c=a/b*6.28+d*(i-1);; 613 gPad->PaintLine(0.,0.,TMath::Cos(c),TMath::Sin(c));; 614 }; 615 TAttLine::SetLineStyle(oldLineStyle);; 616 TAttLine::Modify();; 617 }; 618 }; 619}; 620 ; 621////////////////////////////////////////////////////////////////////////////////; 622/// Paint radial divisions.; 623/// Check for editable pad or create default.; 624 ; 625void TGraphPolargram::PaintRadialDivisions(Bool_t drawaxis); 626{; 627 if (!gPad) return ;; 628 ; 629 static char chopt[8] = """";; 630 Int_t i,j;; 631 Int_t ndiv = TMath::Abs(fNdivRad);; 632 Int_t ndivMajor = ndiv%100;; 633 Int_t ndivMinor = ndiv/100;; 634 Int_t ndivmajor = 0;; 635 Double_t frwrmin = 0., frwrmax = 0., binWidth = 0;; 636 ; 637 THLimitsFinder::Optimize(fRwrmin,fRwrmax,ndivMajor,frwrmin,; 638 frwrmax, ndivmajor,binWidth,"""");; 639 ; 640 if (!gPad->GetLogx()) {; 641 gPad->RangeAxis(-1,-1,1,1);; 642 gPad->Range(-1.25,-1.25,1.25,1.25);; 643 Doub",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:23724,Testability,test,test,23724,"; 677 PaintCircle(0.,0.,rmajmin,0.,360,0);; 678 ; 679 //Paint minor circles.; 680 TAttLine::SetLineStyle(2);; 681 TAttLine::Modify();; 682 for (j=1; j<ndivminor+1; j++) {; 683 if (rmajmin+j*dist2<=1) PaintCircle(0.,0.,rmajmin+j*dist2,0.,360,0);; 684 }; 685 rmajmin = (frwrmin-fRwrmin)/(fRwrmax-fRwrmin)+(i-1)*dist;; 686 }; 687 // Non-optimized case.; 688 } else {; 689 ; 690 // Paint major circles.; 691 for (i=1; i<=ndivMajor; i++) {; 692 TAttLine::SetLineStyle(1);; 693 TAttLine::Modify();; 694 Double_t rmaj = i*1./ndivMajor;; 695 PaintCircle(0.,0.,rmaj,0.,360,0);; 696 ; 697 // Paint minor circles.; 698 for (j=1; j<ndivMinor; j++) {; 699 TAttLine::SetLineStyle(2);; 700 TAttLine::Modify();; 701 PaintCircle(0.,0.,rmaj- j*1./(ndivMajor*ndivMinor),0.,360,0);; 702 }; 703 }; 704 }; 705 } else {; 706 // Draw Log scale on radial axis if option activated.; 707 Int_t big = (Int_t)fRwrmax;; 708 Int_t test= 0;; 709 while (big >= 10) {; 710 big = big/10;; 711 test++;; 712 }; 713 for (i=1; i<=test; i++) {; 714 TAttLine::SetLineStyle(1);; 715 TAttLine::Modify();; 716 Double_t ecart;; 717 ecart = ((double) i)/ ((double) test);; 718 PaintCircle(0.,0.,ecart,0,360,0);; 719 TAttLine::SetLineStyle(GetLineStyle());; 720 TAttLine::Modify();; 721 Double_t a=0;; 722 Double_t b,c,d;; 723 b = TMath::Log(10)*test;; 724 d = 1/(double)test;; 725 for (j=1; j<9; j++) {; 726 a = TMath::Log(j+1)-TMath::Log(j)+a;; 727 c = a/b+d*(i-1);; 728 PaintCircle(0,0.,c,0.,360,0);; 729 }; 730 }; 731 }; 732 TAttLine::SetLineStyle(1);; 733 TAttLine::Modify();; 734}; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Reduce fractions.; 738 ; 739void TGraphPolargram::ReduceFraction(Int_t num, Int_t den, Int_t &rnum, Int_t &rden); 740{; 741 Int_t a = 0;; 742 Int_t b = 0;; 743 Int_t i = 0;; 744 Int_t j = 0;; 745 a = den;; 746 b = num;; 747 if (b > a) {; 748 j = b;; 749 } else {; 750 j = a;; 751 }; 752 for (i=j; i > 1; i--) {; 753 if ((a % i == 0) && (b % i == 0)) {; 754 a = ",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:23782,Testability,test,test,23782,"; 677 PaintCircle(0.,0.,rmajmin,0.,360,0);; 678 ; 679 //Paint minor circles.; 680 TAttLine::SetLineStyle(2);; 681 TAttLine::Modify();; 682 for (j=1; j<ndivminor+1; j++) {; 683 if (rmajmin+j*dist2<=1) PaintCircle(0.,0.,rmajmin+j*dist2,0.,360,0);; 684 }; 685 rmajmin = (frwrmin-fRwrmin)/(fRwrmax-fRwrmin)+(i-1)*dist;; 686 }; 687 // Non-optimized case.; 688 } else {; 689 ; 690 // Paint major circles.; 691 for (i=1; i<=ndivMajor; i++) {; 692 TAttLine::SetLineStyle(1);; 693 TAttLine::Modify();; 694 Double_t rmaj = i*1./ndivMajor;; 695 PaintCircle(0.,0.,rmaj,0.,360,0);; 696 ; 697 // Paint minor circles.; 698 for (j=1; j<ndivMinor; j++) {; 699 TAttLine::SetLineStyle(2);; 700 TAttLine::Modify();; 701 PaintCircle(0.,0.,rmaj- j*1./(ndivMajor*ndivMinor),0.,360,0);; 702 }; 703 }; 704 }; 705 } else {; 706 // Draw Log scale on radial axis if option activated.; 707 Int_t big = (Int_t)fRwrmax;; 708 Int_t test= 0;; 709 while (big >= 10) {; 710 big = big/10;; 711 test++;; 712 }; 713 for (i=1; i<=test; i++) {; 714 TAttLine::SetLineStyle(1);; 715 TAttLine::Modify();; 716 Double_t ecart;; 717 ecart = ((double) i)/ ((double) test);; 718 PaintCircle(0.,0.,ecart,0,360,0);; 719 TAttLine::SetLineStyle(GetLineStyle());; 720 TAttLine::Modify();; 721 Double_t a=0;; 722 Double_t b,c,d;; 723 b = TMath::Log(10)*test;; 724 d = 1/(double)test;; 725 for (j=1; j<9; j++) {; 726 a = TMath::Log(j+1)-TMath::Log(j)+a;; 727 c = a/b+d*(i-1);; 728 PaintCircle(0,0.,c,0.,360,0);; 729 }; 730 }; 731 }; 732 TAttLine::SetLineStyle(1);; 733 TAttLine::Modify();; 734}; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Reduce fractions.; 738 ; 739void TGraphPolargram::ReduceFraction(Int_t num, Int_t den, Int_t &rnum, Int_t &rden); 740{; 741 Int_t a = 0;; 742 Int_t b = 0;; 743 Int_t i = 0;; 744 Int_t j = 0;; 745 a = den;; 746 b = num;; 747 if (b > a) {; 748 j = b;; 749 } else {; 750 j = a;; 751 }; 752 for (i=j; i > 1; i--) {; 753 if ((a % i == 0) && (b % i == 0)) {; 754 a = ",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:23815,Testability,test,test,23815,"; 677 PaintCircle(0.,0.,rmajmin,0.,360,0);; 678 ; 679 //Paint minor circles.; 680 TAttLine::SetLineStyle(2);; 681 TAttLine::Modify();; 682 for (j=1; j<ndivminor+1; j++) {; 683 if (rmajmin+j*dist2<=1) PaintCircle(0.,0.,rmajmin+j*dist2,0.,360,0);; 684 }; 685 rmajmin = (frwrmin-fRwrmin)/(fRwrmax-fRwrmin)+(i-1)*dist;; 686 }; 687 // Non-optimized case.; 688 } else {; 689 ; 690 // Paint major circles.; 691 for (i=1; i<=ndivMajor; i++) {; 692 TAttLine::SetLineStyle(1);; 693 TAttLine::Modify();; 694 Double_t rmaj = i*1./ndivMajor;; 695 PaintCircle(0.,0.,rmaj,0.,360,0);; 696 ; 697 // Paint minor circles.; 698 for (j=1; j<ndivMinor; j++) {; 699 TAttLine::SetLineStyle(2);; 700 TAttLine::Modify();; 701 PaintCircle(0.,0.,rmaj- j*1./(ndivMajor*ndivMinor),0.,360,0);; 702 }; 703 }; 704 }; 705 } else {; 706 // Draw Log scale on radial axis if option activated.; 707 Int_t big = (Int_t)fRwrmax;; 708 Int_t test= 0;; 709 while (big >= 10) {; 710 big = big/10;; 711 test++;; 712 }; 713 for (i=1; i<=test; i++) {; 714 TAttLine::SetLineStyle(1);; 715 TAttLine::Modify();; 716 Double_t ecart;; 717 ecart = ((double) i)/ ((double) test);; 718 PaintCircle(0.,0.,ecart,0,360,0);; 719 TAttLine::SetLineStyle(GetLineStyle());; 720 TAttLine::Modify();; 721 Double_t a=0;; 722 Double_t b,c,d;; 723 b = TMath::Log(10)*test;; 724 d = 1/(double)test;; 725 for (j=1; j<9; j++) {; 726 a = TMath::Log(j+1)-TMath::Log(j)+a;; 727 c = a/b+d*(i-1);; 728 PaintCircle(0,0.,c,0.,360,0);; 729 }; 730 }; 731 }; 732 TAttLine::SetLineStyle(1);; 733 TAttLine::Modify();; 734}; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Reduce fractions.; 738 ; 739void TGraphPolargram::ReduceFraction(Int_t num, Int_t den, Int_t &rnum, Int_t &rden); 740{; 741 Int_t a = 0;; 742 Int_t b = 0;; 743 Int_t i = 0;; 744 Int_t j = 0;; 745 a = den;; 746 b = num;; 747 if (b > a) {; 748 j = b;; 749 } else {; 750 j = a;; 751 }; 752 for (i=j; i > 1; i--) {; 753 if ((a % i == 0) && (b % i == 0)) {; 754 a = ",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:23943,Testability,test,test,23943,"; 677 PaintCircle(0.,0.,rmajmin,0.,360,0);; 678 ; 679 //Paint minor circles.; 680 TAttLine::SetLineStyle(2);; 681 TAttLine::Modify();; 682 for (j=1; j<ndivminor+1; j++) {; 683 if (rmajmin+j*dist2<=1) PaintCircle(0.,0.,rmajmin+j*dist2,0.,360,0);; 684 }; 685 rmajmin = (frwrmin-fRwrmin)/(fRwrmax-fRwrmin)+(i-1)*dist;; 686 }; 687 // Non-optimized case.; 688 } else {; 689 ; 690 // Paint major circles.; 691 for (i=1; i<=ndivMajor; i++) {; 692 TAttLine::SetLineStyle(1);; 693 TAttLine::Modify();; 694 Double_t rmaj = i*1./ndivMajor;; 695 PaintCircle(0.,0.,rmaj,0.,360,0);; 696 ; 697 // Paint minor circles.; 698 for (j=1; j<ndivMinor; j++) {; 699 TAttLine::SetLineStyle(2);; 700 TAttLine::Modify();; 701 PaintCircle(0.,0.,rmaj- j*1./(ndivMajor*ndivMinor),0.,360,0);; 702 }; 703 }; 704 }; 705 } else {; 706 // Draw Log scale on radial axis if option activated.; 707 Int_t big = (Int_t)fRwrmax;; 708 Int_t test= 0;; 709 while (big >= 10) {; 710 big = big/10;; 711 test++;; 712 }; 713 for (i=1; i<=test; i++) {; 714 TAttLine::SetLineStyle(1);; 715 TAttLine::Modify();; 716 Double_t ecart;; 717 ecart = ((double) i)/ ((double) test);; 718 PaintCircle(0.,0.,ecart,0,360,0);; 719 TAttLine::SetLineStyle(GetLineStyle());; 720 TAttLine::Modify();; 721 Double_t a=0;; 722 Double_t b,c,d;; 723 b = TMath::Log(10)*test;; 724 d = 1/(double)test;; 725 for (j=1; j<9; j++) {; 726 a = TMath::Log(j+1)-TMath::Log(j)+a;; 727 c = a/b+d*(i-1);; 728 PaintCircle(0,0.,c,0.,360,0);; 729 }; 730 }; 731 }; 732 TAttLine::SetLineStyle(1);; 733 TAttLine::Modify();; 734}; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Reduce fractions.; 738 ; 739void TGraphPolargram::ReduceFraction(Int_t num, Int_t den, Int_t &rnum, Int_t &rden); 740{; 741 Int_t a = 0;; 742 Int_t b = 0;; 743 Int_t i = 0;; 744 Int_t j = 0;; 745 a = den;; 746 b = num;; 747 if (b > a) {; 748 j = b;; 749 } else {; 750 j = a;; 751 }; 752 for (i=j; i > 1; i--) {; 753 if ((a % i == 0) && (b % i == 0)) {; 754 a = ",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:24123,Testability,test,test,24123,"Rwrmin)+(i-1)*dist;; 686 }; 687 // Non-optimized case.; 688 } else {; 689 ; 690 // Paint major circles.; 691 for (i=1; i<=ndivMajor; i++) {; 692 TAttLine::SetLineStyle(1);; 693 TAttLine::Modify();; 694 Double_t rmaj = i*1./ndivMajor;; 695 PaintCircle(0.,0.,rmaj,0.,360,0);; 696 ; 697 // Paint minor circles.; 698 for (j=1; j<ndivMinor; j++) {; 699 TAttLine::SetLineStyle(2);; 700 TAttLine::Modify();; 701 PaintCircle(0.,0.,rmaj- j*1./(ndivMajor*ndivMinor),0.,360,0);; 702 }; 703 }; 704 }; 705 } else {; 706 // Draw Log scale on radial axis if option activated.; 707 Int_t big = (Int_t)fRwrmax;; 708 Int_t test= 0;; 709 while (big >= 10) {; 710 big = big/10;; 711 test++;; 712 }; 713 for (i=1; i<=test; i++) {; 714 TAttLine::SetLineStyle(1);; 715 TAttLine::Modify();; 716 Double_t ecart;; 717 ecart = ((double) i)/ ((double) test);; 718 PaintCircle(0.,0.,ecart,0,360,0);; 719 TAttLine::SetLineStyle(GetLineStyle());; 720 TAttLine::Modify();; 721 Double_t a=0;; 722 Double_t b,c,d;; 723 b = TMath::Log(10)*test;; 724 d = 1/(double)test;; 725 for (j=1; j<9; j++) {; 726 a = TMath::Log(j+1)-TMath::Log(j)+a;; 727 c = a/b+d*(i-1);; 728 PaintCircle(0,0.,c,0.,360,0);; 729 }; 730 }; 731 }; 732 TAttLine::SetLineStyle(1);; 733 TAttLine::Modify();; 734}; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Reduce fractions.; 738 ; 739void TGraphPolargram::ReduceFraction(Int_t num, Int_t den, Int_t &rnum, Int_t &rden); 740{; 741 Int_t a = 0;; 742 Int_t b = 0;; 743 Int_t i = 0;; 744 Int_t j = 0;; 745 a = den;; 746 b = num;; 747 if (b > a) {; 748 j = b;; 749 } else {; 750 j = a;; 751 }; 752 for (i=j; i > 1; i--) {; 753 if ((a % i == 0) && (b % i == 0)) {; 754 a = a/i;; 755 b = b/i;; 756 }; 757 }; 758 rden = a;; 759 rnum = b;; 760}; 761 ; 762////////////////////////////////////////////////////////////////////////////////; 763/// Set axis angle.; 764 ; 765void TGraphPolargram::SetAxisAngle(Double_t angle); 766{; 767 fAxisAngle = angle/180*TMath::Pi();; 76",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:24148,Testability,test,test,24148,"Rwrmin)+(i-1)*dist;; 686 }; 687 // Non-optimized case.; 688 } else {; 689 ; 690 // Paint major circles.; 691 for (i=1; i<=ndivMajor; i++) {; 692 TAttLine::SetLineStyle(1);; 693 TAttLine::Modify();; 694 Double_t rmaj = i*1./ndivMajor;; 695 PaintCircle(0.,0.,rmaj,0.,360,0);; 696 ; 697 // Paint minor circles.; 698 for (j=1; j<ndivMinor; j++) {; 699 TAttLine::SetLineStyle(2);; 700 TAttLine::Modify();; 701 PaintCircle(0.,0.,rmaj- j*1./(ndivMajor*ndivMinor),0.,360,0);; 702 }; 703 }; 704 }; 705 } else {; 706 // Draw Log scale on radial axis if option activated.; 707 Int_t big = (Int_t)fRwrmax;; 708 Int_t test= 0;; 709 while (big >= 10) {; 710 big = big/10;; 711 test++;; 712 }; 713 for (i=1; i<=test; i++) {; 714 TAttLine::SetLineStyle(1);; 715 TAttLine::Modify();; 716 Double_t ecart;; 717 ecart = ((double) i)/ ((double) test);; 718 PaintCircle(0.,0.,ecart,0,360,0);; 719 TAttLine::SetLineStyle(GetLineStyle());; 720 TAttLine::Modify();; 721 Double_t a=0;; 722 Double_t b,c,d;; 723 b = TMath::Log(10)*test;; 724 d = 1/(double)test;; 725 for (j=1; j<9; j++) {; 726 a = TMath::Log(j+1)-TMath::Log(j)+a;; 727 c = a/b+d*(i-1);; 728 PaintCircle(0,0.,c,0.,360,0);; 729 }; 730 }; 731 }; 732 TAttLine::SetLineStyle(1);; 733 TAttLine::Modify();; 734}; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Reduce fractions.; 738 ; 739void TGraphPolargram::ReduceFraction(Int_t num, Int_t den, Int_t &rnum, Int_t &rden); 740{; 741 Int_t a = 0;; 742 Int_t b = 0;; 743 Int_t i = 0;; 744 Int_t j = 0;; 745 a = den;; 746 b = num;; 747 if (b > a) {; 748 j = b;; 749 } else {; 750 j = a;; 751 }; 752 for (i=j; i > 1; i--) {; 753 if ((a % i == 0) && (b % i == 0)) {; 754 a = a/i;; 755 b = b/i;; 756 }; 757 }; 758 rden = a;; 759 rnum = b;; 760}; 761 ; 762////////////////////////////////////////////////////////////////////////////////; 763/// Set axis angle.; 764 ; 765void TGraphPolargram::SetAxisAngle(Double_t angle); 766{; 767 fAxisAngle = angle/180*TMath::Pi();; 76",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:44674,Testability,log,logarithm,44674,"; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TText::PaintTextvirtual void PaintText(Double_t x, Double_t y, const char *text)Draw this text with new coordinates.Definition TText.cxx:752; bool; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::ACosDouble_t ACos(Double_t)Returns the principal value of the arc cosine of x, expressed in radians.Definition TMath.h:632; TMath::ASinDouble_t ASin(Double_t)Returns the principal value of the arc sine of x, expressed in radians.Definition TMath.h:624; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::TanDouble_t Tan(Double_t)Returns the tangent of an angle of x radians.Definition TMath.h:600; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. graf2dgrafsrcTGraphPolargram.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:6377,Usability,simpl,simply,6377,,MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:6691,Usability,simpl,simply,6691,,MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:11486,Usability,simpl,simplified,11486," = 0.04;; 338 fRadialOffset = 0.025;; 339 fRadian = kTRUE;; 340 fRadialLabelColor = 1;; 341 fRadialLabelFont = 62;; 342 fRadialTextSize = 0.035;; 343 fTickpolarSize = 0.02;; 344}; 345 ; 346////////////////////////////////////////////////////////////////////////////////; 347/// Paint TGraphPolargram.; 348 ; 349void TGraphPolargram::Paint(Option_t * chopt); 350{; 351 Int_t optionpoldiv, optionraddiv;; 352 Bool_t optionLabels = kTRUE;; 353 ; 354 TString opt = chopt;; 355 opt.ToUpper();; 356 ; 357 if(opt.Contains('P')) optionpoldiv=1; else optionpoldiv=0;; 358 if(opt.Contains('R')) optionraddiv=1; else optionraddiv=0;; 359 if(opt.Contains('O')) SetBit(TGraphPolargram::kLabelOrtho);; 360 else ResetBit(TGraphPolargram::kLabelOrtho);; 361 if(!opt.Contains('P') && !opt.Contains('R')) optionpoldiv=optionraddiv=1;; 362 if(opt.Contains('N')) optionLabels = kFALSE;; 363 ; 364 if(optionraddiv) PaintRadialDivisions(kTRUE);; 365 else PaintRadialDivisions(kFALSE);; 366 if(optionpoldiv) PaintPolarDivisions(optionLabels);; 367}; 368 ; 369////////////////////////////////////////////////////////////////////////////////; 370/// This is simplified from TEllipse::PaintEllipse.; 371/// Draw this ellipse with new coordinates.; 372 ; 373void TGraphPolargram::PaintCircle(Double_t x1, Double_t y1, Double_t r,; 374 Double_t phimin, Double_t phimax, Double_t theta); 375{; 376 if (!gPad) return;; 377 ; 378 Int_t i;; 379 const Int_t np = 200; // Number of point to draw circle; 380 static Double_t x[np+3], y[np+3];; 381 ; 382 // Set number of points approximatively proportional to the ellipse; 383 // circumference.; 384 ; 385 Double_t circ = TMath::Pi()*2*r*(phimax-phimin)/36;; 386 Int_t n = (Int_t)(np*circ/((gPad->GetX2()-gPad->GetX1())+; 387 (gPad->GetY2()-gPad->GetY1())));; 388 if (n < 8) n = 8;; 389 if (n > np) n = np;; 390 Double_t angle,dx,dy;; 391 Double_t dphi = (phimax-phimin)*TMath::Pi()/(180*n);; 392 Double_t ct = TMath::Cos(TMath::Pi()*theta/180);; 393 Double_t st = TMath::Sin(TMath::Pi",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:37248,Usability,simpl,simplified,37248,"hPolargram::Initvoid Init()Initialize some of the fields of TGraphPolargram.Definition TGraphPolargram.cxx:327; TGraphPolargram::fRadialTextSizeDouble_t fRadialTextSizeDefinition TGraphPolargram.h:34; TGraphPolargram::GetTickpolarSizeDouble_t GetTickpolarSize()Definition TGraphPolargram.h:79; TGraphPolargram::SetPolarOffsetvoid SetPolarOffset(Double_t PolarOffset=0.04)Set the labels offset.Definition TGraphPolargram.cxx:832; TGraphPolargram::fGradBool_t fGradDefinition TGraphPolargram.h:25; TGraphPolargram::SetTwoPivoid SetTwoPi()Set range from 0 to 2*pi.Definition TGraphPolargram.cxx:947; TGraphPolargram::FindTextAngleDouble_t FindTextAngle(Double_t theta)Determine the orientation of the polar labels according to their angle.Definition TGraphPolargram.cxx:307; TGraphPolargram::SetRadialLabelColorvoid SetRadialLabelColor(Color_t tcolorradial=1)Set radial labels color.Definition TGraphPolargram.cxx:841; TGraphPolargram::PaintCirclevoid PaintCircle(Double_t x, Double_t y, Double_t r, Double_t phimin, Double_t phimax, Double_t theta)This is simplified from TEllipse::PaintEllipse.Definition TGraphPolargram.cxx:373; TGraphPolargram::SetRangeRadialvoid SetRangeRadial(Double_t rmin, Double_t rmax)Set the radial range.Definition TGraphPolargram.cxx:894; TGraphPolargram::fRadianBool_t fRadianDefinition TGraphPolargram.h:23; TGraphPolargram::SetTickpolarSizevoid SetTickpolarSize(Double_t tickpolarsize=0.02)Set polar ticks size.Definition TGraphPolargram.cxx:906; TGraphPolargram::SetAxisAnglevoid SetAxisAngle(Double_t angle=0)Set axis angle.Definition TGraphPolargram.cxx:765; TGraphPolargram::SetToDegreevoid SetToDegree()The Polar circle is labelled using degree.Definition TGraphPolargram.cxx:914; TGraphPolargram::SetNdivPolarvoid SetNdivPolar(Int_t Ndiv=508)Set the number of Polar divisions: enter a number ij with 0<i<99 and 0<j<99.Definition TGraphPolargram.cxx:775; TGraphPolargram::fNdivRadInt_t fNdivRadNumber of radial divisions.Definition TGraphPolargram.h:46; TGraphPolar",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
https://root.cern/doc/master/TGraphPolar_8cxx_source.html:784,Availability,error,error,784,". ROOT: graf2d/graf/src/TGraphPolar.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphPolar.cxx. Go to the documentation of this file. 1// @(#)root/graf:$Id$; 2// Author: Sebastian Boser, Mathieu Demaret 02/02/06; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TGraphPolar; 13\ingroup BasicGraphics; 14 ; 15To draw a polar graph.; 16 ; 17TGraphPolar creates a polar graph (including error bars). A TGraphPolar is; 18a TGraphErrors represented in polar coordinates.; 19It uses the class TGraphPolargram to draw the polar axis.; 20 ; 21Example:; 22 ; 23Begin_Macro(source); 24{; 25 TCanvas * CPol = new TCanvas(""CPol"",""TGraphPolar Example"",500,500);; 26 ; 27 Double_t theta[8];; 28 Double_t radius[8];; 29 Double_t etheta[8];; 30 Double_t eradius[8];; 31 ; 32 for (int i=0; i<8; i++) {; 33 theta[i] = (i+1)*(TMath::Pi()/4.);; 34 radius[i] = (i+1)*0.05;; 35 etheta[i] = TMath::Pi()/8.;; 36 eradius[i] = 0.05;; 37 }; 38 ; 39 TGraphPolar * grP1 = new TGraphPolar(8, theta, radius, etheta, eradius);; 40 grP1->SetTitle(""TGraphPolar Example"");; 41 ; 42 grP1->SetMarkerStyle(20);; 43 grP1->SetMarkerSize(2.);; 44 grP1->SetMarkerColor(4);; 45 grP1->SetLineColor(2);; 46 grP1->SetLineWidth(3);; 47 grP1->Draw(""PE"");; 48 ; 49 // Update, otherwise GetPolargram returns 0; 50 CPol->Update();; 51 grP1->GetPolargram()->SetToRadian();; 52 ; 53 return CPol;; 54}; 55End_Macro; 56*/; 57 ; 58#include ""TGraphPolar.h""; 59#include ""TGraphPolargram.h""; 60 ; 61ClassImp(TGraphPolar);; 62 ; 63////////////////////////////////////////////////////////////////////////////////; 64/// TGraphPolar default constructor.; 65 ; 66T",MatchSource.WIKI,doc/master/TGraphPolar_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolar_8cxx_source.html
https://root.cern/doc/master/TGraphPolar_8cxx_source.html:2395,Availability,error,errors,2395,"; 40 grP1->SetTitle(""TGraphPolar Example"");; 41 ; 42 grP1->SetMarkerStyle(20);; 43 grP1->SetMarkerSize(2.);; 44 grP1->SetMarkerColor(4);; 45 grP1->SetLineColor(2);; 46 grP1->SetLineWidth(3);; 47 grP1->Draw(""PE"");; 48 ; 49 // Update, otherwise GetPolargram returns 0; 50 CPol->Update();; 51 grP1->GetPolargram()->SetToRadian();; 52 ; 53 return CPol;; 54}; 55End_Macro; 56*/; 57 ; 58#include ""TGraphPolar.h""; 59#include ""TGraphPolargram.h""; 60 ; 61ClassImp(TGraphPolar);; 62 ; 63////////////////////////////////////////////////////////////////////////////////; 64/// TGraphPolar default constructor.; 65 ; 66TGraphPolar::TGraphPolar() : TGraphErrors(),; 67 fOptionAxis(kFALSE),fPolargram(nullptr),fXpol(nullptr),fYpol(nullptr); 68{; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// TGraphPolar constructor.; 73///; 74/// \param[in] n number of points.; 75/// \param[in] theta angular values.; 76/// \param[in] r radial values.; 77/// \param[in] etheta errors on angular values.; 78/// \param[in] er errors on radial values.; 79 ; 80TGraphPolar::TGraphPolar(Int_t n, const Double_t* theta, const Double_t* r,; 81 const Double_t *etheta, const Double_t* er); 82 : TGraphErrors(n,theta,r,etheta,er),; 83 fOptionAxis(kFALSE),fPolargram(nullptr),fXpol(nullptr),fYpol(nullptr); 84{; 85 SetEditable(kFALSE);; 86}; 87 ; 88////////////////////////////////////////////////////////////////////////////////; 89/// TGraphPolar destructor.; 90 ; 91TGraphPolar::~TGraphPolar(); 92{; 93 delete [] fXpol;; 94 delete [] fYpol;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Draw TGraphPolar.; 99 ; 100void TGraphPolar::Draw(Option_t* options); 101{; 102 // Process options; 103 TString opt = options;; 104 opt.ToUpper();; 105 ; 106 // Ignore same; 107 opt.ReplaceAll(""SAME"","""");; 108 ; 109 // ReDraw polargram if required by options; 110 if (opt.Contains(""A"")) fOptionAxis = kTRUE;; 111 opt.ReplaceAll(""A"","""");; 112 ",MatchSource.WIKI,doc/master/TGraphPolar_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolar_8cxx_source.html
https://root.cern/doc/master/TGraphPolar_8cxx_source.html:2442,Availability,error,errors,2442," 42 grP1->SetMarkerStyle(20);; 43 grP1->SetMarkerSize(2.);; 44 grP1->SetMarkerColor(4);; 45 grP1->SetLineColor(2);; 46 grP1->SetLineWidth(3);; 47 grP1->Draw(""PE"");; 48 ; 49 // Update, otherwise GetPolargram returns 0; 50 CPol->Update();; 51 grP1->GetPolargram()->SetToRadian();; 52 ; 53 return CPol;; 54}; 55End_Macro; 56*/; 57 ; 58#include ""TGraphPolar.h""; 59#include ""TGraphPolargram.h""; 60 ; 61ClassImp(TGraphPolar);; 62 ; 63////////////////////////////////////////////////////////////////////////////////; 64/// TGraphPolar default constructor.; 65 ; 66TGraphPolar::TGraphPolar() : TGraphErrors(),; 67 fOptionAxis(kFALSE),fPolargram(nullptr),fXpol(nullptr),fYpol(nullptr); 68{; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// TGraphPolar constructor.; 73///; 74/// \param[in] n number of points.; 75/// \param[in] theta angular values.; 76/// \param[in] r radial values.; 77/// \param[in] etheta errors on angular values.; 78/// \param[in] er errors on radial values.; 79 ; 80TGraphPolar::TGraphPolar(Int_t n, const Double_t* theta, const Double_t* r,; 81 const Double_t *etheta, const Double_t* er); 82 : TGraphErrors(n,theta,r,etheta,er),; 83 fOptionAxis(kFALSE),fPolargram(nullptr),fXpol(nullptr),fYpol(nullptr); 84{; 85 SetEditable(kFALSE);; 86}; 87 ; 88////////////////////////////////////////////////////////////////////////////////; 89/// TGraphPolar destructor.; 90 ; 91TGraphPolar::~TGraphPolar(); 92{; 93 delete [] fXpol;; 94 delete [] fYpol;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Draw TGraphPolar.; 99 ; 100void TGraphPolar::Draw(Option_t* options); 101{; 102 // Process options; 103 TString opt = options;; 104 opt.ToUpper();; 105 ; 106 // Ignore same; 107 opt.ReplaceAll(""SAME"","""");; 108 ; 109 // ReDraw polargram if required by options; 110 if (opt.Contains(""A"")) fOptionAxis = kTRUE;; 111 opt.ReplaceAll(""A"","""");; 112 ; 113 AppendPad(opt);; 114}; 115 ; 116//////////",MatchSource.WIKI,doc/master/TGraphPolar_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolar_8cxx_source.html
https://root.cern/doc/master/TGraphPolar_8cxx_source.html:5673,Availability,error,error,5673,"nimum Polar.; 153 ; 154void TGraphPolar::SetMinPolar(Double_t minimum); 155{; 156 if (fPolargram) fPolargram->ChangeRangePolar(minimum, fPolargram->GetTMax());; 157}; 158 ; 159////////////////////////////////////////////////////////////////////////////////; 160/// Set minimum radial in the center of the circle.; 161 ; 162void TGraphPolar::SetMinRadial(Double_t minimum); 163{; 164 if (fPolargram) fPolargram->SetRangeRadial(minimum, fPolargram->GetRMax());; 165}; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TGraphPolar.h; TGraphPolargram.h; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphPolarTo draw a polar graph.Definition TGraphPolar.h:23; TGraphPolar::SetMinRadialvoid SetMinRadial(Double_t minimum=0)Set minimum radial in the center of the circle.Definition TGraphPolar.cxx:162; TGraphPolar::fOptionAxisBool_t fOptionAxisForce drawing of new coord system.Definition TGraphPolar.h:26; TGraphPolar::fXpolDouble_t * fXpol[fNpoints] points in polar coordinatesDefinition TGraphPolar.h:30; TGraphPolar::SetMaxPolarvoid SetMaxPolar(Double_t maximum=6.28318530717958623)Set maximum Polar.Definition TGraphPolar.cxx:137; TGraphPolar::GetYpolDouble_t * GetYpol()Return points in polar coordinates.Definition TGraphPolar.cxx:128; TGraphPolar::fPolargramTGraphPolargram * fPolargramThe polar coordinates system.Definition TGraphPolar.h:29; TGraphPolar::SetMaxRadialvoid SetMaxRadial(Double_t maximum=1)Set maximum radial at the intersection of the positive X axis part and the circle.Definition TGraphPolar.cxx:146; TGraphPolar:",MatchSource.WIKI,doc/master/TGraphPolar_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolar_8cxx_source.html
https://root.cern/doc/master/TGraphPolar_8h_source.html:2784,Availability,error,error,2784,"e_t minimum = 0) override {SetMinRadial(minimum);}; 47 void SetMaxPolar(Double_t maximum = 6.28318530717958623); //*MENU*; 48 void SetMinPolar(Double_t minimum = 0); //*MENU*; 49 void SetOptionAxis(Bool_t opt) {fOptionAxis = opt;}; 50 void SetPolargram(TGraphPolargram *p) {fPolargram = p;}; 51 Double_t *GetXpol();; 52 Double_t *GetYpol();; 53 ; 54 ClassDefOverride(TGraphPolar,1); // Polar graph; 55};; 56 ; 57#endif; Double_tdouble Double_tDefinition RtypesCore.h:59; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TGraphErrors.h; TGraphPolargram.h; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphPolarTo draw a polar graph.Definition TGraphPolar.h:23; TGraphPolar::SetMaximumvoid SetMaximum(Double_t maximum=1) overrideSet the maximum of the graph.Definition TGraphPolar.h:45; TGraphPolar::SetMinRadialvoid SetMinRadial(Double_t minimum=0)Set minimum radial in the center of the circle.Definition TGraphPolar.cxx:162; TGraphPolar::fOptionAxisBool_t fOptionAxisForce drawing of new coord system.Definition TGraphPolar.h:26; TGraphPolar::fXpolDouble_t * fXpol[fNpoints] points in polar coordinatesDefinition TGraphPolar.h:30; TGraphPolar::SetMaxPolarvoid SetMaxPolar(Double_t maximum=6.28318530717958623)Set maximum Polar.Definition TGraphPolar.cxx:137; TGraphPolar::GetYpolDouble_t * GetYpol()Return points in polar coordinates.Definition TGraphPolar.cxx:128; TGraphPolar::fPolargramTGraphPolargram * fPolargramThe polar coordinates system.Definition TGraphPolar.h:29; TGraphPolar::GetPolargramTGraphPolargram * GetPolargram()Defini",MatchSource.WIKI,doc/master/TGraphPolar_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolar_8h_source.html
https://root.cern/doc/master/TGraphQQ_8cxx_source.html:1383,Availability,robust,robust,1383,"ed. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TGraphQQ.h""; 13#include ""TAxis.h""; 14#include ""TF1.h""; 15#include ""TMath.h""; 16 ; 17ClassImp(TGraphQQ);; 18 ; 19/** \class TGraphQQ; 20\ingroup BasicGraphics; 21 ; 22This class allows to draw quantile-quantile plots; 23 ; 24Plots can be drawn for 2 datasets or for a dataset and a theoretical; 25distribution function; 26 ; 27## 2 datasets:; 28 Quantile-quantile plots are used to determine whether 2 samples come from; 29 the same distribution.; 30 A qq-plot draws the quantiles of one dataset against the quantile of the; 31 the other. The quantiles of the dataset with fewer entries are on Y axis,; 32 with more entries - on X axis.; 33 A straight line, going through 0.25 and 0.75 quantiles is also plotted; 34 for reference. It represents a robust linear fit, not sensitive to the; 35 extremes of the datasets.; 36 If the datasets come from the same distribution, points of the plot should; 37 fall approximately on the 45 degrees line. If they have the same; 38 distribution function, but location or scale different parameters,; 39 they should still fall on the straight line, but not the 45 degrees one.; 40 The greater their departure from the straight line, the more evidence there; 41 is, that the datasets come from different distributions.; 42 The advantage of qq-plot is that it not only shows that the underlying; 43 distributions are different, but, unlike the analytical methods, it also; 44 gives information on the nature of this difference: heavier tails,; 45 different location/scale, different shape, etc.; 46 ; 47 Some examples of qqplots of 2 datasets:; 48 ; 49\image html graf_graphqq1.png; 50 ; 51## 1 dataset:; 52 Quantile-quantile plots are used to determine if the dataset comes from the; 53 specified theoretical distribution, such as normal.",MatchSource.WIKI,doc/master/TGraphQQ_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphQQ_8cxx_source.html
https://root.cern/doc/master/TGraphQQ_8cxx_source.html:2688,Availability,robust,robust,2688,"t line, but not the 45 degrees one.; 40 The greater their departure from the straight line, the more evidence there; 41 is, that the datasets come from different distributions.; 42 The advantage of qq-plot is that it not only shows that the underlying; 43 distributions are different, but, unlike the analytical methods, it also; 44 gives information on the nature of this difference: heavier tails,; 45 different location/scale, different shape, etc.; 46 ; 47 Some examples of qqplots of 2 datasets:; 48 ; 49\image html graf_graphqq1.png; 50 ; 51## 1 dataset:; 52 Quantile-quantile plots are used to determine if the dataset comes from the; 53 specified theoretical distribution, such as normal.; 54 A qq-plot draws quantiles of the dataset against quantiles of the specified; 55 theoretical distribution.; 56 (NOTE, that density, not CDF should be specified); 57 A straight line, going through 0.25 and 0.75 quantiles can also be plotted; 58 for reference. It represents a robust linear fit, not sensitive to the; 59 extremes of the dataset.; 60 As in the 2 datasets case, departures from straight line indicate departures; 61 from the specified distribution.; 62 ; 63 ""The correlation coefficient associated with the linear fit to the data; 64 in the probability plot (qq plot in our case) is a measure of the; 65 goodness of the fit.; 66 Estimates of the location and scale parameters of the distribution; 67 are given by the intercept and slope. Probability plots can be generated; 68 for several competing distributions to see which provides the best fit,; 69 and the probability plot generating the highest correlation coefficient; 70 is the best choice since it generates the straightest probability plot.""; 71 ; 72 From ""Engineering statistic handbook"",; 73 ; 74 http://www.itl.nist.gov/div898/handbook/eda/section3/probplot.htm; 75 ; 76 Example of a qq-plot of a dataset from N(3, 2) distribution and; 77 TMath::Gaus(0, 1) theoretical function. Fitting parameters; 78 are estimates of the di",MatchSource.WIKI,doc/master/TGraphQQ_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphQQ_8cxx_source.html
https://root.cern/doc/master/TGraphQQ_8cxx_source.html:12778,Availability,down,down,12778,"nate of the interquartile lineDefinition TGraphQQ.h:24; TGraphQQ::MakeQuantilesvoid MakeQuantiles()When sample sizes are not equal, computes quantiles of the bigger sample by linear interpolation.Definition TGraphQQ.cxx:215; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::fNpointsInt_t fNpointsNumber of points <= fMaxSize.Definition TGraph.h:46; TGraph::fYDouble_t * fY[fNpoints] array of Y pointsDefinition TGraph.h:48; TGraph::CtorAllocateBool_t CtorAllocate()In constructors set fNpoints than call this method.Definition TGraph.cxx:805; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TStringBasic string class.Definition TString.h:139; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::FloorNintInt_t FloorNint(Double_t x)Returns the nearest integer of TMath::Floor(x).Definition TMath.h:686; TMath::NormQuantileDouble_t NormQuantile(Double_t p)Computes quantiles for standard normal distribution N(0, 1) at probability p.Definition TMath.cxx:2456; TMath::Quantilesvoid Quantiles(Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7)Computes sample quantiles, corresponding to the given probabilities.Definition TMath.cxx:1207; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431. graf2dgrafsrcTGraphQQ.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphQQ_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphQQ_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:16206,Availability,error,error,16206,"!format_.IsDigit()) {; 483 Error(""TGraph"", ""Incorrect input format! Allowed formats are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 484 return;; 485 }; 486 Int_t ntokens = format_.Length() ;; 487 if (ntokens < 2) {; 488 Error(""TGraph"", ""Incorrect input format! Only %d tag(s) in format whereas 2 \""%%lg\"" tags are expected!"", ntokens);; 489 return;; 490 }; 491 Int_t ntokensToBeSaved = 0 ;; 492 Bool_t * isTokenToBeSaved = new Bool_t [ntokens] ;; 493 for (Int_t idx = 0; idx < ntokens; idx++) {; 494 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi() ; //atoi(&format_[idx]) does not work for some reason...; 495 if (isTokenToBeSaved[idx] == 1) {; 496 ntokensToBeSaved++ ;; 497 }; 498 }; 499 if (ntokens >= 2 && ntokensToBeSaved != 2) { //first condition not to repeat the previous error message; 500 Error(""TGraph"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2 and only 2 are expected!"", ntokensToBeSaved);; 501 delete [] isTokenToBeSaved ;; 502 return;; 503 }; 504 ; 505 // Initializing loop variables; 506 Bool_t isLineToBeSkipped = kFALSE ; //empty and ill-formed lines; 507 char * token = nullptr ;; 508 TString token_str = """" ;; 509 Int_t token_idx = 0 ;; 510 Double_t * value = new Double_t [2] ; //x,y buffers; 511 Int_t value_idx = 0 ;; 512 ; 513 // Looping; 514 char *rest;; 515 while (std::getline(infile, line, '\n')) {; 516 if (!line.empty()) {; 517 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 518 line.erase(line.end() - 1, line.end()) ;; 519 }; 520 //token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, rest);; 521 token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, &rest);; 522 while (token != nullptr && value_idx < 2) {; 523 if (isTokenToBeSaved[token_idx]) {; 524 token_str = TString(token) ;; 525 token_str.ReplaceAll(""\t"", """") ;; 526 if (!token_str.IsFloat()) {; 527 isLineToBeSkipped = kTRUE ;; 528 break ;; 529 } else {; 530 value[value_idx] = token_str.Atof() ;; 531 value_idx++ ;; 532 }; 53",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:21551,Availability,error,errors,21551,"(Int_t i = 0; i < fNpoints; i++) {; 643 fY[i] = f->Eval(fX[i], fY[i]);; 644 }; 645 if (gPad) gPad->Modified();; 646}; 647 ; 648////////////////////////////////////////////////////////////////////////////////; 649/// Browse; 650 ; 651void TGraph::Browse(TBrowser *b); 652{; 653 TString opt = gEnv->GetValue(""TGraph.BrowseOption"", """");; 654 if (opt.IsNull()) {; 655 opt = b ? b->GetDrawOption() : ""alp"";; 656 opt = (opt == """") ? ""alp"" : opt.Data();; 657 }; 658 Draw(opt.Data());; 659 gPad->Update();; 660}; 661 ; 662////////////////////////////////////////////////////////////////////////////////; 663/// Return the chisquare of this graph with respect to f1.; 664/// The chisquare is computed as the sum of the quantity below at each point:; 665/// \f[; 666/// \frac{(y-f1(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f1'(x))^{2}}; 667/// \f]; 668/// where x and y are the graph point coordinates and f1'(x) is the derivative of function f1(x).; 669/// This method to approximate the uncertainty in y because of the errors in x, is called; 670/// ""effective variance"" method.; 671/// In case of a pure TGraph, the denominator is 1.; 672/// In case of a TGraphErrors or TGraphAsymmErrors the errors are taken; 673/// into account.; 674/// By default the range of the graph is used whatever function range.; 675/// Use option ""R"" to use the function range; 676 ; 677Double_t TGraph::Chisquare(TF1 *func, Option_t * option) const; 678{; 679 if (!func) {; 680 Error(""Chisquare"",""Function pointer is Null - return -1"");; 681 return -1;; 682 }; 683 ; 684 TString opt(option); opt.ToUpper();; 685 bool useRange = opt.Contains(""R"");; 686 ; 687 return ROOT::Fit::Chisquare(*this, *func,useRange);; 688}; 689 ; 690////////////////////////////////////////////////////////////////////////////////; 691/// Return kTRUE if point number ""left""'s argument (angle with respect to positive; 692/// x-axis) is bigger than that of point number ""right"". Can be used by Sort.; 693 ; 694Bool_t TGraph::CompareArg(const TGraph* gr, In",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:21726,Availability,error,errors,21726,"////////////////////////////////////; 649/// Browse; 650 ; 651void TGraph::Browse(TBrowser *b); 652{; 653 TString opt = gEnv->GetValue(""TGraph.BrowseOption"", """");; 654 if (opt.IsNull()) {; 655 opt = b ? b->GetDrawOption() : ""alp"";; 656 opt = (opt == """") ? ""alp"" : opt.Data();; 657 }; 658 Draw(opt.Data());; 659 gPad->Update();; 660}; 661 ; 662////////////////////////////////////////////////////////////////////////////////; 663/// Return the chisquare of this graph with respect to f1.; 664/// The chisquare is computed as the sum of the quantity below at each point:; 665/// \f[; 666/// \frac{(y-f1(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f1'(x))^{2}}; 667/// \f]; 668/// where x and y are the graph point coordinates and f1'(x) is the derivative of function f1(x).; 669/// This method to approximate the uncertainty in y because of the errors in x, is called; 670/// ""effective variance"" method.; 671/// In case of a pure TGraph, the denominator is 1.; 672/// In case of a TGraphErrors or TGraphAsymmErrors the errors are taken; 673/// into account.; 674/// By default the range of the graph is used whatever function range.; 675/// Use option ""R"" to use the function range; 676 ; 677Double_t TGraph::Chisquare(TF1 *func, Option_t * option) const; 678{; 679 if (!func) {; 680 Error(""Chisquare"",""Function pointer is Null - return -1"");; 681 return -1;; 682 }; 683 ; 684 TString opt(option); opt.ToUpper();; 685 bool useRange = opt.Contains(""R"");; 686 ; 687 return ROOT::Fit::Chisquare(*this, *func,useRange);; 688}; 689 ; 690////////////////////////////////////////////////////////////////////////////////; 691/// Return kTRUE if point number ""left""'s argument (angle with respect to positive; 692/// x-axis) is bigger than that of point number ""right"". Can be used by Sort.; 693 ; 694Bool_t TGraph::CompareArg(const TGraph* gr, Int_t left, Int_t right); 695{; 696 Double_t xl = 0, yl = 0, xr = 0, yr = 0;; 697 gr->GetPoint(left, xl, yl);; 698 gr->GetPoint(right, xr, yr);; 699 return (TMath::ATan2(yl",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:38329,Availability,error,errors,38329,"(obj) : nullptr;; 1122}; 1123 ; 1124////////////////////////////////////////////////////////////////////////////////; 1125/// Fit this graph with function f1.; 1126///; 1127/// \param[in] f1 pointer to the function object; 1128/// \param[in] option string defining the fit options (see table below).; 1129/// \param[in] goption specify a list of graphics options. See TGraph::Draw and TGraphPainter for a complete list of these possible options.; 1130/// \param[in] rxmin lower fitting range; 1131/// \param[in] rxmax upper fitting range; 1132///; 1133/// \anchor GFitOpt; 1134/// ### Graph Fitting Options; 1135/// The list of fit options is given in parameter option.; 1136///; 1137/// option | description; 1138/// -------|------------; 1139/// ""S"" | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT::Math::FitResult`.; 1140/// ""W"" | Ignore all point errors when fitting a TGraphErrors or TGraphAsymmErrors; 1141/// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; 1142/// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; 1143/// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; 1144/// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; 1145/// ""Q"" | Quiet mode (minimum printing); 1146/// ""V"" | Verbose mode (default is between Q and V); 1147/// ""+"" | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.; 1148/// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; 1149/// ""0"" | Does not draw the histogram and the fitted function after fi",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:38692,Availability,error,errors,38692,"9/// \param[in] goption specify a list of graphics options. See TGraph::Draw and TGraphPainter for a complete list of these possible options.; 1130/// \param[in] rxmin lower fitting range; 1131/// \param[in] rxmax upper fitting range; 1132///; 1133/// \anchor GFitOpt; 1134/// ### Graph Fitting Options; 1135/// The list of fit options is given in parameter option.; 1136///; 1137/// option | description; 1138/// -------|------------; 1139/// ""S"" | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT::Math::FitResult`.; 1140/// ""W"" | Ignore all point errors when fitting a TGraphErrors or TGraphAsymmErrors; 1141/// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; 1142/// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; 1143/// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; 1144/// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; 1145/// ""Q"" | Quiet mode (minimum printing); 1146/// ""V"" | Verbose mode (default is between Q and V); 1147/// ""+"" | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.; 1148/// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; 1149/// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; 1150/// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; 1151/// ""B"" | Use this option when you want to fix one or more parameters and the fitting function is a ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:38803,Availability,avail,available,38803,"sible options.; 1130/// \param[in] rxmin lower fitting range; 1131/// \param[in] rxmax upper fitting range; 1132///; 1133/// \anchor GFitOpt; 1134/// ### Graph Fitting Options; 1135/// The list of fit options is given in parameter option.; 1136///; 1137/// option | description; 1138/// -------|------------; 1139/// ""S"" | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT::Math::FitResult`.; 1140/// ""W"" | Ignore all point errors when fitting a TGraphErrors or TGraphAsymmErrors; 1141/// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; 1142/// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; 1143/// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; 1144/// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; 1145/// ""Q"" | Quiet mode (minimum printing); 1146/// ""V"" | Verbose mode (default is between Q and V); 1147/// ""+"" | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.; 1148/// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; 1149/// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; 1150/// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; 1151/// ""B"" | Use this option when you want to fix one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits are set.;",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:40151,Availability,error,errors,40151," graphics function, does not draw the histogram with the function after fitting.; 1149/// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; 1150/// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; 1151/// ""B"" | Use this option when you want to fix one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits are set.; 1152/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 1153/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 1154/// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; 1155/// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; 1156///; 1157///; 1158/// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; 1159/// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; 1160///; 1161/// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the cor",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:40264,Availability,robust,robust,40264," graphics function, does not draw the histogram with the function after fitting.; 1149/// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; 1150/// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; 1151/// ""B"" | Use this option when you want to fix one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits are set.; 1152/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 1153/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 1154/// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; 1155/// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; 1156///; 1157///; 1158/// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; 1159/// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; 1160///; 1161/// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the cor",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:40605,Availability,error,errors,40605," or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits are set.; 1152/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 1153/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 1154/// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; 1155/// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; 1156///; 1157///; 1158/// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; 1159/// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; 1160///; 1161/// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; 1171/// The chi-square is then computed as the sum of the quantity below at each data point:; 1172///; 1173/// \f[; 1174/// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; 1175/// \f]; 1176///; 1177/// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; 1178/// function `f(x)`.; 1179///; 1180/// In case of asymmetric errors, ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:40751,Availability,error,error,40751,"its are set.; 1152/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 1153/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 1154/// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; 1155/// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; 1156///; 1157///; 1158/// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; 1159/// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; 1160///; 1161/// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; 1171/// The chi-square is then computed as the sum of the quantity below at each data point:; 1172///; 1173/// \f[; 1174/// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; 1175/// \f]; 1176///; 1177/// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; 1178/// function `f(x)`.; 1179///; 1180/// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; 1181///; 1182/// The approach used to approximate the uncertainty in y because of ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:41005,Availability,error,errors,41005,"e provided TF1 function.; 1154/// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; 1155/// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; 1156///; 1157///; 1158/// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; 1159/// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; 1160///; 1161/// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; 1171/// The chi-square is then computed as the sum of the quantity below at each data point:; 1172///; 1173/// \f[; 1174/// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; 1175/// \f]; 1176///; 1177/// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; 1178/// function `f(x)`.; 1179///; 1180/// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; 1181///; 1182/// The approach used to approximate the uncertainty in y because of the; 1183/// errors in x is to make it equal the error in x times the slope of the line.; 1184/// This approach is called ""effective variance method"" and; 1185/// the implementation is provided in the function FitUtil::EvaluateChi2Effective; 1186///; 1187/// \anch",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:41029,Availability,error,error,41029,"e provided TF1 function.; 1154/// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; 1155/// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; 1156///; 1157///; 1158/// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; 1159/// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; 1160///; 1161/// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; 1171/// The chi-square is then computed as the sum of the quantity below at each data point:; 1172///; 1173/// \f[; 1174/// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; 1175/// \f]; 1176///; 1177/// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; 1178/// function `f(x)`.; 1179///; 1180/// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; 1181///; 1182/// The approach used to approximate the uncertainty in y because of the; 1183/// errors in x is to make it equal the error in x times the slope of the line.; 1184/// This approach is called ""effective variance method"" and; 1185/// the implementation is provided in the function FitUtil::EvaluateChi2Effective; 1186///; 1187/// \anch",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:41234,Availability,error,error,41234,"e provided TF1 function.; 1154/// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; 1155/// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; 1156///; 1157///; 1158/// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; 1159/// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; 1160///; 1161/// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; 1171/// The chi-square is then computed as the sum of the quantity below at each data point:; 1172///; 1173/// \f[; 1174/// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; 1175/// \f]; 1176///; 1177/// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; 1178/// function `f(x)`.; 1179///; 1180/// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; 1181///; 1182/// The approach used to approximate the uncertainty in y because of the; 1183/// errors in x is to make it equal the error in x times the slope of the line.; 1184/// This approach is called ""effective variance method"" and; 1185/// the implementation is provided in the function FitUtil::EvaluateChi2Effective; 1186///; 1187/// \anch",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:41610,Availability,error,errors,41610," a TGraphErrors or TGraphAsymmErrors.; 1160///; 1161/// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; 1171/// The chi-square is then computed as the sum of the quantity below at each data point:; 1172///; 1173/// \f[; 1174/// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; 1175/// \f]; 1176///; 1177/// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; 1178/// function `f(x)`.; 1179///; 1180/// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; 1181///; 1182/// The approach used to approximate the uncertainty in y because of the; 1183/// errors in x is to make it equal the error in x times the slope of the line.; 1184/// This approach is called ""effective variance method"" and; 1185/// the implementation is provided in the function FitUtil::EvaluateChi2Effective; 1186///; 1187/// \anchor GFitLinear; 1188/// ### Linear fitting:; 1189/// When the fitting function is linear (contains the `++` sign) or the fitting; 1190/// function is a polynomial, a linear fitter is initialised.; 1191/// To create a linear function, use the following syntax: linear parts; 1192/// separated by `++` sign.; 1193/// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; 1194/// TF1 object as; 1195///; 1196/// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; 1197///; 1198/// For such a TF1 you don't have to set the initial conditions and the linear fitter",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:41795,Availability,error,errors,41795,"ing the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; 1171/// The chi-square is then computed as the sum of the quantity below at each data point:; 1172///; 1173/// \f[; 1174/// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; 1175/// \f]; 1176///; 1177/// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; 1178/// function `f(x)`.; 1179///; 1180/// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; 1181///; 1182/// The approach used to approximate the uncertainty in y because of the; 1183/// errors in x is to make it equal the error in x times the slope of the line.; 1184/// This approach is called ""effective variance method"" and; 1185/// the implementation is provided in the function FitUtil::EvaluateChi2Effective; 1186///; 1187/// \anchor GFitLinear; 1188/// ### Linear fitting:; 1189/// When the fitting function is linear (contains the `++` sign) or the fitting; 1190/// function is a polynomial, a linear fitter is initialised.; 1191/// To create a linear function, use the following syntax: linear parts; 1192/// separated by `++` sign.; 1193/// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; 1194/// TF1 object as; 1195///; 1196/// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; 1197///; 1198/// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; 1199/// Going via the linear fitter for functions, linear in parameters, gives a; 1200/// considerable advantage in speed.; 1201/// When us",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:41831,Availability,error,error,41831,"ing the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; 1171/// The chi-square is then computed as the sum of the quantity below at each data point:; 1172///; 1173/// \f[; 1174/// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; 1175/// \f]; 1176///; 1177/// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; 1178/// function `f(x)`.; 1179///; 1180/// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; 1181///; 1182/// The approach used to approximate the uncertainty in y because of the; 1183/// errors in x is to make it equal the error in x times the slope of the line.; 1184/// This approach is called ""effective variance method"" and; 1185/// the implementation is provided in the function FitUtil::EvaluateChi2Effective; 1186///; 1187/// \anchor GFitLinear; 1188/// ### Linear fitting:; 1189/// When the fitting function is linear (contains the `++` sign) or the fitting; 1190/// function is a polynomial, a linear fitter is initialised.; 1191/// To create a linear function, use the following syntax: linear parts; 1192/// separated by `++` sign.; 1193/// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; 1194/// TF1 object as; 1195///; 1196/// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; 1197///; 1198/// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; 1199/// Going via the linear fitter for functions, linear in parameters, gives a; 1200/// considerable advantage in speed.; 1201/// When us",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:42840,Availability,robust,robust,42840,"f the line.; 1184/// This approach is called ""effective variance method"" and; 1185/// the implementation is provided in the function FitUtil::EvaluateChi2Effective; 1186///; 1187/// \anchor GFitLinear; 1188/// ### Linear fitting:; 1189/// When the fitting function is linear (contains the `++` sign) or the fitting; 1190/// function is a polynomial, a linear fitter is initialised.; 1191/// To create a linear function, use the following syntax: linear parts; 1192/// separated by `++` sign.; 1193/// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; 1194/// TF1 object as; 1195///; 1196/// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; 1197///; 1198/// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; 1199/// Going via the linear fitter for functions, linear in parameters, gives a; 1200/// considerable advantage in speed.; 1201/// When using the linear fitting it is also possible to perform a robust fitting with the; 1202/// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; 1203/// See the tutorial `fitLinearRobust.C`.; 1204///; 1205/// ### Notes on TGraph/TGraphErrors Fitting:; 1206///; 1207/// 1. By using the ""effective variance"" method a simple linear regression; 1208/// becomes a non-linear case, which takes several iterations; 1209/// instead of 0 as in the linear case.; 1210/// 2. The effective variance technique assumes that there is no correlation; 1211/// between the x and y coordinate.; 1212/// 3. The standard chi2 (least square) method without error in the coordinates (x) can; 1213/// be forced by using option ""EX0""; 1214/// 4. The linear fitter doesn't take into account the errors in x. When fitting a; 1215/// TGraphErrors with a linear functions the errors in x will not be considered.; 1216/// If errors in x are important, use option ""F"" for linear function fitting.; 1217/// 5. When fitting a TGraph (i.e. no errors associated with each point),; 1218/",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:43444,Availability,error,error,43444,"t as; 1195///; 1196/// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; 1197///; 1198/// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; 1199/// Going via the linear fitter for functions, linear in parameters, gives a; 1200/// considerable advantage in speed.; 1201/// When using the linear fitting it is also possible to perform a robust fitting with the; 1202/// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; 1203/// See the tutorial `fitLinearRobust.C`.; 1204///; 1205/// ### Notes on TGraph/TGraphErrors Fitting:; 1206///; 1207/// 1. By using the ""effective variance"" method a simple linear regression; 1208/// becomes a non-linear case, which takes several iterations; 1209/// instead of 0 as in the linear case.; 1210/// 2. The effective variance technique assumes that there is no correlation; 1211/// between the x and y coordinate.; 1212/// 3. The standard chi2 (least square) method without error in the coordinates (x) can; 1213/// be forced by using option ""EX0""; 1214/// 4. The linear fitter doesn't take into account the errors in x. When fitting a; 1215/// TGraphErrors with a linear functions the errors in x will not be considered.; 1216/// If errors in x are important, use option ""F"" for linear function fitting.; 1217/// 5. When fitting a TGraph (i.e. no errors associated with each point),; 1218/// a correction is applied to the errors on the parameters with the following; 1219/// formula:; 1220/// `parameter_error *= sqrt(chisquare/(ndf-1))`; 1221///; 1222/// ### General Fitting documentation; 1223///; 1224/// See in TH1::Fit for the documentation of; 1225/// - [Fit Result](\ref HFitRes); 1226/// - [Fit Status](\ref HFitStatus); 1227/// - [Fit Statistics Box](\ref HFitStatBox); 1228/// - [Fitting in a Range](\ref HFitRange); 1229/// - [Setting Initial Conditions](\ref HFitInitial); 1230 ; 1231TFitResultPtr TGraph::Fit(TF1 *f1, Option_t *option, Option_t *goption, Axis_t rxmin, Axis_t r",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:43578,Availability,error,errors,43578,"ch a TF1 you don't have to set the initial conditions and the linear fitter is used.; 1199/// Going via the linear fitter for functions, linear in parameters, gives a; 1200/// considerable advantage in speed.; 1201/// When using the linear fitting it is also possible to perform a robust fitting with the; 1202/// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; 1203/// See the tutorial `fitLinearRobust.C`.; 1204///; 1205/// ### Notes on TGraph/TGraphErrors Fitting:; 1206///; 1207/// 1. By using the ""effective variance"" method a simple linear regression; 1208/// becomes a non-linear case, which takes several iterations; 1209/// instead of 0 as in the linear case.; 1210/// 2. The effective variance technique assumes that there is no correlation; 1211/// between the x and y coordinate.; 1212/// 3. The standard chi2 (least square) method without error in the coordinates (x) can; 1213/// be forced by using option ""EX0""; 1214/// 4. The linear fitter doesn't take into account the errors in x. When fitting a; 1215/// TGraphErrors with a linear functions the errors in x will not be considered.; 1216/// If errors in x are important, use option ""F"" for linear function fitting.; 1217/// 5. When fitting a TGraph (i.e. no errors associated with each point),; 1218/// a correction is applied to the errors on the parameters with the following; 1219/// formula:; 1220/// `parameter_error *= sqrt(chisquare/(ndf-1))`; 1221///; 1222/// ### General Fitting documentation; 1223///; 1224/// See in TH1::Fit for the documentation of; 1225/// - [Fit Result](\ref HFitRes); 1226/// - [Fit Status](\ref HFitStatus); 1227/// - [Fit Statistics Box](\ref HFitStatBox); 1228/// - [Fitting in a Range](\ref HFitRange); 1229/// - [Setting Initial Conditions](\ref HFitInitial); 1230 ; 1231TFitResultPtr TGraph::Fit(TF1 *f1, Option_t *option, Option_t *goption, Axis_t rxmin, Axis_t rxmax); 1232{; 1233 Foption_t fitOption;; 1234 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType:",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:43656,Availability,error,errors,43656,"ed.; 1199/// Going via the linear fitter for functions, linear in parameters, gives a; 1200/// considerable advantage in speed.; 1201/// When using the linear fitting it is also possible to perform a robust fitting with the; 1202/// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; 1203/// See the tutorial `fitLinearRobust.C`.; 1204///; 1205/// ### Notes on TGraph/TGraphErrors Fitting:; 1206///; 1207/// 1. By using the ""effective variance"" method a simple linear regression; 1208/// becomes a non-linear case, which takes several iterations; 1209/// instead of 0 as in the linear case.; 1210/// 2. The effective variance technique assumes that there is no correlation; 1211/// between the x and y coordinate.; 1212/// 3. The standard chi2 (least square) method without error in the coordinates (x) can; 1213/// be forced by using option ""EX0""; 1214/// 4. The linear fitter doesn't take into account the errors in x. When fitting a; 1215/// TGraphErrors with a linear functions the errors in x will not be considered.; 1216/// If errors in x are important, use option ""F"" for linear function fitting.; 1217/// 5. When fitting a TGraph (i.e. no errors associated with each point),; 1218/// a correction is applied to the errors on the parameters with the following; 1219/// formula:; 1220/// `parameter_error *= sqrt(chisquare/(ndf-1))`; 1221///; 1222/// ### General Fitting documentation; 1223///; 1224/// See in TH1::Fit for the documentation of; 1225/// - [Fit Result](\ref HFitRes); 1226/// - [Fit Status](\ref HFitStatus); 1227/// - [Fit Statistics Box](\ref HFitStatBox); 1228/// - [Fitting in a Range](\ref HFitRange); 1229/// - [Setting Initial Conditions](\ref HFitInitial); 1230 ; 1231TFitResultPtr TGraph::Fit(TF1 *f1, Option_t *option, Option_t *goption, Axis_t rxmin, Axis_t rxmax); 1232{; 1233 Foption_t fitOption;; 1234 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph, option, fitOption);; 1235 // create range and minimizer options with def",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:43704,Availability,error,errors,43704,"// considerable advantage in speed.; 1201/// When using the linear fitting it is also possible to perform a robust fitting with the; 1202/// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; 1203/// See the tutorial `fitLinearRobust.C`.; 1204///; 1205/// ### Notes on TGraph/TGraphErrors Fitting:; 1206///; 1207/// 1. By using the ""effective variance"" method a simple linear regression; 1208/// becomes a non-linear case, which takes several iterations; 1209/// instead of 0 as in the linear case.; 1210/// 2. The effective variance technique assumes that there is no correlation; 1211/// between the x and y coordinate.; 1212/// 3. The standard chi2 (least square) method without error in the coordinates (x) can; 1213/// be forced by using option ""EX0""; 1214/// 4. The linear fitter doesn't take into account the errors in x. When fitting a; 1215/// TGraphErrors with a linear functions the errors in x will not be considered.; 1216/// If errors in x are important, use option ""F"" for linear function fitting.; 1217/// 5. When fitting a TGraph (i.e. no errors associated with each point),; 1218/// a correction is applied to the errors on the parameters with the following; 1219/// formula:; 1220/// `parameter_error *= sqrt(chisquare/(ndf-1))`; 1221///; 1222/// ### General Fitting documentation; 1223///; 1224/// See in TH1::Fit for the documentation of; 1225/// - [Fit Result](\ref HFitRes); 1226/// - [Fit Status](\ref HFitStatus); 1227/// - [Fit Statistics Box](\ref HFitStatBox); 1228/// - [Fitting in a Range](\ref HFitRange); 1229/// - [Setting Initial Conditions](\ref HFitInitial); 1230 ; 1231TFitResultPtr TGraph::Fit(TF1 *f1, Option_t *option, Option_t *goption, Axis_t rxmin, Axis_t rxmax); 1232{; 1233 Foption_t fitOption;; 1234 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph, option, fitOption);; 1235 // create range and minimizer options with default values; 1236 ROOT::Fit::DataRange range(rxmin, rxmax);; 1237 ROOT::Math::MinimizerOptio",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:43818,Availability,error,errors,43818,"tandard chi2 (least square) method without error in the coordinates (x) can; 1213/// be forced by using option ""EX0""; 1214/// 4. The linear fitter doesn't take into account the errors in x. When fitting a; 1215/// TGraphErrors with a linear functions the errors in x will not be considered.; 1216/// If errors in x are important, use option ""F"" for linear function fitting.; 1217/// 5. When fitting a TGraph (i.e. no errors associated with each point),; 1218/// a correction is applied to the errors on the parameters with the following; 1219/// formula:; 1220/// `parameter_error *= sqrt(chisquare/(ndf-1))`; 1221///; 1222/// ### General Fitting documentation; 1223///; 1224/// See in TH1::Fit for the documentation of; 1225/// - [Fit Result](\ref HFitRes); 1226/// - [Fit Status](\ref HFitStatus); 1227/// - [Fit Statistics Box](\ref HFitStatBox); 1228/// - [Fitting in a Range](\ref HFitRange); 1229/// - [Setting Initial Conditions](\ref HFitInitial); 1230 ; 1231TFitResultPtr TGraph::Fit(TF1 *f1, Option_t *option, Option_t *goption, Axis_t rxmin, Axis_t rxmax); 1232{; 1233 Foption_t fitOption;; 1234 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph, option, fitOption);; 1235 // create range and minimizer options with default values; 1236 ROOT::Fit::DataRange range(rxmin, rxmax);; 1237 ROOT::Math::MinimizerOptions minOption;; 1238 return ROOT::Fit::FitObject(this, f1 , fitOption , minOption, goption, range);; 1239}; 1240 ; 1241////////////////////////////////////////////////////////////////////////////////; 1242/// Fit this graph with function with name `fname`.; 1243///; 1244/// This is a different interface to TGraph fitting using TGraph::Fit(TF1 *f1,Option_t *, Option_t *, Axis_t, Axis_t); 1245/// See there for the details about fitting a TGraph.; 1246///; 1247/// The parameter `fname` is the name of an already predefined function created by TF1 or TF2; 1248/// Predefined functions such as gaus, expo and poln are automatically; 1249/// created by ROOT.; 1250///; 1",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:43894,Availability,error,errors,43894,"tandard chi2 (least square) method without error in the coordinates (x) can; 1213/// be forced by using option ""EX0""; 1214/// 4. The linear fitter doesn't take into account the errors in x. When fitting a; 1215/// TGraphErrors with a linear functions the errors in x will not be considered.; 1216/// If errors in x are important, use option ""F"" for linear function fitting.; 1217/// 5. When fitting a TGraph (i.e. no errors associated with each point),; 1218/// a correction is applied to the errors on the parameters with the following; 1219/// formula:; 1220/// `parameter_error *= sqrt(chisquare/(ndf-1))`; 1221///; 1222/// ### General Fitting documentation; 1223///; 1224/// See in TH1::Fit for the documentation of; 1225/// - [Fit Result](\ref HFitRes); 1226/// - [Fit Status](\ref HFitStatus); 1227/// - [Fit Statistics Box](\ref HFitStatBox); 1228/// - [Fitting in a Range](\ref HFitRange); 1229/// - [Setting Initial Conditions](\ref HFitInitial); 1230 ; 1231TFitResultPtr TGraph::Fit(TF1 *f1, Option_t *option, Option_t *goption, Axis_t rxmin, Axis_t rxmax); 1232{; 1233 Foption_t fitOption;; 1234 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph, option, fitOption);; 1235 // create range and minimizer options with default values; 1236 ROOT::Fit::DataRange range(rxmin, rxmax);; 1237 ROOT::Math::MinimizerOptions minOption;; 1238 return ROOT::Fit::FitObject(this, f1 , fitOption , minOption, goption, range);; 1239}; 1240 ; 1241////////////////////////////////////////////////////////////////////////////////; 1242/// Fit this graph with function with name `fname`.; 1243///; 1244/// This is a different interface to TGraph fitting using TGraph::Fit(TF1 *f1,Option_t *, Option_t *, Axis_t, Axis_t); 1245/// See there for the details about fitting a TGraph.; 1246///; 1247/// The parameter `fname` is the name of an already predefined function created by TF1 or TF2; 1248/// Predefined functions such as gaus, expo and poln are automatically; 1249/// created by ROOT.; 1250///; 1",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:88710,Availability,error,errors,88710,"see e.g. older glibc).; 2465/// To compare two points the function parameter greaterfunc is used (see TGraph::CompareX for an; 2466/// example of such a method, which is also the default comparison function for Sort). After; 2467/// the sort, greaterfunc(this, i, j) will return kTRUE for all i>j if ascending == kTRUE, and; 2468/// kFALSE otherwise.; 2469///; 2470/// The last two parameters are used for the recursive quick sort, stating the range to be sorted; 2471///; 2472/// Examples:; 2473/// ~~~ {.cpp}; 2474/// // sort points along x axis; 2475/// graph->Sort();; 2476/// // sort points along their distance to origin; 2477/// graph->Sort(&TGraph::CompareRadius);; 2478///; 2479/// Bool_t CompareErrors(const TGraph* gr, Int_t i, Int_t j) {; 2480/// const TGraphErrors* ge=(const TGraphErrors*)gr;; 2481/// return (ge->GetEY()[i]>ge->GetEY()[j]); }; 2482/// // sort using the above comparison function, largest errors first; 2483/// graph->Sort(&CompareErrors, kFALSE);; 2484/// ~~~; 2485 ; 2486void TGraph::Sort(Bool_t (*greaterfunc)(const TGraph *, Int_t, Int_t) /*=TGraph::CompareX()*/,; 2487 Bool_t ascending /*=kTRUE*/, Int_t low /*=0*/, Int_t high /*=-1111*/); 2488{; 2489 // set the bit in case of an ascending =sort in X; 2490 if (greaterfunc == TGraph::CompareX && ascending && low == 0 && high == -1111); 2491 SetBit(TGraph::kIsSortedX);; 2492 ; 2493 if (high == -1111); 2494 high = fNpoints - 1;; 2495 ; 2496 // Create a vector to store the indices of the graph data points.; 2497 // We use std::vector<Int_t> instead of std::vector<ULong64_t> to match the input type; 2498 // required by the comparison operator's signature provided as `greaterfunc`; 2499 std::vector<Int_t> sorting_indices(fNpoints);; 2500 std::iota(sorting_indices.begin(), sorting_indices.end(), 0);; 2501 ; 2502 // Sort the indices using the provided comparison function; 2503 // We use std::stable_sort here because the libc++ implementation of std::sort; 2504 // is not standard-compliant until LLVM 14 whi",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:89800,Availability,error,errors,89800,"; 2483/// graph->Sort(&CompareErrors, kFALSE);; 2484/// ~~~; 2485 ; 2486void TGraph::Sort(Bool_t (*greaterfunc)(const TGraph *, Int_t, Int_t) /*=TGraph::CompareX()*/,; 2487 Bool_t ascending /*=kTRUE*/, Int_t low /*=0*/, Int_t high /*=-1111*/); 2488{; 2489 // set the bit in case of an ascending =sort in X; 2490 if (greaterfunc == TGraph::CompareX && ascending && low == 0 && high == -1111); 2491 SetBit(TGraph::kIsSortedX);; 2492 ; 2493 if (high == -1111); 2494 high = fNpoints - 1;; 2495 ; 2496 // Create a vector to store the indices of the graph data points.; 2497 // We use std::vector<Int_t> instead of std::vector<ULong64_t> to match the input type; 2498 // required by the comparison operator's signature provided as `greaterfunc`; 2499 std::vector<Int_t> sorting_indices(fNpoints);; 2500 std::iota(sorting_indices.begin(), sorting_indices.end(), 0);; 2501 ; 2502 // Sort the indices using the provided comparison function; 2503 // We use std::stable_sort here because the libc++ implementation of std::sort; 2504 // is not standard-compliant until LLVM 14 which caused errors on the mac nodes; 2505 // of our CI, related issue: https://github.com/llvm/llvm-project/issues/21211; 2506 std::stable_sort(sorting_indices.begin() + low, sorting_indices.begin() + high + 1,; 2507 [&](const auto &left, const auto &right) { return greaterfunc(this, left, right) != ascending; });; 2508 ; 2509 Int_t numSortedPoints = high - low + 1;; 2510 UpdateArrays(sorting_indices, numSortedPoints, low);; 2511}; 2512 ; 2513////////////////////////////////////////////////////////////////////////////////; 2514/// Stream an object of class TGraph.; 2515 ; 2516void TGraph::Streamer(TBuffer &b); 2517{; 2518 if (b.IsReading()) {; 2519 UInt_t R__s, R__c;; 2520 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 2521 if (R__v > 2) {; 2522 b.ReadClassBuffer(TGraph::Class(), this, R__v, R__s, R__c);; 2523 if (fHistogram) fHistogram->SetDirectory(nullptr);; 2524 TIter next(fFunctions);; 2525 TObject *obj;; 2526 while",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:95144,Availability,error,error,95144,"yle());; 2630 SetLineWidth(gStyle->GetHistLineWidth());; 2631 SetMarkerColor(gStyle->GetMarkerColor());; 2632 SetMarkerStyle(gStyle->GetMarkerStyle());; 2633 SetMarkerSize(gStyle->GetMarkerSize());; 2634 } else {; 2635 gStyle->SetHistFillColor(GetFillColor());; 2636 gStyle->SetHistFillStyle(GetFillStyle());; 2637 gStyle->SetHistLineColor(GetLineColor());; 2638 gStyle->SetHistLineStyle(GetLineStyle());; 2639 gStyle->SetHistLineWidth(GetLineWidth());; 2640 gStyle->SetMarkerColor(GetMarkerColor());; 2641 gStyle->SetMarkerStyle(GetMarkerStyle());; 2642 gStyle->SetMarkerSize(GetMarkerSize());; 2643 }; 2644 if (fHistogram) fHistogram->UseCurrentStyle();; 2645 ; 2646 TIter next(GetListOfFunctions());; 2647 TObject *obj;; 2648 ; 2649 while ((obj = next())) {; 2650 obj->UseCurrentStyle();; 2651 }; 2652}; 2653 ; 2654////////////////////////////////////////////////////////////////////////////////; 2655/// Adds all graphs from the collection to this graph.; 2656/// Returns the total number of points in the result or -1 in case of an error.; 2657 ; 2658Int_t TGraph::Merge(TCollection* li); 2659{; 2660 TIter next(li);; 2661 while (TObject* o = next()) {; 2662 TGraph *g = dynamic_cast<TGraph*>(o);; 2663 if (!g) {; 2664 Error(""Merge"",; 2665 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 2666 return -1;; 2667 }; 2668 DoMerge(g);; 2669 }; 2670 return GetN();; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// protected function to perform the merge operation of a graph; 2675 ; 2676Bool_t TGraph::DoMerge(const TGraph* g); 2677{; 2678 Double_t x = 0, y = 0;; 2679 for (Int_t i = 0 ; i < g->GetN(); i++) {; 2680 g->GetPoint(i, x, y);; 2681 SetPoint(GetN(), x, y);; 2682 }; 2683 return kTRUE;; 2684}; 2685 ; 2686////////////////////////////////////////////////////////////////////////////////; 2687/// Move all graph points on specified values dx,dy; 2688/// If log argument specified, calculation done in",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:132103,Availability,error,error,132103,"t.h:199; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TSpline3Class to create third splines to interpolate knots Arbitrary conditions can be introduced for first a...Definition TSpline.h:182; TSpline3::EvalDouble_t Eval(Double_t x) const overrideEval this spline at x.Definition TSpline.cxx:786",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:139748,Availability,down,down,139748,"H1::Fit)Definition HFitImpl.cxx:972; ROOT::Fit::Chisquaredouble Chisquare(const TH1 &h1, TF1 &f1, bool useRange, EChisquareType type)compute the chi2 value for an histogram given a function (see TH1::Chisquare for the documentation)Definition HFitImpl.cxx:1027; ROOT::Fit::FitOptionsMakevoid FitOptionsMake(EFitObjectType type, const char *option, Foption_t &fitOption)Decode list of options into fitOption.Definition HFitImpl.cxx:685; ROOT::Fit::EFitObjectType::kGraph@ kGraph; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; Foption_tDefinition Foption.h:24; Drawth1 Draw(); mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. histhistsrcTGraph.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:34746,Deployability,release,released,34746,") {; 1015 low2 = low;; 1016 low = i;; 1017 } else if (low2 == -1) low2 = i;; 1018 } else if (fX[i] > x) {; 1019 if (up == -1 || fX[i] < fX[up]) {; 1020 up2 = up;; 1021 up = i;; 1022 } else if (up2 == -1) up2 = i;; 1023 } else // case x == fX[i]; 1024 return fY[i]; // no interpolation needed; 1025 }; 1026 ; 1027 // treat cases when x is outside graph min max abscissa; 1028 if (up == -1) {; 1029 up = low;; 1030 low = low2;; 1031 }; 1032 if (low == -1) {; 1033 low = up;; 1034 up = up2;; 1035 }; 1036 }; 1037 // do now the linear interpolation; 1038 assert(low != -1 && up != -1);; 1039 ; 1040 if (fX[low] == fX[up]) return fY[low];; 1041 Double_t yn = fY[up] + (x - fX[up]) * (fY[low] - fY[up]) / (fX[low] - fX[up]);; 1042 return yn;; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// Execute action corresponding to one event.; 1047///; 1048/// This member function is called when a graph is clicked with the locator; 1049///; 1050/// If Left button clicked on one of the line end points, this point; 1051/// follows the cursor until button is released.; 1052///; 1053/// if Middle button clicked, the line is moved parallel to itself; 1054/// until the button is released.; 1055 ; 1056void TGraph::ExecuteEvent(Int_t event, Int_t px, Int_t py); 1057{; 1058 TVirtualGraphPainter *painter = TVirtualGraphPainter::GetPainter();; 1059 if (painter) painter->ExecuteEventHelper(this, event, px, py);; 1060}; 1061 ; 1062////////////////////////////////////////////////////////////////////////////////; 1063/// If array sizes <= newsize, expand storage to 2*newsize.; 1064 ; 1065void TGraph::Expand(Int_t newsize); 1066{; 1067 Double_t **ps = ExpandAndCopy(newsize, fNpoints);; 1068 CopyAndRelease(ps, 0, 0, 0);; 1069}; 1070 ; 1071////////////////////////////////////////////////////////////////////////////////; 1072/// If graph capacity is less than newsize points then make array sizes; 1073/// equal to least multiple of step to contain newsiz",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:34866,Deployability,release,released,34866,";; 1022 } else if (up2 == -1) up2 = i;; 1023 } else // case x == fX[i]; 1024 return fY[i]; // no interpolation needed; 1025 }; 1026 ; 1027 // treat cases when x is outside graph min max abscissa; 1028 if (up == -1) {; 1029 up = low;; 1030 low = low2;; 1031 }; 1032 if (low == -1) {; 1033 low = up;; 1034 up = up2;; 1035 }; 1036 }; 1037 // do now the linear interpolation; 1038 assert(low != -1 && up != -1);; 1039 ; 1040 if (fX[low] == fX[up]) return fY[low];; 1041 Double_t yn = fY[up] + (x - fX[up]) * (fY[low] - fY[up]) / (fX[low] - fX[up]);; 1042 return yn;; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// Execute action corresponding to one event.; 1047///; 1048/// This member function is called when a graph is clicked with the locator; 1049///; 1050/// If Left button clicked on one of the line end points, this point; 1051/// follows the cursor until button is released.; 1052///; 1053/// if Middle button clicked, the line is moved parallel to itself; 1054/// until the button is released.; 1055 ; 1056void TGraph::ExecuteEvent(Int_t event, Int_t px, Int_t py); 1057{; 1058 TVirtualGraphPainter *painter = TVirtualGraphPainter::GetPainter();; 1059 if (painter) painter->ExecuteEventHelper(this, event, px, py);; 1060}; 1061 ; 1062////////////////////////////////////////////////////////////////////////////////; 1063/// If array sizes <= newsize, expand storage to 2*newsize.; 1064 ; 1065void TGraph::Expand(Int_t newsize); 1066{; 1067 Double_t **ps = ExpandAndCopy(newsize, fNpoints);; 1068 CopyAndRelease(ps, 0, 0, 0);; 1069}; 1070 ; 1071////////////////////////////////////////////////////////////////////////////////; 1072/// If graph capacity is less than newsize points then make array sizes; 1073/// equal to least multiple of step to contain newsize points.; 1074 ; 1075void TGraph::Expand(Int_t newsize, Int_t step); 1076{; 1077 if (newsize <= fMaxSize) {; 1078 return;; 1079 }; 1080 Double_t **ps = Allocate(step * (new",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:74402,Deployability,install,install,74402,"x = px - gPad->XtoAbsPixel(gPad->XtoPad(fX[i]));; 2052 Int_t dpy = py - gPad->YtoAbsPixel(gPad->YtoPad(fY[i]));; 2053 if (dpx * dpx + dpy * dpy < 100) {; 2054 ipoint = i;; 2055 break;; 2056 }; 2057 }; 2058 return RemovePoint(ipoint);; 2059}; 2060 ; 2061////////////////////////////////////////////////////////////////////////////////; 2062/// Delete point number ipoint; 2063/// Returns index of removed point (or -1 if nothing was changed); 2064 ; 2065Int_t TGraph::RemovePoint(Int_t ipoint); 2066{; 2067 if ((ipoint < 0) || (ipoint >= fNpoints)); 2068 return -1;; 2069 ; 2070 Double_t **ps = ShrinkAndCopy(fNpoints - 1, ipoint);; 2071 CopyAndRelease(ps, ipoint + 1, fNpoints--, ipoint);; 2072 if (gPad) gPad->Modified();; 2073 return ipoint;; 2074}; 2075 ; 2076////////////////////////////////////////////////////////////////////////////////; 2077/// Save the graph as .csv, .tsv or .txt. In case of any other extension, fall; 2078/// back to TObject::SaveAs; 2079///; 2080/// The result can be immediately imported into Excel, gnuplot, Python or whatever,; 2081/// without the needing to install pyroot, etc.; 2082///; 2083/// \param filename the name of the file where to store the graph; 2084/// \param option some tuning options; 2085///; 2086/// The file extension defines the delimiter used:; 2087/// - `.csv` : comma; 2088/// - `.tsv` : tab; 2089/// - `.txt` : space; 2090///; 2091/// If option = ""title"" a title line is generated with the axis titles.; 2092 ; 2093void TGraph::SaveAs(const char *filename, Option_t *option) const; 2094{; 2095 char del = '\0';; 2096 TString ext = """";; 2097 TString fname = filename;; 2098 TString opt = option;; 2099 ; 2100 if (filename) {; 2101 if (fname.EndsWith("".csv"")) {del = ','; ext = ""csv"";}; 2102 else if (fname.EndsWith("".tsv"")) {del = '\t'; ext = ""tsv"";}; 2103 else if (fname.EndsWith("".txt"")) {del = ' '; ext = ""txt"";}; 2104 }; 2105 if (del) {; 2106 std::ofstream out;; 2107 out.open(filename, std::ios::out);; 2108 if (!out.good ()) {; 2109 Erro",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:96762,Deployability,continuous,continuous,96762,"///////////////////////////////////////; 2655/// Adds all graphs from the collection to this graph.; 2656/// Returns the total number of points in the result or -1 in case of an error.; 2657 ; 2658Int_t TGraph::Merge(TCollection* li); 2659{; 2660 TIter next(li);; 2661 while (TObject* o = next()) {; 2662 TGraph *g = dynamic_cast<TGraph*>(o);; 2663 if (!g) {; 2664 Error(""Merge"",; 2665 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 2666 return -1;; 2667 }; 2668 DoMerge(g);; 2669 }; 2670 return GetN();; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// protected function to perform the merge operation of a graph; 2675 ; 2676Bool_t TGraph::DoMerge(const TGraph* g); 2677{; 2678 Double_t x = 0, y = 0;; 2679 for (Int_t i = 0 ; i < g->GetN(); i++) {; 2680 g->GetPoint(i, x, y);; 2681 SetPoint(GetN(), x, y);; 2682 }; 2683 return kTRUE;; 2684}; 2685 ; 2686////////////////////////////////////////////////////////////////////////////////; 2687/// Move all graph points on specified values dx,dy; 2688/// If log argument specified, calculation done in logarithmic scale like:; 2689/// new_value = exp( log(old_value) + delta );; 2690 ; 2691void TGraph::MovePoints(Double_t dx, Double_t dy, Bool_t logx, Bool_t logy); 2692{; 2693 Double_t x = 0, y = 0;; 2694 for (Int_t i = 0 ; i < GetN(); i++) {; 2695 GetPoint(i, x, y);; 2696 if (!logx) {; 2697 x += dx;; 2698 } else if (x > 0) {; 2699 x = TMath::Exp(TMath::Log(x) + dx);; 2700 }; 2701 if (!logy) {; 2702 y += dy;; 2703 } else if (y > 0) {; 2704 y = TMath::Exp(TMath::Log(y) + dy);; 2705 }; 2706 SetPoint(i, x, y);; 2707 }; 2708}; 2709 ; 2710 ; 2711////////////////////////////////////////////////////////////////////////////////; 2712/// Find zero of a continuous function.; 2713/// This function finds a real zero of the continuous real; 2714/// function Y(X) in a given interval (A,B). See accompanying; 2715/// notes for details of the argument list and ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:96831,Deployability,continuous,continuous,96831,"2681 SetPoint(GetN(), x, y);; 2682 }; 2683 return kTRUE;; 2684}; 2685 ; 2686////////////////////////////////////////////////////////////////////////////////; 2687/// Move all graph points on specified values dx,dy; 2688/// If log argument specified, calculation done in logarithmic scale like:; 2689/// new_value = exp( log(old_value) + delta );; 2690 ; 2691void TGraph::MovePoints(Double_t dx, Double_t dy, Bool_t logx, Bool_t logy); 2692{; 2693 Double_t x = 0, y = 0;; 2694 for (Int_t i = 0 ; i < GetN(); i++) {; 2695 GetPoint(i, x, y);; 2696 if (!logx) {; 2697 x += dx;; 2698 } else if (x > 0) {; 2699 x = TMath::Exp(TMath::Log(x) + dx);; 2700 }; 2701 if (!logy) {; 2702 y += dy;; 2703 } else if (y > 0) {; 2704 y = TMath::Exp(TMath::Log(y) + dy);; 2705 }; 2706 SetPoint(i, x, y);; 2707 }; 2708}; 2709 ; 2710 ; 2711////////////////////////////////////////////////////////////////////////////////; 2712/// Find zero of a continuous function.; 2713/// This function finds a real zero of the continuous real; 2714/// function Y(X) in a given interval (A,B). See accompanying; 2715/// notes for details of the argument list and calling sequence; 2716 ; 2717void TGraph::Zero(Int_t &k, Double_t AZ, Double_t BZ, Double_t E2, Double_t &X, Double_t &Y; 2718 , Int_t maxiterations); 2719{; 2720 static Double_t a, b, ya, ytest, y1, x1, h;; 2721 static Int_t j1, it, j3, j2;; 2722 Double_t yb, x2;; 2723 yb = 0;; 2724 ; 2725 // Calculate Y(X) at X=AZ.; 2726 if (k <= 0) {; 2727 a = AZ;; 2728 b = BZ;; 2729 X = a;; 2730 j1 = 1;; 2731 it = 1;; 2732 k = j1;; 2733 return;; 2734 }; 2735 ; 2736 // Test whether Y(X) is sufficiently small.; 2737 ; 2738 if (TMath::Abs(Y) <= E2) {; 2739 k = 2;; 2740 return;; 2741 }; 2742 ; 2743 // Calculate Y(X) at X=BZ.; 2744 ; 2745 if (j1 == 1) {; 2746 ya = Y;; 2747 X = b;; 2748 j1 = 2;; 2749 return;; 2750 }; 2751 // Test whether the signs of Y(AZ) and Y(BZ) are different.; 2752 // if not, begin the binary subdivision.; 2753 ; 2754 if (j1 != 2) goto L100;; 2755 if (ya * Y",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:120083,Deployability,continuous,continuous,120083,"cxx:731; TGraph::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideImplementation to get information on point of graph at cursor position Adapted from class TH1.Definition TGraph.cxx:1585; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; TGraph::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""y"")Multiply the values of a TGraph by a constant c1.Definition TGraph.cxx:2259; TGraph::fFunctionsTList * fFunctionsPointer to list of functions (fits and user)Definition TGraph.h:49; TGraph::GetCovariancevirtual Double_t GetCovariance() constReturn covariance of vectors x,y.Definition TGraph.cxx:1308; TGraph::SwapValuesstatic void SwapValues(Double_t *arr, Int_t pos1, Int_t pos2)Swap values.Definition TGraph.cxx:2611; TGraph::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraph.Definition TGraph.cxx:2516; TGraph::Zerovoid Zero(Int_t &k, Double_t AZ, Double_t BZ, Double_t E2, Double_t &X, Double_t &Y, Int_t maxiterations)Find zero of a continuous function.Definition TGraph.cxx:2717; TGraph::Allocatevirtual Double_t ** Allocate(Int_t newsize)Allocate internal data structures for newsize points.Definition TGraph.cxx:590; TGraph::FitPanelvirtual void FitPanel()Display a GUI panel with all graph fit options.Definition TGraph.cxx:1274; TGraph::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TGraph.cxx:651; TGraph::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::InsertPointBeforevirtual void InsertPointBefore(Int_t ipoint, Double_t x, Double_t y)Insert a new point with coordinates (x,y) before the point number ipoint.Definition TGraph.cxx:1749; TGraph::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TGraph.h:126; TGraph::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGra",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:36027,Energy Efficiency,allocate,allocate,36027,"; 1055 ; 1056void TGraph::ExecuteEvent(Int_t event, Int_t px, Int_t py); 1057{; 1058 TVirtualGraphPainter *painter = TVirtualGraphPainter::GetPainter();; 1059 if (painter) painter->ExecuteEventHelper(this, event, px, py);; 1060}; 1061 ; 1062////////////////////////////////////////////////////////////////////////////////; 1063/// If array sizes <= newsize, expand storage to 2*newsize.; 1064 ; 1065void TGraph::Expand(Int_t newsize); 1066{; 1067 Double_t **ps = ExpandAndCopy(newsize, fNpoints);; 1068 CopyAndRelease(ps, 0, 0, 0);; 1069}; 1070 ; 1071////////////////////////////////////////////////////////////////////////////////; 1072/// If graph capacity is less than newsize points then make array sizes; 1073/// equal to least multiple of step to contain newsize points.; 1074 ; 1075void TGraph::Expand(Int_t newsize, Int_t step); 1076{; 1077 if (newsize <= fMaxSize) {; 1078 return;; 1079 }; 1080 Double_t **ps = Allocate(step * (newsize / step + (newsize % step ? 1 : 0)));; 1081 CopyAndRelease(ps, 0, fNpoints, 0);; 1082}; 1083 ; 1084////////////////////////////////////////////////////////////////////////////////; 1085/// if size > fMaxSize allocate new arrays of 2*size points and copy iend first; 1086/// points.; 1087/// Return pointer to new arrays.; 1088 ; 1089Double_t **TGraph::ExpandAndCopy(Int_t size, Int_t iend); 1090{; 1091 if (size <= fMaxSize); 1092 return nullptr;; 1093 Double_t **newarrays = Allocate(2 * size);; 1094 CopyPoints(newarrays, 0, iend, 0);; 1095 return newarrays;; 1096}; 1097 ; 1098////////////////////////////////////////////////////////////////////////////////; 1099/// Set zero values for point arrays in the range [begin, end); 1100/// Should be redefined in descendant classes; 1101 ; 1102void TGraph::FillZero(Int_t begin, Int_t end, Bool_t); 1103{; 1104 memset(fX + begin, 0, (end - begin)*sizeof(Double_t));; 1105 memset(fY + begin, 0, (end - begin)*sizeof(Double_t));; 1106}; 1107 ; 1108///////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:67557,Energy Efficiency,power,power,67557,"t (default=fNpoints-1); 1853///; 1854/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 1855 ; 1856void TGraph::LeastSquareFit(Int_t m, Double_t *a, Double_t xmin, Double_t xmax); 1857{; 1858 const Double_t zero = 0.;; 1859 const Double_t one = 1.;; 1860 const Int_t idim = 20;; 1861 ; 1862 Double_t b[400] /* was [20][20] */;; 1863 Int_t i, k, l, ifail;; 1864 Double_t power;; 1865 Double_t da[20], xk, yk;; 1866 Int_t n = fNpoints;; 1867 if (xmax <= xmin) {; 1868 xmin = fX[0];; 1869 xmax = fX[fNpoints-1];; 1870 }; 1871 ; 1872 if (m <= 2) {; 1873 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 1874 return;; 1875 }; 1876 if (m > idim || m > n) return;; 1877 da[0] = zero;; 1878 for (l = 2; l <= m; ++l) {; 1879 b[l-1] = zero;; 1880 b[m + l*20 - 21] = zero;; 1881 da[l-1] = zero;; 1882 }; 1883 Int_t np = 0;; 1884 for (k = 0; k < fNpoints; ++k) {; 1885 xk = fX[k];; 1886 if (xk < xmin || xk > xmax) continue;; 1887 np++;; 1888 yk = fY[k];; 1889 power = one;; 1890 da[0] += yk;; 1891 for (l = 2; l <= m; ++l) {; 1892 power *= xk;; 1893 b[l-1] += power;; 1894 da[l-1] += power * yk;; 1895 }; 1896 for (l = 2; l <= m; ++l) {; 1897 power *= xk;; 1898 b[m + l*20 - 21] += power;; 1899 }; 1900 }; 1901 b[0] = Double_t(np);; 1902 for (i = 3; i <= m; ++i) {; 1903 for (k = i; k <= m; ++k) {; 1904 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 1905 }; 1906 }; 1907 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 1908 ; 1909 if (ifail < 0) {; 1910 a[0] = fY[0];; 1911 for (i = 1; i < m; ++i) a[i] = 0;; 1912 return;; 1913 }; 1914 for (i = 0; i < m; ++i) a[i] = da[i];; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Least square linear fit without weights.; 1919///; 1920/// Fit a straight line (a0 + a1*x) to the data in this graph.; 1921///; 1922/// \param [in] ndata if ndata<0, fits the logarithm of the graph (used in InitExpo() to set; 1923/// the initial parameter values for a fit with exponential function.; 1",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:68144,Energy Efficiency,power,power,68144,"t (default=fNpoints-1); 1853///; 1854/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 1855 ; 1856void TGraph::LeastSquareFit(Int_t m, Double_t *a, Double_t xmin, Double_t xmax); 1857{; 1858 const Double_t zero = 0.;; 1859 const Double_t one = 1.;; 1860 const Int_t idim = 20;; 1861 ; 1862 Double_t b[400] /* was [20][20] */;; 1863 Int_t i, k, l, ifail;; 1864 Double_t power;; 1865 Double_t da[20], xk, yk;; 1866 Int_t n = fNpoints;; 1867 if (xmax <= xmin) {; 1868 xmin = fX[0];; 1869 xmax = fX[fNpoints-1];; 1870 }; 1871 ; 1872 if (m <= 2) {; 1873 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 1874 return;; 1875 }; 1876 if (m > idim || m > n) return;; 1877 da[0] = zero;; 1878 for (l = 2; l <= m; ++l) {; 1879 b[l-1] = zero;; 1880 b[m + l*20 - 21] = zero;; 1881 da[l-1] = zero;; 1882 }; 1883 Int_t np = 0;; 1884 for (k = 0; k < fNpoints; ++k) {; 1885 xk = fX[k];; 1886 if (xk < xmin || xk > xmax) continue;; 1887 np++;; 1888 yk = fY[k];; 1889 power = one;; 1890 da[0] += yk;; 1891 for (l = 2; l <= m; ++l) {; 1892 power *= xk;; 1893 b[l-1] += power;; 1894 da[l-1] += power * yk;; 1895 }; 1896 for (l = 2; l <= m; ++l) {; 1897 power *= xk;; 1898 b[m + l*20 - 21] += power;; 1899 }; 1900 }; 1901 b[0] = Double_t(np);; 1902 for (i = 3; i <= m; ++i) {; 1903 for (k = i; k <= m; ++k) {; 1904 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 1905 }; 1906 }; 1907 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 1908 ; 1909 if (ifail < 0) {; 1910 a[0] = fY[0];; 1911 for (i = 1; i < m; ++i) a[i] = 0;; 1912 return;; 1913 }; 1914 for (i = 0; i < m; ++i) a[i] = da[i];; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Least square linear fit without weights.; 1919///; 1920/// Fit a straight line (a0 + a1*x) to the data in this graph.; 1921///; 1922/// \param [in] ndata if ndata<0, fits the logarithm of the graph (used in InitExpo() to set; 1923/// the initial parameter values for a fit with exponential function.; 1",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:68215,Energy Efficiency,power,power,68215,"t (default=fNpoints-1); 1853///; 1854/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 1855 ; 1856void TGraph::LeastSquareFit(Int_t m, Double_t *a, Double_t xmin, Double_t xmax); 1857{; 1858 const Double_t zero = 0.;; 1859 const Double_t one = 1.;; 1860 const Int_t idim = 20;; 1861 ; 1862 Double_t b[400] /* was [20][20] */;; 1863 Int_t i, k, l, ifail;; 1864 Double_t power;; 1865 Double_t da[20], xk, yk;; 1866 Int_t n = fNpoints;; 1867 if (xmax <= xmin) {; 1868 xmin = fX[0];; 1869 xmax = fX[fNpoints-1];; 1870 }; 1871 ; 1872 if (m <= 2) {; 1873 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 1874 return;; 1875 }; 1876 if (m > idim || m > n) return;; 1877 da[0] = zero;; 1878 for (l = 2; l <= m; ++l) {; 1879 b[l-1] = zero;; 1880 b[m + l*20 - 21] = zero;; 1881 da[l-1] = zero;; 1882 }; 1883 Int_t np = 0;; 1884 for (k = 0; k < fNpoints; ++k) {; 1885 xk = fX[k];; 1886 if (xk < xmin || xk > xmax) continue;; 1887 np++;; 1888 yk = fY[k];; 1889 power = one;; 1890 da[0] += yk;; 1891 for (l = 2; l <= m; ++l) {; 1892 power *= xk;; 1893 b[l-1] += power;; 1894 da[l-1] += power * yk;; 1895 }; 1896 for (l = 2; l <= m; ++l) {; 1897 power *= xk;; 1898 b[m + l*20 - 21] += power;; 1899 }; 1900 }; 1901 b[0] = Double_t(np);; 1902 for (i = 3; i <= m; ++i) {; 1903 for (k = i; k <= m; ++k) {; 1904 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 1905 }; 1906 }; 1907 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 1908 ; 1909 if (ifail < 0) {; 1910 a[0] = fY[0];; 1911 for (i = 1; i < m; ++i) a[i] = 0;; 1912 return;; 1913 }; 1914 for (i = 0; i < m; ++i) a[i] = da[i];; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Least square linear fit without weights.; 1919///; 1920/// Fit a straight line (a0 + a1*x) to the data in this graph.; 1921///; 1922/// \param [in] ndata if ndata<0, fits the logarithm of the graph (used in InitExpo() to set; 1923/// the initial parameter values for a fit with exponential function.; 1",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:68244,Energy Efficiency,power,power,68244,"t (default=fNpoints-1); 1853///; 1854/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 1855 ; 1856void TGraph::LeastSquareFit(Int_t m, Double_t *a, Double_t xmin, Double_t xmax); 1857{; 1858 const Double_t zero = 0.;; 1859 const Double_t one = 1.;; 1860 const Int_t idim = 20;; 1861 ; 1862 Double_t b[400] /* was [20][20] */;; 1863 Int_t i, k, l, ifail;; 1864 Double_t power;; 1865 Double_t da[20], xk, yk;; 1866 Int_t n = fNpoints;; 1867 if (xmax <= xmin) {; 1868 xmin = fX[0];; 1869 xmax = fX[fNpoints-1];; 1870 }; 1871 ; 1872 if (m <= 2) {; 1873 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 1874 return;; 1875 }; 1876 if (m > idim || m > n) return;; 1877 da[0] = zero;; 1878 for (l = 2; l <= m; ++l) {; 1879 b[l-1] = zero;; 1880 b[m + l*20 - 21] = zero;; 1881 da[l-1] = zero;; 1882 }; 1883 Int_t np = 0;; 1884 for (k = 0; k < fNpoints; ++k) {; 1885 xk = fX[k];; 1886 if (xk < xmin || xk > xmax) continue;; 1887 np++;; 1888 yk = fY[k];; 1889 power = one;; 1890 da[0] += yk;; 1891 for (l = 2; l <= m; ++l) {; 1892 power *= xk;; 1893 b[l-1] += power;; 1894 da[l-1] += power * yk;; 1895 }; 1896 for (l = 2; l <= m; ++l) {; 1897 power *= xk;; 1898 b[m + l*20 - 21] += power;; 1899 }; 1900 }; 1901 b[0] = Double_t(np);; 1902 for (i = 3; i <= m; ++i) {; 1903 for (k = i; k <= m; ++k) {; 1904 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 1905 }; 1906 }; 1907 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 1908 ; 1909 if (ifail < 0) {; 1910 a[0] = fY[0];; 1911 for (i = 1; i < m; ++i) a[i] = 0;; 1912 return;; 1913 }; 1914 for (i = 0; i < m; ++i) a[i] = da[i];; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Least square linear fit without weights.; 1919///; 1920/// Fit a straight line (a0 + a1*x) to the data in this graph.; 1921///; 1922/// \param [in] ndata if ndata<0, fits the logarithm of the graph (used in InitExpo() to set; 1923/// the initial parameter values for a fit with exponential function.; 1",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:68268,Energy Efficiency,power,power,68268,"t (default=fNpoints-1); 1853///; 1854/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 1855 ; 1856void TGraph::LeastSquareFit(Int_t m, Double_t *a, Double_t xmin, Double_t xmax); 1857{; 1858 const Double_t zero = 0.;; 1859 const Double_t one = 1.;; 1860 const Int_t idim = 20;; 1861 ; 1862 Double_t b[400] /* was [20][20] */;; 1863 Int_t i, k, l, ifail;; 1864 Double_t power;; 1865 Double_t da[20], xk, yk;; 1866 Int_t n = fNpoints;; 1867 if (xmax <= xmin) {; 1868 xmin = fX[0];; 1869 xmax = fX[fNpoints-1];; 1870 }; 1871 ; 1872 if (m <= 2) {; 1873 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 1874 return;; 1875 }; 1876 if (m > idim || m > n) return;; 1877 da[0] = zero;; 1878 for (l = 2; l <= m; ++l) {; 1879 b[l-1] = zero;; 1880 b[m + l*20 - 21] = zero;; 1881 da[l-1] = zero;; 1882 }; 1883 Int_t np = 0;; 1884 for (k = 0; k < fNpoints; ++k) {; 1885 xk = fX[k];; 1886 if (xk < xmin || xk > xmax) continue;; 1887 np++;; 1888 yk = fY[k];; 1889 power = one;; 1890 da[0] += yk;; 1891 for (l = 2; l <= m; ++l) {; 1892 power *= xk;; 1893 b[l-1] += power;; 1894 da[l-1] += power * yk;; 1895 }; 1896 for (l = 2; l <= m; ++l) {; 1897 power *= xk;; 1898 b[m + l*20 - 21] += power;; 1899 }; 1900 }; 1901 b[0] = Double_t(np);; 1902 for (i = 3; i <= m; ++i) {; 1903 for (k = i; k <= m; ++k) {; 1904 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 1905 }; 1906 }; 1907 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 1908 ; 1909 if (ifail < 0) {; 1910 a[0] = fY[0];; 1911 for (i = 1; i < m; ++i) a[i] = 0;; 1912 return;; 1913 }; 1914 for (i = 0; i < m; ++i) a[i] = da[i];; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Least square linear fit without weights.; 1919///; 1920/// Fit a straight line (a0 + a1*x) to the data in this graph.; 1921///; 1922/// \param [in] ndata if ndata<0, fits the logarithm of the graph (used in InitExpo() to set; 1923/// the initial parameter values for a fit with exponential function.; 1",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:68327,Energy Efficiency,power,power,68327,"t (default=fNpoints-1); 1853///; 1854/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 1855 ; 1856void TGraph::LeastSquareFit(Int_t m, Double_t *a, Double_t xmin, Double_t xmax); 1857{; 1858 const Double_t zero = 0.;; 1859 const Double_t one = 1.;; 1860 const Int_t idim = 20;; 1861 ; 1862 Double_t b[400] /* was [20][20] */;; 1863 Int_t i, k, l, ifail;; 1864 Double_t power;; 1865 Double_t da[20], xk, yk;; 1866 Int_t n = fNpoints;; 1867 if (xmax <= xmin) {; 1868 xmin = fX[0];; 1869 xmax = fX[fNpoints-1];; 1870 }; 1871 ; 1872 if (m <= 2) {; 1873 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 1874 return;; 1875 }; 1876 if (m > idim || m > n) return;; 1877 da[0] = zero;; 1878 for (l = 2; l <= m; ++l) {; 1879 b[l-1] = zero;; 1880 b[m + l*20 - 21] = zero;; 1881 da[l-1] = zero;; 1882 }; 1883 Int_t np = 0;; 1884 for (k = 0; k < fNpoints; ++k) {; 1885 xk = fX[k];; 1886 if (xk < xmin || xk > xmax) continue;; 1887 np++;; 1888 yk = fY[k];; 1889 power = one;; 1890 da[0] += yk;; 1891 for (l = 2; l <= m; ++l) {; 1892 power *= xk;; 1893 b[l-1] += power;; 1894 da[l-1] += power * yk;; 1895 }; 1896 for (l = 2; l <= m; ++l) {; 1897 power *= xk;; 1898 b[m + l*20 - 21] += power;; 1899 }; 1900 }; 1901 b[0] = Double_t(np);; 1902 for (i = 3; i <= m; ++i) {; 1903 for (k = i; k <= m; ++k) {; 1904 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 1905 }; 1906 }; 1907 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 1908 ; 1909 if (ifail < 0) {; 1910 a[0] = fY[0];; 1911 for (i = 1; i < m; ++i) a[i] = 0;; 1912 return;; 1913 }; 1914 for (i = 0; i < m; ++i) a[i] = da[i];; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Least square linear fit without weights.; 1919///; 1920/// Fit a straight line (a0 + a1*x) to the data in this graph.; 1921///; 1922/// \param [in] ndata if ndata<0, fits the logarithm of the graph (used in InitExpo() to set; 1923/// the initial parameter values for a fit with exponential function.; 1",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:68366,Energy Efficiency,power,power,68366,"t (default=fNpoints-1); 1853///; 1854/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 1855 ; 1856void TGraph::LeastSquareFit(Int_t m, Double_t *a, Double_t xmin, Double_t xmax); 1857{; 1858 const Double_t zero = 0.;; 1859 const Double_t one = 1.;; 1860 const Int_t idim = 20;; 1861 ; 1862 Double_t b[400] /* was [20][20] */;; 1863 Int_t i, k, l, ifail;; 1864 Double_t power;; 1865 Double_t da[20], xk, yk;; 1866 Int_t n = fNpoints;; 1867 if (xmax <= xmin) {; 1868 xmin = fX[0];; 1869 xmax = fX[fNpoints-1];; 1870 }; 1871 ; 1872 if (m <= 2) {; 1873 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 1874 return;; 1875 }; 1876 if (m > idim || m > n) return;; 1877 da[0] = zero;; 1878 for (l = 2; l <= m; ++l) {; 1879 b[l-1] = zero;; 1880 b[m + l*20 - 21] = zero;; 1881 da[l-1] = zero;; 1882 }; 1883 Int_t np = 0;; 1884 for (k = 0; k < fNpoints; ++k) {; 1885 xk = fX[k];; 1886 if (xk < xmin || xk > xmax) continue;; 1887 np++;; 1888 yk = fY[k];; 1889 power = one;; 1890 da[0] += yk;; 1891 for (l = 2; l <= m; ++l) {; 1892 power *= xk;; 1893 b[l-1] += power;; 1894 da[l-1] += power * yk;; 1895 }; 1896 for (l = 2; l <= m; ++l) {; 1897 power *= xk;; 1898 b[m + l*20 - 21] += power;; 1899 }; 1900 }; 1901 b[0] = Double_t(np);; 1902 for (i = 3; i <= m; ++i) {; 1903 for (k = i; k <= m; ++k) {; 1904 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 1905 }; 1906 }; 1907 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 1908 ; 1909 if (ifail < 0) {; 1910 a[0] = fY[0];; 1911 for (i = 1; i < m; ++i) a[i] = 0;; 1912 return;; 1913 }; 1914 for (i = 0; i < m; ++i) a[i] = da[i];; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Least square linear fit without weights.; 1919///; 1920/// Fit a straight line (a0 + a1*x) to the data in this graph.; 1921///; 1922/// \param [in] ndata if ndata<0, fits the logarithm of the graph (used in InitExpo() to set; 1923/// the initial parameter values for a fit with exponential function.; 1",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:87196,Energy Efficiency,allocate,allocate,87196,",2);; 2409 } else {; 2410 if (fHistogram) fHistogram->SetTitle(title);; 2411 }; 2412}; 2413 ; 2414////////////////////////////////////////////////////////////////////////////////; 2415/// Set graph name and title; 2416 ; 2417void TGraph::SetNameTitle(const char *name, const char *title); 2418{; 2419 SetName(name);; 2420 SetTitle(title);; 2421}; 2422 ; 2423////////////////////////////////////////////////////////////////////////////////; 2424/// Set statistics option on/off.; 2425///; 2426/// By default, the statistics box is drawn.; 2427/// The paint options can be selected via gStyle->SetOptStat.; 2428/// This function sets/resets the kNoStats bit in the graph object.; 2429/// It has priority over the Style option.; 2430 ; 2431void TGraph::SetStats(Bool_t stats); 2432{; 2433 ResetBit(kNoStats);; 2434 if (!stats) {; 2435 SetBit(kNoStats);; 2436 //remove the ""stats"" object from the list of functions; 2437 if (fFunctions) {; 2438 TObject *obj = fFunctions->FindObject(""stats"");; 2439 if (obj) {; 2440 fFunctions->Remove(obj);; 2441 delete obj;; 2442 }; 2443 }; 2444 }; 2445}; 2446 ; 2447////////////////////////////////////////////////////////////////////////////////; 2448/// if size*2 <= fMaxSize allocate new arrays of size points,; 2449/// copy points [0,oend).; 2450/// Return newarray (passed or new instance if it was zero; 2451/// and allocations are needed); 2452 ; 2453Double_t **TGraph::ShrinkAndCopy(Int_t size, Int_t oend); 2454{; 2455 if (size * 2 > fMaxSize || !fMaxSize); 2456 return nullptr;; 2457 ; 2458 Double_t **newarrays = Allocate(size);; 2459 CopyPoints(newarrays, 0, oend, 0);; 2460 return newarrays;; 2461}; 2462 ; 2463////////////////////////////////////////////////////////////////////////////////; 2464/// Sorts the points of this TGraph using in-place quicksort (see e.g. older glibc).; 2465/// To compare two points the function parameter greaterfunc is used (see TGraph::CompareX for an; 2466/// example of such a method, which is also the default compariso",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:114165,Energy Efficiency,allocate,allocate,114165,"led when either TCanvas::UseCurrentStyle...Definition TGraph.cxx:2623; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::GetYDouble_t * GetY() constDefinition TGraph.h:140; TGraph::Mergevirtual Int_t Merge(TCollection *list)Adds all graphs from the collection to this graph.Definition TGraph.cxx:2658; TGraph::fMaxSizeInt_t fMaxSize!Current dimension of arrays fX and fYDefinition TGraph.h:45; TGraph::SaveHistogramAndFunctionsvoid SaveHistogramAndFunctions(std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option)Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes.Definition TGraph.cxx:2199; TGraph::fOptionTString fOptionOptions used for drawing the graph.Definition TGraph.h:53; TGraph::~TGraph~TGraph() overrideGraph default destructor.Definition TGraph.cxx:566; TGraph::ShrinkAndCopyDouble_t ** ShrinkAndCopy(Int_t size, Int_t iend)if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend).Definition TGraph.cxx:2453; TGraph::GetRMSvirtual Double_t GetRMS(Int_t axis=1) constReturn RMS of X (axis=1) or Y (axis=2)Definition TGraph.cxx:1339; TGraph::fHistogramTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:50; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::kNotEditable@ kNotEditableBit set if graph is non editable.Definition TGraph.h:78; TGraph::kIsHighlight@ kIsHighlightBit set if graph is highlight.Definition TGraph.h:80; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TGraph::kClipFrame@ kClipFrameClip to the frame boundary.Definition TGraph.h:76; TGraph::kResetHisto@ kResetHistofHistogram must be reset in GetHistogramDefinition TGraph.h:77; TGraph::kNoStats@ kNoStatsDon't draw stats box.Definition TGraph.h:75; TGraph::GetErrorXlowvirtual Double_",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:123631,Energy Efficiency,allocate,allocate,123631,"d SwapPoints(Int_t pos1, Int_t pos2)Swap points.Definition TGraph.cxx:2583; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::GetXaxisTAxis * GetXaxis() constGet x axis of the graph.Definition TGraph.cxx:1566; TGraph::GetEditableBool_t GetEditable() constReturn kTRUE if kNotEditable bit is not set, kFALSE otherwise.Definition TGraph.cxx:2292; TGraph::GetEXhighvirtual Double_t * GetEXhigh() constDefinition TGraph.h:143; TGraph::GetCorrelationFactorvirtual Double_t GetCorrelationFactor() constReturn graph correlation factor.Definition TGraph.cxx:1296; TGraph::FillZerovirtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE)Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes.Definition TGraph.cxx:1102; TGraph::GetEYhighvirtual Double_t * GetEYhigh() constDefinition TGraph.h:145; TGraph::ExpandAndCopyDouble_t ** ExpandAndCopy(Int_t size, Int_t iend)if size > fMaxSize allocate new arrays of 2*size points and copy iend first points.Definition TGraph.cxx:1089; TGraph::Expandvirtual void Expand(Int_t newsize)If array sizes <= newsize, expand storage to 2*newsize.Definition TGraph.cxx:1065; TGraph::GetMeanvirtual Double_t GetMean(Int_t axis=1) constReturn mean value of X (axis=1) or Y (axis=2)Definition TGraph.cxx:1324; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::PaintStatsvirtual void PaintStats(TF1 *fit)Draw the stats.Definition TGraph.cxx:2004; TGraph::GetYaxisTAxis * GetYaxis() constGet y axis of the graph.Definition TGraph.cxx:1575; TGraph::FindObjectTObject * FindObject(const char *name) const overrideSearch object named name in the list of functions.Definition TGraph.cxx:1111; TGraph::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TGraph.cxx:2431; TGraph::GetHistogramvirtual TH1F * GetHistogram() constReturns a pointer to the histogram used to draw th",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:139212,Energy Efficiency,power,power,139212,"Definition legend1.C:17; f1TF1 * f1Definition legend1.C:11; ROOT::Fit::FitObjectTFitResultPtr FitObject(TH1 *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)fitting function for a TH1 (called from TH1::Fit)Definition HFitImpl.cxx:972; ROOT::Fit::Chisquaredouble Chisquare(const TH1 &h1, TF1 &f1, bool useRange, EChisquareType type)compute the chi2 value for an histogram given a function (see TH1::Chisquare for the documentation)Definition HFitImpl.cxx:1027; ROOT::Fit::FitOptionsMakevoid FitOptionsMake(EFitObjectType type, const char *option, Foption_t &fitOption)Decode list of options into fitOption.Definition HFitImpl.cxx:685; ROOT::Fit::EFitObjectType::kGraph@ kGraph; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; Foption_tDefinition Foption.h:24; D",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:3074,Integrability,depend,depending,3074,"s.; 66 A TGraph has the default title and name ""Graph"". To change the default title; 67 and name `SetTitle` and `SetName` should be called on the TGraph after its creation.; 68 TGraph was a light weight object to start with, like TPolyline or TPolyMarker.; 69 That’s why it did not have any title and name parameters in the constructors.; 70 ; 71#### Example; 72 ; 73The picture below gives an example:; 74 ; 75Begin_Macro(source); 76{; 77 double x[100], y[100];; 78 int n = 20;; 79 for (int i=0;i<n;i++) {; 80 x[i] = i*0.1;; 81 y[i] = 10*sin(x[i]+0.2);; 82 }; 83 auto g = new TGraph(n,x,y);; 84 g->SetTitle(""Graph title;X title;Y title"");; 85 g->Draw(""AC*"");; 86}; 87End_Macro; 88 ; 89#### Default X-Points; 90 ; 91If one doesn't specify the points in the x-axis, they will get the default values 0, 1, 2, 3, (etc. depending; 92on the length of the y-points):; 93 ; 94Begin_Macro(source); 95{; 96 double y[6] = {3, 8, 1, 10, 5, 7};; 97 auto g = new TGraph(6,y);; 98 g->SetTitle(""A Graph with default X points"");; 99 g->Draw();; 100}; 101End_Macro; 102 ; 103*/; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Graph default constructor.; 107 ; 108TGraph::TGraph() : TAttFill(0, 1000); 109{; 110 fNpoints = -1; //will be reset to 0 in CtorAllocate; 111 if (!CtorAllocate()) return;; 112}; 113 ; 114////////////////////////////////////////////////////////////////////////////////; 115/// Constructor with only the number of points set; 116/// the arrays x and y will be set later; 117 ; 118TGraph::TGraph(Int_t n); 119 : TNamed(""Graph"", ""Graph""), TAttFill(0, 1000); 120{; 121 fNpoints = n;; 122 if (!CtorAllocate()) return;; 123 FillZero(0, fNpoints);; 124}; 125 ; 126////////////////////////////////////////////////////////////////////////////////; 127/// Graph normal constructor with ints.; 128 ; 129TGraph::TGraph(Int_t n, const Int_t *x, const Int_t *y); 130 : TNamed(""Graph"", ""Graph""), TAttFill(0, 1000); 131{; 132 if (!x || !y) {; 133 fNpoints = ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:16212,Integrability,message,message,16212,"!format_.IsDigit()) {; 483 Error(""TGraph"", ""Incorrect input format! Allowed formats are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 484 return;; 485 }; 486 Int_t ntokens = format_.Length() ;; 487 if (ntokens < 2) {; 488 Error(""TGraph"", ""Incorrect input format! Only %d tag(s) in format whereas 2 \""%%lg\"" tags are expected!"", ntokens);; 489 return;; 490 }; 491 Int_t ntokensToBeSaved = 0 ;; 492 Bool_t * isTokenToBeSaved = new Bool_t [ntokens] ;; 493 for (Int_t idx = 0; idx < ntokens; idx++) {; 494 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi() ; //atoi(&format_[idx]) does not work for some reason...; 495 if (isTokenToBeSaved[idx] == 1) {; 496 ntokensToBeSaved++ ;; 497 }; 498 }; 499 if (ntokens >= 2 && ntokensToBeSaved != 2) { //first condition not to repeat the previous error message; 500 Error(""TGraph"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2 and only 2 are expected!"", ntokensToBeSaved);; 501 delete [] isTokenToBeSaved ;; 502 return;; 503 }; 504 ; 505 // Initializing loop variables; 506 Bool_t isLineToBeSkipped = kFALSE ; //empty and ill-formed lines; 507 char * token = nullptr ;; 508 TString token_str = """" ;; 509 Int_t token_idx = 0 ;; 510 Double_t * value = new Double_t [2] ; //x,y buffers; 511 Int_t value_idx = 0 ;; 512 ; 513 // Looping; 514 char *rest;; 515 while (std::getline(infile, line, '\n')) {; 516 if (!line.empty()) {; 517 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 518 line.erase(line.end() - 1, line.end()) ;; 519 }; 520 //token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, rest);; 521 token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, &rest);; 522 while (token != nullptr && value_idx < 2) {; 523 if (isTokenToBeSaved[token_idx]) {; 524 token_str = TString(token) ;; 525 token_str.ReplaceAll(""\t"", """") ;; 526 if (!token_str.IsFloat()) {; 527 isLineToBeSkipped = kTRUE ;; 528 break ;; 529 } else {; 530 value[value_idx] = token_str.Atof() ;; 531 value_idx++ ;; 532 }; 53",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:45027,Integrability,interface,interface,45027," in TH1::Fit for the documentation of; 1225/// - [Fit Result](\ref HFitRes); 1226/// - [Fit Status](\ref HFitStatus); 1227/// - [Fit Statistics Box](\ref HFitStatBox); 1228/// - [Fitting in a Range](\ref HFitRange); 1229/// - [Setting Initial Conditions](\ref HFitInitial); 1230 ; 1231TFitResultPtr TGraph::Fit(TF1 *f1, Option_t *option, Option_t *goption, Axis_t rxmin, Axis_t rxmax); 1232{; 1233 Foption_t fitOption;; 1234 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph, option, fitOption);; 1235 // create range and minimizer options with default values; 1236 ROOT::Fit::DataRange range(rxmin, rxmax);; 1237 ROOT::Math::MinimizerOptions minOption;; 1238 return ROOT::Fit::FitObject(this, f1 , fitOption , minOption, goption, range);; 1239}; 1240 ; 1241////////////////////////////////////////////////////////////////////////////////; 1242/// Fit this graph with function with name `fname`.; 1243///; 1244/// This is a different interface to TGraph fitting using TGraph::Fit(TF1 *f1,Option_t *, Option_t *, Axis_t, Axis_t); 1245/// See there for the details about fitting a TGraph.; 1246///; 1247/// The parameter `fname` is the name of an already predefined function created by TF1 or TF2; 1248/// Predefined functions such as gaus, expo and poln are automatically; 1249/// created by ROOT.; 1250///; 1251/// The parameter `fname` can also be a formula, accepted by the linear fitter (linear parts divided; 1252/// by ""++"" sign), for example ""x++sin(x)"" for fitting ""[0]*x+[1]*sin(x)""; 1253 ; 1254TFitResultPtr TGraph::Fit(const char *fname, Option_t *option, Option_t *, Axis_t xmin, Axis_t xmax); 1255{; 1256 const char *linear = fname ? strstr(fname, ""++"") : nullptr;; 1257 if (linear) {; 1258 TF1 f1(fname, fname, xmin, xmax);; 1259 return Fit(&f1, option, """", xmin, xmax);; 1260 }; 1261 TF1 * f1 = (TF1*)gROOT->GetFunction(fname);; 1262 if (!f1) {; 1263 Printf(""Unknown function: %s"", fname);; 1264 return -1;; 1265 }; 1266 return Fit(f1, option, """", xmin, xmax);; 1267}; 1268 ; 1",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:64183,Integrability,depend,depends,64183,"72 fX[ipoint] = x;; 1773 fY[ipoint] = y;; 1774}; 1775 ; 1776 ; 1777////////////////////////////////////////////////////////////////////////////////; 1778/// Integrate the TGraph data within a given (index) range.; 1779/// Note that this function computes the area of the polygon enclosed by the points of the TGraph.; 1780/// The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; 1781/// since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; 1782/// with the first one. It is clear that the order of the point is essential in defining the polygon.; 1783/// Also note that the segments should not intersect.; 1784///; 1785/// NB:; 1786/// - if last=-1 (default) last is set to the last point.; 1787/// - if (first <0) the first point (0) is taken.; 1788///; 1789/// ### Method:; 1790///; 1791/// There are many ways to calculate the surface of a polygon. It all depends on what kind of data; 1792/// you have to deal with. The most evident solution would be to divide the polygon in triangles and; 1793/// calculate the surface of them. But this can quickly become complicated as you will have to test; 1794/// every segments of every triangles and check if they are intersecting with a current polygon's; 1795/// segment or if it goes outside the polygon. Many calculations that would lead to many problems...; 1796///; 1797/// ### The solution (implemented by R.Brun); 1798/// Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; 1799/// segments don't intersect.; 1800/// It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; 1801/// vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied; 1802/// by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area.; 1803///; 1804/// ### Sources; 1805/// - http://forums.wolfram.com/mat",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:67230,Integrability,rout,routine,67230,"/ the graph vertices 0 otherwise.; 1831///; 1832/// Algorithm:; 1833///; 1834/// The loop is executed with the end-point coordinates of a line segment; 1835/// (X1,Y1)-(X2,Y2) and the Y-coordinate of a horizontal line.; 1836/// The counter inter is incremented if the line (X1,Y1)-(X2,Y2) intersects; 1837/// the horizontal line. In this case XINT is set to the X-coordinate of the; 1838/// intersection point. If inter is an odd number, then the point x,y is within; 1839/// the polygon.; 1840 ; 1841Int_t TGraph::IsInside(Double_t x, Double_t y) const; 1842{; 1843 return (Int_t)TMath::IsInside(x, y, fNpoints, fX, fY);; 1844}; 1845 ; 1846////////////////////////////////////////////////////////////////////////////////; 1847/// Least squares polynomial fitting without weights.; 1848///; 1849/// \param [in] m number of parameters; 1850/// \param [in] a array of parameters; 1851/// \param [in] xmin 1st point number to fit (default =0); 1852/// \param [in] xmax last point number to fit (default=fNpoints-1); 1853///; 1854/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 1855 ; 1856void TGraph::LeastSquareFit(Int_t m, Double_t *a, Double_t xmin, Double_t xmax); 1857{; 1858 const Double_t zero = 0.;; 1859 const Double_t one = 1.;; 1860 const Int_t idim = 20;; 1861 ; 1862 Double_t b[400] /* was [20][20] */;; 1863 Int_t i, k, l, ifail;; 1864 Double_t power;; 1865 Double_t da[20], xk, yk;; 1866 Int_t n = fNpoints;; 1867 if (xmax <= xmin) {; 1868 xmin = fX[0];; 1869 xmax = fX[fNpoints-1];; 1870 }; 1871 ; 1872 if (m <= 2) {; 1873 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 1874 return;; 1875 }; 1876 if (m > idim || m > n) return;; 1877 da[0] = zero;; 1878 for (l = 2; l <= m; ++l) {; 1879 b[l-1] = zero;; 1880 b[m + l*20 - 21] = zero;; 1881 da[l-1] = zero;; 1882 }; 1883 Int_t np = 0;; 1884 for (k = 0; k < fNpoints; ++k) {; 1885 xk = fX[k];; 1886 if (xk < xmin || xk > xmax) continue;; 1887 np++;; 1888 yk = fY[k];; 1889 power = one;; 1890 da[0] += yk;; 1891 f",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:105084,Integrability,rout,routine,105084," Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; SetMarkerStyleOption_t Option_t SetMarkerStyleDefinition TGWin32VirtualXProxy.cxx:52; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; TGraphAsymmErrors.h; TGraphBentErrors.h; TGraphErrors.h; H1LeastSquareSeqndvoid H1LeastSquareSeqnd(Int_t n, Double_t *a, Int_t idim, Int_t &ifail, Int_t k, Double_t *b)Extracted from CERN Program library routine DSEQN.Definition TH1.cxx:4872; TGraph.h; TH1.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; TMath.h; TPluginManager.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; TSpline.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TVectorD.h; TVirtualFitter.h; TVirtualGraphPainter.h; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; ROOT::Fit::DataRangeclass describ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:131398,Integrability,message,message,131398,"e(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::Streamervoid Streamer(TBuffer &) overrideStream an object of class TObject.; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInva",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:132109,Integrability,message,message,132109,"t.h:199; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TSpline3Class to create third splines to interpolate knots Arbitrary conditions can be introduced for first a...Definition TSpline.h:182; TSpline3::EvalDouble_t Eval(Double_t x) const overrideEval this spline at x.Definition TSpline.cxx:786",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:132571,Integrability,message,message,132571,"ct::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TSpline3Class to create third splines to interpolate knots Arbitrary conditions can be introduced for first a...Definition TSpline.h:182; TSpline3::EvalDouble_t Eval(Double_t x) const overrideEval this spline at x.Definition TSpline.cxx:786; TSplineBase class for spline implementation containing the Draw/Paint methods.Definition TSpline.h:31; TSpline::Evalvirtual Double_t Eval(Double_t x) const =0; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString:",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:136659,Integrability,interface,interface,136659,"0; TStyle::GetHistLineStyleStyle_t GetHistLineStyle() constDefinition TStyle.h:235; TStyle::SetHistFillStylevoid SetHistFillStyle(Style_t styl=0)Definition TStyle.h:381; TStyle::GetHistLineWidthWidth_t GetHistLineWidth() constDefinition TStyle.h:236; TStyle::SetHistLineWidthvoid SetHistLineWidth(Width_t width=1)Definition TStyle.h:383; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TVectorTTVectorT.Definition TVectorT.h:27; TVectorT::GetNrowsInt_t GetNrows() constDefinition TVectorT.h:73; TVectorT::GetLwbInt_t GetLwb() constDefinition TVectorT.h:71; TVirtualFitterAbstract Base Class for Fitting.Definition TVirtualFitter.h:29; TVirtualFitter::GetFitterstatic TVirtualFitter * GetFitter()static: return the current FitterDefinition TVirtualFitter.cxx:209; TVirtualFitter::GetUserFuncvirtual TObject * GetUserFunc() constDefinition TVirtualFitter.h:84; TVirtualGraphPainterAbstract interface to a histogram painter.Definition TVirtualGraphPainter.h:28; TVirtualGraphPainter::DrawPanelHelpervirtual void DrawPanelHelper(TGraph *theGraph)=0; TVirtualGraphPainter::ExecuteEventHelpervirtual void ExecuteEventHelper(TGraph *theGraph, Int_t event, Int_t px, Int_t py)=0; TVirtualGraphPainter::SetHighlightvirtual void SetHighlight(TGraph *theGraph)=0; TVirtualGraphPainter::PaintGrapHistvirtual void PaintGrapHist(TGraph *theGraph, Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt)=0; TVirtualGraphPainter::DistancetoPrimitiveHelpervirtual Int_t DistancetoPrimitiveHelper(TGraph *theGraph, Int_t px, Int_t py)=0; TVirtualGraphPainter::PaintGraphvirtual void PaintGraph(TGraph *theGraph, Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt)=0; TVirtualGraphPainter::PaintStatsvirtual void PaintStats(TGraph *theGraph, TF1 *fit)=0; TVirtualGraphPainter::PaintHelpervirtual void PaintHelper(TGraph *theGraph, Option_t *option)=0; TVirtualGraphPainter::",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:16447,Modifiability,variab,variables,16447,"!format_.IsDigit()) {; 483 Error(""TGraph"", ""Incorrect input format! Allowed formats are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 484 return;; 485 }; 486 Int_t ntokens = format_.Length() ;; 487 if (ntokens < 2) {; 488 Error(""TGraph"", ""Incorrect input format! Only %d tag(s) in format whereas 2 \""%%lg\"" tags are expected!"", ntokens);; 489 return;; 490 }; 491 Int_t ntokensToBeSaved = 0 ;; 492 Bool_t * isTokenToBeSaved = new Bool_t [ntokens] ;; 493 for (Int_t idx = 0; idx < ntokens; idx++) {; 494 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi() ; //atoi(&format_[idx]) does not work for some reason...; 495 if (isTokenToBeSaved[idx] == 1) {; 496 ntokensToBeSaved++ ;; 497 }; 498 }; 499 if (ntokens >= 2 && ntokensToBeSaved != 2) { //first condition not to repeat the previous error message; 500 Error(""TGraph"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2 and only 2 are expected!"", ntokensToBeSaved);; 501 delete [] isTokenToBeSaved ;; 502 return;; 503 }; 504 ; 505 // Initializing loop variables; 506 Bool_t isLineToBeSkipped = kFALSE ; //empty and ill-formed lines; 507 char * token = nullptr ;; 508 TString token_str = """" ;; 509 Int_t token_idx = 0 ;; 510 Double_t * value = new Double_t [2] ; //x,y buffers; 511 Int_t value_idx = 0 ;; 512 ; 513 // Looping; 514 char *rest;; 515 while (std::getline(infile, line, '\n')) {; 516 if (!line.empty()) {; 517 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 518 line.erase(line.end() - 1, line.end()) ;; 519 }; 520 //token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, rest);; 521 token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, &rest);; 522 while (token != nullptr && value_idx < 2) {; 523 if (isTokenToBeSaved[token_idx]) {; 524 token_str = TString(token) ;; 525 token_str.ReplaceAll(""\t"", """") ;; 526 if (!token_str.IsFloat()) {; 527 isLineToBeSkipped = kTRUE ;; 528 break ;; 529 } else {; 530 value[value_idx] = token_str.Atof() ;; 531 value_idx++ ;; 532 }; 53",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:46496,Modifiability,plugin,plugin,46496,,MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:46856,Modifiability,plug-in,plug-in,46856,,MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:95392,Modifiability,inherit,inherit,95392,"///////////////////////////////////////; 2655/// Adds all graphs from the collection to this graph.; 2656/// Returns the total number of points in the result or -1 in case of an error.; 2657 ; 2658Int_t TGraph::Merge(TCollection* li); 2659{; 2660 TIter next(li);; 2661 while (TObject* o = next()) {; 2662 TGraph *g = dynamic_cast<TGraph*>(o);; 2663 if (!g) {; 2664 Error(""Merge"",; 2665 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 2666 return -1;; 2667 }; 2668 DoMerge(g);; 2669 }; 2670 return GetN();; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// protected function to perform the merge operation of a graph; 2675 ; 2676Bool_t TGraph::DoMerge(const TGraph* g); 2677{; 2678 Double_t x = 0, y = 0;; 2679 for (Int_t i = 0 ; i < g->GetN(); i++) {; 2680 g->GetPoint(i, x, y);; 2681 SetPoint(GetN(), x, y);; 2682 }; 2683 return kTRUE;; 2684}; 2685 ; 2686////////////////////////////////////////////////////////////////////////////////; 2687/// Move all graph points on specified values dx,dy; 2688/// If log argument specified, calculation done in logarithmic scale like:; 2689/// new_value = exp( log(old_value) + delta );; 2690 ; 2691void TGraph::MovePoints(Double_t dx, Double_t dy, Bool_t logx, Bool_t logy); 2692{; 2693 Double_t x = 0, y = 0;; 2694 for (Int_t i = 0 ; i < GetN(); i++) {; 2695 GetPoint(i, x, y);; 2696 if (!logx) {; 2697 x += dx;; 2698 } else if (x > 0) {; 2699 x = TMath::Exp(TMath::Log(x) + dx);; 2700 }; 2701 if (!logy) {; 2702 y += dy;; 2703 } else if (y > 0) {; 2704 y = TMath::Exp(TMath::Log(y) + dy);; 2705 }; 2706 SetPoint(i, x, y);; 2707 }; 2708}; 2709 ; 2710 ; 2711////////////////////////////////////////////////////////////////////////////////; 2712/// Find zero of a continuous function.; 2713/// This function finds a real zero of the continuous real; 2714/// function Y(X) in a given interval (A,B). See accompanying; 2715/// notes for details of the argument list and ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:131955,Modifiability,inherit,inherits,131955,"d assignment operator.Definition TNamed.cxx:51; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TSpline3Class to create third splines to interpolate",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:132797,Modifiability,plugin,plugin,132797,"set the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TSpline3Class to create third splines to interpolate knots Arbitrary conditions can be introduced for first a...Definition TSpline.h:182; TSpline3::EvalDouble_t Eval(Double_t x) const overrideEval this spline at x.Definition TSpline.cxx:786; TSplineBase class for spline implementation containing the Draw/Paint methods.Definition TSpline.h:31; TSpline::Evalvirtual Double_t Eval(Double_t x) const =0; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::EndsWithBool_t EndsWith(const char *pat, ECaseCompare cmp=kExact) constReturn true if string ends with the specified string.Definition TString.cxx:2244; TString::AtofDouble_t Atof() constReturn floating-point value c",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:1830,Performance,perform,performed,1830,"21#include ""TF1.h""; 22#include ""TStyle.h""; 23#include ""TMath.h""; 24#include ""TVectorD.h""; 25#include ""Foption.h""; 26#include ""TRandom.h""; 27#include ""TSpline.h""; 28#include ""TVirtualFitter.h""; 29#include ""TVirtualPad.h""; 30#include ""TVirtualGraphPainter.h""; 31#include ""TBrowser.h""; 32#include ""TSystem.h""; 33#include ""TPluginManager.h""; 34#include ""strtok.h""; 35 ; 36#include <cstdlib>; 37#include <string>; 38#include <cassert>; 39#include <iostream>; 40#include <fstream>; 41#include <cstring>; 42#include <numeric>; 43 ; 44#include ""HFitInterface.h""; 45#include ""Fit/DataRange.h""; 46#include ""Math/MinimizerOptions.h""; 47 ; 48extern void H1LeastSquareSeqnd(Int_t n, Double_t *a, Int_t idim, Int_t &ifail, Int_t k, Double_t *b);; 49 ; 50ClassImp(TGraph);; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53 ; 54/** \class TGraph; 55 \ingroup Graphs; 56A TGraph is an object made of two arrays X and Y with npoints each.; 57The TGraph painting is performed thanks to the TGraphPainter; 58class. All details about the various painting options are given in this class.; 59 ; 60#### Notes; 61 ; 62 - Unlike histogram or tree (or even TGraph2D), TGraph objects; 63 are not automatically attached to the current TFile, in order to keep the; 64 management and size of the TGraph as small as possible.; 65 - The TGraph constructors do not have the TGraph title and name as parameters.; 66 A TGraph has the default title and name ""Graph"". To change the default title; 67 and name `SetTitle` and `SetName` should be called on the TGraph after its creation.; 68 TGraph was a light weight object to start with, like TPolyline or TPolyMarker.; 69 That’s why it did not have any title and name parameters in the constructors.; 70 ; 71#### Example; 72 ; 73The picture below gives an example:; 74 ; 75Begin_Macro(source); 76{; 77 double x[100], y[100];; 78 int n = 20;; 79 for (int i=0;i<n;i++) {; 80 x[i] = i*0.1;; 81 y[i] = 10*sin(x[i]+0.2);; 82 }; 83 auto g = new TGrap",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:40772,Performance,perform,performed,40772,"its are set.; 1152/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 1153/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 1154/// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; 1155/// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; 1156///; 1157///; 1158/// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; 1159/// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; 1160///; 1161/// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; 1171/// The chi-square is then computed as the sum of the quantity below at each data point:; 1172///; 1173/// \f[; 1174/// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; 1175/// \f]; 1176///; 1177/// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; 1178/// function `f(x)`.; 1179///; 1180/// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; 1181///; 1182/// The approach used to approximate the uncertainty in y because of ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:42830,Performance,perform,perform,42830,"f the line.; 1184/// This approach is called ""effective variance method"" and; 1185/// the implementation is provided in the function FitUtil::EvaluateChi2Effective; 1186///; 1187/// \anchor GFitLinear; 1188/// ### Linear fitting:; 1189/// When the fitting function is linear (contains the `++` sign) or the fitting; 1190/// function is a polynomial, a linear fitter is initialised.; 1191/// To create a linear function, use the following syntax: linear parts; 1192/// separated by `++` sign.; 1193/// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; 1194/// TF1 object as; 1195///; 1196/// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; 1197///; 1198/// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; 1199/// Going via the linear fitter for functions, linear in parameters, gives a; 1200/// considerable advantage in speed.; 1201/// When using the linear fitting it is also possible to perform a robust fitting with the; 1202/// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; 1203/// See the tutorial `fitLinearRobust.C`.; 1204///; 1205/// ### Notes on TGraph/TGraphErrors Fitting:; 1206///; 1207/// 1. By using the ""effective variance"" method a simple linear regression; 1208/// becomes a non-linear case, which takes several iterations; 1209/// instead of 0 as in the linear case.; 1210/// 2. The effective variance technique assumes that there is no correlation; 1211/// between the x and y coordinate.; 1212/// 3. The standard chi2 (least square) method without error in the coordinates (x) can; 1213/// be forced by using option ""EX0""; 1214/// 4. The linear fitter doesn't take into account the errors in x. When fitting a; 1215/// TGraphErrors with a linear functions the errors in x will not be considered.; 1216/// If errors in x are important, use option ""F"" for linear function fitting.; 1217/// 5. When fitting a TGraph (i.e. no errors associated with each point),; 1218/",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:95636,Performance,perform,perform,95636,"///////////////////////////////////////; 2655/// Adds all graphs from the collection to this graph.; 2656/// Returns the total number of points in the result or -1 in case of an error.; 2657 ; 2658Int_t TGraph::Merge(TCollection* li); 2659{; 2660 TIter next(li);; 2661 while (TObject* o = next()) {; 2662 TGraph *g = dynamic_cast<TGraph*>(o);; 2663 if (!g) {; 2664 Error(""Merge"",; 2665 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 2666 return -1;; 2667 }; 2668 DoMerge(g);; 2669 }; 2670 return GetN();; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// protected function to perform the merge operation of a graph; 2675 ; 2676Bool_t TGraph::DoMerge(const TGraph* g); 2677{; 2678 Double_t x = 0, y = 0;; 2679 for (Int_t i = 0 ; i < g->GetN(); i++) {; 2680 g->GetPoint(i, x, y);; 2681 SetPoint(GetN(), x, y);; 2682 }; 2683 return kTRUE;; 2684}; 2685 ; 2686////////////////////////////////////////////////////////////////////////////////; 2687/// Move all graph points on specified values dx,dy; 2688/// If log argument specified, calculation done in logarithmic scale like:; 2689/// new_value = exp( log(old_value) + delta );; 2690 ; 2691void TGraph::MovePoints(Double_t dx, Double_t dy, Bool_t logx, Bool_t logy); 2692{; 2693 Double_t x = 0, y = 0;; 2694 for (Int_t i = 0 ; i < GetN(); i++) {; 2695 GetPoint(i, x, y);; 2696 if (!logx) {; 2697 x += dx;; 2698 } else if (x > 0) {; 2699 x = TMath::Exp(TMath::Log(x) + dx);; 2700 }; 2701 if (!logy) {; 2702 y += dy;; 2703 } else if (y > 0) {; 2704 y = TMath::Exp(TMath::Log(y) + dy);; 2705 }; 2706 SetPoint(i, x, y);; 2707 }; 2708}; 2709 ; 2710 ; 2711////////////////////////////////////////////////////////////////////////////////; 2712/// Find zero of a continuous function.; 2713/// This function finds a real zero of the continuous real; 2714/// function Y(X) in a given interval (A,B). See accompanying; 2715/// notes for details of the argument list and ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:120541,Performance,perform,perform,120541,"unctionsPointer to list of functions (fits and user)Definition TGraph.h:49; TGraph::GetCovariancevirtual Double_t GetCovariance() constReturn covariance of vectors x,y.Definition TGraph.cxx:1308; TGraph::SwapValuesstatic void SwapValues(Double_t *arr, Int_t pos1, Int_t pos2)Swap values.Definition TGraph.cxx:2611; TGraph::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraph.Definition TGraph.cxx:2516; TGraph::Zerovoid Zero(Int_t &k, Double_t AZ, Double_t BZ, Double_t E2, Double_t &X, Double_t &Y, Int_t maxiterations)Find zero of a continuous function.Definition TGraph.cxx:2717; TGraph::Allocatevirtual Double_t ** Allocate(Int_t newsize)Allocate internal data structures for newsize points.Definition TGraph.cxx:590; TGraph::FitPanelvirtual void FitPanel()Display a GUI panel with all graph fit options.Definition TGraph.cxx:1274; TGraph::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TGraph.cxx:651; TGraph::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::InsertPointBeforevirtual void InsertPointBefore(Int_t ipoint, Double_t x, Double_t y)Insert a new point with coordinates (x,y) before the point number ipoint.Definition TGraph.cxx:1749; TGraph::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TGraph.h:126; TGraph::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGraph.cxx:1056; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TGraph::SaveAsvoid SaveAs(const char *filename=""graph"", Option_t *option="""") const overrideSave the graph as .csv, .tsv or .txt.Definition TGraph.cxx:2093; TGraph::Evalvirtual Double_t Eval(Double_t x, TSpline *spline=nullptr, Option_t *option="""") constInterpolate points in this graph at x using a TSpline.Definition TGraph.cxx:953; TGraph::InitExpovirtual void InitExpo(Double_t xmin=0, Double_t xmax=0)Compute Initial values of p",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:13758,Safety,avoid,avoid,13758,"points; i++) fY[i] /= integ;; 409 }; 410 ; 411 f->TAttLine::Copy(*this);; 412 f->TAttFill::Copy(*this);; 413 f->TAttMarker::Copy(*this);; 414 ; 415 SetName(f->GetName());; 416 SetTitle(f->GetTitle());; 417}; 418 ; 419////////////////////////////////////////////////////////////////////////////////; 420/// Graph constructor reading input from filename.; 421///; 422/// `filename` is assumed to contain at least two columns of numbers.; 423/// The string format is by default `""%lg %lg""`.; 424/// This is a standard c formatting for `scanf()`.; 425/// For example, set format to `""%lg,%lg""` for a comma-separated file.; 426///; 427/// If columns of numbers should be skipped, a `""%*lg""` or `""%*s""` for each column; 428/// can be added, e.g. `""%lg %*lg %lg""` would read x-values from the first and; 429/// y-values from the third column.; 430///; 431/// For files separated by a specific delimiter different from ' ' and '\\t' (e.g.; 432/// ';' in csv files) you can avoid using `%*s` to bypass this delimiter by explicitly; 433/// specify the `option` argument,; 434/// e.g. option=`"" \\t,;""` for columns of figures separated by any of these characters; 435/// (' ', '\\t', ',', ';'); 436/// used once (e.g. `""1;1""`) or in a combined way (`"" 1;,;; 1""`).; 437/// Note in that case, the instantiation is about two times slower.; 438 ; 439TGraph::TGraph(const char *filename, const char *format, Option_t *option); 440 : TNamed(""Graph"", filename), TAttFill(0, 1000); 441{; 442 Double_t x, y;; 443 TString fname = filename;; 444 gSystem->ExpandPathName(fname);; 445 ; 446 std::ifstream infile(fname.Data());; 447 if (!infile.good()) {; 448 MakeZombie();; 449 Error(""TGraph"", ""Cannot open file: %s, TGraph is Zombie"", filename);; 450 fNpoints = 0;; 451 return;; 452 } else {; 453 fNpoints = 100; //initial number of points; 454 }; 455 if (!CtorAllocate()) return;; 456 std::string line;; 457 Int_t np = 0;; 458 ; 459 // No delimiters specified (standard constructor).; 460 if (strcmp(option, """") == 0) {; 46",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:18708,Safety,avoid,avoid,18708,"ken = nullptr ;; 546 token_idx = 0 ;; 547 value_idx = 0 ;; 548 }; 549 Set(np) ;; 550 ; 551 // Cleaning; 552 delete [] isTokenToBeSaved ;; 553 delete [] value ;; 554 delete token ;; 555 }; 556 infile.close();; 557 if (fNpoints == 0) {; 558 Warning(""TGraph"", ""No points were found in file %s with the specified input format %s"", filename, format);; 559 return;; 560 }; 561}; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Graph default destructor.; 565 ; 566TGraph::~TGraph(); 567{; 568 delete [] fX;; 569 delete [] fY;; 570 if (fFunctions) {; 571 fFunctions->SetBit(kInvalidObject);; 572 //special logic to support the case where the same object is; 573 //added multiple times in fFunctions.; 574 //This case happens when the same object is added with different; 575 //drawing modes; 576 TObject *obj;; 577 while ((obj = fFunctions->First())) {; 578 while (fFunctions->Remove(obj)) { }; 579 delete obj;; 580 }; 581 delete fFunctions;; 582 fFunctions = nullptr; //to avoid accessing a deleted object in RecursiveRemove; 583 }; 584 delete fHistogram;; 585}; 586 ; 587////////////////////////////////////////////////////////////////////////////////; 588/// Allocate internal data structures for `newsize` points.; 589 ; 590Double_t **TGraph::Allocate(Int_t newsize); 591{; 592 return AllocateArrays(2, newsize);; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Allocate arrays.; 597 ; 598Double_t** TGraph::AllocateArrays(Int_t Narrays, Int_t arraySize); 599{; 600 if (arraySize < 0) {; 601 arraySize = 0;; 602 }; 603 Double_t **newarrays = new Double_t*[Narrays];; 604 if (!arraySize) {; 605 for (Int_t i = 0; i < Narrays; ++i); 606 newarrays[i] = nullptr;; 607 } else {; 608 for (Int_t i = 0; i < Narrays; ++i); 609 newarrays[i] = new Double_t[arraySize];; 610 }; 611 fMaxSize = arraySize;; 612 return newarrays;; 613}; 614 ; 615//////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:53877,Safety,avoid,avoid,53877,,MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:63121,Safety,avoid,avoid,63121,"st and last point; 1732 Int_t dpx = px - gPad->XtoAbsPixel(gPad->XtoPad(fX[0]));; 1733 Int_t dpy = py - gPad->YtoAbsPixel(gPad->XtoPad(fY[0]));; 1734 if (dpx * dpx + dpy * dpy < 25) ipoint = 0;; 1735 else ipoint = fNpoints;; 1736 }; 1737 ; 1738 ; 1739 InsertPointBefore(ipoint, gPad->AbsPixeltoX(px), gPad->AbsPixeltoY(py));; 1740 ; 1741 gPad->Modified();; 1742 return ipoint;; 1743}; 1744 ; 1745 ; 1746////////////////////////////////////////////////////////////////////////////////; 1747/// Insert a new point with coordinates (x,y) before the point number `ipoint`.; 1748 ; 1749void TGraph::InsertPointBefore(Int_t ipoint, Double_t x, Double_t y); 1750{; 1751 if (ipoint < 0) {; 1752 Error(""TGraph"", ""Inserted point index should be >= 0"");; 1753 return;; 1754 }; 1755 ; 1756 if (ipoint > fNpoints) {; 1757 Error(""TGraph"", ""Inserted point index should be <= %d"", fNpoints);; 1758 return;; 1759 }; 1760 ; 1761 if (ipoint == fNpoints) {; 1762 SetPoint(ipoint, x, y);; 1763 return;; 1764 }; 1765 ; 1766 Double_t **ps = ExpandAndCopy(fNpoints + 1, ipoint);; 1767 CopyAndRelease(ps, ipoint, fNpoints++, ipoint + 1);; 1768 ; 1769 // To avoid redefinitions in descendant classes; 1770 FillZero(ipoint, ipoint + 1);; 1771 ; 1772 fX[ipoint] = x;; 1773 fY[ipoint] = y;; 1774}; 1775 ; 1776 ; 1777////////////////////////////////////////////////////////////////////////////////; 1778/// Integrate the TGraph data within a given (index) range.; 1779/// Note that this function computes the area of the polygon enclosed by the points of the TGraph.; 1780/// The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; 1781/// since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; 1782/// with the first one. It is clear that the order of the point is essential in defining the polygon.; 1783/// Also note that the segments should not intersect.; 1784///; 1785/// NB:; 1786/// - if last=-1 (default) last i",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:84220,Safety,avoid,avoid,84220,"////////////////////////////////////////////////////////; 2322/// Set the maximum of the graph.; 2323 ; 2324void TGraph::SetMaximum(Double_t maximum); 2325{; 2326 fMaximum = maximum;; 2327 GetHistogram()->SetMaximum(maximum);; 2328}; 2329 ; 2330////////////////////////////////////////////////////////////////////////////////; 2331/// Set the minimum of the graph.; 2332 ; 2333void TGraph::SetMinimum(Double_t minimum); 2334{; 2335 fMinimum = minimum;; 2336 GetHistogram()->SetMinimum(minimum);; 2337}; 2338 ; 2339////////////////////////////////////////////////////////////////////////////////; 2340/// Set x and y values for point number i.; 2341 ; 2342void TGraph::SetPoint(Int_t i, Double_t x, Double_t y); 2343{; 2344 if (i < 0) return;; 2345 if (fHistogram) SetBit(kResetHisto);; 2346 ; 2347 if (i >= fMaxSize) {; 2348 Double_t **ps = ExpandAndCopy(i + 1, fNpoints);; 2349 CopyAndRelease(ps, 0, 0, 0);; 2350 }; 2351 if (i >= fNpoints) {; 2352 // points above i can be not initialized; 2353 // set zero up to i-th point to avoid redefinition; 2354 // of this method in descendant classes; 2355 FillZero(fNpoints, i + 1);; 2356 fNpoints = i + 1;; 2357 }; 2358 fX[i] = x;; 2359 fY[i] = y;; 2360 if (gPad) gPad->Modified();; 2361}; 2362 ; 2363////////////////////////////////////////////////////////////////////////////////; 2364/// Set x value for point i.; 2365 ; 2366void TGraph::SetPointX(Int_t i, Double_t x); 2367{; 2368 SetPoint(i, x, GetPointY(i));; 2369}; 2370 ; 2371////////////////////////////////////////////////////////////////////////////////; 2372/// Set y value for point i.; 2373 ; 2374void TGraph::SetPointY(Int_t i, Double_t y); 2375{; 2376 SetPoint(i, GetPointX(i), y);; 2377}; 2378 ; 2379////////////////////////////////////////////////////////////////////////////////; 2380/// Set graph name.; 2381void TGraph::SetName(const char *name); 2382{; 2383 fName = name;; 2384 if (fHistogram) fHistogram->SetName(name);; 2385}; 2386 ; 2387/////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:18714,Security,access,accessing,18714,"ken = nullptr ;; 546 token_idx = 0 ;; 547 value_idx = 0 ;; 548 }; 549 Set(np) ;; 550 ; 551 // Cleaning; 552 delete [] isTokenToBeSaved ;; 553 delete [] value ;; 554 delete token ;; 555 }; 556 infile.close();; 557 if (fNpoints == 0) {; 558 Warning(""TGraph"", ""No points were found in file %s with the specified input format %s"", filename, format);; 559 return;; 560 }; 561}; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Graph default destructor.; 565 ; 566TGraph::~TGraph(); 567{; 568 delete [] fX;; 569 delete [] fY;; 570 if (fFunctions) {; 571 fFunctions->SetBit(kInvalidObject);; 572 //special logic to support the case where the same object is; 573 //added multiple times in fFunctions.; 574 //This case happens when the same object is added with different; 575 //drawing modes; 576 TObject *obj;; 577 while ((obj = fFunctions->First())) {; 578 while (fFunctions->Remove(obj)) { }; 579 delete obj;; 580 }; 581 delete fFunctions;; 582 fFunctions = nullptr; //to avoid accessing a deleted object in RecursiveRemove; 583 }; 584 delete fHistogram;; 585}; 586 ; 587////////////////////////////////////////////////////////////////////////////////; 588/// Allocate internal data structures for `newsize` points.; 589 ; 590Double_t **TGraph::Allocate(Int_t newsize); 591{; 592 return AllocateArrays(2, newsize);; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Allocate arrays.; 597 ; 598Double_t** TGraph::AllocateArrays(Int_t Narrays, Int_t arraySize); 599{; 600 if (arraySize < 0) {; 601 arraySize = 0;; 602 }; 603 Double_t **newarrays = new Double_t*[Narrays];; 604 if (!arraySize) {; 605 for (Int_t i = 0; i < Narrays; ++i); 606 newarrays[i] = nullptr;; 607 } else {; 608 for (Int_t i = 0; i < Narrays; ++i); 609 newarrays[i] = new Double_t[arraySize];; 610 }; 611 fMaxSize = arraySize;; 612 return newarrays;; 613}; 614 ; 615//////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:18340,Testability,log,logic,18340,"TRUE ;; 528 break ;; 529 } else {; 530 value[value_idx] = token_str.Atof() ;; 531 value_idx++ ;; 532 }; 533 }; 534 token = R__STRTOK_R(nullptr, option, &rest); // next token; 535 token_idx++ ;; 536 }; 537 if (!isLineToBeSkipped && value_idx == 2) {; 538 x = value[0] ;; 539 y = value[1] ;; 540 SetPoint(np, x, y) ;; 541 np++ ;; 542 }; 543 }; 544 isLineToBeSkipped = kFALSE ;; 545 token = nullptr ;; 546 token_idx = 0 ;; 547 value_idx = 0 ;; 548 }; 549 Set(np) ;; 550 ; 551 // Cleaning; 552 delete [] isTokenToBeSaved ;; 553 delete [] value ;; 554 delete token ;; 555 }; 556 infile.close();; 557 if (fNpoints == 0) {; 558 Warning(""TGraph"", ""No points were found in file %s with the specified input format %s"", filename, format);; 559 return;; 560 }; 561}; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Graph default destructor.; 565 ; 566TGraph::~TGraph(); 567{; 568 delete [] fX;; 569 delete [] fY;; 570 if (fFunctions) {; 571 fFunctions->SetBit(kInvalidObject);; 572 //special logic to support the case where the same object is; 573 //added multiple times in fFunctions.; 574 //This case happens when the same object is added with different; 575 //drawing modes; 576 TObject *obj;; 577 while ((obj = fFunctions->First())) {; 578 while (fFunctions->Remove(obj)) { }; 579 delete obj;; 580 }; 581 delete fFunctions;; 582 fFunctions = nullptr; //to avoid accessing a deleted object in RecursiveRemove; 583 }; 584 delete fHistogram;; 585}; 586 ; 587////////////////////////////////////////////////////////////////////////////////; 588/// Allocate internal data structures for `newsize` points.; 589 ; 590Double_t **TGraph::Allocate(Int_t newsize); 591{; 592 return AllocateArrays(2, newsize);; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Allocate arrays.; 597 ; 598Double_t** TGraph::AllocateArrays(Int_t Narrays, Int_t arraySize); 599{; 600 if (arraySize < 0) {; 601 arraySize = 0;; 602 }; 60",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:24257,Testability,log,log,24257,"t, Int_t right); 714{; 715 return gr->fY[left] > gr->fY[right];; 716}; 717 ; 718////////////////////////////////////////////////////////////////////////////////; 719/// Return kTRUE if point number ""left""'s distance to origin is bigger than; 720/// that of point number ""right"". Can be used by Sort.; 721 ; 722Bool_t TGraph::CompareRadius(const TGraph* gr, Int_t left, Int_t right); 723{; 724 return gr->fX[left] * gr->fX[left] + gr->fY[left] * gr->fY[left]; 725 > gr->fX[right] * gr->fX[right] + gr->fY[right] * gr->fY[right];; 726}; 727 ; 728////////////////////////////////////////////////////////////////////////////////; 729/// Compute the x/y range of the points in this graph; 730 ; 731void TGraph::ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const; 732{; 733 if (fNpoints <= 0) {; 734 xmin = xmax = ymin = ymax = 0;; 735 return;; 736 }; 737 xmin = xmax = fX[0];; 738 ymin = ymax = fY[0];; 739 ; 740 Double_t xminl = 0; // Positive minimum. Used in case of log scale along X axis.; 741 Double_t yminl = 0; // Positive minimum. Used in case of log scale along Y axis.; 742 ; 743 for (Int_t i = 1; i < fNpoints; i++) {; 744 if (fX[i] < xmin) xmin = fX[i];; 745 if (fX[i] > xmax) xmax = fX[i];; 746 if (fY[i] < ymin) ymin = fY[i];; 747 if (fY[i] > ymax) ymax = fY[i];; 748 if (ymin>0 && (yminl==0 || ymin<yminl)) yminl = ymin;; 749 if (xmin>0 && (xminl==0 || xmin<xminl)) xminl = xmin;; 750 }; 751 ; 752 if (gPad && gPad->GetLogy() && yminl>0) ymin = yminl;; 753 if (gPad && gPad->GetLogx() && xminl>0) xmin = xminl;; 754}; 755 ; 756////////////////////////////////////////////////////////////////////////////////; 757/// Copy points from fX and fY to arrays[0] and arrays[1]; 758/// or to fX and fY if arrays == 0 and ibegin != iend.; 759/// If newarrays is non null, replace fX, fY with pointers from newarrays[0,1].; 760/// Delete newarrays, old fX and fY; 761 ; 762void TGraph::CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend,; 763 Int_t obegin)",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:24343,Testability,log,log,24343,"//////////////////////////////////////////////////////////////////////////; 719/// Return kTRUE if point number ""left""'s distance to origin is bigger than; 720/// that of point number ""right"". Can be used by Sort.; 721 ; 722Bool_t TGraph::CompareRadius(const TGraph* gr, Int_t left, Int_t right); 723{; 724 return gr->fX[left] * gr->fX[left] + gr->fY[left] * gr->fY[left]; 725 > gr->fX[right] * gr->fX[right] + gr->fY[right] * gr->fY[right];; 726}; 727 ; 728////////////////////////////////////////////////////////////////////////////////; 729/// Compute the x/y range of the points in this graph; 730 ; 731void TGraph::ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const; 732{; 733 if (fNpoints <= 0) {; 734 xmin = xmax = ymin = ymax = 0;; 735 return;; 736 }; 737 xmin = xmax = fX[0];; 738 ymin = ymax = fY[0];; 739 ; 740 Double_t xminl = 0; // Positive minimum. Used in case of log scale along X axis.; 741 Double_t yminl = 0; // Positive minimum. Used in case of log scale along Y axis.; 742 ; 743 for (Int_t i = 1; i < fNpoints; i++) {; 744 if (fX[i] < xmin) xmin = fX[i];; 745 if (fX[i] > xmax) xmax = fX[i];; 746 if (fY[i] < ymin) ymin = fY[i];; 747 if (fY[i] > ymax) ymax = fY[i];; 748 if (ymin>0 && (yminl==0 || ymin<yminl)) yminl = ymin;; 749 if (xmin>0 && (xminl==0 || xmin<xminl)) xminl = xmin;; 750 }; 751 ; 752 if (gPad && gPad->GetLogy() && yminl>0) ymin = yminl;; 753 if (gPad && gPad->GetLogx() && xminl>0) xmin = xminl;; 754}; 755 ; 756////////////////////////////////////////////////////////////////////////////////; 757/// Copy points from fX and fY to arrays[0] and arrays[1]; 758/// or to fX and fY if arrays == 0 and ibegin != iend.; 759/// If newarrays is non null, replace fX, fY with pointers from newarrays[0,1].; 760/// Delete newarrays, old fX and fY; 761 ; 762void TGraph::CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend,; 763 Int_t obegin); 764{; 765 CopyPoints(newarrays, ibegin, iend, obegin);; 766 if (newarrays) {; 767 de",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:34192,Testability,assert,assert,34192,"rt[0], fNpoints);; 982 Double_t result = s.Eval(x);; 983 return result;; 984 }; 985 }; 986 //linear interpolation; 987 //In case x is < fX[0] or > fX[fNpoints-1] return the extrapolated point; 988 ; 989 //find points in graph around x assuming points are not sorted; 990 // (if point are sorted use a binary search); 991 Int_t low = -1;; 992 Int_t up = -1;; 993 if (TestBit(TGraph::kIsSortedX) ) {; 994 low = TMath::BinarySearch(fNpoints, fX, x);; 995 if (low == -1) {; 996 // use first two points for doing an extrapolation; 997 low = 0;; 998 }; 999 if (fX[low] == x) return fY[low];; 1000 if (low == fNpoints-1) low--; // for extrapolating; 1001 up = low+1;; 1002 }; 1003 else {; 1004 // case TGraph is not sorted; 1005 ; 1006 // find neighbours simply looping all points; 1007 // and find also the 2 adjacent points: (low2 < low < x < up < up2 ); 1008 // needed in case x is outside the graph ascissa interval; 1009 Int_t low2 = -1;; 1010 Int_t up2 = -1;; 1011 ; 1012 for (Int_t i = 0; i < fNpoints; ++i) {; 1013 if (fX[i] < x) {; 1014 if (low == -1 || fX[i] > fX[low]) {; 1015 low2 = low;; 1016 low = i;; 1017 } else if (low2 == -1) low2 = i;; 1018 } else if (fX[i] > x) {; 1019 if (up == -1 || fX[i] < fX[up]) {; 1020 up2 = up;; 1021 up = i;; 1022 } else if (up2 == -1) up2 = i;; 1023 } else // case x == fX[i]; 1024 return fY[i]; // no interpolation needed; 1025 }; 1026 ; 1027 // treat cases when x is outside graph min max abscissa; 1028 if (up == -1) {; 1029 up = low;; 1030 low = low2;; 1031 }; 1032 if (low == -1) {; 1033 low = up;; 1034 up = up2;; 1035 }; 1036 }; 1037 // do now the linear interpolation; 1038 assert(low != -1 && up != -1);; 1039 ; 1040 if (fX[low] == fX[up]) return fY[low];; 1041 Double_t yn = fY[up] + (x - fX[up]) * (fY[low] - fY[up]) / (fX[low] - fX[up]);; 1042 return yn;; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// Execute action corresponding to one event.; 1047///; 1048/// This member function is ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:51618,Testability,log,log,51618,"///////////////////////////////////////////////; 1411/// Return pointer to function with name.; 1412///; 1413/// Functions such as TGraph::Fit store the fitted function in the list of; 1414/// functions of this graph.; 1415 ; 1416TF1 *TGraph::GetFunction(const char *name) const; 1417{; 1418 if (!fFunctions) return nullptr;; 1419 return (TF1*)fFunctions->FindObject(name);; 1420}; 1421 ; 1422////////////////////////////////////////////////////////////////////////////////; 1423/// Returns a pointer to the histogram used to draw the axis; 1424/// Takes into account the two following cases.; 1425/// 1. option 'A' was specified in TGraph::Draw. Return fHistogram; 1426/// 2. user had called TPad::DrawFrame. return pointer to hframe histogram; 1427 ; 1428TH1F *TGraph::GetHistogram() const; 1429{; 1430 Double_t rwxmin, rwxmax, rwymin, rwymax, maximum, minimum, dx, dy;; 1431 Double_t uxmin, uxmax;; 1432 ; 1433 ComputeRange(rwxmin, rwymin, rwxmax, rwymax); //this is redefined in TGraphErrors; 1434 ; 1435 // (if fHistogram exist) && (if the log scale is on) &&; 1436 // (if the computed range minimum is > 0) && (if the fHistogram minimum is zero); 1437 // then it means fHistogram limits have been computed in linear scale; 1438 // therefore they might be too strict and cut some points. In that case the; 1439 // fHistogram limits should be recomputed ie: the existing fHistogram; 1440 // should not be returned.; 1441 TH1F *historg = nullptr;; 1442 if (fHistogram) {; 1443 if (!TestBit(kResetHisto)) {; 1444 if (gPad && gPad->GetLogx()) {; 1445 if (rwxmin <= 0 || fHistogram->GetXaxis()->GetXmin() != 0) return fHistogram;; 1446 } else if (gPad && gPad->GetLogy()) {; 1447 if (rwymin <= 0 || fHistogram->GetMinimum() != 0) return fHistogram;; 1448 } else {; 1449 return fHistogram;; 1450 }; 1451 } else {; 1452 const_cast <TGraph*>(this)->ResetBit(kResetHisto);; 1453 }; 1454 historg = fHistogram;; 1455 }; 1456 ; 1457 if (rwxmin == rwxmax) rwxmax += 1.;; 1458 if (rwymin == rwymax) rwymax += 1",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:64418,Testability,test,test,64418," area of the polygon enclosed by the points of the TGraph.; 1780/// The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; 1781/// since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; 1782/// with the first one. It is clear that the order of the point is essential in defining the polygon.; 1783/// Also note that the segments should not intersect.; 1784///; 1785/// NB:; 1786/// - if last=-1 (default) last is set to the last point.; 1787/// - if (first <0) the first point (0) is taken.; 1788///; 1789/// ### Method:; 1790///; 1791/// There are many ways to calculate the surface of a polygon. It all depends on what kind of data; 1792/// you have to deal with. The most evident solution would be to divide the polygon in triangles and; 1793/// calculate the surface of them. But this can quickly become complicated as you will have to test; 1794/// every segments of every triangles and check if they are intersecting with a current polygon's; 1795/// segment or if it goes outside the polygon. Many calculations that would lead to many problems...; 1796///; 1797/// ### The solution (implemented by R.Brun); 1798/// Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; 1799/// segments don't intersect.; 1800/// It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; 1801/// vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied; 1802/// by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area.; 1803///; 1804/// ### Sources; 1805/// - http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; 1806/// - http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon; 1807 ; 1808Double_t TGraph::Integral(Int_t first, Int_t last) const; 1809{; 1810 if (first < 0) first = 0;; 1811 i",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:69045,Testability,log,logarithm,69045," xmin || xk > xmax) continue;; 1887 np++;; 1888 yk = fY[k];; 1889 power = one;; 1890 da[0] += yk;; 1891 for (l = 2; l <= m; ++l) {; 1892 power *= xk;; 1893 b[l-1] += power;; 1894 da[l-1] += power * yk;; 1895 }; 1896 for (l = 2; l <= m; ++l) {; 1897 power *= xk;; 1898 b[m + l*20 - 21] += power;; 1899 }; 1900 }; 1901 b[0] = Double_t(np);; 1902 for (i = 3; i <= m; ++i) {; 1903 for (k = i; k <= m; ++k) {; 1904 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 1905 }; 1906 }; 1907 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 1908 ; 1909 if (ifail < 0) {; 1910 a[0] = fY[0];; 1911 for (i = 1; i < m; ++i) a[i] = 0;; 1912 return;; 1913 }; 1914 for (i = 0; i < m; ++i) a[i] = da[i];; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Least square linear fit without weights.; 1919///; 1920/// Fit a straight line (a0 + a1*x) to the data in this graph.; 1921///; 1922/// \param [in] ndata if ndata<0, fits the logarithm of the graph (used in InitExpo() to set; 1923/// the initial parameter values for a fit with exponential function.; 1924/// \param [in] a0 constant; 1925/// \param [in] a1 slope; 1926/// \param [in] ifail return parameter indicating the status of the fit (ifail=0, fit is OK); 1927/// \param [in] xmin, xmax fitting range; 1928///; 1929/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 1930 ; 1931void TGraph::LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t &a1, Int_t &ifail, Double_t xmin, Double_t xmax); 1932{; 1933 Double_t xbar, ybar, x2bar;; 1934 Int_t i;; 1935 Double_t xybar;; 1936 Double_t fn, xk, yk;; 1937 Double_t det;; 1938 if (xmax <= xmin) {; 1939 xmin = fX[0];; 1940 xmax = fX[fNpoints-1];; 1941 }; 1942 ; 1943 ifail = -2;; 1944 xbar = ybar = x2bar = xybar = 0;; 1945 Int_t np = 0;; 1946 for (i = 0; i < fNpoints; ++i) {; 1947 xk = fX[i];; 1948 if (xk < xmin || xk > xmax) continue;; 1949 np++;; 1950 yk = fY[i];; 1951 if (ndata < 0) {; 1952 if (yk <= 0) yk = 1e-9;; 1953 yk = TMath",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:96065,Testability,log,log,96065,"///////////////////////////////////////; 2655/// Adds all graphs from the collection to this graph.; 2656/// Returns the total number of points in the result or -1 in case of an error.; 2657 ; 2658Int_t TGraph::Merge(TCollection* li); 2659{; 2660 TIter next(li);; 2661 while (TObject* o = next()) {; 2662 TGraph *g = dynamic_cast<TGraph*>(o);; 2663 if (!g) {; 2664 Error(""Merge"",; 2665 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 2666 return -1;; 2667 }; 2668 DoMerge(g);; 2669 }; 2670 return GetN();; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// protected function to perform the merge operation of a graph; 2675 ; 2676Bool_t TGraph::DoMerge(const TGraph* g); 2677{; 2678 Double_t x = 0, y = 0;; 2679 for (Int_t i = 0 ; i < g->GetN(); i++) {; 2680 g->GetPoint(i, x, y);; 2681 SetPoint(GetN(), x, y);; 2682 }; 2683 return kTRUE;; 2684}; 2685 ; 2686////////////////////////////////////////////////////////////////////////////////; 2687/// Move all graph points on specified values dx,dy; 2688/// If log argument specified, calculation done in logarithmic scale like:; 2689/// new_value = exp( log(old_value) + delta );; 2690 ; 2691void TGraph::MovePoints(Double_t dx, Double_t dy, Bool_t logx, Bool_t logy); 2692{; 2693 Double_t x = 0, y = 0;; 2694 for (Int_t i = 0 ; i < GetN(); i++) {; 2695 GetPoint(i, x, y);; 2696 if (!logx) {; 2697 x += dx;; 2698 } else if (x > 0) {; 2699 x = TMath::Exp(TMath::Log(x) + dx);; 2700 }; 2701 if (!logy) {; 2702 y += dy;; 2703 } else if (y > 0) {; 2704 y = TMath::Exp(TMath::Log(y) + dy);; 2705 }; 2706 SetPoint(i, x, y);; 2707 }; 2708}; 2709 ; 2710 ; 2711////////////////////////////////////////////////////////////////////////////////; 2712/// Find zero of a continuous function.; 2713/// This function finds a real zero of the continuous real; 2714/// function Y(X) in a given interval (A,B). See accompanying; 2715/// notes for details of the argument list and ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:96109,Testability,log,logarithmic,96109,"///////////////////////////////////////; 2655/// Adds all graphs from the collection to this graph.; 2656/// Returns the total number of points in the result or -1 in case of an error.; 2657 ; 2658Int_t TGraph::Merge(TCollection* li); 2659{; 2660 TIter next(li);; 2661 while (TObject* o = next()) {; 2662 TGraph *g = dynamic_cast<TGraph*>(o);; 2663 if (!g) {; 2664 Error(""Merge"",; 2665 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 2666 return -1;; 2667 }; 2668 DoMerge(g);; 2669 }; 2670 return GetN();; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// protected function to perform the merge operation of a graph; 2675 ; 2676Bool_t TGraph::DoMerge(const TGraph* g); 2677{; 2678 Double_t x = 0, y = 0;; 2679 for (Int_t i = 0 ; i < g->GetN(); i++) {; 2680 g->GetPoint(i, x, y);; 2681 SetPoint(GetN(), x, y);; 2682 }; 2683 return kTRUE;; 2684}; 2685 ; 2686////////////////////////////////////////////////////////////////////////////////; 2687/// Move all graph points on specified values dx,dy; 2688/// If log argument specified, calculation done in logarithmic scale like:; 2689/// new_value = exp( log(old_value) + delta );; 2690 ; 2691void TGraph::MovePoints(Double_t dx, Double_t dy, Bool_t logx, Bool_t logy); 2692{; 2693 Double_t x = 0, y = 0;; 2694 for (Int_t i = 0 ; i < GetN(); i++) {; 2695 GetPoint(i, x, y);; 2696 if (!logx) {; 2697 x += dx;; 2698 } else if (x > 0) {; 2699 x = TMath::Exp(TMath::Log(x) + dx);; 2700 }; 2701 if (!logy) {; 2702 y += dy;; 2703 } else if (y > 0) {; 2704 y = TMath::Exp(TMath::Log(y) + dy);; 2705 }; 2706 SetPoint(i, x, y);; 2707 }; 2708}; 2709 ; 2710 ; 2711////////////////////////////////////////////////////////////////////////////////; 2712/// Find zero of a continuous function.; 2713/// This function finds a real zero of the continuous real; 2714/// function Y(X) in a given interval (A,B). See accompanying; 2715/// notes for details of the argument list and ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:96159,Testability,log,log,96159,"///////////////////////////////////////; 2655/// Adds all graphs from the collection to this graph.; 2656/// Returns the total number of points in the result or -1 in case of an error.; 2657 ; 2658Int_t TGraph::Merge(TCollection* li); 2659{; 2660 TIter next(li);; 2661 while (TObject* o = next()) {; 2662 TGraph *g = dynamic_cast<TGraph*>(o);; 2663 if (!g) {; 2664 Error(""Merge"",; 2665 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 2666 return -1;; 2667 }; 2668 DoMerge(g);; 2669 }; 2670 return GetN();; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// protected function to perform the merge operation of a graph; 2675 ; 2676Bool_t TGraph::DoMerge(const TGraph* g); 2677{; 2678 Double_t x = 0, y = 0;; 2679 for (Int_t i = 0 ; i < g->GetN(); i++) {; 2680 g->GetPoint(i, x, y);; 2681 SetPoint(GetN(), x, y);; 2682 }; 2683 return kTRUE;; 2684}; 2685 ; 2686////////////////////////////////////////////////////////////////////////////////; 2687/// Move all graph points on specified values dx,dy; 2688/// If log argument specified, calculation done in logarithmic scale like:; 2689/// new_value = exp( log(old_value) + delta );; 2690 ; 2691void TGraph::MovePoints(Double_t dx, Double_t dy, Bool_t logx, Bool_t logy); 2692{; 2693 Double_t x = 0, y = 0;; 2694 for (Int_t i = 0 ; i < GetN(); i++) {; 2695 GetPoint(i, x, y);; 2696 if (!logx) {; 2697 x += dx;; 2698 } else if (x > 0) {; 2699 x = TMath::Exp(TMath::Log(x) + dx);; 2700 }; 2701 if (!logy) {; 2702 y += dy;; 2703 } else if (y > 0) {; 2704 y = TMath::Exp(TMath::Log(y) + dy);; 2705 }; 2706 SetPoint(i, x, y);; 2707 }; 2708}; 2709 ; 2710 ; 2711////////////////////////////////////////////////////////////////////////////////; 2712/// Find zero of a continuous function.; 2713/// This function finds a real zero of the continuous real; 2714/// function Y(X) in a given interval (A,B). See accompanying; 2715/// notes for details of the argument list and ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:96254,Testability,log,logx,96254,"///////////////////////////////////////; 2655/// Adds all graphs from the collection to this graph.; 2656/// Returns the total number of points in the result or -1 in case of an error.; 2657 ; 2658Int_t TGraph::Merge(TCollection* li); 2659{; 2660 TIter next(li);; 2661 while (TObject* o = next()) {; 2662 TGraph *g = dynamic_cast<TGraph*>(o);; 2663 if (!g) {; 2664 Error(""Merge"",; 2665 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 2666 return -1;; 2667 }; 2668 DoMerge(g);; 2669 }; 2670 return GetN();; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// protected function to perform the merge operation of a graph; 2675 ; 2676Bool_t TGraph::DoMerge(const TGraph* g); 2677{; 2678 Double_t x = 0, y = 0;; 2679 for (Int_t i = 0 ; i < g->GetN(); i++) {; 2680 g->GetPoint(i, x, y);; 2681 SetPoint(GetN(), x, y);; 2682 }; 2683 return kTRUE;; 2684}; 2685 ; 2686////////////////////////////////////////////////////////////////////////////////; 2687/// Move all graph points on specified values dx,dy; 2688/// If log argument specified, calculation done in logarithmic scale like:; 2689/// new_value = exp( log(old_value) + delta );; 2690 ; 2691void TGraph::MovePoints(Double_t dx, Double_t dy, Bool_t logx, Bool_t logy); 2692{; 2693 Double_t x = 0, y = 0;; 2694 for (Int_t i = 0 ; i < GetN(); i++) {; 2695 GetPoint(i, x, y);; 2696 if (!logx) {; 2697 x += dx;; 2698 } else if (x > 0) {; 2699 x = TMath::Exp(TMath::Log(x) + dx);; 2700 }; 2701 if (!logy) {; 2702 y += dy;; 2703 } else if (y > 0) {; 2704 y = TMath::Exp(TMath::Log(y) + dy);; 2705 }; 2706 SetPoint(i, x, y);; 2707 }; 2708}; 2709 ; 2710 ; 2711////////////////////////////////////////////////////////////////////////////////; 2712/// Find zero of a continuous function.; 2713/// This function finds a real zero of the continuous real; 2714/// function Y(X) in a given interval (A,B). See accompanying; 2715/// notes for details of the argument list and ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:96267,Testability,log,logy,96267,"///////////////////////////////////////; 2655/// Adds all graphs from the collection to this graph.; 2656/// Returns the total number of points in the result or -1 in case of an error.; 2657 ; 2658Int_t TGraph::Merge(TCollection* li); 2659{; 2660 TIter next(li);; 2661 while (TObject* o = next()) {; 2662 TGraph *g = dynamic_cast<TGraph*>(o);; 2663 if (!g) {; 2664 Error(""Merge"",; 2665 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 2666 return -1;; 2667 }; 2668 DoMerge(g);; 2669 }; 2670 return GetN();; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// protected function to perform the merge operation of a graph; 2675 ; 2676Bool_t TGraph::DoMerge(const TGraph* g); 2677{; 2678 Double_t x = 0, y = 0;; 2679 for (Int_t i = 0 ; i < g->GetN(); i++) {; 2680 g->GetPoint(i, x, y);; 2681 SetPoint(GetN(), x, y);; 2682 }; 2683 return kTRUE;; 2684}; 2685 ; 2686////////////////////////////////////////////////////////////////////////////////; 2687/// Move all graph points on specified values dx,dy; 2688/// If log argument specified, calculation done in logarithmic scale like:; 2689/// new_value = exp( log(old_value) + delta );; 2690 ; 2691void TGraph::MovePoints(Double_t dx, Double_t dy, Bool_t logx, Bool_t logy); 2692{; 2693 Double_t x = 0, y = 0;; 2694 for (Int_t i = 0 ; i < GetN(); i++) {; 2695 GetPoint(i, x, y);; 2696 if (!logx) {; 2697 x += dx;; 2698 } else if (x > 0) {; 2699 x = TMath::Exp(TMath::Log(x) + dx);; 2700 }; 2701 if (!logy) {; 2702 y += dy;; 2703 } else if (y > 0) {; 2704 y = TMath::Exp(TMath::Log(y) + dy);; 2705 }; 2706 SetPoint(i, x, y);; 2707 }; 2708}; 2709 ; 2710 ; 2711////////////////////////////////////////////////////////////////////////////////; 2712/// Find zero of a continuous function.; 2713/// This function finds a real zero of the continuous real; 2714/// function Y(X) in a given interval (A,B). See accompanying; 2715/// notes for details of the argument list and ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:96389,Testability,log,logx,96389,"///////////////////////////////////////; 2655/// Adds all graphs from the collection to this graph.; 2656/// Returns the total number of points in the result or -1 in case of an error.; 2657 ; 2658Int_t TGraph::Merge(TCollection* li); 2659{; 2660 TIter next(li);; 2661 while (TObject* o = next()) {; 2662 TGraph *g = dynamic_cast<TGraph*>(o);; 2663 if (!g) {; 2664 Error(""Merge"",; 2665 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 2666 return -1;; 2667 }; 2668 DoMerge(g);; 2669 }; 2670 return GetN();; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// protected function to perform the merge operation of a graph; 2675 ; 2676Bool_t TGraph::DoMerge(const TGraph* g); 2677{; 2678 Double_t x = 0, y = 0;; 2679 for (Int_t i = 0 ; i < g->GetN(); i++) {; 2680 g->GetPoint(i, x, y);; 2681 SetPoint(GetN(), x, y);; 2682 }; 2683 return kTRUE;; 2684}; 2685 ; 2686////////////////////////////////////////////////////////////////////////////////; 2687/// Move all graph points on specified values dx,dy; 2688/// If log argument specified, calculation done in logarithmic scale like:; 2689/// new_value = exp( log(old_value) + delta );; 2690 ; 2691void TGraph::MovePoints(Double_t dx, Double_t dy, Bool_t logx, Bool_t logy); 2692{; 2693 Double_t x = 0, y = 0;; 2694 for (Int_t i = 0 ; i < GetN(); i++) {; 2695 GetPoint(i, x, y);; 2696 if (!logx) {; 2697 x += dx;; 2698 } else if (x > 0) {; 2699 x = TMath::Exp(TMath::Log(x) + dx);; 2700 }; 2701 if (!logy) {; 2702 y += dy;; 2703 } else if (y > 0) {; 2704 y = TMath::Exp(TMath::Log(y) + dy);; 2705 }; 2706 SetPoint(i, x, y);; 2707 }; 2708}; 2709 ; 2710 ; 2711////////////////////////////////////////////////////////////////////////////////; 2712/// Find zero of a continuous function.; 2713/// This function finds a real zero of the continuous real; 2714/// function Y(X) in a given interval (A,B). See accompanying; 2715/// notes for details of the argument list and ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:96499,Testability,log,logy,96499,"///////////////////////////////////////; 2655/// Adds all graphs from the collection to this graph.; 2656/// Returns the total number of points in the result or -1 in case of an error.; 2657 ; 2658Int_t TGraph::Merge(TCollection* li); 2659{; 2660 TIter next(li);; 2661 while (TObject* o = next()) {; 2662 TGraph *g = dynamic_cast<TGraph*>(o);; 2663 if (!g) {; 2664 Error(""Merge"",; 2665 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 2666 return -1;; 2667 }; 2668 DoMerge(g);; 2669 }; 2670 return GetN();; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// protected function to perform the merge operation of a graph; 2675 ; 2676Bool_t TGraph::DoMerge(const TGraph* g); 2677{; 2678 Double_t x = 0, y = 0;; 2679 for (Int_t i = 0 ; i < g->GetN(); i++) {; 2680 g->GetPoint(i, x, y);; 2681 SetPoint(GetN(), x, y);; 2682 }; 2683 return kTRUE;; 2684}; 2685 ; 2686////////////////////////////////////////////////////////////////////////////////; 2687/// Move all graph points on specified values dx,dy; 2688/// If log argument specified, calculation done in logarithmic scale like:; 2689/// new_value = exp( log(old_value) + delta );; 2690 ; 2691void TGraph::MovePoints(Double_t dx, Double_t dy, Bool_t logx, Bool_t logy); 2692{; 2693 Double_t x = 0, y = 0;; 2694 for (Int_t i = 0 ; i < GetN(); i++) {; 2695 GetPoint(i, x, y);; 2696 if (!logx) {; 2697 x += dx;; 2698 } else if (x > 0) {; 2699 x = TMath::Exp(TMath::Log(x) + dx);; 2700 }; 2701 if (!logy) {; 2702 y += dy;; 2703 } else if (y > 0) {; 2704 y = TMath::Exp(TMath::Log(y) + dy);; 2705 }; 2706 SetPoint(i, x, y);; 2707 }; 2708}; 2709 ; 2710 ; 2711////////////////////////////////////////////////////////////////////////////////; 2712/// Find zero of a continuous function.; 2713/// This function finds a real zero of the continuous real; 2714/// function Y(X) in a given interval (A,B). See accompanying; 2715/// notes for details of the argument list and ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:115312,Testability,log,logx,115312," (axis=2)Definition TGraph.cxx:1339; TGraph::fHistogramTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:50; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::kNotEditable@ kNotEditableBit set if graph is non editable.Definition TGraph.h:78; TGraph::kIsHighlight@ kIsHighlightBit set if graph is highlight.Definition TGraph.h:80; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TGraph::kClipFrame@ kClipFrameClip to the frame boundary.Definition TGraph.h:76; TGraph::kResetHisto@ kResetHistofHistogram must be reset in GetHistogramDefinition TGraph.h:77; TGraph::kNoStats@ kNoStatsDon't draw stats box.Definition TGraph.h:75; TGraph::GetErrorXlowvirtual Double_t GetErrorXlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1387; TGraph::MovePointsvirtual void MovePoints(Double_t dx, Double_t dy, Bool_t logx=kFALSE, Bool_t logy=kFALSE)Move all graph points on specified values dx,dy If log argument specified, calculation done in logari...Definition TGraph.cxx:2691; TGraph::GetErrorYlowvirtual Double_t GetErrorYlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1405; TGraph::UpdateArraysvirtual void UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low)Update the fX and fY arrays with the sorted values.Definition TGraph.cxx:2592; TGraph::CopyAndReleasevirtual void CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:762; TGraph::GetMinimumDouble_t GetMinimum() constDefinition TGraph.h:152; TGraph::Printvoid Print(Option_t *chopt="""") const overridePrint graph values.Definition TGraph.cxx:2013; TGraph::GetEYlowvirtual Double_t * GetEYlow() constDefinition TGraph.h:146; TGraph::SetMaximumvirtual void SetMaximu",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:115332,Testability,log,logy,115332," (axis=2)Definition TGraph.cxx:1339; TGraph::fHistogramTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:50; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::kNotEditable@ kNotEditableBit set if graph is non editable.Definition TGraph.h:78; TGraph::kIsHighlight@ kIsHighlightBit set if graph is highlight.Definition TGraph.h:80; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TGraph::kClipFrame@ kClipFrameClip to the frame boundary.Definition TGraph.h:76; TGraph::kResetHisto@ kResetHistofHistogram must be reset in GetHistogramDefinition TGraph.h:77; TGraph::kNoStats@ kNoStatsDon't draw stats box.Definition TGraph.h:75; TGraph::GetErrorXlowvirtual Double_t GetErrorXlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1387; TGraph::MovePointsvirtual void MovePoints(Double_t dx, Double_t dy, Bool_t logx=kFALSE, Bool_t logy=kFALSE)Move all graph points on specified values dx,dy If log argument specified, calculation done in logari...Definition TGraph.cxx:2691; TGraph::GetErrorYlowvirtual Double_t GetErrorYlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1405; TGraph::UpdateArraysvirtual void UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low)Update the fX and fY arrays with the sorted values.Definition TGraph.cxx:2592; TGraph::CopyAndReleasevirtual void CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:762; TGraph::GetMinimumDouble_t GetMinimum() constDefinition TGraph.h:152; TGraph::Printvoid Print(Option_t *chopt="""") const overridePrint graph values.Definition TGraph.cxx:2013; TGraph::GetEYlowvirtual Double_t * GetEYlow() constDefinition TGraph.h:146; TGraph::SetMaximumvirtual void SetMaximu",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:115395,Testability,log,log,115395," (axis=2)Definition TGraph.cxx:1339; TGraph::fHistogramTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:50; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::kNotEditable@ kNotEditableBit set if graph is non editable.Definition TGraph.h:78; TGraph::kIsHighlight@ kIsHighlightBit set if graph is highlight.Definition TGraph.h:80; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TGraph::kClipFrame@ kClipFrameClip to the frame boundary.Definition TGraph.h:76; TGraph::kResetHisto@ kResetHistofHistogram must be reset in GetHistogramDefinition TGraph.h:77; TGraph::kNoStats@ kNoStatsDon't draw stats box.Definition TGraph.h:75; TGraph::GetErrorXlowvirtual Double_t GetErrorXlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1387; TGraph::MovePointsvirtual void MovePoints(Double_t dx, Double_t dy, Bool_t logx=kFALSE, Bool_t logy=kFALSE)Move all graph points on specified values dx,dy If log argument specified, calculation done in logari...Definition TGraph.cxx:2691; TGraph::GetErrorYlowvirtual Double_t GetErrorYlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1405; TGraph::UpdateArraysvirtual void UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low)Update the fX and fY arrays with the sorted values.Definition TGraph.cxx:2592; TGraph::CopyAndReleasevirtual void CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:762; TGraph::GetMinimumDouble_t GetMinimum() constDefinition TGraph.h:152; TGraph::Printvoid Print(Option_t *chopt="""") const overridePrint graph values.Definition TGraph.cxx:2013; TGraph::GetEYlowvirtual Double_t * GetEYlow() constDefinition TGraph.h:146; TGraph::SetMaximumvirtual void SetMaximu",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:115439,Testability,log,logari,115439," (axis=2)Definition TGraph.cxx:1339; TGraph::fHistogramTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:50; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::kNotEditable@ kNotEditableBit set if graph is non editable.Definition TGraph.h:78; TGraph::kIsHighlight@ kIsHighlightBit set if graph is highlight.Definition TGraph.h:80; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TGraph::kClipFrame@ kClipFrameClip to the frame boundary.Definition TGraph.h:76; TGraph::kResetHisto@ kResetHistofHistogram must be reset in GetHistogramDefinition TGraph.h:77; TGraph::kNoStats@ kNoStatsDon't draw stats box.Definition TGraph.h:75; TGraph::GetErrorXlowvirtual Double_t GetErrorXlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1387; TGraph::MovePointsvirtual void MovePoints(Double_t dx, Double_t dy, Bool_t logx=kFALSE, Bool_t logy=kFALSE)Move all graph points on specified values dx,dy If log argument specified, calculation done in logari...Definition TGraph.cxx:2691; TGraph::GetErrorYlowvirtual Double_t GetErrorYlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1405; TGraph::UpdateArraysvirtual void UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low)Update the fX and fY arrays with the sorted values.Definition TGraph.cxx:2592; TGraph::CopyAndReleasevirtual void CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:762; TGraph::GetMinimumDouble_t GetMinimum() constDefinition TGraph.h:152; TGraph::Printvoid Print(Option_t *chopt="""") const overridePrint graph values.Definition TGraph.cxx:2013; TGraph::GetEYlowvirtual Double_t * GetEYlow() constDefinition TGraph.h:146; TGraph::SetMaximumvirtual void SetMaximu",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:139448,Testability,log,logarithm,139448,"led from TH1::Fit)Definition HFitImpl.cxx:972; ROOT::Fit::Chisquaredouble Chisquare(const TH1 &h1, TF1 &f1, bool useRange, EChisquareType type)compute the chi2 value for an histogram given a function (see TH1::Chisquare for the documentation)Definition HFitImpl.cxx:1027; ROOT::Fit::FitOptionsMakevoid FitOptionsMake(EFitObjectType type, const char *option, Foption_t &fitOption)Decode list of options into fitOption.Definition HFitImpl.cxx:685; ROOT::Fit::EFitObjectType::kGraph@ kGraph; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; Foption_tDefinition Foption.h:24; Drawth1 Draw(); mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. histhistsrcTGraph.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:33 (GVA Time) using Doxygen 1.",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:33318,Usability,simpl,simply,33318,"rt[0], fNpoints);; 982 Double_t result = s.Eval(x);; 983 return result;; 984 }; 985 }; 986 //linear interpolation; 987 //In case x is < fX[0] or > fX[fNpoints-1] return the extrapolated point; 988 ; 989 //find points in graph around x assuming points are not sorted; 990 // (if point are sorted use a binary search); 991 Int_t low = -1;; 992 Int_t up = -1;; 993 if (TestBit(TGraph::kIsSortedX) ) {; 994 low = TMath::BinarySearch(fNpoints, fX, x);; 995 if (low == -1) {; 996 // use first two points for doing an extrapolation; 997 low = 0;; 998 }; 999 if (fX[low] == x) return fY[low];; 1000 if (low == fNpoints-1) low--; // for extrapolating; 1001 up = low+1;; 1002 }; 1003 else {; 1004 // case TGraph is not sorted; 1005 ; 1006 // find neighbours simply looping all points; 1007 // and find also the 2 adjacent points: (low2 < low < x < up < up2 ); 1008 // needed in case x is outside the graph ascissa interval; 1009 Int_t low2 = -1;; 1010 Int_t up2 = -1;; 1011 ; 1012 for (Int_t i = 0; i < fNpoints; ++i) {; 1013 if (fX[i] < x) {; 1014 if (low == -1 || fX[i] > fX[low]) {; 1015 low2 = low;; 1016 low = i;; 1017 } else if (low2 == -1) low2 = i;; 1018 } else if (fX[i] > x) {; 1019 if (up == -1 || fX[i] < fX[up]) {; 1020 up2 = up;; 1021 up = i;; 1022 } else if (up2 == -1) up2 = i;; 1023 } else // case x == fX[i]; 1024 return fY[i]; // no interpolation needed; 1025 }; 1026 ; 1027 // treat cases when x is outside graph min max abscissa; 1028 if (up == -1) {; 1029 up = low;; 1030 low = low2;; 1031 }; 1032 if (low == -1) {; 1033 low = up;; 1034 up = up2;; 1035 }; 1036 }; 1037 // do now the linear interpolation; 1038 assert(low != -1 && up != -1);; 1039 ; 1040 if (fX[low] == fX[up]) return fY[low];; 1041 Double_t yn = fY[up] + (x - fX[up]) * (fY[low] - fY[up]) / (fX[low] - fX[up]);; 1042 return yn;; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// Execute action corresponding to one event.; 1047///; 1048/// This member function is ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:40720,Usability,simpl,simple,40720,"its are set.; 1152/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 1153/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 1154/// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; 1155/// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; 1156///; 1157///; 1158/// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; 1159/// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; 1160///; 1161/// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; 1162/// un-weighted least-square (chi-square) method.; 1163///; 1164///; 1165///\anchor GFitErrors; 1166/// ### TGraphErrors fit:; 1167///; 1168/// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; 1169/// is projected along the y-direction by calculating the function at the points `x-ex_low` and; 1170/// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; 1171/// The chi-square is then computed as the sum of the quantity below at each data point:; 1172///; 1173/// \f[; 1174/// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; 1175/// \f]; 1176///; 1177/// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; 1178/// function `f(x)`.; 1179///; 1180/// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; 1181///; 1182/// The approach used to approximate the uncertainty in y because of ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:43124,Usability,simpl,simple,43124,"ing; 1190/// function is a polynomial, a linear fitter is initialised.; 1191/// To create a linear function, use the following syntax: linear parts; 1192/// separated by `++` sign.; 1193/// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; 1194/// TF1 object as; 1195///; 1196/// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; 1197///; 1198/// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; 1199/// Going via the linear fitter for functions, linear in parameters, gives a; 1200/// considerable advantage in speed.; 1201/// When using the linear fitting it is also possible to perform a robust fitting with the; 1202/// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; 1203/// See the tutorial `fitLinearRobust.C`.; 1204///; 1205/// ### Notes on TGraph/TGraphErrors Fitting:; 1206///; 1207/// 1. By using the ""effective variance"" method a simple linear regression; 1208/// becomes a non-linear case, which takes several iterations; 1209/// instead of 0 as in the linear case.; 1210/// 2. The effective variance technique assumes that there is no correlation; 1211/// between the x and y coordinate.; 1212/// 3. The standard chi2 (least square) method without error in the coordinates (x) can; 1213/// be forced by using option ""EX0""; 1214/// 4. The linear fitter doesn't take into account the errors in x. When fitting a; 1215/// TGraphErrors with a linear functions the errors in x will not be considered.; 1216/// If errors in x are important, use option ""F"" for linear function fitting.; 1217/// 5. When fitting a TGraph (i.e. no errors associated with each point),; 1218/// a correction is applied to the errors on the parameters with the following; 1219/// formula:; 1220/// `parameter_error *= sqrt(chisquare/(ndf-1))`; 1221///; 1222/// ### General Fitting documentation; 1223///; 1224/// See in TH1::Fit for the documentation of; 1225/// - [Fit Result](\ref HFitRes); 1226/// - ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:63798,Usability,clear,clear,63798,"index should be <= %d"", fNpoints);; 1758 return;; 1759 }; 1760 ; 1761 if (ipoint == fNpoints) {; 1762 SetPoint(ipoint, x, y);; 1763 return;; 1764 }; 1765 ; 1766 Double_t **ps = ExpandAndCopy(fNpoints + 1, ipoint);; 1767 CopyAndRelease(ps, ipoint, fNpoints++, ipoint + 1);; 1768 ; 1769 // To avoid redefinitions in descendant classes; 1770 FillZero(ipoint, ipoint + 1);; 1771 ; 1772 fX[ipoint] = x;; 1773 fY[ipoint] = y;; 1774}; 1775 ; 1776 ; 1777////////////////////////////////////////////////////////////////////////////////; 1778/// Integrate the TGraph data within a given (index) range.; 1779/// Note that this function computes the area of the polygon enclosed by the points of the TGraph.; 1780/// The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; 1781/// since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; 1782/// with the first one. It is clear that the order of the point is essential in defining the polygon.; 1783/// Also note that the segments should not intersect.; 1784///; 1785/// NB:; 1786/// - if last=-1 (default) last is set to the last point.; 1787/// - if (first <0) the first point (0) is taken.; 1788///; 1789/// ### Method:; 1790///; 1791/// There are many ways to calculate the surface of a polygon. It all depends on what kind of data; 1792/// you have to deal with. The most evident solution would be to divide the polygon in triangles and; 1793/// calculate the surface of them. But this can quickly become complicated as you will have to test; 1794/// every segments of every triangles and check if they are intersecting with a current polygon's; 1795/// segment or if it goes outside the polygon. Many calculations that would lead to many problems...; 1796///; 1797/// ### The solution (implemented by R.Brun); 1798/// Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; 1799/// segments don't intersect.; 1800",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8cxx_source.html:64731,Usability,simpl,simple,64731,"ph point; 1782/// with the first one. It is clear that the order of the point is essential in defining the polygon.; 1783/// Also note that the segments should not intersect.; 1784///; 1785/// NB:; 1786/// - if last=-1 (default) last is set to the last point.; 1787/// - if (first <0) the first point (0) is taken.; 1788///; 1789/// ### Method:; 1790///; 1791/// There are many ways to calculate the surface of a polygon. It all depends on what kind of data; 1792/// you have to deal with. The most evident solution would be to divide the polygon in triangles and; 1793/// calculate the surface of them. But this can quickly become complicated as you will have to test; 1794/// every segments of every triangles and check if they are intersecting with a current polygon's; 1795/// segment or if it goes outside the polygon. Many calculations that would lead to many problems...; 1796///; 1797/// ### The solution (implemented by R.Brun); 1798/// Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; 1799/// segments don't intersect.; 1800/// It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; 1801/// vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied; 1802/// by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area.; 1803///; 1804/// ### Sources; 1805/// - http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; 1806/// - http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon; 1807 ; 1808Double_t TGraph::Integral(Int_t first, Int_t last) const; 1809{; 1810 if (first < 0) first = 0;; 1811 if (last < 0) last = fNpoints - 1;; 1812 if (last >= fNpoints) last = fNpoints - 1;; 1813 if (first >= last) return 0;; 1814 Int_t np = last - first + 1;; 1815 Double_t sum = 0.0;; 1816 //for(Int_t i=first;i<=last;i++) {; 1817 // Int_t j = first + (i-first+1)%np;; 1818 // sum += TMath::Ab",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
https://root.cern/doc/master/TGraph_8h.html:343,Integrability,depend,dependency,343,". ROOT: hist/hist/inc/TGraph.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TGraph.h File Reference. #include ""TNamed.h""; #include ""TAttLine.h""; #include ""TAttFill.h""; #include ""TAttMarker.h""; #include ""TVectorFfwd.h""; #include ""TVectorDfwd.h""; #include ""TFitResultPtr.h"". Include dependency graph for TGraph.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGraph;  A TGraph is an object made of two arrays X and Y with npoints each. More...;  . histhistincTGraph.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraph_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h.html
https://root.cern/doc/master/TGraph_8h_source.html:22224,Deployability,continuous,continuous,22224,"in this graph.Definition TGraph.cxx:731; TGraph::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideImplementation to get information on point of graph at cursor position Adapted from class TH1.Definition TGraph.cxx:1585; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; TGraph::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""y"")Multiply the values of a TGraph by a constant c1.Definition TGraph.cxx:2259; TGraph::fFunctionsTList * fFunctionsPointer to list of functions (fits and user)Definition TGraph.h:49; TGraph::GetCovariancevirtual Double_t GetCovariance() constReturn covariance of vectors x,y.Definition TGraph.cxx:1308; TGraph::GetEYlowdvirtual Double_t * GetEYlowd() constDefinition TGraph.h:149; TGraph::SwapValuesstatic void SwapValues(Double_t *arr, Int_t pos1, Int_t pos2)Swap values.Definition TGraph.cxx:2611; TGraph::Zerovoid Zero(Int_t &k, Double_t AZ, Double_t BZ, Double_t E2, Double_t &X, Double_t &Y, Int_t maxiterations)Find zero of a continuous function.Definition TGraph.cxx:2717; TGraph::Allocatevirtual Double_t ** Allocate(Int_t newsize)Allocate internal data structures for newsize points.Definition TGraph.cxx:590; TGraph::FitPanelvirtual void FitPanel()Display a GUI panel with all graph fit options.Definition TGraph.cxx:1274; TGraph::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TGraph.cxx:651; TGraph::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::InsertPointBeforevirtual void InsertPointBefore(Int_t ipoint, Double_t x, Double_t y)Insert a new point with coordinates (x,y) before the point number ipoint.Definition TGraph.cxx:1749; TGraph::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TGraph.h:126; TGraph::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGra",MatchSource.WIKI,doc/master/TGraph_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html
https://root.cern/doc/master/TGraph_8h_source.html:16045,Energy Efficiency,allocate,allocate,16045,"led when either TCanvas::UseCurrentStyle...Definition TGraph.cxx:2623; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::GetYDouble_t * GetY() constDefinition TGraph.h:140; TGraph::Mergevirtual Int_t Merge(TCollection *list)Adds all graphs from the collection to this graph.Definition TGraph.cxx:2658; TGraph::fMaxSizeInt_t fMaxSize!Current dimension of arrays fX and fYDefinition TGraph.h:45; TGraph::SaveHistogramAndFunctionsvoid SaveHistogramAndFunctions(std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option)Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes.Definition TGraph.cxx:2199; TGraph::fOptionTString fOptionOptions used for drawing the graph.Definition TGraph.h:53; TGraph::~TGraph~TGraph() overrideGraph default destructor.Definition TGraph.cxx:566; TGraph::ShrinkAndCopyDouble_t ** ShrinkAndCopy(Int_t size, Int_t iend)if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend).Definition TGraph.cxx:2453; TGraph::GetRMSvirtual Double_t GetRMS(Int_t axis=1) constReturn RMS of X (axis=1) or Y (axis=2)Definition TGraph.cxx:1339; TGraph::GetEXhighdvirtual Double_t * GetEXhighd() constDefinition TGraph.h:148; TGraph::IsEditablevirtual Bool_t IsEditable() constDefinition TGraph.h:166; TGraph::fHistogramTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:50; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::EStatusBitsEStatusBitsDefinition TGraph.h:74; TGraph::kNotEditable@ kNotEditableBit set if graph is non editable.Definition TGraph.h:78; TGraph::kIsHighlight@ kIsHighlightBit set if graph is highlight.Definition TGraph.h:80; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TGraph::kClipFrame@ kClipFrameClip to the frame boundary.Definition TGrap",MatchSource.WIKI,doc/master/TGraph_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html
https://root.cern/doc/master/TGraph_8h_source.html:25884,Energy Efficiency,allocate,allocate,25884,"ts.Definition TGraph.cxx:2583; TGraph::GetEYhighdvirtual Double_t * GetEYhighd() constDefinition TGraph.h:150; TGraph::SetOptionvirtual void SetOption(Option_t *option="" "")Definition TGraph.h:190; TGraph::GetXaxisTAxis * GetXaxis() constGet x axis of the graph.Definition TGraph.cxx:1566; TGraph::GetEditableBool_t GetEditable() constReturn kTRUE if kNotEditable bit is not set, kFALSE otherwise.Definition TGraph.cxx:2292; TGraph::GetEXhighvirtual Double_t * GetEXhigh() constDefinition TGraph.h:143; TGraph::GetCorrelationFactorvirtual Double_t GetCorrelationFactor() constReturn graph correlation factor.Definition TGraph.cxx:1296; TGraph::FillZerovirtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE)Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes.Definition TGraph.cxx:1102; TGraph::GetEYhighvirtual Double_t * GetEYhigh() constDefinition TGraph.h:145; TGraph::ExpandAndCopyDouble_t ** ExpandAndCopy(Int_t size, Int_t iend)if size > fMaxSize allocate new arrays of 2*size points and copy iend first points.Definition TGraph.cxx:1089; TGraph::Expandvirtual void Expand(Int_t newsize)If array sizes <= newsize, expand storage to 2*newsize.Definition TGraph.cxx:1065; TGraph::GetMeanvirtual Double_t GetMean(Int_t axis=1) constReturn mean value of X (axis=1) or Y (axis=2)Definition TGraph.cxx:1324; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::PaintStatsvirtual void PaintStats(TF1 *fit)Draw the stats.Definition TGraph.cxx:2004; TGraph::GetYaxisTAxis * GetYaxis() constGet y axis of the graph.Definition TGraph.cxx:1575; TGraph::FindObjectTObject * FindObject(const char *name) const overrideSearch object named name in the list of functions.Definition TGraph.cxx:1111; TGraph::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TGraph.cxx:2431; TGraph::GetHistogramvirtual TH1F * GetHistogram() constReturns a pointer to the histogram used to draw th",MatchSource.WIKI,doc/master/TGraph_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html
https://root.cern/doc/master/TGraph_8h_source.html:22682,Performance,perform,perform,22682,"59; TGraph::fFunctionsTList * fFunctionsPointer to list of functions (fits and user)Definition TGraph.h:49; TGraph::GetCovariancevirtual Double_t GetCovariance() constReturn covariance of vectors x,y.Definition TGraph.cxx:1308; TGraph::GetEYlowdvirtual Double_t * GetEYlowd() constDefinition TGraph.h:149; TGraph::SwapValuesstatic void SwapValues(Double_t *arr, Int_t pos1, Int_t pos2)Swap values.Definition TGraph.cxx:2611; TGraph::Zerovoid Zero(Int_t &k, Double_t AZ, Double_t BZ, Double_t E2, Double_t &X, Double_t &Y, Int_t maxiterations)Find zero of a continuous function.Definition TGraph.cxx:2717; TGraph::Allocatevirtual Double_t ** Allocate(Int_t newsize)Allocate internal data structures for newsize points.Definition TGraph.cxx:590; TGraph::FitPanelvirtual void FitPanel()Display a GUI panel with all graph fit options.Definition TGraph.cxx:1274; TGraph::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TGraph.cxx:651; TGraph::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::InsertPointBeforevirtual void InsertPointBefore(Int_t ipoint, Double_t x, Double_t y)Insert a new point with coordinates (x,y) before the point number ipoint.Definition TGraph.cxx:1749; TGraph::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TGraph.h:126; TGraph::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGraph.cxx:1056; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TGraph::SaveAsvoid SaveAs(const char *filename=""graph"", Option_t *option="""") const overrideSave the graph as .csv, .tsv or .txt.Definition TGraph.cxx:2093; TGraph::Evalvirtual Double_t Eval(Double_t x, TSpline *spline=nullptr, Option_t *option="""") constInterpolate points in this graph at x using a TSpline.Definition TGraph.cxx:953; TGraph::GetMaxSizeInt_t GetMaxSize() constDefinition TGraph.h:131; TGraph::InitExpovirtual void In",MatchSource.WIKI,doc/master/TGraph_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html
https://root.cern/doc/master/TGraph_8h_source.html:8562,Testability,log,logx,8562,"tMaximum() const {return fMaximum;}; 152 Double_t GetMinimum() const {return fMinimum;}; 153 TAxis *GetXaxis() const ;; 154 TAxis *GetYaxis() const ;; 155 char *GetObjectInfo(Int_t px, Int_t py) const override;; 156 virtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) const;; 157 virtual Double_t GetPointX(Int_t i) const;; 158 virtual Double_t GetPointY(Int_t i) const;; 159 ; 160 virtual void InitExpo(Double_t xmin=0, Double_t xmax=0);; 161 virtual void InitGaus(Double_t xmin=0, Double_t xmax=0);; 162 virtual void InitPolynom(Double_t xmin=0, Double_t xmax=0);; 163 virtual Int_t InsertPoint(); // *MENU*; 164 virtual void InsertPointBefore(Int_t ipoint, Double_t x, Double_t y);; 165 virtual Double_t Integral(Int_t first=0, Int_t last=-1) const;; 166 virtual Bool_t IsEditable() const {return !TestBit(kNotEditable);}; 167 virtual Bool_t IsHighlight() const { return TestBit(kIsHighlight); }; 168 virtual Int_t IsInside(Double_t x, Double_t y) const;; 169 virtual void LeastSquareFit(Int_t m, Double_t *a, Double_t xmin=0, Double_t xmax=0);; 170 virtual void LeastSquareLinearFit(Int_t n, Double_t &a0, Double_t &a1, Int_t &ifail, Double_t xmin=0, Double_t xmax=0);; 171 virtual Int_t Merge(TCollection* list);; 172 virtual void MovePoints(Double_t dx, Double_t dy, Bool_t logx = kFALSE, Bool_t logy = kFALSE);; 173 void Paint(Option_t *chopt="""") override;; 174 void PaintGraph(Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt);; 175 void PaintGrapHist(Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt);; 176 virtual void PaintStats(TF1 *fit);; 177 void Print(Option_t *chopt="""") const override;; 178 void RecursiveRemove(TObject *obj) override;; 179 virtual Int_t RemovePoint(); // *MENU*; 180 virtual Int_t RemovePoint(Int_t ipoint);; 181 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 182 void SaveAs(const char *filename = ""graph"", Option_t *option = """") const override; // *MENU*; 183 virtual void Scale(Double_t c1=1.",MatchSource.WIKI,doc/master/TGraph_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html
https://root.cern/doc/master/TGraph_8h_source.html:8584,Testability,log,logy,8584,"tMaximum() const {return fMaximum;}; 152 Double_t GetMinimum() const {return fMinimum;}; 153 TAxis *GetXaxis() const ;; 154 TAxis *GetYaxis() const ;; 155 char *GetObjectInfo(Int_t px, Int_t py) const override;; 156 virtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) const;; 157 virtual Double_t GetPointX(Int_t i) const;; 158 virtual Double_t GetPointY(Int_t i) const;; 159 ; 160 virtual void InitExpo(Double_t xmin=0, Double_t xmax=0);; 161 virtual void InitGaus(Double_t xmin=0, Double_t xmax=0);; 162 virtual void InitPolynom(Double_t xmin=0, Double_t xmax=0);; 163 virtual Int_t InsertPoint(); // *MENU*; 164 virtual void InsertPointBefore(Int_t ipoint, Double_t x, Double_t y);; 165 virtual Double_t Integral(Int_t first=0, Int_t last=-1) const;; 166 virtual Bool_t IsEditable() const {return !TestBit(kNotEditable);}; 167 virtual Bool_t IsHighlight() const { return TestBit(kIsHighlight); }; 168 virtual Int_t IsInside(Double_t x, Double_t y) const;; 169 virtual void LeastSquareFit(Int_t m, Double_t *a, Double_t xmin=0, Double_t xmax=0);; 170 virtual void LeastSquareLinearFit(Int_t n, Double_t &a0, Double_t &a1, Int_t &ifail, Double_t xmin=0, Double_t xmax=0);; 171 virtual Int_t Merge(TCollection* list);; 172 virtual void MovePoints(Double_t dx, Double_t dy, Bool_t logx = kFALSE, Bool_t logy = kFALSE);; 173 void Paint(Option_t *chopt="""") override;; 174 void PaintGraph(Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt);; 175 void PaintGrapHist(Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt);; 176 virtual void PaintStats(TF1 *fit);; 177 void Print(Option_t *chopt="""") const override;; 178 void RecursiveRemove(TObject *obj) override;; 179 virtual Int_t RemovePoint(); // *MENU*; 180 virtual Int_t RemovePoint(Int_t ipoint);; 181 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 182 void SaveAs(const char *filename = ""graph"", Option_t *option = """") const override; // *MENU*; 183 virtual void Scale(Double_t c1=1.",MatchSource.WIKI,doc/master/TGraph_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html
https://root.cern/doc/master/TGraph_8h_source.html:17402,Testability,log,logx,17402,"mTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:50; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::EStatusBitsEStatusBitsDefinition TGraph.h:74; TGraph::kNotEditable@ kNotEditableBit set if graph is non editable.Definition TGraph.h:78; TGraph::kIsHighlight@ kIsHighlightBit set if graph is highlight.Definition TGraph.h:80; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TGraph::kClipFrame@ kClipFrameClip to the frame boundary.Definition TGraph.h:76; TGraph::kResetHisto@ kResetHistofHistogram must be reset in GetHistogramDefinition TGraph.h:77; TGraph::kNoStats@ kNoStatsDon't draw stats box.Definition TGraph.h:75; TGraph::GetErrorXlowvirtual Double_t GetErrorXlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1387; TGraph::MovePointsvirtual void MovePoints(Double_t dx, Double_t dy, Bool_t logx=kFALSE, Bool_t logy=kFALSE)Move all graph points on specified values dx,dy If log argument specified, calculation done in logari...Definition TGraph.cxx:2691; TGraph::GetErrorYlowvirtual Double_t GetErrorYlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1405; TGraph::UpdateArraysvirtual void UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low)Update the fX and fY arrays with the sorted values.Definition TGraph.cxx:2592; TGraph::CopyAndReleasevirtual void CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:762; TGraph::GetMinimumDouble_t GetMinimum() constDefinition TGraph.h:152; TGraph::Printvoid Print(Option_t *chopt="""") const overridePrint graph values.Definition TGraph.cxx:2013; TGraph::GetEYlowvirtual Double_t * GetEYlow() constDefinition TGraph.h:146; TGraph::SetMaximumvirtual void SetMaximu",MatchSource.WIKI,doc/master/TGraph_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html
https://root.cern/doc/master/TGraph_8h_source.html:17422,Testability,log,logy,17422,"mTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:50; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::EStatusBitsEStatusBitsDefinition TGraph.h:74; TGraph::kNotEditable@ kNotEditableBit set if graph is non editable.Definition TGraph.h:78; TGraph::kIsHighlight@ kIsHighlightBit set if graph is highlight.Definition TGraph.h:80; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TGraph::kClipFrame@ kClipFrameClip to the frame boundary.Definition TGraph.h:76; TGraph::kResetHisto@ kResetHistofHistogram must be reset in GetHistogramDefinition TGraph.h:77; TGraph::kNoStats@ kNoStatsDon't draw stats box.Definition TGraph.h:75; TGraph::GetErrorXlowvirtual Double_t GetErrorXlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1387; TGraph::MovePointsvirtual void MovePoints(Double_t dx, Double_t dy, Bool_t logx=kFALSE, Bool_t logy=kFALSE)Move all graph points on specified values dx,dy If log argument specified, calculation done in logari...Definition TGraph.cxx:2691; TGraph::GetErrorYlowvirtual Double_t GetErrorYlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1405; TGraph::UpdateArraysvirtual void UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low)Update the fX and fY arrays with the sorted values.Definition TGraph.cxx:2592; TGraph::CopyAndReleasevirtual void CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:762; TGraph::GetMinimumDouble_t GetMinimum() constDefinition TGraph.h:152; TGraph::Printvoid Print(Option_t *chopt="""") const overridePrint graph values.Definition TGraph.cxx:2013; TGraph::GetEYlowvirtual Double_t * GetEYlow() constDefinition TGraph.h:146; TGraph::SetMaximumvirtual void SetMaximu",MatchSource.WIKI,doc/master/TGraph_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html
https://root.cern/doc/master/TGraph_8h_source.html:17485,Testability,log,log,17485,"mTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:50; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::EStatusBitsEStatusBitsDefinition TGraph.h:74; TGraph::kNotEditable@ kNotEditableBit set if graph is non editable.Definition TGraph.h:78; TGraph::kIsHighlight@ kIsHighlightBit set if graph is highlight.Definition TGraph.h:80; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TGraph::kClipFrame@ kClipFrameClip to the frame boundary.Definition TGraph.h:76; TGraph::kResetHisto@ kResetHistofHistogram must be reset in GetHistogramDefinition TGraph.h:77; TGraph::kNoStats@ kNoStatsDon't draw stats box.Definition TGraph.h:75; TGraph::GetErrorXlowvirtual Double_t GetErrorXlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1387; TGraph::MovePointsvirtual void MovePoints(Double_t dx, Double_t dy, Bool_t logx=kFALSE, Bool_t logy=kFALSE)Move all graph points on specified values dx,dy If log argument specified, calculation done in logari...Definition TGraph.cxx:2691; TGraph::GetErrorYlowvirtual Double_t GetErrorYlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1405; TGraph::UpdateArraysvirtual void UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low)Update the fX and fY arrays with the sorted values.Definition TGraph.cxx:2592; TGraph::CopyAndReleasevirtual void CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:762; TGraph::GetMinimumDouble_t GetMinimum() constDefinition TGraph.h:152; TGraph::Printvoid Print(Option_t *chopt="""") const overridePrint graph values.Definition TGraph.cxx:2013; TGraph::GetEYlowvirtual Double_t * GetEYlow() constDefinition TGraph.h:146; TGraph::SetMaximumvirtual void SetMaximu",MatchSource.WIKI,doc/master/TGraph_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html
https://root.cern/doc/master/TGraph_8h_source.html:17529,Testability,log,logari,17529,"mTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:50; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::EStatusBitsEStatusBitsDefinition TGraph.h:74; TGraph::kNotEditable@ kNotEditableBit set if graph is non editable.Definition TGraph.h:78; TGraph::kIsHighlight@ kIsHighlightBit set if graph is highlight.Definition TGraph.h:80; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TGraph::kClipFrame@ kClipFrameClip to the frame boundary.Definition TGraph.h:76; TGraph::kResetHisto@ kResetHistofHistogram must be reset in GetHistogramDefinition TGraph.h:77; TGraph::kNoStats@ kNoStatsDon't draw stats box.Definition TGraph.h:75; TGraph::GetErrorXlowvirtual Double_t GetErrorXlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1387; TGraph::MovePointsvirtual void MovePoints(Double_t dx, Double_t dy, Bool_t logx=kFALSE, Bool_t logy=kFALSE)Move all graph points on specified values dx,dy If log argument specified, calculation done in logari...Definition TGraph.cxx:2691; TGraph::GetErrorYlowvirtual Double_t GetErrorYlow(Int_t bin) constIt always returns a negative value.Definition TGraph.cxx:1405; TGraph::UpdateArraysvirtual void UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low)Update the fX and fY arrays with the sorted values.Definition TGraph.cxx:2592; TGraph::CopyAndReleasevirtual void CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:762; TGraph::GetMinimumDouble_t GetMinimum() constDefinition TGraph.h:152; TGraph::Printvoid Print(Option_t *chopt="""") const overridePrint graph values.Definition TGraph.cxx:2013; TGraph::GetEYlowvirtual Double_t * GetEYlow() constDefinition TGraph.h:146; TGraph::SetMaximumvirtual void SetMaximu",MatchSource.WIKI,doc/master/TGraph_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html
https://root.cern/doc/master/TGWin32ProxyDefs_8h.html:246,Integrability,depend,dependency,246,". ROOT: graf2d/win32gdk/inc/TGWin32ProxyDefs.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros |; Enumerations |; Variables ; TGWin32ProxyDefs.h File Reference. #include ""Rtypes.h"". Include dependency graph for TGWin32ProxyDefs.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define _NAME4_(name1, name2, name3, name4)   _NAME3_(name1,name2,name3)name4;  ; #define DEBUG_PROFILE_PROXY_START(method);  ; #define DEBUG_PROFILE_PROXY_STOP(method);  ; #define RETURN_METHOD_ARG0(klass, type, method);  ; #define RETURN_METHOD_ARG0_CONST(klass, type, method);  ; #define RETURN_METHOD_ARG1(klass, type, method, type1, par1);  ; #define RETURN_METHOD_ARG10(klass, type, method, type1, par1, type2, par2, type3, par3, type4, par4, type5, par5, type6, par6, type7, par7, type8, par8, type9, par9, type10, par10);  ; #define RETURN_METHOD_ARG11(klass, type, method, type1, par1, type2, par2, type3, par3, type4, par4, type5, par5, type6, par6, type7, par7, type8, par8, type9, par9, type10, par10, type11, par11);  ; #define RETURN_METHOD_ARG2(klass, type, method, type1, par1, type2, par2);  ; #define RETURN_METHOD_ARG3(klass, type, method, type1, par1, type2, par2, type3, par3);  ; #define RETURN_METHOD_ARG4(klass, type, method, type1, par1, type2, par2, type3, par3, type4, par4);  ; #define RETURN_METHOD_ARG5(klass, type, method, type1, par1, type2, par2, type3, par3, type4, par4, type5, par5);  ; #define RETURN_METHOD_ARG6(klass, type, method, type1, par1, type2, par2, type3, par3, type4, par4, type5, par5, type6, par6);  ; #define RETURN_METHOD_ARG7(klass, type, method, type1, par1, type2, par2, type3, par3, type4, par4, type5, par5, type6, par6, type7, par7);  ; #define RETURN_METHOD_ARG8(klass, type, method, type1, par1, type2,",MatchSource.WIKI,doc/master/TGWin32ProxyDefs_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32ProxyDefs_8h.html
https://root.cern/doc/master/TGWin32ProxyDefs_8h.html:7807,Integrability,interface,interface,7807,"hxx:444; Bool_tbool Bool_tDefinition RtypesCore.h:63; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TGWin32This class is the basic interface to the Win32 graphics system.Definition TGWin32.h:64; TMVA_SOFIE_GNN_Parser.tmptmpDefinition TMVA_SOFIE_GNN_Parser.py:196. Definition at line 533 of file TGWin32ProxyDefs.h. ◆ RETURN_METHOD_ARG0_CONST. #define RETURN_METHOD_ARG0_CONST; (;  ; klass, .  ; type, .  ; method . ). Value:type _NAME3_(TGWin32,klass,Proxy)::method() const\; {\; type ret;\; TGWin32::Lock();\; ret = _NAME3_(TGWin32,klass,Proxy)::RealObject()->method();\; TGWin32::Unlock();\; return ret;\; }. Definition at line 522 of file TGWin32ProxyDefs.h. ◆ RETURN_METHOD_ARG1. #define RETURN_METHOD_ARG1; (;  ; klass, .  ; type, .  ; method, .  ; type1, .  ; par1 . ). Value:void _NAME4_(p2,klass,method,par1)(void *in)\; {\; struct tmp {\; type1 par1; type ret;\; };\; tmp *p = (tmp*)in;\; p->ret = _NAME3_(TGWin32,klass,Proxy)::RealObject()->method(p->par1);\; }\; \; type _NAME3_(TGWin32,klass,Proxy)::method(type1 par1)\; {\; DEBUG_PROFILE_PROXY_START(method)\; type ret;\; struct tmp {\; type1 par1; type ret;\; tmp(typ",MatchSource.WIKI,doc/master/TGWin32ProxyDefs_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32ProxyDefs_8h.html
https://root.cern/doc/master/TGWin32ProxyDefs_8h_source.html:904,Integrability,interface,interface,904,". ROOT: graf2d/win32gdk/inc/TGWin32ProxyDefs.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGWin32ProxyDefs.h. Go to the documentation of this file. 1// @(#)root/win32gdk:$Id$; 2// Author: Valeriy Onuchin 08/08/2003; 3 ; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#ifndef ROOT_TGWin32ProxyDefs; 14#define ROOT_TGWin32ProxyDefs; 15 ; 16#include ""Rtypes.h"" // CINT headers; 17 ; 18 ; 19#define _NAME4_(name1,name2,name3,name4) _NAME3_(name1,name2,name3)name4; 20 ; 21 ; 22 ; 23///////////////////// debug & profile interface /////////////////////////////; 24//; 25// - recompile with gDebugProxy = 1; 26//; 27// root [0] gDebug = -123 // start profiling; 28//or; 29// root [0] gDebug = -1234 // start profiling and debugging(call trace); 30//; 31// root [1] .x macro.C // profile macro.C; 32// root [2] gDebug = 0 // stop profiling; 33// root [3] .x macro.C // print results; 34//; 35 ; 36static int gDebugProxy = 0; // if kTRUE - use debug & profile interface; 37 ; 38enum { kDebugProfile = -123, kDebugTrace = -1234 };; 39 ; 40static unsigned int total = 0;; 41static double total_time = 0;; 42 ; 43#define DEBUG_PROFILE_PROXY_START(method)\; 44 static int i = 0;\; 45 static double t = 0;\; 46 double start = 0;\; 47 int gDebugValue = 0;\; 48 int debug = 0;\; 49 if (gDebugProxy) {\; 50 gDebugValue = gDebug;\; 51 debug = (gDebugValue==kDebugProfile) || (gDebugValue==kDebugTrace);\; 52 if (debug) {\; 53 start = GetMilliSeconds();\; 54 } else {\; 55 if (total) {\; 56 printf("" method name hits time/hits(ms) time(ms) | Total = %d hits %6.2f ms\n"",total,total_time );\; 57 printf(""----------------------------",MatchSource.WIKI,doc/master/TGWin32ProxyDefs_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32ProxyDefs_8h_source.html
https://root.cern/doc/master/TGWin32ProxyDefs_8h_source.html:1340,Integrability,interface,interface,1340,"*********************************************************/; 12 ; 13#ifndef ROOT_TGWin32ProxyDefs; 14#define ROOT_TGWin32ProxyDefs; 15 ; 16#include ""Rtypes.h"" // CINT headers; 17 ; 18 ; 19#define _NAME4_(name1,name2,name3,name4) _NAME3_(name1,name2,name3)name4; 20 ; 21 ; 22 ; 23///////////////////// debug & profile interface /////////////////////////////; 24//; 25// - recompile with gDebugProxy = 1; 26//; 27// root [0] gDebug = -123 // start profiling; 28//or; 29// root [0] gDebug = -1234 // start profiling and debugging(call trace); 30//; 31// root [1] .x macro.C // profile macro.C; 32// root [2] gDebug = 0 // stop profiling; 33// root [3] .x macro.C // print results; 34//; 35 ; 36static int gDebugProxy = 0; // if kTRUE - use debug & profile interface; 37 ; 38enum { kDebugProfile = -123, kDebugTrace = -1234 };; 39 ; 40static unsigned int total = 0;; 41static double total_time = 0;; 42 ; 43#define DEBUG_PROFILE_PROXY_START(method)\; 44 static int i = 0;\; 45 static double t = 0;\; 46 double start = 0;\; 47 int gDebugValue = 0;\; 48 int debug = 0;\; 49 if (gDebugProxy) {\; 50 gDebugValue = gDebug;\; 51 debug = (gDebugValue==kDebugProfile) || (gDebugValue==kDebugTrace);\; 52 if (debug) {\; 53 start = GetMilliSeconds();\; 54 } else {\; 55 if (total) {\; 56 printf("" method name hits time/hits(ms) time(ms) | Total = %d hits %6.2f ms\n"",total,total_time );\; 57 printf(""------------------------------------------------------------------------------------------------------------\n"");\; 58 }\; 59 if (i && !total) {\; 60 printf("" %-30s %-6d %-3.2f %-4.2f\n"",#method,i,t/i,t);\; 61 }\; 62 total_time = t = total = i = 0;\; 63 }\; 64 }\; 65 ; 66#define DEBUG_PROFILE_PROXY_STOP(method)\; 67 if (gDebugProxy) {\; 68 if (debug) {\; 69 double dt = GetMilliSeconds() - start;\; 70 i++; total++;\; 71 t += dt;\; 72 total_time += dt;\; 73 if (gDebugValue==kDebugTrace) printf(#method "" %d\n"",i);\; 74 }\; 75 }\; 76 ; 77 ; 78//____________________________________________________________________",MatchSource.WIKI,doc/master/TGWin32ProxyDefs_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32ProxyDefs_8h_source.html
https://root.cern/doc/master/TGWin32VirtualGLProxy_8cxx.html:355,Integrability,depend,dependency,355,". ROOT: graf2d/win32gdk/src/TGWin32VirtualGLProxy.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions |; Variables ; TGWin32VirtualGLProxy.cxx File Reference. #include ""TGWin32ProxyDefs.h""; #include ""TGWin32VirtualGLProxy.h""; #include ""TGWin32.h""; #include ""TROOT.h""; #include ""TList.h"". Include dependency graph for TGWin32VirtualGLProxy.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; winID h RETURN_METHOD_ARG1 (GLManager, Bool_t, MakeCurrent, Int_t, devInd) VOID_METHOD_ARG1(GLManager;  ; winID RETURN_METHOD_ARG1 (GLManager, Int_t, CreateGLContext, Int_t, winInd) RETURN_METHOD_ARG5(GLManager;  ; winID h RETURN_METHOD_ARG1 (GLManager, Int_t, GetVirtualXInd, Int_t, pixInd) VOID_METHOD_ARG2(GLManager;  ; winID h TVirtualViewer3D TVirtualGLPainter RETURN_METHOD_ARG3 (GLManager, Bool_t, PlotSelected, TVirtualGLPainter *, plot, Int_t, x, Int_t, y) RETURN_METHOD_ARG3(GLManager;  ; winID h TVirtualViewer3D TVirtualGLPainter char TVirtualGLPainter y RETURN_METHOD_ARG4 (GLManager, Bool_t, SelectManip, TVirtualGLManip *, manip, const TGLCamera *, camera, const TGLRect *, rect, const TGLBoundingBox *, box) RETURN_METHOD_ARG1(GLManager;  ; winID h RETURN_METHOD_ARG5 (GLManager, Bool_t, ResizeOffScreenDevice, Int_t, pixInd, Int_t, x, Int_t, y, UInt_t, w, UInt_t, h) VOID_METHOD_ARG1(GLManager;  ;  RETURN_PROXY_OBJECT (GLManager) RETURN_METHOD_ARG1(GLManager;  ; winID h TVirtualViewer3D VOID_METHOD_ARG1 (GLManager, PaintSingleObject, TVirtualGLPainter *, p, 1) VOID_METHOD_ARG3(GLManager;  ; winID h VOID_METHOD_ARG1 (GLManager, ReadGLBuffer, Int_t, devInd, 1) VOID_METHOD_ARG1(GLManager;  ; winID h VOID_METHOD_ARG2 (GLManager, ExtractViewport, Int_t, pixInd, Int_t *, vp, 1) VOID_METHOD_ARG1(GLManager;  . Variables; winID AttachOffScreenDevice;  ; winID Bool_t;  ; winID h DeleteGLContext;  ; winID h devInd;  ; winID h direct;  ; winID h Flush;  ; winID h TVirtualViewer3D TVir",MatchSource.WIKI,doc/master/TGWin32VirtualGLProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualGLProxy_8cxx.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html:31708,Availability,mask,mask,31708,"h GetMarkerStyle GetTextAlign GetTextColor GetTextSize void VOID_METHOD_ARG2 (VirtualX, SetWMState, Window_t, id, EInitialState, state, 1) VOID_METHOD_ARG3(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list VOID_METHOD_ARG3 (VirtualX, ChangeActivePointerGrab, Window_t, win, UInt_t, mask, Cursor_t, cur, 1) VOID_METHOD_ARG5(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t VOID_METHOD_ARG3 (VirtualX, GetFontProperties, FontStruct_t, font, Int_t &, max_ascent, Int_t &, max_descent, 1) VOID_METHOD_ARG5(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t VOID_METHOD_ARG3 (VirtualX, GetImageSize, Drawable_t, id, UInt_t &, width, UInt_t &, height, 1) VOID_METHOD_ARG3(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Flo",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html:39420,Availability,mask,mask,39420,"e, Drawable_t, id, GContext_t, gc, Int_t, x, Int_t, y, UInt_t, w, UInt_t, h, 1) VOID_METHOD_ARG7(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t VOID_METHOD_ARG6 (VirtualX, DrawString, Drawable_t, id, GContext_t, gc, Int_t, x, Int_t, y, const char *, s, Int_t, len, 1) VOID_METHOD_ARG6(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t VOID_METHOD_ARG6 (VirtualX, GrabPointer, Window_t, id, UInt_t, evmask, Window_t, confine, Cursor_t, cursor, Bool_t, grab, Bool_t, owner_events, 1) VOID_METHOD_ARG6(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t VOID_METHOD_ARG7 (VirtualX, DrawCellArray, Int_t, x1, Int_t, y1, Int_t, x2, Int_t, y2, Int_t, nx, Int_t, ny, Int_t *, ic, 1) VOID_METHOD_ARG7(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t VOID_METHOD_ARG8 (VirtualX, QueryPointer, Window_t, id, Window_t &, rootw, Window_t &, childw, Int_t &, root_x, Int_t &, root_y, Int_t &, win_x, Int_t &, win_y, UInt_t &, mask, 1) VOID_METHOD_ARG0(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t VOID_METHOD_ARG9 (VirtualX, PutImage, Drawable_t, id, GContext_t, gc, Drawable_t, img, Int_t, dx, Int_t, dy, Int_t, x, Int_t, y, UInt_t, w, UInt_t, h, 1) VOID_METHOD_ARG9(VirtualX;  .",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html:73089,Availability,mask,mask,73089,xt const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Long_t;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize LowerWindow;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void main_id;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize MapSubwindows;  ; Option_t Option_t markerstyle;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t mask;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Mask_t;  ; Option_t Option_t mgn;  ; Option_t Option_t TPoint TPoint const char mode;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t modifier;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t MoveResizeWindow;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Recta,MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html:136503,Availability,mask,mask,136503,"_ARG2 ; (; VirtualX ; , . SetWMState ; , . Window_t ; , . id ; , . EInitialState ; , . state ; , . 1 ;  . ). ◆ VOID_METHOD_ARG3() [1/11]. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list VOID_METHOD_ARG3 ; (; VirtualX ; , . ChangeActivePointerGrab ; , . Window_t ; , . win ; , . UInt_t ; , . mask ; , . Cursor_t ; , . cur ; , . 1 ;  . ). ◆ VOID_METHOD_ARG3() [2/11]. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t VOID_METHOD_ARG3 ; (; VirtualX ; , . GetFontProperties ; , . FontStruct_t ; , . font ; , . Int_t & ; , . max_ascent ; , . Int_t & ; , . max_descent ; , . 1 ;  . ). ◆ VOID_METHOD_ARG3() [3/11]. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t VOID_METHOD_ARG3 ; (; VirtualX ; , . GetImageSize ; , . Drawable_t ; , . id ; , . UInt_t & ; , . width ; , . UInt_t & ; , . height ; , . 1 ;  . ). ◆ VOID_METHOD_ARG3() [4/11]. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html:145711,Availability,mask,mask,145711,"1 ;  . ). ◆ VOID_METHOD_ARG7(). Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t VOID_METHOD_ARG7 ; (; VirtualX ; , . DrawCellArray ; , . Int_t ; , . x1 ; , . Int_t ; , . y1 ; , . Int_t ; , . x2 ; , . Int_t ; , . y2 ; , . Int_t ; , . nx ; , . Int_t ; , . ny ; , . Int_t * ; , . ic ; , . 1 ;  . ). ◆ VOID_METHOD_ARG8(). Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t VOID_METHOD_ARG8 ; (; VirtualX ; , . QueryPointer ; , . Window_t ; , . id ; , . Window_t & ; , . rootw ; , . Window_t & ; , . childw ; , . Int_t & ; , . root_x ; , . Int_t & ; , . root_y ; , . Int_t & ; , . win_x ; , . Int_t & ; , . win_y ; , . UInt_t & ; , . mask ; , . 1 ;  . ). ◆ VOID_METHOD_ARG9(). Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t VOID_METHOD_ARG9 ; (; VirtualX ; , . PutImage ; , . Drawable_t ; , . id ; , . GContext_t ; , . gc ; , . Drawable_t ; , . img ; , . Int_t ; , . dx ; , . Int_t ; , . dy ; , . Int_t ; , . x ; , . Int_t ; , . y ; , . UInt_t ; , . w ; , . UInt_t ; , . h ; , . 1 ;  . ). Variable Documentation. ◆ act_format. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html:193944,Availability,mask,mask,193944,Struct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Long_t. Definition at line 245 of file TGWin32VirtualXProxy.cxx. ◆ LowerWindow. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize LowerWindow. Definition at line 100 of file TGWin32VirtualXProxy.cxx. ◆ main_id. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void main_id. Definition at line 126 of file TGWin32VirtualXProxy.cxx. ◆ MapSubwindows. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize MapSubwindows. Definition at line 94 of file TGWin32VirtualXProxy.cxx. ◆ markerstyle. Option_t Option_t markerstyle. Definition at line 52 of file TGWin32VirtualXProxy.cxx. ◆ mask. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h mask. Definition at line 178 of file TGWin32VirtualXProxy.cxx. ◆ Mask_t. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float,MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html:194650,Availability,mask,mask,194650,indow. Definition at line 100 of file TGWin32VirtualXProxy.cxx. ◆ main_id. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void main_id. Definition at line 126 of file TGWin32VirtualXProxy.cxx. ◆ MapSubwindows. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize MapSubwindows. Definition at line 94 of file TGWin32VirtualXProxy.cxx. ◆ markerstyle. Option_t Option_t markerstyle. Definition at line 52 of file TGWin32VirtualXProxy.cxx. ◆ mask. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h mask. Definition at line 178 of file TGWin32VirtualXProxy.cxx. ◆ Mask_t. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Mask_t. Definition at line 178 of file TGWin32VirtualXProxy.cxx. ◆ mgn. Option_t Option_t TPoint TPoint mgn. Definition at line 48 of file TGWin32VirtualXProxy.cxx. ◆ mode. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor Get,MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html:332,Integrability,depend,dependency,332,". ROOT: graf2d/win32gdk/src/TGWin32VirtualXProxy.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions |; Variables ; TGWin32VirtualXProxy.cxx File Reference. #include ""TGWin32ProxyDefs.h""; #include ""TGWin32VirtualXProxy.h""; #include ""TGWin32.h""; #include ""TList.h"". Include dependency graph for TGWin32VirtualXProxy.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner RETURN_METHOD_ARG0 (VirtualX, Region_t, CreateRegion) RETURN_METHOD_ARG0_CONST(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t RETURN_METHOD_ARG0 (VirtualX, Window_t, GetInputFocus) RETURN_METHOD_ARG0(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap RETURN_METHOD_ARG0_CONST (VirtualX, Bool_t, HasTTFonts) RETURN_METHOD_ARG0_CONST(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle RETURN_METHOD_ARG0_CONST (VirtualX, Bool_t, IsTransparent) RETURN_METHOD_ARG0_CONST(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude RETURN_METHO",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html:11914,Availability,mask,mask,11914,"t&,h,1); 168VOID_METHOD_ARG4(VirtualX,GetRGB,Int_t,index,Float_t&,r,Float_t&,g,Float_t&,b,1); 169VOID_METHOD_ARG3(VirtualX,GetFontProperties,FontStruct_t,font,Int_t&,max_ascent,Int_t&,max_descent,1); 170VOID_METHOD_ARG5(VirtualX,GetWindowSize,Drawable_t,id,Int_t&,x,Int_t&,y,UInt_t&,w,UInt_t&,h,1); 171VOID_METHOD_ARG3(VirtualX,GetImageSize,Drawable_t,id,UInt_t&,width,UInt_t&,height,1); 172VOID_METHOD_ARG3(VirtualX,UnionRectWithRegion,Rectangle_t*,rect,Region_t,src,Region_t,dest,1); 173VOID_METHOD_ARG3(VirtualX,UnionRegion,Region_t,rega,Region_t,regb,Region_t,result,1); 174VOID_METHOD_ARG3(VirtualX,IntersectRegion,Region_t,rega,Region_t,regb,Region_t,result,1); 175VOID_METHOD_ARG3(VirtualX,SubtractRegion,Region_t,rega,Region_t,regb,Region_t,result,1); 176VOID_METHOD_ARG3(VirtualX,XorRegion,Region_t,rega,Region_t,regb,Region_t,result,1); 177VOID_METHOD_ARG2(VirtualX,GetRegionBox,Region_t,reg,Rectangle_t*,rect,1); 178VOID_METHOD_ARG3(VirtualX,CopyGC,GContext_t,org,GContext_t,dest,Mask_t,mask,1); 179VOID_METHOD_ARG3(VirtualX,GetTextExtent,UInt_t&,w,UInt_t&,h,char*,mess,1); 180VOID_METHOD_ARG7(VirtualX,TranslateCoordinates,Window_t,src,Window_t,dest,Int_t,src_x,Int_t,src_y,Int_t&,dest_x,Int_t&,dest_y,Window_t&,child,1); 181VOID_METHOD_ARG8(VirtualX,QueryPointer,Window_t,id,Window_t&,rootw,Window_t&,childw,Int_t&,root_x,Int_t&,root_y,Int_t&,win_x,Int_t&,win_y,UInt_t&,mask,1); 182VOID_METHOD_ARG0(VirtualX,ClearWindow,1); 183VOID_METHOD_ARG1(VirtualX,SetDrawMode,TVirtualX::EDrawMode,mode,1); 184VOID_METHOD_ARG3(VirtualX,MoveWindow,Int_t,wid,Int_t,x,Int_t,y,1); 185VOID_METHOD_ARG1(VirtualX,ResizeWindow,Int_t,winid,1); 186VOID_METHOD_ARG2(VirtualX,SetCursor,Int_t,win,ECursor,cursor,1); 187VOID_METHOD_ARG2(VirtualX,QueryPointer,Int_t&,ix,Int_t&,iy,1); 188VOID_METHOD_ARG5(VirtualX,GetPasteBuffer,Window_t,id,Atom_t,atom,TString&,text,Int_t&,nchar,Bool_t,del,1); 189VOID_METHOD_ARG1(VirtualX,GetPlanes,Int_t&,planes,1); 190VOID_METHOD_ARG2(VirtualX,GetGCValues,GContext_t,gc,GCValues_",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html:12299,Availability,mask,mask,12299,"); 172VOID_METHOD_ARG3(VirtualX,UnionRectWithRegion,Rectangle_t*,rect,Region_t,src,Region_t,dest,1); 173VOID_METHOD_ARG3(VirtualX,UnionRegion,Region_t,rega,Region_t,regb,Region_t,result,1); 174VOID_METHOD_ARG3(VirtualX,IntersectRegion,Region_t,rega,Region_t,regb,Region_t,result,1); 175VOID_METHOD_ARG3(VirtualX,SubtractRegion,Region_t,rega,Region_t,regb,Region_t,result,1); 176VOID_METHOD_ARG3(VirtualX,XorRegion,Region_t,rega,Region_t,regb,Region_t,result,1); 177VOID_METHOD_ARG2(VirtualX,GetRegionBox,Region_t,reg,Rectangle_t*,rect,1); 178VOID_METHOD_ARG3(VirtualX,CopyGC,GContext_t,org,GContext_t,dest,Mask_t,mask,1); 179VOID_METHOD_ARG3(VirtualX,GetTextExtent,UInt_t&,w,UInt_t&,h,char*,mess,1); 180VOID_METHOD_ARG7(VirtualX,TranslateCoordinates,Window_t,src,Window_t,dest,Int_t,src_x,Int_t,src_y,Int_t&,dest_x,Int_t&,dest_y,Window_t&,child,1); 181VOID_METHOD_ARG8(VirtualX,QueryPointer,Window_t,id,Window_t&,rootw,Window_t&,childw,Int_t&,root_x,Int_t&,root_y,Int_t&,win_x,Int_t&,win_y,UInt_t&,mask,1); 182VOID_METHOD_ARG0(VirtualX,ClearWindow,1); 183VOID_METHOD_ARG1(VirtualX,SetDrawMode,TVirtualX::EDrawMode,mode,1); 184VOID_METHOD_ARG3(VirtualX,MoveWindow,Int_t,wid,Int_t,x,Int_t,y,1); 185VOID_METHOD_ARG1(VirtualX,ResizeWindow,Int_t,winid,1); 186VOID_METHOD_ARG2(VirtualX,SetCursor,Int_t,win,ECursor,cursor,1); 187VOID_METHOD_ARG2(VirtualX,QueryPointer,Int_t&,ix,Int_t&,iy,1); 188VOID_METHOD_ARG5(VirtualX,GetPasteBuffer,Window_t,id,Atom_t,atom,TString&,text,Int_t&,nchar,Bool_t,del,1); 189VOID_METHOD_ARG1(VirtualX,GetPlanes,Int_t&,planes,1); 190VOID_METHOD_ARG2(VirtualX,GetGCValues,GContext_t,gc,GCValues_t&,gval,1); 191RETURN_METHOD_ARG0(VirtualX,Window_t,GetInputFocus); 192RETURN_METHOD_ARG0(VirtualX,Window_t,GetPrimarySelectionOwner); 193RETURN_METHOD_ARG0(VirtualX,Region_t,CreateRegion); 194RETURN_METHOD_ARG0_CONST(VirtualX,Display_t,GetDisplay); 195RETURN_METHOD_ARG0_CONST(VirtualX,Visual_t,GetVisual); 196RETURN_METHOD_ARG0_CONST(VirtualX,Int_t,GetScreen); 197RETURN_METHOD_ARG0_",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html:17286,Availability,mask,mask,17286,"_t&,pict_mask,PictureAttributes_t&,attr); 233RETURN_METHOD_ARG5(VirtualX,Bool_t,CreatePictureFromData,Drawable_t,id,char**,data,Pixmap_t&,pict,Pixmap_t&,pict_mask,PictureAttributes_t&,attr); 234RETURN_METHOD_ARG2(VirtualX,Bool_t,ReadPictureDataFromFile,const char*,filename,char***,ret_data); 235RETURN_METHOD_ARG2(VirtualX,Int_t,SetTextFont,char*,fontname,TVirtualX::ETextSetMode,mode); 236RETURN_METHOD_ARG3(VirtualX,Pixmap_t,CreatePixmap,Drawable_t,wid,UInt_t,w,UInt_t,h); 237RETURN_METHOD_ARG1(VirtualX,ULong_t,GetPixel,Color_t,cindex); 238RETURN_METHOD_ARG5(VirtualX,unsigned char*,GetColorBits,Drawable_t,wid,Int_t,x,Int_t,y,UInt_t,width,UInt_t,height); 239RETURN_METHOD_ARG3(VirtualX,Pixmap_t,CreatePixmapFromData,unsigned char*,bits,UInt_t,width,UInt_t,height); 240RETURN_METHOD_ARG3(VirtualX,Int_t,AddWindow,ULongptr_t,qwid,UInt_t,w,UInt_t,h); 241VOID_METHOD_ARG1(VirtualX,RemoveWindow,ULongptr_t,qwid,1); 242VOID_METHOD_ARG4(VirtualX,ShapeCombineMask,Window_t,id,Int_t,x,Int_t,y,Pixmap_t,mask,1); 243 ; 244VOID_METHOD_ARG2(VirtualX,DeleteProperty,Window_t,win,Atom_t&,prop,1); 245RETURN_METHOD_ARG11(VirtualX,Int_t,GetProperty,Window_t,win,Atom_t,prop,Long_t,offset,Long_t,length,Bool_t,del,Atom_t,req_type,Atom_t*,act_type,Int_t*,act_format,ULong_t*,nitems,ULong_t*,bytes,unsigned char**,prop_list); 246VOID_METHOD_ARG3(VirtualX,ChangeActivePointerGrab,Window_t,win,UInt_t,mask,Cursor_t,cur,1); 247VOID_METHOD_ARG5(VirtualX,ConvertSelection,Window_t,win,Atom_t&,sel,Atom_t&,target,Atom_t&,prop,Time_t&,stamp,1); 248RETURN_METHOD_ARG2(VirtualX,Bool_t,SetSelectionOwner,Window_t,win,Atom_t&,prop); 249VOID_METHOD_ARG6(VirtualX,ChangeProperties,Window_t,id,Atom_t,property,Atom_t,type,Int_t,format,UChar_t*,data,Int_t,len,1); 250VOID_METHOD_ARG2(VirtualX,SetDNDAware,Window_t,id,Atom_t*,typelist,1); 251VOID_METHOD_ARG3(VirtualX,SetTypeList,Window_t,win,Atom_t,prop,Atom_t*,typelist,1);; 252RETURN_METHOD_ARG6(VirtualX,Window_t,FindRWindow,Window_t,win,Window_t,dragwin,Window_t,input,int,x,in",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html:17672,Availability,mask,mask,17672,"; 236RETURN_METHOD_ARG3(VirtualX,Pixmap_t,CreatePixmap,Drawable_t,wid,UInt_t,w,UInt_t,h); 237RETURN_METHOD_ARG1(VirtualX,ULong_t,GetPixel,Color_t,cindex); 238RETURN_METHOD_ARG5(VirtualX,unsigned char*,GetColorBits,Drawable_t,wid,Int_t,x,Int_t,y,UInt_t,width,UInt_t,height); 239RETURN_METHOD_ARG3(VirtualX,Pixmap_t,CreatePixmapFromData,unsigned char*,bits,UInt_t,width,UInt_t,height); 240RETURN_METHOD_ARG3(VirtualX,Int_t,AddWindow,ULongptr_t,qwid,UInt_t,w,UInt_t,h); 241VOID_METHOD_ARG1(VirtualX,RemoveWindow,ULongptr_t,qwid,1); 242VOID_METHOD_ARG4(VirtualX,ShapeCombineMask,Window_t,id,Int_t,x,Int_t,y,Pixmap_t,mask,1); 243 ; 244VOID_METHOD_ARG2(VirtualX,DeleteProperty,Window_t,win,Atom_t&,prop,1); 245RETURN_METHOD_ARG11(VirtualX,Int_t,GetProperty,Window_t,win,Atom_t,prop,Long_t,offset,Long_t,length,Bool_t,del,Atom_t,req_type,Atom_t*,act_type,Int_t*,act_format,ULong_t*,nitems,ULong_t*,bytes,unsigned char**,prop_list); 246VOID_METHOD_ARG3(VirtualX,ChangeActivePointerGrab,Window_t,win,UInt_t,mask,Cursor_t,cur,1); 247VOID_METHOD_ARG5(VirtualX,ConvertSelection,Window_t,win,Atom_t&,sel,Atom_t&,target,Atom_t&,prop,Time_t&,stamp,1); 248RETURN_METHOD_ARG2(VirtualX,Bool_t,SetSelectionOwner,Window_t,win,Atom_t&,prop); 249VOID_METHOD_ARG6(VirtualX,ChangeProperties,Window_t,id,Atom_t,property,Atom_t,type,Int_t,format,UChar_t*,data,Int_t,len,1); 250VOID_METHOD_ARG2(VirtualX,SetDNDAware,Window_t,id,Atom_t*,typelist,1); 251VOID_METHOD_ARG3(VirtualX,SetTypeList,Window_t,win,Atom_t,prop,Atom_t*,typelist,1);; 252RETURN_METHOD_ARG6(VirtualX,Window_t,FindRWindow,Window_t,win,Window_t,dragwin,Window_t,input,int,x,int,y,int,maxd);; 253RETURN_METHOD_ARG2(VirtualX,Bool_t,IsDNDAware,Window_t,win,Atom_t*,typelist);; 254 ; 255//VOID_METHOD_ARG1(VirtualX,CreateOpenGLContext,Int_t,wid,1); 256//VOID_METHOD_ARG1(VirtualX,DeleteOpenGLContext,Int_t,wid,1); 257//VOID_METHOD_ARG1(VirtualX,RemoveWindow,ULongptr_t,qwid,1); 258//RETURN_METHOD_ARG1(VirtualX,ExecCommand,UInt_t,TGWin32Command*,code); 259//RETURN_M",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html:31369,Availability,mask,maskDefinition,31369,void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t GetWindowSizeDefinition TGWin32VirtualXProxy.cxx:170; UnmapWindowOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize UnmapWindowDefinition TGWin32VirtualXProxy.cxx:96; regbOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t regbDefinition TGWin32VirtualXProxy.cxx:174; hOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void hDefinition TGWin32VirtualXProxy.cxx:138; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; cindexOption_t Option_t cindexDefinition TGWin32VirtualXProxy.cxx:50; pict_maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t pict_maskDefinition TGWin32VirtualXProxy.cxx:232; SetLineWidthOption_t Option_t SetLineWidthDefinition TGWin32VirtualXProxy.cxx:56;,MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html:817,Integrability,interface,interface,817,". ROOT: graf2d/win32gdk/src/TGWin32VirtualXProxy.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGWin32VirtualXProxy.cxx. Go to the documentation of this file. 1// @(#)root/win32gdk:$Id$; 2// Author: Valeriy Onuchin 08/08/2003; 3 ; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13 ; 14//////////////////////////////////////////////////////////////////////////; 15// //; 16// TGWin32Proxy //; 17// //; 18// This class is the proxy interface to the Win32 graphics system. //; 19// //; 20//////////////////////////////////////////////////////////////////////////; 21 ; 22#include ""TGWin32ProxyDefs.h""; 23#include ""TGWin32VirtualXProxy.h""; 24#include ""TGWin32.h""; 25#include ""TList.h""; 26 ; 27TVirtualX *TGWin32VirtualXProxy::fgRealObject = 0;; 28 ; 29////////////////////////////////////////////////////////////////////////////////; 30////////////////////////////////////////////////////////////////////////////////; 31 ; 32TVirtualX *TGWin32VirtualXProxy::RealObject(); 33{; 34 return fgRealObject;; 35}; 36 ; 37RETURN_PROXY_OBJECT(VirtualX); 38VOID_METHOD_ARG0(VirtualX,SetFillAttributes,1); 39VOID_METHOD_ARG0(VirtualX,SetMarkerAttributes,1); 40VOID_METHOD_ARG0(VirtualX,SetLineAttributes,1); 41VOID_METHOD_ARG0(VirtualX,SetTextAttributes,1); 42VOID_METHOD_ARG1(VirtualX,ResetAttMarker,Option_t*,toption,1); 43VOID_METHOD_ARG1(VirtualX,ResetAttFill,Option_t*,option,1); 44VOID_METHOD_ARG1(VirtualX,ResetAttLine,Option_t*,option,1); 45VOID_METHOD_ARG1(VirtualX,ResetAttText,Option_t*,option,1); 46VOID_METHOD_ARG1(VirtualX,SetFillStyle,Style_t,style,1); 47VOID_METHOD_ARG1(VirtualX,SetTextAngle,Float_t,tangle,1); 4",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html:95202,Integrability,interface,interface,95202,"lXProxy.cxx:274; TGWin32VirtualXProxy::SendEventvoid SendEvent(Window_t id, Event_t *ev) overrideSend event ev to window id.Definition TGWin32VirtualXProxy.cxx:320; TGWin32VirtualXProxy::GetCurrentWindowWindow_t GetCurrentWindow() const overrideReturn a pointer to the current window.Definition TGWin32VirtualXProxy.cxx:336; TGWin32VirtualXProxy::EventsPendingInt_t EventsPending() overrideReturn number of pending events.Definition TGWin32VirtualXProxy.cxx:296; TGWin32VirtualXProxy::IsCmdThreadBool_t IsCmdThread() const overrideReturn kTRUE if we are inside cmd/server thread.Definition TGWin32VirtualXProxy.cxx:328; TGWin32VirtualXProxy::RealObjectstatic TVirtualX * RealObject()Definition TGWin32VirtualXProxy.cxx:32; TGWin32VirtualXProxy::NextEventvoid NextEvent(Event_t &event) overrideProcess next event in the queue - if any.Definition TGWin32VirtualXProxy.cxx:304; TPointDefinition TPoint.h:31; TStringBasic string class.Definition TString.h:139; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; TVirtualX::IsCmdThreadvirtual Bool_t IsCmdThread() constDefinition TVirtualX.h:328; TVirtualX::LookupStringvirtual void LookupString(Event_t *event, char *buf, Int_t buflen, UInt_t &keysym)Converts the keycode from the event structure to a key symbol (according to the modifiers specified i...Definition TVirtualX.cxx:2009; TVirtualX::SendEventvirtual void SendEvent(Window_t id, Event_t *ev)Specifies the event ""ev"" is to be sent to the window ""id"".Definition TVirtualX.cxx:1623; TVirtualX::GetCurrentWindowvirtual Window_t GetCurrentWindow() constpointer to the current internal window used in canvas graphicsDefinition TVirtualX.cxx:2341; TVirtualX::NextEventvirtual void NextEvent(Event_t &event)The ""event"" is set to default event.Definition TVirtualX.cxx:137; TVirtualX::EventsPendingvirtual Int_t EventsPending()Returns the number of events that have been received from the X server but have not been removed from.",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html:20379,Performance,queue,queue,20379," 275{; 276 return (Window_t)gdk_window_get_parent((GdkWindow *) id);; 277}; 278 ; 279////////////////////////////////////////////////////////////////////////////////; 280/// Convert the keycode from the event structure to a key symbol (according; 281/// to the modifiers specified in the event structure and the current; 282/// keyboard mapping). In buf a null terminated ASCII string is returned; 283/// representing the string that is currently mapped to the key code.; 284 ; 285void TGWin32VirtualXProxy::LookupString(Event_t * event, char *buf, Int_t buflen,; 286 UInt_t & keysym); 287{; 288 DEBUG_PROFILE_PROXY_START(LookupString); 289 fgRealObject->LookupString(event,buf,buflen,keysym);; 290 DEBUG_PROFILE_PROXY_STOP(LookupString); 291}; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// Return number of pending events.; 295 ; 296Int_t TGWin32VirtualXProxy::EventsPending(); 297{ ; 298 return fgRealObject->EventsPending();; 299}; 300 ; 301////////////////////////////////////////////////////////////////////////////////; 302/// Process next event in the queue - if any.; 303 ; 304void TGWin32VirtualXProxy::NextEvent(Event_t & event); 305{; 306 fgRealObject->NextEvent(event);; 307}; 308 ; 309////////////////////////////////////////////////////////////////////////////////; 310/// Check if there is for window ""id"" an event of type ""type"".; 311 ; 312Bool_t TGWin32VirtualXProxy::CheckEvent(Window_t id, EGEventType type, Event_t &ev); 313{; 314 return fgRealObject->CheckEvent(id,type,ev);; 315}; 316 ; 317////////////////////////////////////////////////////////////////////////////////; 318/// Send event ev to window id.; 319 ; 320void TGWin32VirtualXProxy::SendEvent(Window_t id, Event_t *ev); 321{; 322 fgRealObject->SendEvent(id,ev);; 323}; 324 ; 325////////////////////////////////////////////////////////////////////////////////; 326/// Return kTRUE if we are inside cmd/server thread.; 327 ; 328Bool_t TGWin32VirtualXProxy::IsCmdThread",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html:95011,Performance,queue,queue,95011,"o a key symbol (according to the modifiers specified in...Definition TGWin32VirtualXProxy.cxx:285; TGWin32VirtualXProxy::GetParentWindow_t GetParent(Window_t id) const overridemight be thread unsafe (?)Definition TGWin32VirtualXProxy.cxx:274; TGWin32VirtualXProxy::SendEventvoid SendEvent(Window_t id, Event_t *ev) overrideSend event ev to window id.Definition TGWin32VirtualXProxy.cxx:320; TGWin32VirtualXProxy::GetCurrentWindowWindow_t GetCurrentWindow() const overrideReturn a pointer to the current window.Definition TGWin32VirtualXProxy.cxx:336; TGWin32VirtualXProxy::EventsPendingInt_t EventsPending() overrideReturn number of pending events.Definition TGWin32VirtualXProxy.cxx:296; TGWin32VirtualXProxy::IsCmdThreadBool_t IsCmdThread() const overrideReturn kTRUE if we are inside cmd/server thread.Definition TGWin32VirtualXProxy.cxx:328; TGWin32VirtualXProxy::RealObjectstatic TVirtualX * RealObject()Definition TGWin32VirtualXProxy.cxx:32; TGWin32VirtualXProxy::NextEventvoid NextEvent(Event_t &event) overrideProcess next event in the queue - if any.Definition TGWin32VirtualXProxy.cxx:304; TPointDefinition TPoint.h:31; TStringBasic string class.Definition TString.h:139; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; TVirtualX::IsCmdThreadvirtual Bool_t IsCmdThread() constDefinition TVirtualX.h:328; TVirtualX::LookupStringvirtual void LookupString(Event_t *event, char *buf, Int_t buflen, UInt_t &keysym)Converts the keycode from the event structure to a key symbol (according to the modifiers specified i...Definition TVirtualX.cxx:2009; TVirtualX::SendEventvirtual void SendEvent(Window_t id, Event_t *ev)Specifies the event ""ev"" is to be sent to the window ""id"".Definition TVirtualX.cxx:1623; TVirtualX::GetCurrentWindowvirtual Window_t GetCurrentWindow() constpointer to the current internal window used in canvas graphicsDefinition TVirtualX.cxx:2341; TVirtualX::NextEventvirtual void NextEvent(Event_t &ev",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html:19187,Safety,unsafe,unsafe,19187,"_ARG3(VirtualX,ChangeActivePointerGrab,Window_t,win,UInt_t,mask,Cursor_t,cur,1); 247VOID_METHOD_ARG5(VirtualX,ConvertSelection,Window_t,win,Atom_t&,sel,Atom_t&,target,Atom_t&,prop,Time_t&,stamp,1); 248RETURN_METHOD_ARG2(VirtualX,Bool_t,SetSelectionOwner,Window_t,win,Atom_t&,prop); 249VOID_METHOD_ARG6(VirtualX,ChangeProperties,Window_t,id,Atom_t,property,Atom_t,type,Int_t,format,UChar_t*,data,Int_t,len,1); 250VOID_METHOD_ARG2(VirtualX,SetDNDAware,Window_t,id,Atom_t*,typelist,1); 251VOID_METHOD_ARG3(VirtualX,SetTypeList,Window_t,win,Atom_t,prop,Atom_t*,typelist,1);; 252RETURN_METHOD_ARG6(VirtualX,Window_t,FindRWindow,Window_t,win,Window_t,dragwin,Window_t,input,int,x,int,y,int,maxd);; 253RETURN_METHOD_ARG2(VirtualX,Bool_t,IsDNDAware,Window_t,win,Atom_t*,typelist);; 254 ; 255//VOID_METHOD_ARG1(VirtualX,CreateOpenGLContext,Int_t,wid,1); 256//VOID_METHOD_ARG1(VirtualX,DeleteOpenGLContext,Int_t,wid,1); 257//VOID_METHOD_ARG1(VirtualX,RemoveWindow,ULongptr_t,qwid,1); 258//RETURN_METHOD_ARG1(VirtualX,ExecCommand,UInt_t,TGWin32Command*,code); 259//RETURN_METHOD_ARG3(VirtualX,Int_t,AddWindow,ULongptr_t,qwid,UInt_t,w,UInt_t,h); 260 ; 261//////////////////////// some non-standard methods /////////////////////////////; 262////////////////////////////////////////////////////////////////////////////////; 263///; 264 ; 265void TGWin32VirtualXProxy::CloseDisplay(); 266{; 267 if (gDebug) printf(""CloseDisplay\n"");; 268 fgRealObject->CloseDisplay();; 269}; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// might be thread unsafe (?); 273 ; 274Window_t TGWin32VirtualXProxy::GetParent(Window_t id) const; 275{; 276 return (Window_t)gdk_window_get_parent((GdkWindow *) id);; 277}; 278 ; 279////////////////////////////////////////////////////////////////////////////////; 280/// Convert the keycode from the event structure to a key symbol (according; 281/// to the modifiers specified in the event structure and the current; 282/// keyboard mapping).",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html
https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html:94158,Safety,unsafe,unsafe,94158,"har y1Definition TGWin32VirtualXProxy.cxx:70; TGWin32VirtualXProxy.h; GetPixelstatic void GetPixel(int y, int width, Byte_t *scline)Get pixels in line y and put in array scline.Definition TGWin32.cxx:4302; TGWin32.h; namechar name[80]Definition TGX11.cxx:110; TList.h; gDebugInt_t gDebugDefinition TROOT.cxx:597; TGWin32VirtualXProxyDefinition TGWin32VirtualXProxy.h:30; TGWin32VirtualXProxy::fgRealObjectstatic TVirtualX * fgRealObjectDefinition TGWin32VirtualXProxy.h:35; TGWin32VirtualXProxy::CheckEventBool_t CheckEvent(Window_t id, EGEventType type, Event_t &ev) overrideCheck if there is for window ""id"" an event of type ""type"".Definition TGWin32VirtualXProxy.cxx:312; TGWin32VirtualXProxy::LookupStringvoid LookupString(Event_t *event, char *buf, Int_t buflen, UInt_t &keysym) overrideConvert the keycode from the event structure to a key symbol (according to the modifiers specified in...Definition TGWin32VirtualXProxy.cxx:285; TGWin32VirtualXProxy::GetParentWindow_t GetParent(Window_t id) const overridemight be thread unsafe (?)Definition TGWin32VirtualXProxy.cxx:274; TGWin32VirtualXProxy::SendEventvoid SendEvent(Window_t id, Event_t *ev) overrideSend event ev to window id.Definition TGWin32VirtualXProxy.cxx:320; TGWin32VirtualXProxy::GetCurrentWindowWindow_t GetCurrentWindow() const overrideReturn a pointer to the current window.Definition TGWin32VirtualXProxy.cxx:336; TGWin32VirtualXProxy::EventsPendingInt_t EventsPending() overrideReturn number of pending events.Definition TGWin32VirtualXProxy.cxx:296; TGWin32VirtualXProxy::IsCmdThreadBool_t IsCmdThread() const overrideReturn kTRUE if we are inside cmd/server thread.Definition TGWin32VirtualXProxy.cxx:328; TGWin32VirtualXProxy::RealObjectstatic TVirtualX * RealObject()Definition TGWin32VirtualXProxy.cxx:32; TGWin32VirtualXProxy::NextEventvoid NextEvent(Event_t &event) overrideProcess next event in the queue - if any.Definition TGWin32VirtualXProxy.cxx:304; TPointDefinition TPoint.h:31; TStringBasic string class.Defin",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx.html:1290,Availability,error,error,1290,"11.h""; #include ""TPoint.h""; #include ""TMath.h""; #include ""TStorage.h""; #include ""TStyle.h""; #include ""TExMap.h""; #include ""TEnv.h""; #include ""TString.h""; #include ""TObjString.h""; #include ""TObjArray.h""; #include ""RStipples.h""; #include ""strlcpy.h""; #include <X11/Xlib.h>; #include <X11/Xutil.h>; #include <X11/Xatom.h>; #include <X11/cursorfont.h>; #include <X11/keysym.h>; #include <X11/xpm.h>; #include <cstdio>; #include <cstring>; #include <cstdlib>; #include <cctype>; #include <unistd.h>. Include dependency graph for TGX11.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  RVisual;  ; struct  RXColor;  ; struct  RXGCValues;  ; struct  RXImage;  ; struct  RXPoint;  ; struct  RXVisualInfo;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Functions; static Int_t DummyX11ErrorHandler (Display *, XErrorEvent *);  Dummy error handler for X11. Used by FindUsableVisual(). ;  ; static void GetPixel (int y, int width, Byte_t *scline);  Get pixels in line y and put in array scline. ;  ; int GIFdecode (Byte_t *gifArr, Byte_t *pixArr, int *Width, int *Height, int *Ncols, Byte_t *R, Byte_t *G, Byte_t *B);  ; long GIFencode (int Width, int Height, Int_t Ncol, Byte_t R[], Byte_t G[], Byte_t B[], Byte_t ScLine[], void(*get_scline)(int, int, Byte_t *), void(*pb)(Byte_t));  ; int GIFinfo (Byte_t *gifArr, int *Width, int *Height, int *Ncols);  ; int GIFquantize (UInt_t width, UInt_t height, Int_t *ncol, Byte_t *red, Byte_t *green, Byte_t *blue, Byte_t *outputBuf, Byte_t *outputCmap);  ; static void PutByte (Byte_t b);  Put byte b in output stream. ;  ; int XRotDrawAlignedImageString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *, int);  A front end to XRotPaintAlignedString: -does alignment, paints background. ;  ; int XRotDrawAlignedString (Display *, XFontStruct *, f",MatchSource.WIKI,doc/master/TGX11_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx.html
https://root.cern/doc/master/TGX11_8cxx.html:4735,Availability,error,error,4735,"GC * gGCmark = &gGClist[1];  ; static GC * gGCpxmp = &gGClist[6];  ; static GC * gGCtext = &gGClist[3];  ; static int gJoinStyle = JoinMiter;  ; static ULong_t gKeybdMask;  ; static int gLineStyle = LineSolid;  ; static int gLineWidth = 0;  ; struct { ;  ;    int   n ;  ;    int   type ;  ;    XPoint   xy [kMAXMK] ;  ; } gMarker ;  ; static int gMarkerCapStyle = CapRound;  ; static int gMarkerJoinStyle = JoinRound;  ; static int gMarkerLineStyle = LineSolid;  ; static int gMarkerLineWidth = 0;  ; static ULong_t gMouseMask;  ; static Cursor gNullCursor = 0;  ; static FILE * gOut;  ; static XFontStruct * gTextFont;  ; static XWindow_t * gTws;  ; static XImage * gXimage = nullptr;  ; const Int_t kBIGGEST_RGB_VALUE = 65535;  ; const Int_t kMAXFONT = 4;  ; const int kMAXGC = 7;  ; const Int_t kMAXMK = 100;  ; const char null_cursor_bits [];  . Function Documentation. ◆ DummyX11ErrorHandler(). static Int_t DummyX11ErrorHandler ; (; Display * ; , . XErrorEvent * ;  . ). static . Dummy error handler for X11. Used by FindUsableVisual(). ; Definition at line 839 of file TGX11.cxx. ◆ GetPixel(). static void GetPixel ; (; int ; y, . int ; width, . Byte_t * ; scline . ). static . Get pixels in line y and put in array scline. ; Definition at line 3308 of file TGX11.cxx. ◆ GIFdecode(). int GIFdecode ; (; Byte_t * ; gifArr, . Byte_t * ; pixArr, . int * ; Width, . int * ; Height, . int * ; Ncols, . Byte_t * ; R, . Byte_t * ; G, . Byte_t * ; B . ). Definition at line 149 of file gifdecode.c. ◆ GIFencode(). long GIFencode ; (; int ; Width, . int ; Height, . Int_t ; Ncol, . Byte_t ; R[], . Byte_t ; G[], . Byte_t ; B[], . Byte_t ; ScLine[], . void(*)(int, int, Byte_t *) ; get_scline, . void(*)(Byte_t) ; pb . ). ◆ GIFinfo(). int GIFinfo ; (; Byte_t * ; gifArr, . int * ; Width, . int * ; Height, . int * ; Ncols . ). Definition at line 80 of file gifdecode.c. ◆ GIFquantize(). int GIFquantize ; (; UInt_t ; width, . UInt_t ; height, . Int_t * ; ncol, . Byte_t * ; red, . Byte_t * ; green, . By",MatchSource.WIKI,doc/master/TGX11_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx.html
https://root.cern/doc/master/TGX11_8cxx.html:1892,Energy Efficiency,green,green,1892," #include <unistd.h>. Include dependency graph for TGX11.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  RVisual;  ; struct  RXColor;  ; struct  RXGCValues;  ; struct  RXImage;  ; struct  RXPoint;  ; struct  RXVisualInfo;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Functions; static Int_t DummyX11ErrorHandler (Display *, XErrorEvent *);  Dummy error handler for X11. Used by FindUsableVisual(). ;  ; static void GetPixel (int y, int width, Byte_t *scline);  Get pixels in line y and put in array scline. ;  ; int GIFdecode (Byte_t *gifArr, Byte_t *pixArr, int *Width, int *Height, int *Ncols, Byte_t *R, Byte_t *G, Byte_t *B);  ; long GIFencode (int Width, int Height, Int_t Ncol, Byte_t R[], Byte_t G[], Byte_t B[], Byte_t ScLine[], void(*get_scline)(int, int, Byte_t *), void(*pb)(Byte_t));  ; int GIFinfo (Byte_t *gifArr, int *Width, int *Height, int *Ncols);  ; int GIFquantize (UInt_t width, UInt_t height, Int_t *ncol, Byte_t *red, Byte_t *green, Byte_t *blue, Byte_t *outputBuf, Byte_t *outputCmap);  ; static void PutByte (Byte_t b);  Put byte b in output stream. ;  ; int XRotDrawAlignedImageString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *, int);  A front end to XRotPaintAlignedString: -does alignment, paints background. ;  ; int XRotDrawAlignedString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *, int);  A front end to XRotPaintAlignedString: -does alignment, no background. ;  ; int XRotDrawImageString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *);  A front end to XRotPaintAlignedString: -no alignment, paints background. ;  ; int XRotDrawString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *);  A front end to XRotPaintAlignedString: -no alignment, no background. ;  ; void XRotSetBounding",MatchSource.WIKI,doc/master/TGX11_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx.html
https://root.cern/doc/master/TGX11_8cxx.html:5732,Energy Efficiency,green,green,5732,"ummy error handler for X11. Used by FindUsableVisual(). ; Definition at line 839 of file TGX11.cxx. ◆ GetPixel(). static void GetPixel ; (; int ; y, . int ; width, . Byte_t * ; scline . ). static . Get pixels in line y and put in array scline. ; Definition at line 3308 of file TGX11.cxx. ◆ GIFdecode(). int GIFdecode ; (; Byte_t * ; gifArr, . Byte_t * ; pixArr, . int * ; Width, . int * ; Height, . int * ; Ncols, . Byte_t * ; R, . Byte_t * ; G, . Byte_t * ; B . ). Definition at line 149 of file gifdecode.c. ◆ GIFencode(). long GIFencode ; (; int ; Width, . int ; Height, . Int_t ; Ncol, . Byte_t ; R[], . Byte_t ; G[], . Byte_t ; B[], . Byte_t ; ScLine[], . void(*)(int, int, Byte_t *) ; get_scline, . void(*)(Byte_t) ; pb . ). ◆ GIFinfo(). int GIFinfo ; (; Byte_t * ; gifArr, . int * ; Width, . int * ; Height, . int * ; Ncols . ). Definition at line 80 of file gifdecode.c. ◆ GIFquantize(). int GIFquantize ; (; UInt_t ; width, . UInt_t ; height, . Int_t * ; ncol, . Byte_t * ; red, . Byte_t * ; green, . Byte_t * ; blue, . Byte_t * ; outputBuf, . Byte_t * ; outputCmap . ). ◆ PutByte(). static void PutByte ; (; Byte_t ; b). static . Put byte b in output stream. ; Definition at line 3317 of file TGX11.cxx. ◆ XRotDrawAlignedImageString(). int XRotDrawAlignedImageString ; (; Display * ; dpy, . XFontStruct * ; font, . float ; angle, . Drawable ; drawable, . GC ; gc, . int ; x, . int ; y, . char * ; text, . int ; align . ). A front end to XRotPaintAlignedString: -does alignment, paints background. ; Definition at line 316 of file Rotated.cxx. ◆ XRotDrawAlignedString(). int XRotDrawAlignedString ; (; Display * ; dpy, . XFontStruct * ; font, . float ; angle, . Drawable ; drawable, . GC ; gc, . int ; x, . int ; y, . char * ; text, . int ; align . ). A front end to XRotPaintAlignedString: -does alignment, no background. ; Definition at line 305 of file Rotated.cxx. ◆ XRotDrawImageString(). int XRotDrawImageString ; (; Display * ; dpy, . XFontStruct * ; font, . float ; angle, . Drawabl",MatchSource.WIKI,doc/master/TGX11_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx.html
https://root.cern/doc/master/TGX11_8cxx.html:763,Integrability,depend,dependency,763,". ROOT: graf2d/x11/src/TGX11.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions |; Variables ; TGX11.cxx File Reference. #include ""TROOT.h""; #include ""TColor.h""; #include ""TGX11.h""; #include ""TPoint.h""; #include ""TMath.h""; #include ""TStorage.h""; #include ""TStyle.h""; #include ""TExMap.h""; #include ""TEnv.h""; #include ""TString.h""; #include ""TObjString.h""; #include ""TObjArray.h""; #include ""RStipples.h""; #include ""strlcpy.h""; #include <X11/Xlib.h>; #include <X11/Xutil.h>; #include <X11/Xatom.h>; #include <X11/cursorfont.h>; #include <X11/keysym.h>; #include <X11/xpm.h>; #include <cstdio>; #include <cstring>; #include <cstdlib>; #include <cctype>; #include <unistd.h>. Include dependency graph for TGX11.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  RVisual;  ; struct  RXColor;  ; struct  RXGCValues;  ; struct  RXImage;  ; struct  RXPoint;  ; struct  RXVisualInfo;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Functions; static Int_t DummyX11ErrorHandler (Display *, XErrorEvent *);  Dummy error handler for X11. Used by FindUsableVisual(). ;  ; static void GetPixel (int y, int width, Byte_t *scline);  Get pixels in line y and put in array scline. ;  ; int GIFdecode (Byte_t *gifArr, Byte_t *pixArr, int *Width, int *Height, int *Ncols, Byte_t *R, Byte_t *G, Byte_t *B);  ; long GIFencode (int Width, int Height, Int_t Ncol, Byte_t R[], Byte_t G[], Byte_t B[], Byte_t ScLine[], void(*get_scline)(int, int, Byte_t *), void(*pb)(Byte_t));  ; int GIFinfo (Byte_t *gifArr, int *Width, int *Height, int *Ncols);  ; int GIFquantize (UInt_t width, UInt_t height, Int_t *ncol, Byte_t *red, Byte_t *green, Byte_t *blue, Byte_t *outputBuf, Byte_t *outputCmap);  ; static void PutByte (Byte_t b);  Put byte b i",MatchSource.WIKI,doc/master/TGX11_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx.html
https://root.cern/doc/master/TGX11_8cxx_source.html:3405,Availability,echo,echo,3405,"isplay*, XFontStruct*, float,; 73 Drawable, GC, int, int, char*, int);; 74extern int XRotDrawAlignedImageString(Display*, XFontStruct*, float,; 75 Drawable, GC, int, int, char*, int);; 76extern XPoint *XRotTextExtents(Display*, XFontStruct*, float,; 77 int, int, char*, int);; 78 ; 79//---- globals; 80 ; 81static XWindow_t *gCws; // gCws: pointer to the current window; 82static XWindow_t *gTws; // gTws: temporary pointer; 83 ; 84const Int_t kBIGGEST_RGB_VALUE = 65535;; 85 ; 86//; 87// Primitives Graphic Contexts global for all windows; 88//; 89const int kMAXGC = 7;; 90static GC gGClist[kMAXGC];; 91static GC *gGCline = &gGClist[0]; // PolyLines; 92static GC *gGCmark = &gGClist[1]; // PolyMarker; 93static GC *gGCfill = &gGClist[2]; // Fill areas; 94static GC *gGCtext = &gGClist[3]; // Text; 95static GC *gGCinvt = &gGClist[4]; // Inverse text; 96static GC *gGCdash = &gGClist[5]; // Dashed lines; 97static GC *gGCpxmp = &gGClist[6]; // Pixmap management; 98 ; 99static GC gGCecho; // Input echo; 100 ; 101static Int_t gFillHollow; // Flag if fill style is hollow; 102static Pixmap gFillPattern = 0; // Fill pattern; 103 ; 104//; 105// Text management; 106//; 107const Int_t kMAXFONT = 4;; 108static struct {; 109 XFontStruct *id;; 110 char name[80]; // Font name; 111} gFont[kMAXFONT]; // List of fonts loaded; 112 ; 113static XFontStruct *gTextFont; // Current font; 114static Int_t gCurrentFontNumber = 0; // Current font number in gFont[]; 115 ; 116//; 117// Markers; 118//; 119const Int_t kMAXMK = 100;; 120static struct {; 121 int type;; 122 int n;; 123 XPoint xy[kMAXMK];; 124} gMarker; // Point list to draw marker; 125static int gMarkerLineWidth = 0;; 126static int gMarkerLineStyle = LineSolid;; 127static int gMarkerCapStyle = CapRound;; 128static int gMarkerJoinStyle = JoinRound;; 129 ; 130//; 131// Keep style values for line GC; 132//; 133static int gLineWidth = 0;; 134static int gLineStyle = LineSolid;; 135static int gCapStyle = CapButt;; 136static int gJoinStyle = JoinMiter;",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:4560,Availability,mask,masks,4560,"103 ; 104//; 105// Text management; 106//; 107const Int_t kMAXFONT = 4;; 108static struct {; 109 XFontStruct *id;; 110 char name[80]; // Font name; 111} gFont[kMAXFONT]; // List of fonts loaded; 112 ; 113static XFontStruct *gTextFont; // Current font; 114static Int_t gCurrentFontNumber = 0; // Current font number in gFont[]; 115 ; 116//; 117// Markers; 118//; 119const Int_t kMAXMK = 100;; 120static struct {; 121 int type;; 122 int n;; 123 XPoint xy[kMAXMK];; 124} gMarker; // Point list to draw marker; 125static int gMarkerLineWidth = 0;; 126static int gMarkerLineStyle = LineSolid;; 127static int gMarkerCapStyle = CapRound;; 128static int gMarkerJoinStyle = JoinRound;; 129 ; 130//; 131// Keep style values for line GC; 132//; 133static int gLineWidth = 0;; 134static int gLineStyle = LineSolid;; 135static int gCapStyle = CapButt;; 136static int gJoinStyle = JoinMiter;; 137static char gDashList[10];; 138static int gDashLength = 0;; 139static int gDashOffset = 0;; 140static int gDashSize = 0;; 141 ; 142//; 143// Event masks; 144//; 145static ULong_t gMouseMask = ButtonPressMask | ButtonReleaseMask |; 146 EnterWindowMask | LeaveWindowMask |; 147 PointerMotionMask | KeyPressMask |; 148 KeyReleaseMask;; 149static ULong_t gKeybdMask = ButtonPressMask | KeyPressMask |; 150 EnterWindowMask | LeaveWindowMask;; 151 ; 152//; 153// Data to create an invisible cursor; 154//; 155const char null_cursor_bits[] = {; 1560x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,; 1570x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,; 1580x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};; 159static Cursor gNullCursor = 0;; 160 ; 161struct RXGCValues:XGCValues{};; 162struct RXColor:XColor{};; 163struct RXImage:XImage{};; 164struct RXPoint:XPoint{};; 165struct RXVisualInfo:XVisualInfo{};; 166struct RVisual:Visual{};; 167 ; 168ClassImp(TGX11);; 169 ; 170////////////////////////////////////////////////////////////////////////////////; 171/// Default constructor.",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:10643,Availability,failure,failure,10643,"06 fColors = new TExMap;; 307 Long64_t key, value;; 308 TExMapIter it(org.fColors);; 309 while (it.Next(key, value)) {; 310 XColor_t *colo = (XColor_t *) (Long_t)value;; 311 XColor_t *col = new XColor_t;; 312 col->fPixel = colo->fPixel;; 313 col->fRed = colo->fRed;; 314 col->fGreen = colo->fGreen;; 315 col->fBlue = colo->fBlue;; 316 col->fDefined = colo->fDefined;; 317 fColors->Add(key, (Long_t) col);; 318 }; 319}; 320 ; 321////////////////////////////////////////////////////////////////////////////////; 322/// Destructor.; 323 ; 324TGX11::~TGX11(); 325{; 326 delete (XEvent*)fXEvent;; 327 if (fWindows) TStorage::Dealloc(fWindows);; 328 ; 329 if (!fColors) return;; 330 Long64_t key, value;; 331 TExMapIter it(fColors);; 332 while (it.Next(key, value)) {; 333 XColor_t *col = (XColor_t *) (Long_t)value;; 334 delete col;; 335 }; 336 delete fColors;; 337}; 338 ; 339////////////////////////////////////////////////////////////////////////////////; 340/// Initialize X11 system. Returns kFALSE in case of failure.; 341 ; 342Bool_t TGX11::Init(void *display); 343{; 344 if (OpenDisplay(display) == -1) return kFALSE;; 345 return kTRUE;; 346}; 347 ; 348////////////////////////////////////////////////////////////////////////////////; 349/// Allocate color in colormap. If we are on an <= 8 plane machine; 350/// we will use XAllocColor. If we are on a >= 15 (15, 16 or 24) plane; 351/// true color machine we will calculate the pixel value using:; 352/// for 15 and 16 bit true colors have 6 bits precision per color however; 353/// only the 5 most significant bits are used in the color index.; 354/// Except for 16 bits where green uses all 6 bits. I.e.:; 355/// ~~~ {.cpp}; 356/// 15 bits = rrrrrgggggbbbbb; 357/// 16 bits = rrrrrggggggbbbbb; 358/// ~~~; 359/// for 24 bits each r, g and b are represented by 8 bits.; 360///; 361/// Since all colors are set with a max of 65535 (16 bits) per r, g, b; 362/// we just right shift them by 10, 11 and 10 bits for 16 planes, and; 363/// (10, 10, 10 ",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:17498,Availability,down,down,17498,"p, xpos, ypos, ww, hh, 0, 0);; 516 XFlush((Display*)fDisplay);; 517}; 518 ; 519////////////////////////////////////////////////////////////////////////////////; 520/// Draw a box.; 521///; 522/// - mode=0 hollow (kHollow); 523/// - mode=1 solid (kSolid); 524 ; 525void TGX11::DrawBox(int x1, int y1, int x2, int y2, EBoxMode mode); 526{; 527 Int_t x = TMath::Min(x1, x2);; 528 Int_t y = TMath::Min(y1, y2);; 529 Int_t w = TMath::Abs(x2 - x1);; 530 Int_t h = TMath::Abs(y2 - y1);; 531 ; 532 switch (mode) {; 533 ; 534 case kHollow:; 535 XDrawRectangle((Display*)fDisplay, gCws->fDrawing, *gGCline, x, y, w, h);; 536 break;; 537 ; 538 case kFilled:; 539 XFillRectangle((Display*)fDisplay, gCws->fDrawing, *gGCfill, x, y, w, h);; 540 break;; 541 ; 542 default:; 543 break;; 544 }; 545}; 546 ; 547////////////////////////////////////////////////////////////////////////////////; 548/// Draw a cell array.; 549//; 550/// \param [in] x1,y1 : left down corner; 551/// \param [in] x2,y2 : right up corner; 552/// \param [in] nx,ny : array size; 553/// \param [in] ic : array; 554///; 555/// Draw a cell array. The drawing is done with the pixel precision; 556/// if (X2-X1)/NX (or Y) is not a exact pixel number the position of; 557/// the top right corner may be wrong.; 558 ; 559void TGX11::DrawCellArray(int x1, int y1, int x2, int y2, int nx, int ny, int *ic); 560{; 561 int i, j, icol, ix, iy, w, h, current_icol;; 562 ; 563 current_icol = -1;; 564 w = TMath::Max((x2-x1)/(nx),1);; 565 h = TMath::Max((y1-y2)/(ny),1);; 566 ix = x1;; 567 ; 568 for (i = 0; i < nx; i++) {; 569 iy = y1-h;; 570 for (j = 0; j < ny; j++) {; 571 icol = ic[i+(nx*j)];; 572 if (icol != current_icol) {; 573 XSetForeground((Display*)fDisplay, *gGCfill, GetColor(icol).fPixel);; 574 current_icol = icol;; 575 }; 576 XFillRectangle((Display*)fDisplay, gCws->fDrawing, *gGCfill, ix, iy, w, h);; 577 iy = iy-h;; 578 }; 579 ix = ix+w;; 580 }; 581}; 582 ; 583/////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:25846,Availability,mask,mask,25846,"15) && findvis) {; 787 ; 788 // try to find better visual; 789 static XVisualInfo templates[] = {; 790 // Visual, visualid, screen, depth, class , red_mask, green_mask, blue_mask, colormap_size, bits_per_rgb; 791 { nullptr, 0 , 0 , 24 , TrueColor , 0 , 0 , 0 , 0 , 0 },; 792 { nullptr, 0 , 0 , 32 , TrueColor , 0 , 0 , 0 , 0 , 0 },; 793 { nullptr, 0 , 0 , 16 , TrueColor , 0 , 0 , 0 , 0 , 0 },; 794 { nullptr, 0 , 0 , 15 , TrueColor , 0 , 0 , 0 , 0 , 0 },; 795 // no suitable TrueColorMode found - now do the same thing to DirectColor; 796 { nullptr, 0 , 0 , 24 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 797 { nullptr, 0 , 0 , 32 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 798 { nullptr, 0 , 0 , 16 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 799 { nullptr, 0 , 0 , 15 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 800 { nullptr, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },; 801 };; 802 ; 803 Int_t nitems = 0;; 804 XVisualInfo *vlist = nullptr;; 805 for (Int_t i = 0; templates[i].depth != 0; i++) {; 806 Int_t mask = VisualScreenMask|VisualDepthMask|VisualClassMask;; 807 templates[i].screen = fScreenNumber;; 808 if ((vlist = XGetVisualInfo((Display*)fDisplay, mask, &(templates[i]), &nitems))) {; 809 FindUsableVisual((RXVisualInfo*)vlist, nitems);; 810 XFree(vlist);; 811 vlist = nullptr;; 812 if (fVisual); 813 break;; 814 }; 815 }; 816 }; 817 ; 818 fRootWin = RootWindow((Display*)fDisplay, fScreenNumber);; 819 ; 820 if (!fVisual) {; 821 fDepth = DefaultDepth((Display*)fDisplay, fScreenNumber);; 822 fVisual = (RVisual*)DefaultVisual((Display*)fDisplay, fScreenNumber);; 823 fVisRootWin = fRootWin;; 824 if (fDepth > 1); 825 fColormap = DefaultColormap((Display*)fDisplay, fScreenNumber);; 826 fBlackPixel = BlackPixel((Display*)fDisplay, fScreenNumber);; 827 fWhitePixel = WhitePixel((Display*)fDisplay, fScreenNumber);; 828 }; 829 if (gDebug > 1); 830 Printf(""Selected visual 0x%lx: depth %d, class %d, colormap: %s"",; 831 fVisual->visualid, fDepth, fVisual->c_class,; 832 fColormap == DefaultColormap((Display*)fDisplay, fS",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:25998,Availability,mask,mask,25998," , 0 , 32 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 798 { nullptr, 0 , 0 , 16 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 799 { nullptr, 0 , 0 , 15 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 800 { nullptr, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },; 801 };; 802 ; 803 Int_t nitems = 0;; 804 XVisualInfo *vlist = nullptr;; 805 for (Int_t i = 0; templates[i].depth != 0; i++) {; 806 Int_t mask = VisualScreenMask|VisualDepthMask|VisualClassMask;; 807 templates[i].screen = fScreenNumber;; 808 if ((vlist = XGetVisualInfo((Display*)fDisplay, mask, &(templates[i]), &nitems))) {; 809 FindUsableVisual((RXVisualInfo*)vlist, nitems);; 810 XFree(vlist);; 811 vlist = nullptr;; 812 if (fVisual); 813 break;; 814 }; 815 }; 816 }; 817 ; 818 fRootWin = RootWindow((Display*)fDisplay, fScreenNumber);; 819 ; 820 if (!fVisual) {; 821 fDepth = DefaultDepth((Display*)fDisplay, fScreenNumber);; 822 fVisual = (RVisual*)DefaultVisual((Display*)fDisplay, fScreenNumber);; 823 fVisRootWin = fRootWin;; 824 if (fDepth > 1); 825 fColormap = DefaultColormap((Display*)fDisplay, fScreenNumber);; 826 fBlackPixel = BlackPixel((Display*)fDisplay, fScreenNumber);; 827 fWhitePixel = WhitePixel((Display*)fDisplay, fScreenNumber);; 828 }; 829 if (gDebug > 1); 830 Printf(""Selected visual 0x%lx: depth %d, class %d, colormap: %s"",; 831 fVisual->visualid, fDepth, fVisual->c_class,; 832 fColormap == DefaultColormap((Display*)fDisplay, fScreenNumber) ? ""default"" :; 833 ""custom"");; 834}; 835 ; 836////////////////////////////////////////////////////////////////////////////////; 837/// Dummy error handler for X11. Used by FindUsableVisual().; 838 ; 839static Int_t DummyX11ErrorHandler(Display *, XErrorEvent *); 840{; 841 return 0;; 842}; 843 ; 844////////////////////////////////////////////////////////////////////////////////; 845/// Check if visual is usable, if so set fVisual, fDepth, fColormap,; 846/// fBlackPixel and fWhitePixel.; 847 ; 848void TGX11::FindUsableVisual(RXVisualInfo *vlist, Int_t nitems); 849{; 850 Int_t (*oldErrorHandler)(D",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:27023,Availability,error,error,27023," , 0 , 32 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 798 { nullptr, 0 , 0 , 16 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 799 { nullptr, 0 , 0 , 15 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 800 { nullptr, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },; 801 };; 802 ; 803 Int_t nitems = 0;; 804 XVisualInfo *vlist = nullptr;; 805 for (Int_t i = 0; templates[i].depth != 0; i++) {; 806 Int_t mask = VisualScreenMask|VisualDepthMask|VisualClassMask;; 807 templates[i].screen = fScreenNumber;; 808 if ((vlist = XGetVisualInfo((Display*)fDisplay, mask, &(templates[i]), &nitems))) {; 809 FindUsableVisual((RXVisualInfo*)vlist, nitems);; 810 XFree(vlist);; 811 vlist = nullptr;; 812 if (fVisual); 813 break;; 814 }; 815 }; 816 }; 817 ; 818 fRootWin = RootWindow((Display*)fDisplay, fScreenNumber);; 819 ; 820 if (!fVisual) {; 821 fDepth = DefaultDepth((Display*)fDisplay, fScreenNumber);; 822 fVisual = (RVisual*)DefaultVisual((Display*)fDisplay, fScreenNumber);; 823 fVisRootWin = fRootWin;; 824 if (fDepth > 1); 825 fColormap = DefaultColormap((Display*)fDisplay, fScreenNumber);; 826 fBlackPixel = BlackPixel((Display*)fDisplay, fScreenNumber);; 827 fWhitePixel = WhitePixel((Display*)fDisplay, fScreenNumber);; 828 }; 829 if (gDebug > 1); 830 Printf(""Selected visual 0x%lx: depth %d, class %d, colormap: %s"",; 831 fVisual->visualid, fDepth, fVisual->c_class,; 832 fColormap == DefaultColormap((Display*)fDisplay, fScreenNumber) ? ""default"" :; 833 ""custom"");; 834}; 835 ; 836////////////////////////////////////////////////////////////////////////////////; 837/// Dummy error handler for X11. Used by FindUsableVisual().; 838 ; 839static Int_t DummyX11ErrorHandler(Display *, XErrorEvent *); 840{; 841 return 0;; 842}; 843 ; 844////////////////////////////////////////////////////////////////////////////////; 845/// Check if visual is usable, if so set fVisual, fDepth, fColormap,; 846/// fBlackPixel and fWhitePixel.; 847 ; 848void TGX11::FindUsableVisual(RXVisualInfo *vlist, Int_t nitems); 849{; 850 Int_t (*oldErrorHandler)(D",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:36844,Availability,echo,echo,36844,"default background; 1109 GetColor(0).fPixel = fWhitePixel;; 1110 ; 1111 // Inquire the XServer Vendor; 1112 char vendor[132];; 1113 strlcpy(vendor, XServerVendor((Display*)fDisplay),132);; 1114 ; 1115 // Create primitives graphic contexts; 1116 for (i = 0; i < kMAXGC; i++); 1117 gGClist[i] = XCreateGC((Display*)fDisplay, fVisRootWin, 0, nullptr);; 1118 ; 1119 XGCValues values;; 1120 if (XGetGCValues((Display*)fDisplay, *gGCtext, GCForeground|GCBackground, &values)) {; 1121 XSetForeground((Display*)fDisplay, *gGCinvt, values.background);; 1122 XSetBackground((Display*)fDisplay, *gGCinvt, values.foreground);; 1123 } else {; 1124 Error(""OpenDisplay"", ""cannot get GC values"");; 1125 }; 1126 ; 1127 // Turn-off GraphicsExpose and NoExpose event reporting for the pixmap; 1128 // manipulation GC, this to prevent these events from being stacked up; 1129 // without ever being processed and thereby wasting a lot of memory.; 1130 XSetGraphicsExposures((Display*)fDisplay, *gGCpxmp, False);; 1131 ; 1132 // Create input echo graphic context; 1133 XGCValues echov;; 1134 echov.foreground = fBlackPixel;; 1135 echov.background = fWhitePixel;; 1136 if (strstr(vendor,""Hewlett"")); 1137 echov.function = GXxor;; 1138 else; 1139 echov.function = GXinvert;; 1140 ; 1141 gGCecho = XCreateGC((Display*)fDisplay, fVisRootWin,; 1142 GCForeground | GCBackground | GCFunction,; 1143 &echov);; 1144 ; 1145 // Load a default Font; 1146 static int isdisp = 0;; 1147 if (!isdisp) {; 1148 for (i = 0; i < kMAXFONT; i++) {; 1149 gFont[i].id = nullptr;; 1150 strcpy(gFont[i].name, "" "");; 1151 }; 1152 fontlist = XListFonts((Display*)fDisplay, ""*courier*"", 1, &fontcount);; 1153 if (fontlist && fontcount != 0) {; 1154 gFont[gCurrentFontNumber].id = XLoadQueryFont((Display*)fDisplay, fontlist[0]);; 1155 gTextFont = gFont[gCurrentFontNumber].id;; 1156 strcpy(gFont[gCurrentFontNumber].name, ""*courier*"");; 1157 gCurrentFontNumber++;; 1158 XFreeFontNames(fontlist);; 1159 } else {; 1160 // emergency: try fixed font; 1161",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:36881,Availability,echo,echov,36881,"default background; 1109 GetColor(0).fPixel = fWhitePixel;; 1110 ; 1111 // Inquire the XServer Vendor; 1112 char vendor[132];; 1113 strlcpy(vendor, XServerVendor((Display*)fDisplay),132);; 1114 ; 1115 // Create primitives graphic contexts; 1116 for (i = 0; i < kMAXGC; i++); 1117 gGClist[i] = XCreateGC((Display*)fDisplay, fVisRootWin, 0, nullptr);; 1118 ; 1119 XGCValues values;; 1120 if (XGetGCValues((Display*)fDisplay, *gGCtext, GCForeground|GCBackground, &values)) {; 1121 XSetForeground((Display*)fDisplay, *gGCinvt, values.background);; 1122 XSetBackground((Display*)fDisplay, *gGCinvt, values.foreground);; 1123 } else {; 1124 Error(""OpenDisplay"", ""cannot get GC values"");; 1125 }; 1126 ; 1127 // Turn-off GraphicsExpose and NoExpose event reporting for the pixmap; 1128 // manipulation GC, this to prevent these events from being stacked up; 1129 // without ever being processed and thereby wasting a lot of memory.; 1130 XSetGraphicsExposures((Display*)fDisplay, *gGCpxmp, False);; 1131 ; 1132 // Create input echo graphic context; 1133 XGCValues echov;; 1134 echov.foreground = fBlackPixel;; 1135 echov.background = fWhitePixel;; 1136 if (strstr(vendor,""Hewlett"")); 1137 echov.function = GXxor;; 1138 else; 1139 echov.function = GXinvert;; 1140 ; 1141 gGCecho = XCreateGC((Display*)fDisplay, fVisRootWin,; 1142 GCForeground | GCBackground | GCFunction,; 1143 &echov);; 1144 ; 1145 // Load a default Font; 1146 static int isdisp = 0;; 1147 if (!isdisp) {; 1148 for (i = 0; i < kMAXFONT; i++) {; 1149 gFont[i].id = nullptr;; 1150 strcpy(gFont[i].name, "" "");; 1151 }; 1152 fontlist = XListFonts((Display*)fDisplay, ""*courier*"", 1, &fontcount);; 1153 if (fontlist && fontcount != 0) {; 1154 gFont[gCurrentFontNumber].id = XLoadQueryFont((Display*)fDisplay, fontlist[0]);; 1155 gTextFont = gFont[gCurrentFontNumber].id;; 1156 strcpy(gFont[gCurrentFontNumber].name, ""*courier*"");; 1157 gCurrentFontNumber++;; 1158 XFreeFontNames(fontlist);; 1159 } else {; 1160 // emergency: try fixed font; 1161",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:36894,Availability,echo,echov,36894,"default background; 1109 GetColor(0).fPixel = fWhitePixel;; 1110 ; 1111 // Inquire the XServer Vendor; 1112 char vendor[132];; 1113 strlcpy(vendor, XServerVendor((Display*)fDisplay),132);; 1114 ; 1115 // Create primitives graphic contexts; 1116 for (i = 0; i < kMAXGC; i++); 1117 gGClist[i] = XCreateGC((Display*)fDisplay, fVisRootWin, 0, nullptr);; 1118 ; 1119 XGCValues values;; 1120 if (XGetGCValues((Display*)fDisplay, *gGCtext, GCForeground|GCBackground, &values)) {; 1121 XSetForeground((Display*)fDisplay, *gGCinvt, values.background);; 1122 XSetBackground((Display*)fDisplay, *gGCinvt, values.foreground);; 1123 } else {; 1124 Error(""OpenDisplay"", ""cannot get GC values"");; 1125 }; 1126 ; 1127 // Turn-off GraphicsExpose and NoExpose event reporting for the pixmap; 1128 // manipulation GC, this to prevent these events from being stacked up; 1129 // without ever being processed and thereby wasting a lot of memory.; 1130 XSetGraphicsExposures((Display*)fDisplay, *gGCpxmp, False);; 1131 ; 1132 // Create input echo graphic context; 1133 XGCValues echov;; 1134 echov.foreground = fBlackPixel;; 1135 echov.background = fWhitePixel;; 1136 if (strstr(vendor,""Hewlett"")); 1137 echov.function = GXxor;; 1138 else; 1139 echov.function = GXinvert;; 1140 ; 1141 gGCecho = XCreateGC((Display*)fDisplay, fVisRootWin,; 1142 GCForeground | GCBackground | GCFunction,; 1143 &echov);; 1144 ; 1145 // Load a default Font; 1146 static int isdisp = 0;; 1147 if (!isdisp) {; 1148 for (i = 0; i < kMAXFONT; i++) {; 1149 gFont[i].id = nullptr;; 1150 strcpy(gFont[i].name, "" "");; 1151 }; 1152 fontlist = XListFonts((Display*)fDisplay, ""*courier*"", 1, &fontcount);; 1153 if (fontlist && fontcount != 0) {; 1154 gFont[gCurrentFontNumber].id = XLoadQueryFont((Display*)fDisplay, fontlist[0]);; 1155 gTextFont = gFont[gCurrentFontNumber].id;; 1156 strcpy(gFont[gCurrentFontNumber].name, ""*courier*"");; 1157 gCurrentFontNumber++;; 1158 XFreeFontNames(fontlist);; 1159 } else {; 1160 // emergency: try fixed font; 1161",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:36932,Availability,echo,echov,36932,"Vendor; 1112 char vendor[132];; 1113 strlcpy(vendor, XServerVendor((Display*)fDisplay),132);; 1114 ; 1115 // Create primitives graphic contexts; 1116 for (i = 0; i < kMAXGC; i++); 1117 gGClist[i] = XCreateGC((Display*)fDisplay, fVisRootWin, 0, nullptr);; 1118 ; 1119 XGCValues values;; 1120 if (XGetGCValues((Display*)fDisplay, *gGCtext, GCForeground|GCBackground, &values)) {; 1121 XSetForeground((Display*)fDisplay, *gGCinvt, values.background);; 1122 XSetBackground((Display*)fDisplay, *gGCinvt, values.foreground);; 1123 } else {; 1124 Error(""OpenDisplay"", ""cannot get GC values"");; 1125 }; 1126 ; 1127 // Turn-off GraphicsExpose and NoExpose event reporting for the pixmap; 1128 // manipulation GC, this to prevent these events from being stacked up; 1129 // without ever being processed and thereby wasting a lot of memory.; 1130 XSetGraphicsExposures((Display*)fDisplay, *gGCpxmp, False);; 1131 ; 1132 // Create input echo graphic context; 1133 XGCValues echov;; 1134 echov.foreground = fBlackPixel;; 1135 echov.background = fWhitePixel;; 1136 if (strstr(vendor,""Hewlett"")); 1137 echov.function = GXxor;; 1138 else; 1139 echov.function = GXinvert;; 1140 ; 1141 gGCecho = XCreateGC((Display*)fDisplay, fVisRootWin,; 1142 GCForeground | GCBackground | GCFunction,; 1143 &echov);; 1144 ; 1145 // Load a default Font; 1146 static int isdisp = 0;; 1147 if (!isdisp) {; 1148 for (i = 0; i < kMAXFONT; i++) {; 1149 gFont[i].id = nullptr;; 1150 strcpy(gFont[i].name, "" "");; 1151 }; 1152 fontlist = XListFonts((Display*)fDisplay, ""*courier*"", 1, &fontcount);; 1153 if (fontlist && fontcount != 0) {; 1154 gFont[gCurrentFontNumber].id = XLoadQueryFont((Display*)fDisplay, fontlist[0]);; 1155 gTextFont = gFont[gCurrentFontNumber].id;; 1156 strcpy(gFont[gCurrentFontNumber].name, ""*courier*"");; 1157 gCurrentFontNumber++;; 1158 XFreeFontNames(fontlist);; 1159 } else {; 1160 // emergency: try fixed font; 1161 fontlist = XListFonts((Display*)fDisplay, ""fixed"", 1, &fontcount);; 1162 if (fontlist && fontc",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:37006,Availability,echo,echov,37006,"rverVendor((Display*)fDisplay),132);; 1114 ; 1115 // Create primitives graphic contexts; 1116 for (i = 0; i < kMAXGC; i++); 1117 gGClist[i] = XCreateGC((Display*)fDisplay, fVisRootWin, 0, nullptr);; 1118 ; 1119 XGCValues values;; 1120 if (XGetGCValues((Display*)fDisplay, *gGCtext, GCForeground|GCBackground, &values)) {; 1121 XSetForeground((Display*)fDisplay, *gGCinvt, values.background);; 1122 XSetBackground((Display*)fDisplay, *gGCinvt, values.foreground);; 1123 } else {; 1124 Error(""OpenDisplay"", ""cannot get GC values"");; 1125 }; 1126 ; 1127 // Turn-off GraphicsExpose and NoExpose event reporting for the pixmap; 1128 // manipulation GC, this to prevent these events from being stacked up; 1129 // without ever being processed and thereby wasting a lot of memory.; 1130 XSetGraphicsExposures((Display*)fDisplay, *gGCpxmp, False);; 1131 ; 1132 // Create input echo graphic context; 1133 XGCValues echov;; 1134 echov.foreground = fBlackPixel;; 1135 echov.background = fWhitePixel;; 1136 if (strstr(vendor,""Hewlett"")); 1137 echov.function = GXxor;; 1138 else; 1139 echov.function = GXinvert;; 1140 ; 1141 gGCecho = XCreateGC((Display*)fDisplay, fVisRootWin,; 1142 GCForeground | GCBackground | GCFunction,; 1143 &echov);; 1144 ; 1145 // Load a default Font; 1146 static int isdisp = 0;; 1147 if (!isdisp) {; 1148 for (i = 0; i < kMAXFONT; i++) {; 1149 gFont[i].id = nullptr;; 1150 strcpy(gFont[i].name, "" "");; 1151 }; 1152 fontlist = XListFonts((Display*)fDisplay, ""*courier*"", 1, &fontcount);; 1153 if (fontlist && fontcount != 0) {; 1154 gFont[gCurrentFontNumber].id = XLoadQueryFont((Display*)fDisplay, fontlist[0]);; 1155 gTextFont = gFont[gCurrentFontNumber].id;; 1156 strcpy(gFont[gCurrentFontNumber].name, ""*courier*"");; 1157 gCurrentFontNumber++;; 1158 XFreeFontNames(fontlist);; 1159 } else {; 1160 // emergency: try fixed font; 1161 fontlist = XListFonts((Display*)fDisplay, ""fixed"", 1, &fontcount);; 1162 if (fontlist && fontcount != 0) {; 1163 gFont[gCurrentFontNumber].id = XLoadQ",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:37047,Availability,echo,echov,37047,"te primitives graphic contexts; 1116 for (i = 0; i < kMAXGC; i++); 1117 gGClist[i] = XCreateGC((Display*)fDisplay, fVisRootWin, 0, nullptr);; 1118 ; 1119 XGCValues values;; 1120 if (XGetGCValues((Display*)fDisplay, *gGCtext, GCForeground|GCBackground, &values)) {; 1121 XSetForeground((Display*)fDisplay, *gGCinvt, values.background);; 1122 XSetBackground((Display*)fDisplay, *gGCinvt, values.foreground);; 1123 } else {; 1124 Error(""OpenDisplay"", ""cannot get GC values"");; 1125 }; 1126 ; 1127 // Turn-off GraphicsExpose and NoExpose event reporting for the pixmap; 1128 // manipulation GC, this to prevent these events from being stacked up; 1129 // without ever being processed and thereby wasting a lot of memory.; 1130 XSetGraphicsExposures((Display*)fDisplay, *gGCpxmp, False);; 1131 ; 1132 // Create input echo graphic context; 1133 XGCValues echov;; 1134 echov.foreground = fBlackPixel;; 1135 echov.background = fWhitePixel;; 1136 if (strstr(vendor,""Hewlett"")); 1137 echov.function = GXxor;; 1138 else; 1139 echov.function = GXinvert;; 1140 ; 1141 gGCecho = XCreateGC((Display*)fDisplay, fVisRootWin,; 1142 GCForeground | GCBackground | GCFunction,; 1143 &echov);; 1144 ; 1145 // Load a default Font; 1146 static int isdisp = 0;; 1147 if (!isdisp) {; 1148 for (i = 0; i < kMAXFONT; i++) {; 1149 gFont[i].id = nullptr;; 1150 strcpy(gFont[i].name, "" "");; 1151 }; 1152 fontlist = XListFonts((Display*)fDisplay, ""*courier*"", 1, &fontcount);; 1153 if (fontlist && fontcount != 0) {; 1154 gFont[gCurrentFontNumber].id = XLoadQueryFont((Display*)fDisplay, fontlist[0]);; 1155 gTextFont = gFont[gCurrentFontNumber].id;; 1156 strcpy(gFont[gCurrentFontNumber].name, ""*courier*"");; 1157 gCurrentFontNumber++;; 1158 XFreeFontNames(fontlist);; 1159 } else {; 1160 // emergency: try fixed font; 1161 fontlist = XListFonts((Display*)fDisplay, ""fixed"", 1, &fontcount);; 1162 if (fontlist && fontcount != 0) {; 1163 gFont[gCurrentFontNumber].id = XLoadQueryFont((Display*)fDisplay, fontlist[0]);; 1164 gTextFont",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:37195,Availability,echo,echov,37195,"lues;; 1120 if (XGetGCValues((Display*)fDisplay, *gGCtext, GCForeground|GCBackground, &values)) {; 1121 XSetForeground((Display*)fDisplay, *gGCinvt, values.background);; 1122 XSetBackground((Display*)fDisplay, *gGCinvt, values.foreground);; 1123 } else {; 1124 Error(""OpenDisplay"", ""cannot get GC values"");; 1125 }; 1126 ; 1127 // Turn-off GraphicsExpose and NoExpose event reporting for the pixmap; 1128 // manipulation GC, this to prevent these events from being stacked up; 1129 // without ever being processed and thereby wasting a lot of memory.; 1130 XSetGraphicsExposures((Display*)fDisplay, *gGCpxmp, False);; 1131 ; 1132 // Create input echo graphic context; 1133 XGCValues echov;; 1134 echov.foreground = fBlackPixel;; 1135 echov.background = fWhitePixel;; 1136 if (strstr(vendor,""Hewlett"")); 1137 echov.function = GXxor;; 1138 else; 1139 echov.function = GXinvert;; 1140 ; 1141 gGCecho = XCreateGC((Display*)fDisplay, fVisRootWin,; 1142 GCForeground | GCBackground | GCFunction,; 1143 &echov);; 1144 ; 1145 // Load a default Font; 1146 static int isdisp = 0;; 1147 if (!isdisp) {; 1148 for (i = 0; i < kMAXFONT; i++) {; 1149 gFont[i].id = nullptr;; 1150 strcpy(gFont[i].name, "" "");; 1151 }; 1152 fontlist = XListFonts((Display*)fDisplay, ""*courier*"", 1, &fontcount);; 1153 if (fontlist && fontcount != 0) {; 1154 gFont[gCurrentFontNumber].id = XLoadQueryFont((Display*)fDisplay, fontlist[0]);; 1155 gTextFont = gFont[gCurrentFontNumber].id;; 1156 strcpy(gFont[gCurrentFontNumber].name, ""*courier*"");; 1157 gCurrentFontNumber++;; 1158 XFreeFontNames(fontlist);; 1159 } else {; 1160 // emergency: try fixed font; 1161 fontlist = XListFonts((Display*)fDisplay, ""fixed"", 1, &fontcount);; 1162 if (fontlist && fontcount != 0) {; 1163 gFont[gCurrentFontNumber].id = XLoadQueryFont((Display*)fDisplay, fontlist[0]);; 1164 gTextFont = gFont[gCurrentFontNumber].id;; 1165 strcpy(gFont[gCurrentFontNumber].name, ""fixed"");; 1166 gCurrentFontNumber++;; 1167 XFreeFontNames(fontlist);; 1168 } else {; 1",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:60335,Availability,error,errors,60335," gTws->fHeight = h;; 1867}; 1868 ; 1869////////////////////////////////////////////////////////////////////////////////; 1870/// Resize a pixmap.; 1871///; 1872/// \param [in] wid : pixmap to be resized; 1873/// \param [in] w,h : Width and height of the pixmap; 1874 ; 1875int TGX11::ResizePixmap(int wid, unsigned int w, unsigned int h); 1876{; 1877 Window root;; 1878 unsigned int wval, hval;; 1879 int xx, yy, i;; 1880 unsigned int ww, hh, border, depth;; 1881 wval = w;; 1882 hval = h;; 1883 ; 1884 gTws = &fWindows[wid];; 1885 ; 1886 // don't do anything when size did not change; 1887 // if (gTws->fWidth == wval && gTws->fHeight == hval) return 0;; 1888 ; 1889 // due to round-off errors in TPad::Resize() we might get +/- 1 pixel; 1890 // change, in those cases don't resize pixmap; 1891 if (gTws->fWidth >= wval-1 && gTws->fWidth <= wval+1 &&; 1892 gTws->fHeight >= hval-1 && gTws->fHeight <= hval+1) return 0;; 1893 ; 1894 // don't free and recreate pixmap when new pixmap is smaller; 1895 if (gTws->fWidth < wval || gTws->fHeight < hval) {; 1896 XFreePixmap((Display*)fDisplay, gTws->fWindow);; 1897 gTws->fWindow = XCreatePixmap((Display*)fDisplay, fRootWin, wval, hval, fDepth);; 1898 }; 1899 XGetGeometry((Display*)fDisplay, gTws->fWindow, &root, &xx, &yy, &ww, &hh, &border, &depth);; 1900 ; 1901 for (i = 0; i < kMAXGC; i++); 1902 XSetClipMask((Display*)fDisplay, gGClist[i], None);; 1903 ; 1904 SetColor(gGCpxmp, 0);; 1905 XFillRectangle((Display*)fDisplay, gTws->fWindow, *gGCpxmp, 0, 0, ww, hh);; 1906 SetColor(gGCpxmp, 1);; 1907 ; 1908 // Initialise the window structure; 1909 gTws->fDrawing = gTws->fWindow;; 1910 gTws->fWidth = wval;; 1911 gTws->fHeight = hval;; 1912 ; 1913 return 1;; 1914}; 1915 ; 1916////////////////////////////////////////////////////////////////////////////////; 1917/// Resize the current window if necessary.; 1918 ; 1919void TGX11::ResizeWindow(Int_t wid); 1920{; 1921 int i;; 1922 int xval=0, yval=0;; 1923 Window win, root=0;; 1924 unsigned int wval=",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:69371,Availability,echo,echo,69371,"Tws->fBuffer = XCreatePixmap((Display*)fDisplay, fRootWin,; 2139 gTws->fWidth, gTws->fHeight, fDepth);; 2140 SetColor(gGCpxmp, 0);; 2141 XFillRectangle((Display*)fDisplay, gTws->fBuffer, *gGCpxmp, 0, 0, gTws->fWidth, gTws->fHeight);; 2142 SetColor(gGCpxmp, 1);; 2143 }; 2144 for (int i = 0; i < kMAXGC; i++) XSetClipMask((Display*)fDisplay, gGClist[i], None);; 2145 gTws->fDoubleBuffer = 1;; 2146 gTws->fDrawing = gTws->fBuffer;; 2147}; 2148 ; 2149////////////////////////////////////////////////////////////////////////////////; 2150/// Set the drawing mode.; 2151///; 2152/// \param [in] mode : drawing mode; 2153/// - mode=1 copy; 2154/// - mode=2 xor; 2155/// - mode=3 invert; 2156/// - mode=4 set the suitable mode for cursor echo according to; 2157/// the vendor; 2158 ; 2159void TGX11::SetDrawMode(EDrawMode mode); 2160{; 2161 int i;; 2162 if (fDisplay) {; 2163 switch (mode) {; 2164 case kCopy:; 2165 for (i = 0; i < kMAXGC; i++) XSetFunction((Display*)fDisplay, gGClist[i], GXcopy);; 2166 break;; 2167 ; 2168 case kXor:; 2169 for (i = 0; i < kMAXGC; i++) XSetFunction((Display*)fDisplay, gGClist[i], GXxor);; 2170 break;; 2171 ; 2172 case kInvert:; 2173 for (i = 0; i < kMAXGC; i++) XSetFunction((Display*)fDisplay, gGClist[i], GXinvert);; 2174 break;; 2175 }; 2176 }; 2177 fDrawMode = mode;; 2178}; 2179 ; 2180////////////////////////////////////////////////////////////////////////////////; 2181/// Set color index for fill areas.; 2182 ; 2183void TGX11::SetFillColor(Color_t cindex); 2184{; 2185 if (!gStyle->GetFillColor() && cindex > 1) cindex = 0;; 2186 if (cindex >= 0) SetColor(gGCfill, Int_t(cindex));; 2187 fFillColor = cindex;; 2188 ; 2189 // invalidate fill pattern; 2190 if (gFillPattern != 0) {; 2191 XFreePixmap((Display*)fDisplay, gFillPattern);; 2192 gFillPattern = 0;; 2193 }; 2194}; 2195 ; 2196////////////////////////////////////////////////////////////////////////////////; 2197/// Set fill area style.; 2198///; 2199/// \param [in] fstyle : compound fill area interior ",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:81352,Availability,down,down,81352,"aped marker (with 9 pixel); 2492 shape[0].x = -1 ; shape[0].y = 1;; 2493 shape[1].x = 1 ; shape[1].y = 1;; 2494 shape[2].x = -1 ; shape[2].y = 0;; 2495 shape[3].x = 1 ; shape[3].y = 0;; 2496 shape[4].x = -1 ; shape[4].y = -1;; 2497 shape[5].x = 1 ; shape[5].y = -1;; 2498 SetMarkerType(4,6,shape);; 2499 } else if (markerstyle == 8 || markerstyle == 20) {; 2500 // O shaped marker (filled); 2501 SetMarkerType(1,im*2,shape);; 2502 } else if (markerstyle == 21) {; 2503 // full square; 2504 shape[0].x = -im; shape[0].y = -im;; 2505 shape[1].x = im; shape[1].y = -im;; 2506 shape[2].x = im; shape[2].y = im;; 2507 shape[3].x = -im; shape[3].y = im;; 2508 shape[4].x = -im; shape[4].y = -im;; 2509 SetMarkerType(3,5,shape);; 2510 } else if (markerstyle == 22) {; 2511 // full triangle up; 2512 shape[0].x = -im; shape[0].y = im;; 2513 shape[1].x = im; shape[1].y = im;; 2514 shape[2].x = 0; shape[2].y = -im;; 2515 shape[3].x = -im; shape[3].y = im;; 2516 SetMarkerType(3,4,shape);; 2517 } else if (markerstyle == 23) {; 2518 // full triangle down; 2519 shape[0].x = 0; shape[0].y = im;; 2520 shape[1].x = im; shape[1].y = -im;; 2521 shape[2].x = -im; shape[2].y = -im;; 2522 shape[3].x = 0; shape[3].y = im;; 2523 SetMarkerType(3,4,shape);; 2524 } else if (markerstyle == 25) {; 2525 // open square; 2526 shape[0].x = -im; shape[0].y = -im;; 2527 shape[1].x = im; shape[1].y = -im;; 2528 shape[2].x = im; shape[2].y = im;; 2529 shape[3].x = -im; shape[3].y = im;; 2530 shape[4].x = -im; shape[4].y = -im;; 2531 SetMarkerType(2,5,shape);; 2532 } else if (markerstyle == 26) {; 2533 // open triangle up; 2534 shape[0].x = -im; shape[0].y = im;; 2535 shape[1].x = im; shape[1].y = im;; 2536 shape[2].x = 0; shape[2].y = -im;; 2537 shape[3].x = -im; shape[3].y = im;; 2538 SetMarkerType(2,4,shape);; 2539 } else if (markerstyle == 27) {; 2540 // open losange; 2541 Int_t imx = Int_t(2.66*MarkerSizeReduced + 0.5);; 2542 shape[0].x =-imx; shape[0].y = 0;; 2543 shape[1].x = 0; shape[1].y = -im;; 2544 shape[",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:84752,Availability,down,down,84752," im4;; 2578 shape[7].x = im4; shape[7].y = im4;; 2579 shape[8].x = 0; shape[8].y = im;; 2580 shape[9].x =-im4; shape[9].y = im4;; 2581 shape[10].x= -im; shape[10].y= im4;; 2582 SetMarkerType(3,11,shape);; 2583 } else if (markerstyle == 30) {; 2584 // open star pentagone; 2585 Int_t im1 = Int_t(0.66*MarkerSizeReduced + 0.5);; 2586 Int_t im2 = Int_t(2.00*MarkerSizeReduced + 0.5);; 2587 Int_t im3 = Int_t(2.66*MarkerSizeReduced + 0.5);; 2588 Int_t im4 = Int_t(1.33*MarkerSizeReduced + 0.5);; 2589 shape[0].x = -im; shape[0].y = im4;; 2590 shape[1].x =-im2; shape[1].y =-im1;; 2591 shape[2].x =-im3; shape[2].y = -im;; 2592 shape[3].x = 0; shape[3].y =-im2;; 2593 shape[4].x = im3; shape[4].y = -im;; 2594 shape[5].x = im2; shape[5].y =-im1;; 2595 shape[6].x = im; shape[6].y = im4;; 2596 shape[7].x = im4; shape[7].y = im4;; 2597 shape[8].x = 0; shape[8].y = im;; 2598 shape[9].x =-im4; shape[9].y = im4;; 2599 shape[10].x= -im; shape[10].y= im4;; 2600 SetMarkerType(2,11,shape);; 2601 } else if (markerstyle == 32) {; 2602 // open triangle down; 2603 shape[0].x = 0; shape[0].y = im;; 2604 shape[1].x = im; shape[1].y = -im;; 2605 shape[2].x = -im; shape[2].y = -im;; 2606 shape[3].x = 0; shape[3].y = im;; 2607 SetMarkerType(2,4,shape);; 2608 } else if (markerstyle == 33) {; 2609 // full losange; 2610 Int_t imx = Int_t(2.66*MarkerSizeReduced + 0.5);; 2611 shape[0].x =-imx; shape[0].y = 0;; 2612 shape[1].x = 0; shape[1].y = -im;; 2613 shape[2].x = imx; shape[2].y = 0;; 2614 shape[3].x = 0; shape[3].y = im;; 2615 shape[4].x =-imx; shape[4].y = 0;; 2616 SetMarkerType(3,5,shape);; 2617 } else if (markerstyle == 34) {; 2618 // full cross; 2619 Int_t imx = Int_t(1.33*MarkerSizeReduced + 0.5);; 2620 shape[0].x = -im; shape[0].y =-imx;; 2621 shape[1].x =-imx; shape[1].y =-imx;; 2622 shape[2].x =-imx; shape[2].y = -im;; 2623 shape[3].x = imx; shape[3].y = -im;; 2624 shape[4].x = imx; shape[4].y =-imx;; 2625 shape[5].x = im; shape[5].y =-imx;; 2626 shape[6].x = im; shape[6].y = imx;; 2627 shap",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:100216,Availability,failure,failure,100216,"978 RXColor *xcol = new RXColor[ncolors];; 2979 ; 2980 int i;; 2981 for (i = 0; i < ncolors; i++) {; 2982 xcol[i].pixel = orgcolors[i];; 2983 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 2984 xcol[i].flags = DoRed | DoGreen | DoBlue;; 2985 }; 2986 QueryColors(fColormap, xcol, ncolors);; 2987 ; 2988 UShort_t add = percent * kBIGGEST_RGB_VALUE / 100;; 2989 ; 2990 Int_t val;; 2991 for (i = 0; i < ncolors; i++) {; 2992 val = xcol[i].red + add;; 2993 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2994 xcol[i].red = (UShort_t) val;; 2995 val = xcol[i].green + add;; 2996 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2997 xcol[i].green = (UShort_t) val;; 2998 val = xcol[i].blue + add;; 2999 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 3000 xcol[i].blue = (UShort_t) val;; 3001 if (!AllocColor(fColormap, &xcol[i])); 3002 Warning(""MakeOpaqueColors"", ""failed to allocate color %hd, %hd, %hd"",; 3003 xcol[i].red, xcol[i].green, xcol[i].blue);; 3004 // assumes that in case of failure xcol[i].pixel is not changed; 3005 }; 3006 ; 3007 gCws->fNewColors = new ULong_t[ncolors];; 3008 gCws->fNcolors = ncolors;; 3009 ; 3010 for (i = 0; i < ncolors; i++); 3011 gCws->fNewColors[i] = xcol[i].pixel;; 3012 ; 3013 delete [] xcol;; 3014}; 3015 ; 3016////////////////////////////////////////////////////////////////////////////////; 3017/// Returns index in orgcolors (and fNewColors) for pixel.; 3018 ; 3019Int_t TGX11::FindColor(ULong_t pixel, ULong_t *orgcolors, Int_t ncolors); 3020{; 3021 for (int i = 0; i < ncolors; i++); 3022 if (pixel == orgcolors[i]) return i;; 3023 ; 3024 Error(""FindColor"", ""did not find color, should never happen!"");; 3025 ; 3026 return 0;; 3027}; 3028 ; 3029////////////////////////////////////////////////////////////////////////////////; 3030/// Set color intensities for given color index.; 3031///; 3032/// \param [in] cindex : color index; 3033/// \param [in] r,g,b : red, green, blue intensities between 0.0 and 1.0; 3034 ; 3035void TGX",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:121198,Availability,error,error,121198,"ster new pixmap; 3644 ; 3645Int_t TGX11::AddPixmap(ULong_t pixid, UInt_t w, UInt_t h); 3646{; 3647 Int_t wid = 0;; 3648 ; 3649 // Select next free window number; 3650 for (; wid < fMaxNumberOfWindows; ++wid); 3651 if (!fWindows[wid].fOpen); 3652 break;; 3653 ; 3654 if (wid == fMaxNumberOfWindows) {; 3655 Int_t newsize = fMaxNumberOfWindows + 10;; 3656 fWindows = (XWindow_t*) TStorage::ReAlloc(; 3657 fWindows, newsize * sizeof(XWindow_t),; 3658 fMaxNumberOfWindows*sizeof(XWindow_t); 3659 );; 3660 ; 3661 for (Int_t i = fMaxNumberOfWindows; i < newsize; ++i); 3662 fWindows[i].fOpen = 0;; 3663 ; 3664 fMaxNumberOfWindows = newsize;; 3665 }; 3666 ; 3667 fWindows[wid].fOpen = 1;; 3668 gCws = fWindows + wid;; 3669 gCws->fWindow = pixid;; 3670 gCws->fDrawing = gCws->fWindow;; 3671 gCws->fBuffer = 0;; 3672 gCws->fDoubleBuffer = 0;; 3673 gCws->fIsPixmap = 1;; 3674 gCws->fClip = 0;; 3675 gCws->fWidth = w;; 3676 gCws->fHeight = h;; 3677 gCws->fNewColors = nullptr;; 3678 gCws->fShared = kFALSE;; 3679 ; 3680 return wid;; 3681}; 3682 ; 3683////////////////////////////////////////////////////////////////////////////////; 3684/// Returns 1 if window system server supports extension given by the; 3685/// argument, returns 0 in case extension is not supported and returns -1; 3686/// in case of error (like server not initialized).; 3687/// Examples:; 3688/// - ""Apple-WM"" - does server run on MacOS X;; 3689/// - ""XINERAMA"" - does server support Xinerama.; 3690/// See also the output of xdpyinfo.; 3691 ; 3692Int_t TGX11::SupportsExtension(const char *ext) const; 3693{; 3694 Int_t major_opcode, first_event, first_error;; 3695 if (!(Display*)fDisplay); 3696 return -1;; 3697 return XQueryExtension((Display*)fDisplay, ext, &major_opcode, &first_event, &first_error);; 3698}; ECursorECursorDefinition GuiTypes.h:372; kRightSide@ kRightSideDefinition GuiTypes.h:373; kBottomSide@ kBottomSideDefinition GuiTypes.h:373; kArrowRight@ kArrowRightDefinition GuiTypes.h:375; kTopLeft@ kTopLeftDefinition Gu",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:125658,Availability,mask,maskDefinition,125658, Font_tshort Font_tDefinition RtypesCore.h:81; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TColor.h; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TExMap.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pixOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void pixDefinition TGWin32VirtualXProxy.cxx:128; chupyOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void chupyDefinition TGWin32VirtualXProxy.cxx:116; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; cindexOption_t Option_t cindexDefinition TGWin32VirtualXProxy.cxx:50; cursorOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t cursorDefinition TGWin32VirtualXProxy.cxx:160; cmapOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void cmapDefinition TGWin32VirtualXProxy.cxx:124; pixelOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void pixelDefinition TGWin32VirtualXProxy.cxx:124; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerSt,MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:139986,Availability,error,error,139986,"gGCtextstatic GC * gGCtextDefinition TGX11.cxx:94; XRotDrawAlignedStringint XRotDrawAlignedString(Display *, XFontStruct *, float, Drawable, GC, int, int, char *, int)A front end to XRotPaintAlignedString: -does alignment, no background.Definition Rotated.cxx:305; XRotDrawImageStringint XRotDrawImageString(Display *, XFontStruct *, float, Drawable, GC, int, int, char *)A front end to XRotPaintAlignedString: -no alignment, paints background.Definition Rotated.cxx:294; gDashSizestatic int gDashSizeDefinition TGX11.cxx:140; gLineWidthstatic int gLineWidthDefinition TGX11.cxx:133; gXimagestatic XImage * gXimageDefinition TGX11.cxx:3294; xyXPoint xy[kMAXMK]Definition TGX11.cxx:123; gMarkerCapStylestatic int gMarkerCapStyleDefinition TGX11.cxx:127; gTextFontstatic XFontStruct * gTextFontDefinition TGX11.cxx:113; XRotSetBoundingBoxPadvoid XRotSetBoundingBoxPad(int)Set the padding used when calculating bounding boxes.Definition Rotated.cxx:251; DummyX11ErrorHandlerstatic Int_t DummyX11ErrorHandler(Display *, XErrorEvent *)Dummy error handler for X11. Used by FindUsableVisual().Definition TGX11.cxx:839; gCwsstatic XWindow_t * gCwsDefinition TGX11.cxx:81; GIFinfoint GIFinfo(Byte_t *gifArr, int *Width, int *Height, int *Ncols)Definition gifdecode.c:80; TGX11.h; ColormapXID ColormapDefinition TGX11.h:35; WindowXID WindowDefinition TGX11.h:36; DrawableXID DrawableDefinition TGX11.h:33; CursorXID CursorDefinition TGX11.h:34; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; kNMAXconst Int_t kNMAXDefinition THistPainter.cxx:3162; TMath.h; TObjArray.h; TObjString.h; TPoint.h; gDebugInt_t gDebugDefinition TROOT.cxx:597; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TStorage.h; TString.h; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; TStyle.h; gStyleR__EXTERN TStyl",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:152125,Availability,failure,failure,152125,"t markersize) overrideSet marker size index.Definition TGX11.cxx:2395; TGX11::CopyWindowtoPixmapvoid CopyWindowtoPixmap(Drawable *pix, Int_t xpos, Int_t ypos)Copy area of current window in the pixmap pix.Definition TGX11.cxx:508; TGX11::fVisRootWinDrawable fVisRootWinRoot window with fVisual to be used to create GC's and XImages.Definition TGX11.h:128; TGX11::SetDoubleBufferONvoid SetDoubleBufferON() overrideTurn double buffer mode on.Definition TGX11.cxx:2134; TGX11::fColorsTExMap * fColorsHash list of colors.Definition TGX11.h:85; TGX11::fTextAlignInt_t fTextAlignText alignment (set in SetTextAlign)Definition TGX11.h:135; TGX11::SetMarkerTypevoid SetMarkerType(Int_t type, Int_t n, RXPoint *xy)Set marker type.Definition TGX11.cxx:2420; TGX11::fRedDivInt_t fRedDivRed value divider, -1 if no TrueColor visual.Definition TGX11.h:140; TGX11::fDepthInt_t fDepthNumber of color planes.Definition TGX11.h:139; TGX11::InitBool_t Init(void *display) overrideInitialize X11 system. Returns kFALSE in case of failure.Definition TGX11.cxx:342; TGX11::SetLineTypevoid SetLineType(Int_t n, Int_t *dash) overrideSet line type.Definition TGX11.cxx:2297; TGX11::CloseWindow1void CloseWindow1()Delete current window.Definition TGX11.cxx:461; TGX11::fBlackPixelULong_t fBlackPixelValue of black pixel in colormap.Definition TGX11.h:130; TGX11::SetTextSizevoid SetTextSize(Float_t textsize) overrideSet current text size.Definition TGX11.cxx:3203; TGX11::fCharacterUpXFloat_t fCharacterUpXCharacter Up vector along X.Definition TGX11.h:136; TGX11::DrawCellArrayvoid DrawCellArray(Int_t x1, Int_t y1, Int_t x2, Int_t y2, Int_t nx, Int_t ny, Int_t *ic) overrideDraw a cell array.Definition TGX11.cxx:559; TGX11::SetLineStylevoid SetLineStyle(Style_t linestyle) overrideSet line style.Definition TGX11.cxx:2323; TGX11::fGreenDivInt_t fGreenDivGreen value divider.Definition TGX11.h:141; TGX11::QueryPointervoid QueryPointer(Int_t &ix, Int_t &iy) overrideQuery pointer position.Definition TGX11.cxx:1454; TGX11::G",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:158788,Availability,error,error,158788,"d, UInt_t w, UInt_t h) overrideRegister a window created by Qt as a ROOT window (like InitWindow()).Definition TGX11.cxx:1378; TGX11::fCharacterUpYFloat_t fCharacterUpYCharacter Up vector along Y.Definition TGX11.h:137; TGX11::fHasTTFontsBool_t fHasTTFontsTrue when TrueType fonts are used.Definition TGX11.h:146; TGX11::SelectWindowvoid SelectWindow(Int_t wid) overrideSelect window to which subsequent output is directed.Definition TGX11.cxx:1958; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjStringCollectable string class.Definition TObjString.h:28; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPointDefinition TPoint.h:31; TStorage::Allocstatic void * Alloc(size_t size)Allocate a block of memory, that later can be resized using TStorage::ReAlloc().Definition TStorage.cxx:152; TStorage::Deallocstatic void Dealloc(void *ptr)De-allocate block of memory, that was allocated via TStorage::Alloc().Definition TStorage.cxx:170; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TStringBasic string class.Definition TString.h:139; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TStyle::GetLineStyleStringconst char * GetLineStyleString(Int_t i=1) constReturn line style string (used by PostScript).Definition TStyle.cxx:1166; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; TVirtualX::EDrawModeEDraw",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:161037,Availability,down,downward,161037," kOpaqueDefinition TVirtualX.h:51; TVirtualX::kClear@ kClearDefinition TVirtualX.h:51; TVirtualX::fDrawModeEDrawMode fDrawModeDefinition TVirtualX.h:55; TVirtualX::EBoxModeEBoxModeDefinition TVirtualX.h:50; TVirtualX::kFilled@ kFilledDefinition TVirtualX.h:50; TVirtualX::kHollow@ kHollowDefinition TVirtualX.h:50; TVirtualX::ETextSetModeETextSetModeDefinition TVirtualX.h:52; TVirtualX::kLoad@ kLoadDefinition TVirtualX.h:52; Visual; XColor; XGCValues; XImage; XSetWindowAttributes; XVisualInfo; bool; int; unsigned int; ptTPaveText * ptDefinition entrylist_figure1.C:7; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; G#define G(x, y, z); TMath::ACosDouble_t ACos(Double_t)Returns the principal value of the arc cosine of x, expressed in radians.Definition TMath.h:632; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; RVisualDefinition GX11Gui.cxx:141; RXColorDefinition GX11Gui.cxx:138; RXGCValuesDefinition GX11Gui.cxx:137; RXImageDefinition TGX11.cxx:163; RXPointDefinition TGX11.cxx:164; RXVisualInfoDefinition TGX11.cxx:165; XColor_tDescription of a X11 color.Definition TGWin32.h:56; XColor_t::fDefinedBool_t fDefinedtrue if pixel value is definedDefinition TGWin32.h:58; XColor_t::fBlueUShort_t fBlueblue valueDefinition TGX11.h:72; XColor_t::fRedUShort_t fRedred value in range [0,kBIGGEST_RGB_VALUE]Definition TGX11.h:70; XColor_t::fGreenUShort_t fGreengreen value",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:20645,Deployability,update,update,20645,"f line; 607 ; 608void TGX11::DrawLine(Int_t x1, Int_t y1, Int_t x2, Int_t y2); 609{; 610 if (gLineStyle == LineSolid); 611 XDrawLine((Display*)fDisplay, gCws->fDrawing, *gGCline, x1, y1, x2, y2);; 612 else {; 613 XSetDashes((Display*)fDisplay, *gGCdash, gDashOffset, gDashList, gDashSize);; 614 XDrawLine((Display*)fDisplay, gCws->fDrawing, *gGCdash, x1, y1, x2, y2);; 615 }; 616}; 617 ; 618////////////////////////////////////////////////////////////////////////////////; 619/// Draw a line through all points.; 620///; 621/// \param [in] n number of points; 622/// \param [in] xy list of points; 623 ; 624void TGX11::DrawPolyLine(int n, TPoint *xy); 625{; 626 XPoint *xyp = (XPoint*)xy;; 627 ; 628 const Int_t kMaxPoints = 1000001;; 629 ; 630 if (n > kMaxPoints) {; 631 int ibeg = 0;; 632 int iend = kMaxPoints - 1;; 633 while (iend < n) {; 634 DrawPolyLine( kMaxPoints, &xy[ibeg] );; 635 ibeg = iend;; 636 iend += kMaxPoints - 1;; 637 }; 638 if (ibeg < n) {; 639 int npt = n - ibeg;; 640 DrawPolyLine( npt, &xy[ibeg] );; 641 }; 642 } else if (n > 1) {; 643 if (gLineStyle == LineSolid); 644 XDrawLines((Display*)fDisplay, gCws->fDrawing, *gGCline, xyp, n, CoordModeOrigin);; 645 else {; 646 int i;; 647 XSetDashes((Display*)fDisplay, *gGCdash,; 648 gDashOffset, gDashList, gDashSize);; 649 XDrawLines((Display*)fDisplay, gCws->fDrawing, *gGCdash, xyp, n, CoordModeOrigin);; 650 ; 651 // calculate length of line to update dash offset; 652 for (i = 1; i < n; i++) {; 653 int dx = xyp[i].x - xyp[i-1].x;; 654 int dy = xyp[i].y - xyp[i-1].y;; 655 if (dx < 0) dx = - dx;; 656 if (dy < 0) dy = - dy;; 657 gDashOffset += dx > dy ? dx : dy;; 658 }; 659 gDashOffset %= gDashLength;; 660 }; 661 } else {; 662 int px,py;; 663 px=xyp[0].x;; 664 py=xyp[0].y;; 665 XDrawPoint((Display*)fDisplay, gCws->fDrawing,; 666 gLineStyle == LineSolid ? *gGCline : *gGCdash, px, py);; 667 }; 668}; 669 ; 670////////////////////////////////////////////////////////////////////////////////; 671/// Draw n markers with the c",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:49515,Deployability,release,released,49515,"/////////////////////////////////////////////////////////////////////; 1470/// Remove the pixmap pix.; 1471 ; 1472void TGX11::RemovePixmap(Drawable *pix); 1473{; 1474 XFreePixmap((Display*)fDisplay,*pix);; 1475}; 1476 ; 1477////////////////////////////////////////////////////////////////////////////////; 1478/// Request Locator position.; 1479///; 1480/// \param [in] x,y : cursor position at moment of button press (output); 1481/// \param [in] ctyp : cursor type (input); 1482/// - ctyp=1 tracking cross; 1483/// - ctyp=2 cross-hair; 1484/// - ctyp=3 rubber circle; 1485/// - ctyp=4 rubber band; 1486/// - ctyp=5 rubber rectangle; 1487///; 1488/// \param [in] mode : input mode; 1489/// - mode=0 request; 1490/// - mode=1 sample; 1491///; 1492/// Request locator:; 1493/// return button number:; 1494/// - 1 = left is pressed; 1495/// - 2 = middle is pressed; 1496/// - 3 = right is pressed; 1497/// in sample mode:; 1498/// - 11 = left is released; 1499/// - 12 = middle is released; 1500/// - 13 = right is released; 1501/// - -1 = nothing is pressed or released; 1502/// - -2 = leave the window; 1503/// - else = keycode (keyboard is pressed); 1504 ; 1505Int_t TGX11::RequestLocator(int mode, int ctyp, int &x, int &y); 1506{; 1507 static int xloc = 0;; 1508 static int yloc = 0;; 1509 static int xlocp = 0;; 1510 static int ylocp = 0;; 1511 static Cursor cursor = 0;; 1512 ; 1513 XEvent event;; 1514 int button_press;; 1515 int radius;; 1516 ; 1517 // Change the cursor shape; 1518 if (cursor == 0) {; 1519 if (ctyp > 1) {; 1520 XDefineCursor((Display*)fDisplay, gCws->fWindow, gNullCursor);; 1521 XSetForeground((Display*)fDisplay, gGCecho, GetColor(0).fPixel);; 1522 } else {; 1523 cursor = XCreateFontCursor((Display*)fDisplay, XC_crosshair);; 1524 XDefineCursor((Display*)fDisplay, gCws->fWindow, cursor);; 1525 }; 1526 }; 1527 ; 1528 // Event loop; 1529 ; 1530 button_press = 0;; 1531 ; 1532 while (button_press == 0) {; 1533 ; 1534 switch (ctyp) {; 1535 ; 1536 case 1 :; 1537 break;; 153",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:49550,Deployability,release,released,49550,"/////////////////////////////////////////////////////////////////////; 1470/// Remove the pixmap pix.; 1471 ; 1472void TGX11::RemovePixmap(Drawable *pix); 1473{; 1474 XFreePixmap((Display*)fDisplay,*pix);; 1475}; 1476 ; 1477////////////////////////////////////////////////////////////////////////////////; 1478/// Request Locator position.; 1479///; 1480/// \param [in] x,y : cursor position at moment of button press (output); 1481/// \param [in] ctyp : cursor type (input); 1482/// - ctyp=1 tracking cross; 1483/// - ctyp=2 cross-hair; 1484/// - ctyp=3 rubber circle; 1485/// - ctyp=4 rubber band; 1486/// - ctyp=5 rubber rectangle; 1487///; 1488/// \param [in] mode : input mode; 1489/// - mode=0 request; 1490/// - mode=1 sample; 1491///; 1492/// Request locator:; 1493/// return button number:; 1494/// - 1 = left is pressed; 1495/// - 2 = middle is pressed; 1496/// - 3 = right is pressed; 1497/// in sample mode:; 1498/// - 11 = left is released; 1499/// - 12 = middle is released; 1500/// - 13 = right is released; 1501/// - -1 = nothing is pressed or released; 1502/// - -2 = leave the window; 1503/// - else = keycode (keyboard is pressed); 1504 ; 1505Int_t TGX11::RequestLocator(int mode, int ctyp, int &x, int &y); 1506{; 1507 static int xloc = 0;; 1508 static int yloc = 0;; 1509 static int xlocp = 0;; 1510 static int ylocp = 0;; 1511 static Cursor cursor = 0;; 1512 ; 1513 XEvent event;; 1514 int button_press;; 1515 int radius;; 1516 ; 1517 // Change the cursor shape; 1518 if (cursor == 0) {; 1519 if (ctyp > 1) {; 1520 XDefineCursor((Display*)fDisplay, gCws->fWindow, gNullCursor);; 1521 XSetForeground((Display*)fDisplay, gGCecho, GetColor(0).fPixel);; 1522 } else {; 1523 cursor = XCreateFontCursor((Display*)fDisplay, XC_crosshair);; 1524 XDefineCursor((Display*)fDisplay, gCws->fWindow, cursor);; 1525 }; 1526 }; 1527 ; 1528 // Event loop; 1529 ; 1530 button_press = 0;; 1531 ; 1532 while (button_press == 0) {; 1533 ; 1534 switch (ctyp) {; 1535 ; 1536 case 1 :; 1537 break;; 153",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:49584,Deployability,release,released,49584,"/////////////////////////////////////////////////////////////////////; 1470/// Remove the pixmap pix.; 1471 ; 1472void TGX11::RemovePixmap(Drawable *pix); 1473{; 1474 XFreePixmap((Display*)fDisplay,*pix);; 1475}; 1476 ; 1477////////////////////////////////////////////////////////////////////////////////; 1478/// Request Locator position.; 1479///; 1480/// \param [in] x,y : cursor position at moment of button press (output); 1481/// \param [in] ctyp : cursor type (input); 1482/// - ctyp=1 tracking cross; 1483/// - ctyp=2 cross-hair; 1484/// - ctyp=3 rubber circle; 1485/// - ctyp=4 rubber band; 1486/// - ctyp=5 rubber rectangle; 1487///; 1488/// \param [in] mode : input mode; 1489/// - mode=0 request; 1490/// - mode=1 sample; 1491///; 1492/// Request locator:; 1493/// return button number:; 1494/// - 1 = left is pressed; 1495/// - 2 = middle is pressed; 1496/// - 3 = right is pressed; 1497/// in sample mode:; 1498/// - 11 = left is released; 1499/// - 12 = middle is released; 1500/// - 13 = right is released; 1501/// - -1 = nothing is pressed or released; 1502/// - -2 = leave the window; 1503/// - else = keycode (keyboard is pressed); 1504 ; 1505Int_t TGX11::RequestLocator(int mode, int ctyp, int &x, int &y); 1506{; 1507 static int xloc = 0;; 1508 static int yloc = 0;; 1509 static int xlocp = 0;; 1510 static int ylocp = 0;; 1511 static Cursor cursor = 0;; 1512 ; 1513 XEvent event;; 1514 int button_press;; 1515 int radius;; 1516 ; 1517 // Change the cursor shape; 1518 if (cursor == 0) {; 1519 if (ctyp > 1) {; 1520 XDefineCursor((Display*)fDisplay, gCws->fWindow, gNullCursor);; 1521 XSetForeground((Display*)fDisplay, gGCecho, GetColor(0).fPixel);; 1522 } else {; 1523 cursor = XCreateFontCursor((Display*)fDisplay, XC_crosshair);; 1524 XDefineCursor((Display*)fDisplay, gCws->fWindow, cursor);; 1525 }; 1526 }; 1527 ; 1528 // Event loop; 1529 ; 1530 button_press = 0;; 1531 ; 1532 while (button_press == 0) {; 1533 ; 1534 switch (ctyp) {; 1535 ; 1536 case 1 :; 1537 break;; 153",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:49631,Deployability,release,released,49631,"/////////////////////////////////////////////////////////////////////; 1470/// Remove the pixmap pix.; 1471 ; 1472void TGX11::RemovePixmap(Drawable *pix); 1473{; 1474 XFreePixmap((Display*)fDisplay,*pix);; 1475}; 1476 ; 1477////////////////////////////////////////////////////////////////////////////////; 1478/// Request Locator position.; 1479///; 1480/// \param [in] x,y : cursor position at moment of button press (output); 1481/// \param [in] ctyp : cursor type (input); 1482/// - ctyp=1 tracking cross; 1483/// - ctyp=2 cross-hair; 1484/// - ctyp=3 rubber circle; 1485/// - ctyp=4 rubber band; 1486/// - ctyp=5 rubber rectangle; 1487///; 1488/// \param [in] mode : input mode; 1489/// - mode=0 request; 1490/// - mode=1 sample; 1491///; 1492/// Request locator:; 1493/// return button number:; 1494/// - 1 = left is pressed; 1495/// - 2 = middle is pressed; 1496/// - 3 = right is pressed; 1497/// in sample mode:; 1498/// - 11 = left is released; 1499/// - 12 = middle is released; 1500/// - 13 = right is released; 1501/// - -1 = nothing is pressed or released; 1502/// - -2 = leave the window; 1503/// - else = keycode (keyboard is pressed); 1504 ; 1505Int_t TGX11::RequestLocator(int mode, int ctyp, int &x, int &y); 1506{; 1507 static int xloc = 0;; 1508 static int yloc = 0;; 1509 static int xlocp = 0;; 1510 static int ylocp = 0;; 1511 static Cursor cursor = 0;; 1512 ; 1513 XEvent event;; 1514 int button_press;; 1515 int radius;; 1516 ; 1517 // Change the cursor shape; 1518 if (cursor == 0) {; 1519 if (ctyp > 1) {; 1520 XDefineCursor((Display*)fDisplay, gCws->fWindow, gNullCursor);; 1521 XSetForeground((Display*)fDisplay, gGCecho, GetColor(0).fPixel);; 1522 } else {; 1523 cursor = XCreateFontCursor((Display*)fDisplay, XC_crosshair);; 1524 XDefineCursor((Display*)fDisplay, gCws->fWindow, cursor);; 1525 }; 1526 }; 1527 ; 1528 // Event loop; 1529 ; 1530 button_press = 0;; 1531 ; 1532 while (button_press == 0) {; 1533 ; 1534 switch (ctyp) {; 1535 ; 1536 case 1 :; 1537 break;; 153",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:106776,Deployability,update,update,106776,"current text font number.; 3194 ; 3195void TGX11::SetTextFont(Font_t fontnumber); 3196{; 3197 fTextFont = fontnumber;; 3198}; 3199 ; 3200////////////////////////////////////////////////////////////////////////////////; 3201/// Set current text size.; 3202 ; 3203void TGX11::SetTextSize(Float_t textsize); 3204{; 3205 fTextSize = textsize;; 3206}; 3207 ; 3208////////////////////////////////////////////////////////////////////////////////; 3209/// Set synchronisation on or off.; 3210///; 3211/// \param [in] mode : synchronisation on/off; 3212/// - mode=1 on; 3213/// - mode<>0 off; 3214 ; 3215void TGX11::Sync(int mode); 3216{; 3217 switch (mode) {; 3218 ; 3219 case 1 :; 3220 XSynchronize((Display*)fDisplay,1);; 3221 break;; 3222 ; 3223 default:; 3224 XSynchronize((Display*)fDisplay,0);; 3225 break;; 3226 }; 3227}; 3228 ; 3229////////////////////////////////////////////////////////////////////////////////; 3230/// Update display.; 3231///; 3232/// \param [in] mode : (1) update (0) sync; 3233///; 3234/// Synchronise client and server once (not permanent).; 3235/// Copy the pixmap gCws->fDrawing on the window gCws->fWindow; 3236/// if the double buffer is on.; 3237 ; 3238void TGX11::UpdateWindow(int mode); 3239{; 3240 if (gCws->fDoubleBuffer) {; 3241 XCopyArea((Display*)fDisplay, gCws->fDrawing, gCws->fWindow,; 3242 *gGCpxmp, 0, 0, gCws->fWidth, gCws->fHeight, 0, 0);; 3243 }; 3244 if (mode == 1) {; 3245 XFlush((Display*)fDisplay);; 3246 } else {; 3247 XSync((Display*)fDisplay, False);; 3248 }; 3249}; 3250 ; 3251////////////////////////////////////////////////////////////////////////////////; 3252/// Set pointer position.; 3253///; 3254/// \param [in] ix New X coordinate of pointer; 3255/// \param [in] iy New Y coordinate of pointer; 3256/// \param [in] id Window identifier; 3257///; 3258/// Coordinates are relative to the origin of the window id; 3259/// or to the origin of the current window if id == 0.; 3260 ; 3261void TGX11::Warp(Int_t ix, Int_t iy, Window_t id); 3262{; 3",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:111819,Deployability,update,update,111819," 3342 }; 3343 }; 3344 ; 3345 // get RGB values belonging to pixels; 3346 RXColor *xcol = new RXColor[ncolors];; 3347 ; 3348 int i;; 3349 for (i = 0; i < ncolors; i++) {; 3350 xcol[i].pixel = orgcolors[i];; 3351 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 3352 xcol[i].flags = DoRed | DoGreen | DoBlue;; 3353 }; 3354 QueryColors(fColormap, xcol, ncolors);; 3355 ; 3356 // create RGB arrays and store RGB's for each color and set number of colors; 3357 // (space must be delete by caller); 3358 R = new Int_t[ncolors];; 3359 G = new Int_t[ncolors];; 3360 B = new Int_t[ncolors];; 3361 ; 3362 for (i = 0; i < ncolors; i++) {; 3363 R[i] = xcol[i].red;; 3364 G[i] = xcol[i].green;; 3365 B[i] = xcol[i].blue;; 3366 }; 3367 ncol = ncolors;; 3368 ; 3369 // update image with indices (pixels) into the new RGB colormap; 3370 for (x = 0; x < (int) gCws->fWidth; x++) {; 3371 for (y = 0; y < (int) gCws->fHeight; y++) {; 3372 ULong_t pixel = XGetPixel(image, x, y);; 3373 Int_t idx = FindColor(pixel, orgcolors, ncolors);; 3374 XPutPixel(image, x, y, idx);; 3375 }; 3376 }; 3377 ; 3378 // cleanup; 3379 delete [] xcol;; 3380 ::operator delete(orgcolors);; 3381}; 3382 ; 3383////////////////////////////////////////////////////////////////////////////////; 3384/// Writes the current window into GIF file. Returns 1 in case of success,; 3385/// 0 otherwise.; 3386 ; 3387Int_t TGX11::WriteGIF(char *name); 3388{; 3389 Byte_t scline[2000], r[256], b[256], g[256];; 3390 Int_t *red, *green, *blue;; 3391 Int_t ncol, maxcol, i;; 3392 ; 3393 if (gXimage) {; 3394 XDestroyImage(gXimage);; 3395 gXimage = nullptr;; 3396 }; 3397 ; 3398 gXimage = XGetImage((Display*)fDisplay, gCws->fDrawing, 0, 0,; 3399 gCws->fWidth, gCws->fHeight,; 3400 AllPlanes, ZPixmap);; 3401 ; 3402 ImgPickPalette((RXImage*)gXimage, ncol, red, green, blue);; 3403 ; 3404 if (ncol > 256) {; 3405 //GIFquantize(...);; 3406 Error(""WriteGIF"", ""Cannot create GIF of image containing more than 256 colors. Try in batch mode."");; 3407 delete [] red",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:11265,Energy Efficiency,green,green,11265,"c(fWindows);; 328 ; 329 if (!fColors) return;; 330 Long64_t key, value;; 331 TExMapIter it(fColors);; 332 while (it.Next(key, value)) {; 333 XColor_t *col = (XColor_t *) (Long_t)value;; 334 delete col;; 335 }; 336 delete fColors;; 337}; 338 ; 339////////////////////////////////////////////////////////////////////////////////; 340/// Initialize X11 system. Returns kFALSE in case of failure.; 341 ; 342Bool_t TGX11::Init(void *display); 343{; 344 if (OpenDisplay(display) == -1) return kFALSE;; 345 return kTRUE;; 346}; 347 ; 348////////////////////////////////////////////////////////////////////////////////; 349/// Allocate color in colormap. If we are on an <= 8 plane machine; 350/// we will use XAllocColor. If we are on a >= 15 (15, 16 or 24) plane; 351/// true color machine we will calculate the pixel value using:; 352/// for 15 and 16 bit true colors have 6 bits precision per color however; 353/// only the 5 most significant bits are used in the color index.; 354/// Except for 16 bits where green uses all 6 bits. I.e.:; 355/// ~~~ {.cpp}; 356/// 15 bits = rrrrrgggggbbbbb; 357/// 16 bits = rrrrrggggggbbbbb; 358/// ~~~; 359/// for 24 bits each r, g and b are represented by 8 bits.; 360///; 361/// Since all colors are set with a max of 65535 (16 bits) per r, g, b; 362/// we just right shift them by 10, 11 and 10 bits for 16 planes, and; 363/// (10, 10, 10 for 15 planes) and by 8 bits for 24 planes.; 364/// Returns kFALSE in case color allocation failed.; 365 ; 366Bool_t TGX11::AllocColor(Colormap cmap, RXColor *color); 367{; 368 if (fRedDiv == -1) {; 369 if (XAllocColor((Display*)fDisplay, cmap, color)); 370 return kTRUE;; 371 } else {; 372 color->pixel = (color->red >> fRedDiv) << fRedShift |; 373 (color->green >> fGreenDiv) << fGreenShift |; 374 (color->blue >> fBlueDiv) << fBlueShift;; 375 return kTRUE;; 376 }; 377 return kFALSE;; 378}; 379 ; 380////////////////////////////////////////////////////////////////////////////////; 381/// Returns the current RGB value for",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:11992,Energy Efficiency,green,green,11992,"ne; 351/// true color machine we will calculate the pixel value using:; 352/// for 15 and 16 bit true colors have 6 bits precision per color however; 353/// only the 5 most significant bits are used in the color index.; 354/// Except for 16 bits where green uses all 6 bits. I.e.:; 355/// ~~~ {.cpp}; 356/// 15 bits = rrrrrgggggbbbbb; 357/// 16 bits = rrrrrggggggbbbbb; 358/// ~~~; 359/// for 24 bits each r, g and b are represented by 8 bits.; 360///; 361/// Since all colors are set with a max of 65535 (16 bits) per r, g, b; 362/// we just right shift them by 10, 11 and 10 bits for 16 planes, and; 363/// (10, 10, 10 for 15 planes) and by 8 bits for 24 planes.; 364/// Returns kFALSE in case color allocation failed.; 365 ; 366Bool_t TGX11::AllocColor(Colormap cmap, RXColor *color); 367{; 368 if (fRedDiv == -1) {; 369 if (XAllocColor((Display*)fDisplay, cmap, color)); 370 return kTRUE;; 371 } else {; 372 color->pixel = (color->red >> fRedDiv) << fRedShift |; 373 (color->green >> fGreenDiv) << fGreenShift |; 374 (color->blue >> fBlueDiv) << fBlueShift;; 375 return kTRUE;; 376 }; 377 return kFALSE;; 378}; 379 ; 380////////////////////////////////////////////////////////////////////////////////; 381/// Returns the current RGB value for the pixel in the XColor structure.; 382 ; 383void TGX11::QueryColors(Colormap cmap, RXColor *color, Int_t ncolors); 384{; 385 if (fRedDiv == -1) {; 386 XQueryColors((Display*)fDisplay, cmap, color, ncolors);; 387 } else {; 388 ULong_t r, g, b;; 389 for (Int_t i = 0; i < ncolors; i++) {; 390 r = (color[i].pixel & fVisual->red_mask) >> fRedShift;; 391 color[i].red = UShort_t(r*kBIGGEST_RGB_VALUE/(fVisual->red_mask >> fRedShift));; 392 ; 393 g = (color[i].pixel & fVisual->green_mask) >> fGreenShift;; 394 color[i].green = UShort_t(g*kBIGGEST_RGB_VALUE/(fVisual->green_mask >> fGreenShift));; 395 ; 396 b = (color[i].pixel & fVisual->blue_mask) >> fBlueShift;; 397 color[i].blue = UShort_t(b*kBIGGEST_RGB_VALUE/(fVisual->blue_mask >> fBlueShift));; 398 ",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:12776,Energy Efficiency,green,green,12776,"1) {; 369 if (XAllocColor((Display*)fDisplay, cmap, color)); 370 return kTRUE;; 371 } else {; 372 color->pixel = (color->red >> fRedDiv) << fRedShift |; 373 (color->green >> fGreenDiv) << fGreenShift |; 374 (color->blue >> fBlueDiv) << fBlueShift;; 375 return kTRUE;; 376 }; 377 return kFALSE;; 378}; 379 ; 380////////////////////////////////////////////////////////////////////////////////; 381/// Returns the current RGB value for the pixel in the XColor structure.; 382 ; 383void TGX11::QueryColors(Colormap cmap, RXColor *color, Int_t ncolors); 384{; 385 if (fRedDiv == -1) {; 386 XQueryColors((Display*)fDisplay, cmap, color, ncolors);; 387 } else {; 388 ULong_t r, g, b;; 389 for (Int_t i = 0; i < ncolors; i++) {; 390 r = (color[i].pixel & fVisual->red_mask) >> fRedShift;; 391 color[i].red = UShort_t(r*kBIGGEST_RGB_VALUE/(fVisual->red_mask >> fRedShift));; 392 ; 393 g = (color[i].pixel & fVisual->green_mask) >> fGreenShift;; 394 color[i].green = UShort_t(g*kBIGGEST_RGB_VALUE/(fVisual->green_mask >> fGreenShift));; 395 ; 396 b = (color[i].pixel & fVisual->blue_mask) >> fBlueShift;; 397 color[i].blue = UShort_t(b*kBIGGEST_RGB_VALUE/(fVisual->blue_mask >> fBlueShift));; 398 ; 399 color[i].flags = DoRed | DoGreen | DoBlue;; 400 }; 401 }; 402}; 403 ; 404////////////////////////////////////////////////////////////////////////////////; 405/// Clear the pixmap pix.; 406 ; 407void TGX11::ClearPixmap(Drawable *pix); 408{; 409 Window root;; 410 int xx, yy;; 411 unsigned int ww, hh, border, depth;; 412 XGetGeometry((Display*)fDisplay, *pix, &root, &xx, &yy, &ww, &hh, &border, &depth);; 413 SetColor(gGCpxmp, 0);; 414 XFillRectangle((Display*)fDisplay, *pix, *gGCpxmp, 0 ,0 ,ww ,hh);; 415 SetColor(gGCpxmp, 1);; 416 XFlush((Display*)fDisplay);; 417}; 418 ; 419////////////////////////////////////////////////////////////////////////////////; 420/// Clear current window.; 421 ; 422void TGX11::ClearWindow(); 423{; 424 if (!gCws->fIsPixmap && !gCws->fDoubleBuffer) {; 425 XSetWindowBackgrou",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:96467,Energy Efficiency,allocate,allocated,96467,,MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:99044,Energy Efficiency,allocate,allocate,99044," }; 2930 ; 2931 // put image back in pixmap on server; 2932 XPutImage((Display*)fDisplay, gCws->fDrawing, *gGCpxmp, image, 0, 0, 0, 0,; 2933 gCws->fWidth, gCws->fHeight);; 2934 XFlush((Display*)fDisplay);; 2935 ; 2936 // clean up; 2937 if (tmpc) {; 2938 if (fRedDiv == -1); 2939 XFreeColors((Display*)fDisplay, fColormap, tmpc, ntmpc, 0);; 2940 delete [] tmpc;; 2941 }; 2942 XDestroyImage(image);; 2943 ::operator delete(orgcolors);; 2944}; 2945 ; 2946////////////////////////////////////////////////////////////////////////////////; 2947/// Collect in orgcolors all different original image colors.; 2948 ; 2949void TGX11::CollectImageColors(ULong_t pixel, ULong_t *&orgcolors, Int_t &ncolors,; 2950 Int_t &maxcolors); 2951{; 2952 if (maxcolors == 0) {; 2953 ncolors = 0;; 2954 maxcolors = 100;; 2955 orgcolors = (ULong_t*) ::operator new(maxcolors*sizeof(ULong_t));; 2956 }; 2957 ; 2958 for (int i = 0; i < ncolors; i++); 2959 if (pixel == orgcolors[i]) return;; 2960 ; 2961 if (ncolors >= maxcolors) {; 2962 orgcolors = (ULong_t*) TStorage::ReAlloc(orgcolors,; 2963 maxcolors*2*sizeof(ULong_t), maxcolors*sizeof(ULong_t));; 2964 maxcolors *= 2;; 2965 }; 2966 ; 2967 orgcolors[ncolors++] = pixel;; 2968}; 2969 ; 2970////////////////////////////////////////////////////////////////////////////////; 2971/// Get RGB values for orgcolors, add percent neutral to the RGB and; 2972/// allocate fNewColors.; 2973 ; 2974void TGX11::MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors); 2975{; 2976 if (ncolors == 0) return;; 2977 ; 2978 RXColor *xcol = new RXColor[ncolors];; 2979 ; 2980 int i;; 2981 for (i = 0; i < ncolors; i++) {; 2982 xcol[i].pixel = orgcolors[i];; 2983 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 2984 xcol[i].flags = DoRed | DoGreen | DoBlue;; 2985 }; 2986 QueryColors(fColormap, xcol, ncolors);; 2987 ; 2988 UShort_t add = percent * kBIGGEST_RGB_VALUE / 100;; 2989 ; 2990 Int_t val;; 2991 for (i = 0; i < ncolors; i++) {; 2992 val = xcol[i].red + add;; 2993 if (v",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:99368,Energy Efficiency,green,green,99368,"ors); 2951{; 2952 if (maxcolors == 0) {; 2953 ncolors = 0;; 2954 maxcolors = 100;; 2955 orgcolors = (ULong_t*) ::operator new(maxcolors*sizeof(ULong_t));; 2956 }; 2957 ; 2958 for (int i = 0; i < ncolors; i++); 2959 if (pixel == orgcolors[i]) return;; 2960 ; 2961 if (ncolors >= maxcolors) {; 2962 orgcolors = (ULong_t*) TStorage::ReAlloc(orgcolors,; 2963 maxcolors*2*sizeof(ULong_t), maxcolors*sizeof(ULong_t));; 2964 maxcolors *= 2;; 2965 }; 2966 ; 2967 orgcolors[ncolors++] = pixel;; 2968}; 2969 ; 2970////////////////////////////////////////////////////////////////////////////////; 2971/// Get RGB values for orgcolors, add percent neutral to the RGB and; 2972/// allocate fNewColors.; 2973 ; 2974void TGX11::MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors); 2975{; 2976 if (ncolors == 0) return;; 2977 ; 2978 RXColor *xcol = new RXColor[ncolors];; 2979 ; 2980 int i;; 2981 for (i = 0; i < ncolors; i++) {; 2982 xcol[i].pixel = orgcolors[i];; 2983 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 2984 xcol[i].flags = DoRed | DoGreen | DoBlue;; 2985 }; 2986 QueryColors(fColormap, xcol, ncolors);; 2987 ; 2988 UShort_t add = percent * kBIGGEST_RGB_VALUE / 100;; 2989 ; 2990 Int_t val;; 2991 for (i = 0; i < ncolors; i++) {; 2992 val = xcol[i].red + add;; 2993 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2994 xcol[i].red = (UShort_t) val;; 2995 val = xcol[i].green + add;; 2996 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2997 xcol[i].green = (UShort_t) val;; 2998 val = xcol[i].blue + add;; 2999 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 3000 xcol[i].blue = (UShort_t) val;; 3001 if (!AllocColor(fColormap, &xcol[i])); 3002 Warning(""MakeOpaqueColors"", ""failed to allocate color %hd, %hd, %hd"",; 3003 xcol[i].red, xcol[i].green, xcol[i].blue);; 3004 // assumes that in case of failure xcol[i].pixel is not changed; 3005 }; 3006 ; 3007 gCws->fNewColors = new ULong_t[ncolors];; 3008 gCws->fNcolors = ncolors;; 3009 ; 3010 for (i = 0; i < ",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:99770,Energy Efficiency,green,green,99770,"5 }; 2966 ; 2967 orgcolors[ncolors++] = pixel;; 2968}; 2969 ; 2970////////////////////////////////////////////////////////////////////////////////; 2971/// Get RGB values for orgcolors, add percent neutral to the RGB and; 2972/// allocate fNewColors.; 2973 ; 2974void TGX11::MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors); 2975{; 2976 if (ncolors == 0) return;; 2977 ; 2978 RXColor *xcol = new RXColor[ncolors];; 2979 ; 2980 int i;; 2981 for (i = 0; i < ncolors; i++) {; 2982 xcol[i].pixel = orgcolors[i];; 2983 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 2984 xcol[i].flags = DoRed | DoGreen | DoBlue;; 2985 }; 2986 QueryColors(fColormap, xcol, ncolors);; 2987 ; 2988 UShort_t add = percent * kBIGGEST_RGB_VALUE / 100;; 2989 ; 2990 Int_t val;; 2991 for (i = 0; i < ncolors; i++) {; 2992 val = xcol[i].red + add;; 2993 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2994 xcol[i].red = (UShort_t) val;; 2995 val = xcol[i].green + add;; 2996 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2997 xcol[i].green = (UShort_t) val;; 2998 val = xcol[i].blue + add;; 2999 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 3000 xcol[i].blue = (UShort_t) val;; 3001 if (!AllocColor(fColormap, &xcol[i])); 3002 Warning(""MakeOpaqueColors"", ""failed to allocate color %hd, %hd, %hd"",; 3003 xcol[i].red, xcol[i].green, xcol[i].blue);; 3004 // assumes that in case of failure xcol[i].pixel is not changed; 3005 }; 3006 ; 3007 gCws->fNewColors = new ULong_t[ncolors];; 3008 gCws->fNcolors = ncolors;; 3009 ; 3010 for (i = 0; i < ncolors; i++); 3011 gCws->fNewColors[i] = xcol[i].pixel;; 3012 ; 3013 delete [] xcol;; 3014}; 3015 ; 3016////////////////////////////////////////////////////////////////////////////////; 3017/// Returns index in orgcolors (and fNewColors) for pixel.; 3018 ; 3019Int_t TGX11::FindColor(ULong_t pixel, ULong_t *orgcolors, Int_t ncolors); 3020{; 3021 for (int i = 0; i < ncolors; i++); 3022 if (pixel == orgcolors[i]) return i;; 3023 ; 3024 E",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:99859,Energy Efficiency,green,green,99859,"///////////////////////////////////////////////////////////////////////////////; 2971/// Get RGB values for orgcolors, add percent neutral to the RGB and; 2972/// allocate fNewColors.; 2973 ; 2974void TGX11::MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors); 2975{; 2976 if (ncolors == 0) return;; 2977 ; 2978 RXColor *xcol = new RXColor[ncolors];; 2979 ; 2980 int i;; 2981 for (i = 0; i < ncolors; i++) {; 2982 xcol[i].pixel = orgcolors[i];; 2983 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 2984 xcol[i].flags = DoRed | DoGreen | DoBlue;; 2985 }; 2986 QueryColors(fColormap, xcol, ncolors);; 2987 ; 2988 UShort_t add = percent * kBIGGEST_RGB_VALUE / 100;; 2989 ; 2990 Int_t val;; 2991 for (i = 0; i < ncolors; i++) {; 2992 val = xcol[i].red + add;; 2993 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2994 xcol[i].red = (UShort_t) val;; 2995 val = xcol[i].green + add;; 2996 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2997 xcol[i].green = (UShort_t) val;; 2998 val = xcol[i].blue + add;; 2999 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 3000 xcol[i].blue = (UShort_t) val;; 3001 if (!AllocColor(fColormap, &xcol[i])); 3002 Warning(""MakeOpaqueColors"", ""failed to allocate color %hd, %hd, %hd"",; 3003 xcol[i].red, xcol[i].green, xcol[i].blue);; 3004 // assumes that in case of failure xcol[i].pixel is not changed; 3005 }; 3006 ; 3007 gCws->fNewColors = new ULong_t[ncolors];; 3008 gCws->fNcolors = ncolors;; 3009 ; 3010 for (i = 0; i < ncolors; i++); 3011 gCws->fNewColors[i] = xcol[i].pixel;; 3012 ; 3013 delete [] xcol;; 3014}; 3015 ; 3016////////////////////////////////////////////////////////////////////////////////; 3017/// Returns index in orgcolors (and fNewColors) for pixel.; 3018 ; 3019Int_t TGX11::FindColor(ULong_t pixel, ULong_t *orgcolors, Int_t ncolors); 3020{; 3021 for (int i = 0; i < ncolors; i++); 3022 if (pixel == orgcolors[i]) return i;; 3023 ; 3024 Error(""FindColor"", ""did not find color, should never happen!"");; 30",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:100103,Energy Efficiency,allocate,allocate,100103,"3 ; 2974void TGX11::MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors); 2975{; 2976 if (ncolors == 0) return;; 2977 ; 2978 RXColor *xcol = new RXColor[ncolors];; 2979 ; 2980 int i;; 2981 for (i = 0; i < ncolors; i++) {; 2982 xcol[i].pixel = orgcolors[i];; 2983 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 2984 xcol[i].flags = DoRed | DoGreen | DoBlue;; 2985 }; 2986 QueryColors(fColormap, xcol, ncolors);; 2987 ; 2988 UShort_t add = percent * kBIGGEST_RGB_VALUE / 100;; 2989 ; 2990 Int_t val;; 2991 for (i = 0; i < ncolors; i++) {; 2992 val = xcol[i].red + add;; 2993 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2994 xcol[i].red = (UShort_t) val;; 2995 val = xcol[i].green + add;; 2996 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2997 xcol[i].green = (UShort_t) val;; 2998 val = xcol[i].blue + add;; 2999 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 3000 xcol[i].blue = (UShort_t) val;; 3001 if (!AllocColor(fColormap, &xcol[i])); 3002 Warning(""MakeOpaqueColors"", ""failed to allocate color %hd, %hd, %hd"",; 3003 xcol[i].red, xcol[i].green, xcol[i].blue);; 3004 // assumes that in case of failure xcol[i].pixel is not changed; 3005 }; 3006 ; 3007 gCws->fNewColors = new ULong_t[ncolors];; 3008 gCws->fNcolors = ncolors;; 3009 ; 3010 for (i = 0; i < ncolors; i++); 3011 gCws->fNewColors[i] = xcol[i].pixel;; 3012 ; 3013 delete [] xcol;; 3014}; 3015 ; 3016////////////////////////////////////////////////////////////////////////////////; 3017/// Returns index in orgcolors (and fNewColors) for pixel.; 3018 ; 3019Int_t TGX11::FindColor(ULong_t pixel, ULong_t *orgcolors, Int_t ncolors); 3020{; 3021 for (int i = 0; i < ncolors; i++); 3022 if (pixel == orgcolors[i]) return i;; 3023 ; 3024 Error(""FindColor"", ""did not find color, should never happen!"");; 3025 ; 3026 return 0;; 3027}; 3028 ; 3029////////////////////////////////////////////////////////////////////////////////; 3030/// Set color intensities for given color index.; 3031///; 3032/",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:100161,Energy Efficiency,green,green,100161," if (ncolors == 0) return;; 2977 ; 2978 RXColor *xcol = new RXColor[ncolors];; 2979 ; 2980 int i;; 2981 for (i = 0; i < ncolors; i++) {; 2982 xcol[i].pixel = orgcolors[i];; 2983 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 2984 xcol[i].flags = DoRed | DoGreen | DoBlue;; 2985 }; 2986 QueryColors(fColormap, xcol, ncolors);; 2987 ; 2988 UShort_t add = percent * kBIGGEST_RGB_VALUE / 100;; 2989 ; 2990 Int_t val;; 2991 for (i = 0; i < ncolors; i++) {; 2992 val = xcol[i].red + add;; 2993 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2994 xcol[i].red = (UShort_t) val;; 2995 val = xcol[i].green + add;; 2996 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 2997 xcol[i].green = (UShort_t) val;; 2998 val = xcol[i].blue + add;; 2999 if (val > kBIGGEST_RGB_VALUE) val = kBIGGEST_RGB_VALUE;; 3000 xcol[i].blue = (UShort_t) val;; 3001 if (!AllocColor(fColormap, &xcol[i])); 3002 Warning(""MakeOpaqueColors"", ""failed to allocate color %hd, %hd, %hd"",; 3003 xcol[i].red, xcol[i].green, xcol[i].blue);; 3004 // assumes that in case of failure xcol[i].pixel is not changed; 3005 }; 3006 ; 3007 gCws->fNewColors = new ULong_t[ncolors];; 3008 gCws->fNcolors = ncolors;; 3009 ; 3010 for (i = 0; i < ncolors; i++); 3011 gCws->fNewColors[i] = xcol[i].pixel;; 3012 ; 3013 delete [] xcol;; 3014}; 3015 ; 3016////////////////////////////////////////////////////////////////////////////////; 3017/// Returns index in orgcolors (and fNewColors) for pixel.; 3018 ; 3019Int_t TGX11::FindColor(ULong_t pixel, ULong_t *orgcolors, Int_t ncolors); 3020{; 3021 for (int i = 0; i < ncolors; i++); 3022 if (pixel == orgcolors[i]) return i;; 3023 ; 3024 Error(""FindColor"", ""did not find color, should never happen!"");; 3025 ; 3026 return 0;; 3027}; 3028 ; 3029////////////////////////////////////////////////////////////////////////////////; 3030/// Set color intensities for given color index.; 3031///; 3032/// \param [in] cindex : color index; 3033/// \param [in] r,g,b : red, green, blue intensities betwe",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:101140,Energy Efficiency,green,green,101140,"lor %hd, %hd, %hd"",; 3003 xcol[i].red, xcol[i].green, xcol[i].blue);; 3004 // assumes that in case of failure xcol[i].pixel is not changed; 3005 }; 3006 ; 3007 gCws->fNewColors = new ULong_t[ncolors];; 3008 gCws->fNcolors = ncolors;; 3009 ; 3010 for (i = 0; i < ncolors; i++); 3011 gCws->fNewColors[i] = xcol[i].pixel;; 3012 ; 3013 delete [] xcol;; 3014}; 3015 ; 3016////////////////////////////////////////////////////////////////////////////////; 3017/// Returns index in orgcolors (and fNewColors) for pixel.; 3018 ; 3019Int_t TGX11::FindColor(ULong_t pixel, ULong_t *orgcolors, Int_t ncolors); 3020{; 3021 for (int i = 0; i < ncolors; i++); 3022 if (pixel == orgcolors[i]) return i;; 3023 ; 3024 Error(""FindColor"", ""did not find color, should never happen!"");; 3025 ; 3026 return 0;; 3027}; 3028 ; 3029////////////////////////////////////////////////////////////////////////////////; 3030/// Set color intensities for given color index.; 3031///; 3032/// \param [in] cindex : color index; 3033/// \param [in] r,g,b : red, green, blue intensities between 0.0 and 1.0; 3034 ; 3035void TGX11::SetRGB(int cindex, float r, float g, float b); 3036{; 3037 if (fColormap) {; 3038 RXColor xcol;; 3039 xcol.red = (UShort_t)(r * kBIGGEST_RGB_VALUE);; 3040 xcol.green = (UShort_t)(g * kBIGGEST_RGB_VALUE);; 3041 xcol.blue = (UShort_t)(b * kBIGGEST_RGB_VALUE);; 3042 xcol.flags = DoRed | DoGreen | DoBlue;; 3043 XColor_t &col = GetColor(cindex);; 3044 if (col.fDefined) {; 3045 // if color is already defined with same rgb just return; 3046 if (col.fRed == xcol.red && col.fGreen == xcol.green &&; 3047 col.fBlue == xcol.blue); 3048 return;; 3049 col.fDefined = kFALSE;; 3050 if (fRedDiv == -1); 3051 XFreeColors((Display*)fDisplay, fColormap, &col.fPixel, 1, 0);; 3052 }; 3053 if (AllocColor(fColormap, &xcol)) {; 3054 col.fDefined = kTRUE;; 3055 col.fPixel = xcol.pixel;; 3056 col.fRed = xcol.red;; 3057 col.fGreen = xcol.green;; 3058 col.fBlue = xcol.blue;; 3059 }; 3060 }; 3061}; 3062 ; 3063//////////////",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:101368,Energy Efficiency,green,green,101368," gCws->fNewColors[i] = xcol[i].pixel;; 3012 ; 3013 delete [] xcol;; 3014}; 3015 ; 3016////////////////////////////////////////////////////////////////////////////////; 3017/// Returns index in orgcolors (and fNewColors) for pixel.; 3018 ; 3019Int_t TGX11::FindColor(ULong_t pixel, ULong_t *orgcolors, Int_t ncolors); 3020{; 3021 for (int i = 0; i < ncolors; i++); 3022 if (pixel == orgcolors[i]) return i;; 3023 ; 3024 Error(""FindColor"", ""did not find color, should never happen!"");; 3025 ; 3026 return 0;; 3027}; 3028 ; 3029////////////////////////////////////////////////////////////////////////////////; 3030/// Set color intensities for given color index.; 3031///; 3032/// \param [in] cindex : color index; 3033/// \param [in] r,g,b : red, green, blue intensities between 0.0 and 1.0; 3034 ; 3035void TGX11::SetRGB(int cindex, float r, float g, float b); 3036{; 3037 if (fColormap) {; 3038 RXColor xcol;; 3039 xcol.red = (UShort_t)(r * kBIGGEST_RGB_VALUE);; 3040 xcol.green = (UShort_t)(g * kBIGGEST_RGB_VALUE);; 3041 xcol.blue = (UShort_t)(b * kBIGGEST_RGB_VALUE);; 3042 xcol.flags = DoRed | DoGreen | DoBlue;; 3043 XColor_t &col = GetColor(cindex);; 3044 if (col.fDefined) {; 3045 // if color is already defined with same rgb just return; 3046 if (col.fRed == xcol.red && col.fGreen == xcol.green &&; 3047 col.fBlue == xcol.blue); 3048 return;; 3049 col.fDefined = kFALSE;; 3050 if (fRedDiv == -1); 3051 XFreeColors((Display*)fDisplay, fColormap, &col.fPixel, 1, 0);; 3052 }; 3053 if (AllocColor(fColormap, &xcol)) {; 3054 col.fDefined = kTRUE;; 3055 col.fPixel = xcol.pixel;; 3056 col.fRed = xcol.red;; 3057 col.fGreen = xcol.green;; 3058 col.fBlue = xcol.blue;; 3059 }; 3060 }; 3061}; 3062 ; 3063////////////////////////////////////////////////////////////////////////////////; 3064/// Set text alignment.; 3065///; 3066/// \param [in] talign text alignment; 3067 ; 3068void TGX11::SetTextAlign(Short_t talign); 3069{; 3070 Int_t txalh = talign/10;; 3071 Int_t txalv = talign%10;; 3072 fTextA",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:101693,Energy Efficiency,green,green,101693,"ncolors); 3020{; 3021 for (int i = 0; i < ncolors; i++); 3022 if (pixel == orgcolors[i]) return i;; 3023 ; 3024 Error(""FindColor"", ""did not find color, should never happen!"");; 3025 ; 3026 return 0;; 3027}; 3028 ; 3029////////////////////////////////////////////////////////////////////////////////; 3030/// Set color intensities for given color index.; 3031///; 3032/// \param [in] cindex : color index; 3033/// \param [in] r,g,b : red, green, blue intensities between 0.0 and 1.0; 3034 ; 3035void TGX11::SetRGB(int cindex, float r, float g, float b); 3036{; 3037 if (fColormap) {; 3038 RXColor xcol;; 3039 xcol.red = (UShort_t)(r * kBIGGEST_RGB_VALUE);; 3040 xcol.green = (UShort_t)(g * kBIGGEST_RGB_VALUE);; 3041 xcol.blue = (UShort_t)(b * kBIGGEST_RGB_VALUE);; 3042 xcol.flags = DoRed | DoGreen | DoBlue;; 3043 XColor_t &col = GetColor(cindex);; 3044 if (col.fDefined) {; 3045 // if color is already defined with same rgb just return; 3046 if (col.fRed == xcol.red && col.fGreen == xcol.green &&; 3047 col.fBlue == xcol.blue); 3048 return;; 3049 col.fDefined = kFALSE;; 3050 if (fRedDiv == -1); 3051 XFreeColors((Display*)fDisplay, fColormap, &col.fPixel, 1, 0);; 3052 }; 3053 if (AllocColor(fColormap, &xcol)) {; 3054 col.fDefined = kTRUE;; 3055 col.fPixel = xcol.pixel;; 3056 col.fRed = xcol.red;; 3057 col.fGreen = xcol.green;; 3058 col.fBlue = xcol.blue;; 3059 }; 3060 }; 3061}; 3062 ; 3063////////////////////////////////////////////////////////////////////////////////; 3064/// Set text alignment.; 3065///; 3066/// \param [in] talign text alignment; 3067 ; 3068void TGX11::SetTextAlign(Short_t talign); 3069{; 3070 Int_t txalh = talign/10;; 3071 Int_t txalv = talign%10;; 3072 fTextAlignH = txalh;; 3073 fTextAlignV = txalv;; 3074 ; 3075 switch (txalh) {; 3076 ; 3077 case 0 :; 3078 case 1 :; 3079 switch (txalv) { //left; 3080 case 1 :; 3081 fTextAlign = 7; //bottom; 3082 break;; 3083 case 2 :; 3084 fTextAlign = 4; //center; 3085 break;; 3086 case 3 :; 3087 fTextAlign = 1; //top; 3088 b",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:102029,Energy Efficiency,green,green,102029,"iven color index.; 3031///; 3032/// \param [in] cindex : color index; 3033/// \param [in] r,g,b : red, green, blue intensities between 0.0 and 1.0; 3034 ; 3035void TGX11::SetRGB(int cindex, float r, float g, float b); 3036{; 3037 if (fColormap) {; 3038 RXColor xcol;; 3039 xcol.red = (UShort_t)(r * kBIGGEST_RGB_VALUE);; 3040 xcol.green = (UShort_t)(g * kBIGGEST_RGB_VALUE);; 3041 xcol.blue = (UShort_t)(b * kBIGGEST_RGB_VALUE);; 3042 xcol.flags = DoRed | DoGreen | DoBlue;; 3043 XColor_t &col = GetColor(cindex);; 3044 if (col.fDefined) {; 3045 // if color is already defined with same rgb just return; 3046 if (col.fRed == xcol.red && col.fGreen == xcol.green &&; 3047 col.fBlue == xcol.blue); 3048 return;; 3049 col.fDefined = kFALSE;; 3050 if (fRedDiv == -1); 3051 XFreeColors((Display*)fDisplay, fColormap, &col.fPixel, 1, 0);; 3052 }; 3053 if (AllocColor(fColormap, &xcol)) {; 3054 col.fDefined = kTRUE;; 3055 col.fPixel = xcol.pixel;; 3056 col.fRed = xcol.red;; 3057 col.fGreen = xcol.green;; 3058 col.fBlue = xcol.blue;; 3059 }; 3060 }; 3061}; 3062 ; 3063////////////////////////////////////////////////////////////////////////////////; 3064/// Set text alignment.; 3065///; 3066/// \param [in] talign text alignment; 3067 ; 3068void TGX11::SetTextAlign(Short_t talign); 3069{; 3070 Int_t txalh = talign/10;; 3071 Int_t txalv = talign%10;; 3072 fTextAlignH = txalh;; 3073 fTextAlignV = txalv;; 3074 ; 3075 switch (txalh) {; 3076 ; 3077 case 0 :; 3078 case 1 :; 3079 switch (txalv) { //left; 3080 case 1 :; 3081 fTextAlign = 7; //bottom; 3082 break;; 3083 case 2 :; 3084 fTextAlign = 4; //center; 3085 break;; 3086 case 3 :; 3087 fTextAlign = 1; //top; 3088 break;; 3089 }; 3090 break;; 3091 case 2 :; 3092 switch (txalv) { //center; 3093 case 1 :; 3094 fTextAlign = 8; //bottom; 3095 break;; 3096 case 2 :; 3097 fTextAlign = 5; //center; 3098 break;; 3099 case 3 :; 3100 fTextAlign = 2; //top; 3101 break;; 3102 }; 3103 break;; 3104 case 3 :; 3105 switch (txalv) { //right; 3106 case 1 :; 3107",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:108990,Energy Efficiency,green,green,108990," iy);; 3266 } else {; 3267 XWarpPointer((Display*)fDisplay, None, (Window) id, 0, 0, 0, 0, ix, iy);; 3268 }; 3269}; 3270 ; 3271////////////////////////////////////////////////////////////////////////////////; 3272/// Write the pixmap wid in the bitmap file pxname.; 3273///; 3274/// \param [in] wid : Pixmap address; 3275/// \param [in] w,h : Width and height of the pixmap.; 3276/// \param [in] pxname : pixmap name; 3277 ; 3278void TGX11::WritePixmap(int wid, unsigned int w, unsigned int h, char *pxname); 3279{; 3280 unsigned int wval, hval;; 3281 wval = w;; 3282 hval = h;; 3283 ; 3284 gTws = &fWindows[wid];; 3285 XWriteBitmapFile((Display*)fDisplay, pxname, gTws->fDrawing, wval, hval, -1, -1);; 3286}; 3287 ; 3288 ; 3289//; 3290// Functions for GIFencode(); 3291//; 3292 ; 3293static FILE *gOut; // output unit used WriteGIF and PutByte; 3294static XImage *gXimage = nullptr; // image used in WriteGIF and GetPixel; 3295 ; 3296extern ""C"" {; 3297 int GIFquantize(UInt_t width, UInt_t height, Int_t *ncol, Byte_t *red, Byte_t *green,; 3298 Byte_t *blue, Byte_t *outputBuf, Byte_t *outputCmap);; 3299 long GIFencode(int Width, int Height, Int_t Ncol, Byte_t R[], Byte_t G[], Byte_t B[], Byte_t ScLine[],; 3300 void (*get_scline) (int, int, Byte_t *), void (*pb)(Byte_t));; 3301 int GIFdecode(Byte_t *gifArr, Byte_t *pixArr, int *Width, int *Height, int *Ncols, Byte_t *R, Byte_t *G, Byte_t *B);; 3302 int GIFinfo(Byte_t *gifArr, int *Width, int *Height, int *Ncols);; 3303}; 3304 ; 3305////////////////////////////////////////////////////////////////////////////////; 3306/// Get pixels in line y and put in array scline.; 3307 ; 3308static void GetPixel(int y, int width, Byte_t *scline); 3309{; 3310 for (int i = 0; i < width; i++); 3311 scline[i] = Byte_t(XGetPixel(gXimage, i, y));; 3312}; 3313 ; 3314////////////////////////////////////////////////////////////////////////////////; 3315/// Put byte b in output stream.; 3316 ; 3317static void PutByte(Byte_t b); 3318{; 3319 if (ferror(gOut)",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:110523,Energy Efficiency,reduce,reduce,110523,"/////////////////////////////; 3306/// Get pixels in line y and put in array scline.; 3307 ; 3308static void GetPixel(int y, int width, Byte_t *scline); 3309{; 3310 for (int i = 0; i < width; i++); 3311 scline[i] = Byte_t(XGetPixel(gXimage, i, y));; 3312}; 3313 ; 3314////////////////////////////////////////////////////////////////////////////////; 3315/// Put byte b in output stream.; 3316 ; 3317static void PutByte(Byte_t b); 3318{; 3319 if (ferror(gOut) == 0) fputc(b, gOut);; 3320}; 3321 ; 3322////////////////////////////////////////////////////////////////////////////////; 3323/// Returns in R G B the ncol colors of the palette used by the image.; 3324/// The image pixels are changed to index values in these R G B arrays.; 3325/// This produces a colormap with only the used colors (so even on displays; 3326/// with more than 8 planes we will be able to create GIF's when the image; 3327/// contains no more than 256 different colors). If it does contain more; 3328/// colors we will have to use GIFquantize to reduce the number of colors.; 3329/// The R G B arrays must be deleted by the caller.; 3330 ; 3331void TGX11::ImgPickPalette(RXImage *image, Int_t &ncol, Int_t *&R, Int_t *&G, Int_t *&B); 3332{; 3333 ULong_t *orgcolors = nullptr;; 3334 Int_t maxcolors = 0, ncolors = 0;; 3335 ; 3336 // collect different image colors; 3337 int x, y;; 3338 for (x = 0; x < (int) gCws->fWidth; x++) {; 3339 for (y = 0; y < (int) gCws->fHeight; y++) {; 3340 ULong_t pixel = XGetPixel(image, x, y);; 3341 CollectImageColors(pixel, orgcolors, ncolors, maxcolors);; 3342 }; 3343 }; 3344 ; 3345 // get RGB values belonging to pixels; 3346 RXColor *xcol = new RXColor[ncolors];; 3347 ; 3348 int i;; 3349 for (i = 0; i < ncolors; i++) {; 3350 xcol[i].pixel = orgcolors[i];; 3351 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 3352 xcol[i].flags = DoRed | DoGreen | DoBlue;; 3353 }; 3354 QueryColors(fColormap, xcol, ncolors);; 3355 ; 3356 // create RGB arrays and store RGB's for each color and set n",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:111298,Energy Efficiency,green,green,111298,"isplays; 3326/// with more than 8 planes we will be able to create GIF's when the image; 3327/// contains no more than 256 different colors). If it does contain more; 3328/// colors we will have to use GIFquantize to reduce the number of colors.; 3329/// The R G B arrays must be deleted by the caller.; 3330 ; 3331void TGX11::ImgPickPalette(RXImage *image, Int_t &ncol, Int_t *&R, Int_t *&G, Int_t *&B); 3332{; 3333 ULong_t *orgcolors = nullptr;; 3334 Int_t maxcolors = 0, ncolors = 0;; 3335 ; 3336 // collect different image colors; 3337 int x, y;; 3338 for (x = 0; x < (int) gCws->fWidth; x++) {; 3339 for (y = 0; y < (int) gCws->fHeight; y++) {; 3340 ULong_t pixel = XGetPixel(image, x, y);; 3341 CollectImageColors(pixel, orgcolors, ncolors, maxcolors);; 3342 }; 3343 }; 3344 ; 3345 // get RGB values belonging to pixels; 3346 RXColor *xcol = new RXColor[ncolors];; 3347 ; 3348 int i;; 3349 for (i = 0; i < ncolors; i++) {; 3350 xcol[i].pixel = orgcolors[i];; 3351 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 3352 xcol[i].flags = DoRed | DoGreen | DoBlue;; 3353 }; 3354 QueryColors(fColormap, xcol, ncolors);; 3355 ; 3356 // create RGB arrays and store RGB's for each color and set number of colors; 3357 // (space must be delete by caller); 3358 R = new Int_t[ncolors];; 3359 G = new Int_t[ncolors];; 3360 B = new Int_t[ncolors];; 3361 ; 3362 for (i = 0; i < ncolors; i++) {; 3363 R[i] = xcol[i].red;; 3364 G[i] = xcol[i].green;; 3365 B[i] = xcol[i].blue;; 3366 }; 3367 ncol = ncolors;; 3368 ; 3369 // update image with indices (pixels) into the new RGB colormap; 3370 for (x = 0; x < (int) gCws->fWidth; x++) {; 3371 for (y = 0; y < (int) gCws->fHeight; y++) {; 3372 ULong_t pixel = XGetPixel(image, x, y);; 3373 Int_t idx = FindColor(pixel, orgcolors, ncolors);; 3374 XPutPixel(image, x, y, idx);; 3375 }; 3376 }; 3377 ; 3378 // cleanup; 3379 delete [] xcol;; 3380 ::operator delete(orgcolors);; 3381}; 3382 ; 3383/////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:111739,Energy Efficiency,green,green,111739," 3334 Int_t maxcolors = 0, ncolors = 0;; 3335 ; 3336 // collect different image colors; 3337 int x, y;; 3338 for (x = 0; x < (int) gCws->fWidth; x++) {; 3339 for (y = 0; y < (int) gCws->fHeight; y++) {; 3340 ULong_t pixel = XGetPixel(image, x, y);; 3341 CollectImageColors(pixel, orgcolors, ncolors, maxcolors);; 3342 }; 3343 }; 3344 ; 3345 // get RGB values belonging to pixels; 3346 RXColor *xcol = new RXColor[ncolors];; 3347 ; 3348 int i;; 3349 for (i = 0; i < ncolors; i++) {; 3350 xcol[i].pixel = orgcolors[i];; 3351 xcol[i].red = xcol[i].green = xcol[i].blue = 0;; 3352 xcol[i].flags = DoRed | DoGreen | DoBlue;; 3353 }; 3354 QueryColors(fColormap, xcol, ncolors);; 3355 ; 3356 // create RGB arrays and store RGB's for each color and set number of colors; 3357 // (space must be delete by caller); 3358 R = new Int_t[ncolors];; 3359 G = new Int_t[ncolors];; 3360 B = new Int_t[ncolors];; 3361 ; 3362 for (i = 0; i < ncolors; i++) {; 3363 R[i] = xcol[i].red;; 3364 G[i] = xcol[i].green;; 3365 B[i] = xcol[i].blue;; 3366 }; 3367 ncol = ncolors;; 3368 ; 3369 // update image with indices (pixels) into the new RGB colormap; 3370 for (x = 0; x < (int) gCws->fWidth; x++) {; 3371 for (y = 0; y < (int) gCws->fHeight; y++) {; 3372 ULong_t pixel = XGetPixel(image, x, y);; 3373 Int_t idx = FindColor(pixel, orgcolors, ncolors);; 3374 XPutPixel(image, x, y, idx);; 3375 }; 3376 }; 3377 ; 3378 // cleanup; 3379 delete [] xcol;; 3380 ::operator delete(orgcolors);; 3381}; 3382 ; 3383////////////////////////////////////////////////////////////////////////////////; 3384/// Writes the current window into GIF file. Returns 1 in case of success,; 3385/// 0 otherwise.; 3386 ; 3387Int_t TGX11::WriteGIF(char *name); 3388{; 3389 Byte_t scline[2000], r[256], b[256], g[256];; 3390 Int_t *red, *green, *blue;; 3391 Int_t ncol, maxcol, i;; 3392 ; 3393 if (gXimage) {; 3394 XDestroyImage(gXimage);; 3395 gXimage = nullptr;; 3396 }; 3397 ; 3398 gXimage = XGetImage((Display*)fDisplay, gCws->fDrawing, 0, 0,; 3399",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:112539,Energy Efficiency,green,green,112539,"< ncolors; i++) {; 3363 R[i] = xcol[i].red;; 3364 G[i] = xcol[i].green;; 3365 B[i] = xcol[i].blue;; 3366 }; 3367 ncol = ncolors;; 3368 ; 3369 // update image with indices (pixels) into the new RGB colormap; 3370 for (x = 0; x < (int) gCws->fWidth; x++) {; 3371 for (y = 0; y < (int) gCws->fHeight; y++) {; 3372 ULong_t pixel = XGetPixel(image, x, y);; 3373 Int_t idx = FindColor(pixel, orgcolors, ncolors);; 3374 XPutPixel(image, x, y, idx);; 3375 }; 3376 }; 3377 ; 3378 // cleanup; 3379 delete [] xcol;; 3380 ::operator delete(orgcolors);; 3381}; 3382 ; 3383////////////////////////////////////////////////////////////////////////////////; 3384/// Writes the current window into GIF file. Returns 1 in case of success,; 3385/// 0 otherwise.; 3386 ; 3387Int_t TGX11::WriteGIF(char *name); 3388{; 3389 Byte_t scline[2000], r[256], b[256], g[256];; 3390 Int_t *red, *green, *blue;; 3391 Int_t ncol, maxcol, i;; 3392 ; 3393 if (gXimage) {; 3394 XDestroyImage(gXimage);; 3395 gXimage = nullptr;; 3396 }; 3397 ; 3398 gXimage = XGetImage((Display*)fDisplay, gCws->fDrawing, 0, 0,; 3399 gCws->fWidth, gCws->fHeight,; 3400 AllPlanes, ZPixmap);; 3401 ; 3402 ImgPickPalette((RXImage*)gXimage, ncol, red, green, blue);; 3403 ; 3404 if (ncol > 256) {; 3405 //GIFquantize(...);; 3406 Error(""WriteGIF"", ""Cannot create GIF of image containing more than 256 colors. Try in batch mode."");; 3407 delete [] red;; 3408 delete [] green;; 3409 delete [] blue;; 3410 return 0;; 3411 }; 3412 ; 3413 maxcol = 0;; 3414 for (i = 0; i < ncol; i++) {; 3415 if (maxcol < red[i] ) maxcol = red[i];; 3416 if (maxcol < green[i] ) maxcol = green[i];; 3417 if (maxcol < blue[i] ) maxcol = blue[i];; 3418 r[i] = 0;; 3419 g[i] = 0;; 3420 b[i] = 0;; 3421 }; 3422 if (maxcol != 0) {; 3423 for (i = 0; i < ncol; i++) {; 3424 r[i] = red[i] * 255/maxcol;; 3425 g[i] = green[i] * 255/maxcol;; 3426 b[i] = blue[i] * 255/maxcol;; 3427 }; 3428 }; 3429 ; 3430 gOut = fopen(name, ""w+"");; 3431 ; 3432 if (gOut) {; 3433 GIFencode(gCws->fWidth, gCws->f",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:112868,Energy Efficiency,green,green,112868,"< ncolors; i++) {; 3363 R[i] = xcol[i].red;; 3364 G[i] = xcol[i].green;; 3365 B[i] = xcol[i].blue;; 3366 }; 3367 ncol = ncolors;; 3368 ; 3369 // update image with indices (pixels) into the new RGB colormap; 3370 for (x = 0; x < (int) gCws->fWidth; x++) {; 3371 for (y = 0; y < (int) gCws->fHeight; y++) {; 3372 ULong_t pixel = XGetPixel(image, x, y);; 3373 Int_t idx = FindColor(pixel, orgcolors, ncolors);; 3374 XPutPixel(image, x, y, idx);; 3375 }; 3376 }; 3377 ; 3378 // cleanup; 3379 delete [] xcol;; 3380 ::operator delete(orgcolors);; 3381}; 3382 ; 3383////////////////////////////////////////////////////////////////////////////////; 3384/// Writes the current window into GIF file. Returns 1 in case of success,; 3385/// 0 otherwise.; 3386 ; 3387Int_t TGX11::WriteGIF(char *name); 3388{; 3389 Byte_t scline[2000], r[256], b[256], g[256];; 3390 Int_t *red, *green, *blue;; 3391 Int_t ncol, maxcol, i;; 3392 ; 3393 if (gXimage) {; 3394 XDestroyImage(gXimage);; 3395 gXimage = nullptr;; 3396 }; 3397 ; 3398 gXimage = XGetImage((Display*)fDisplay, gCws->fDrawing, 0, 0,; 3399 gCws->fWidth, gCws->fHeight,; 3400 AllPlanes, ZPixmap);; 3401 ; 3402 ImgPickPalette((RXImage*)gXimage, ncol, red, green, blue);; 3403 ; 3404 if (ncol > 256) {; 3405 //GIFquantize(...);; 3406 Error(""WriteGIF"", ""Cannot create GIF of image containing more than 256 colors. Try in batch mode."");; 3407 delete [] red;; 3408 delete [] green;; 3409 delete [] blue;; 3410 return 0;; 3411 }; 3412 ; 3413 maxcol = 0;; 3414 for (i = 0; i < ncol; i++) {; 3415 if (maxcol < red[i] ) maxcol = red[i];; 3416 if (maxcol < green[i] ) maxcol = green[i];; 3417 if (maxcol < blue[i] ) maxcol = blue[i];; 3418 r[i] = 0;; 3419 g[i] = 0;; 3420 b[i] = 0;; 3421 }; 3422 if (maxcol != 0) {; 3423 for (i = 0; i < ncol; i++) {; 3424 r[i] = red[i] * 255/maxcol;; 3425 g[i] = green[i] * 255/maxcol;; 3426 b[i] = blue[i] * 255/maxcol;; 3427 }; 3428 }; 3429 ; 3430 gOut = fopen(name, ""w+"");; 3431 ; 3432 if (gOut) {; 3433 GIFencode(gCws->fWidth, gCws->f",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:113083,Energy Efficiency,green,green,113083,"e;; 3391 Int_t ncol, maxcol, i;; 3392 ; 3393 if (gXimage) {; 3394 XDestroyImage(gXimage);; 3395 gXimage = nullptr;; 3396 }; 3397 ; 3398 gXimage = XGetImage((Display*)fDisplay, gCws->fDrawing, 0, 0,; 3399 gCws->fWidth, gCws->fHeight,; 3400 AllPlanes, ZPixmap);; 3401 ; 3402 ImgPickPalette((RXImage*)gXimage, ncol, red, green, blue);; 3403 ; 3404 if (ncol > 256) {; 3405 //GIFquantize(...);; 3406 Error(""WriteGIF"", ""Cannot create GIF of image containing more than 256 colors. Try in batch mode."");; 3407 delete [] red;; 3408 delete [] green;; 3409 delete [] blue;; 3410 return 0;; 3411 }; 3412 ; 3413 maxcol = 0;; 3414 for (i = 0; i < ncol; i++) {; 3415 if (maxcol < red[i] ) maxcol = red[i];; 3416 if (maxcol < green[i] ) maxcol = green[i];; 3417 if (maxcol < blue[i] ) maxcol = blue[i];; 3418 r[i] = 0;; 3419 g[i] = 0;; 3420 b[i] = 0;; 3421 }; 3422 if (maxcol != 0) {; 3423 for (i = 0; i < ncol; i++) {; 3424 r[i] = red[i] * 255/maxcol;; 3425 g[i] = green[i] * 255/maxcol;; 3426 b[i] = blue[i] * 255/maxcol;; 3427 }; 3428 }; 3429 ; 3430 gOut = fopen(name, ""w+"");; 3431 ; 3432 if (gOut) {; 3433 GIFencode(gCws->fWidth, gCws->fHeight,; 3434 ncol, r, g, b, scline, ::GetPixel, PutByte);; 3435 fclose(gOut);; 3436 i = 1;; 3437 } else {; 3438 Error(""WriteGIF"",""cannot write file: %s"",name);; 3439 i = 0;; 3440 }; 3441 delete [] red;; 3442 delete [] green;; 3443 delete [] blue;; 3444 return i;; 3445}; 3446 ; 3447////////////////////////////////////////////////////////////////////////////////; 3448/// Draw image.; 3449 ; 3450void TGX11::PutImage(Int_t offset,Int_t itran,Int_t x0,Int_t y0,Int_t nx,Int_t ny,Int_t xmin,; 3451 Int_t ymin,Int_t xmax,Int_t ymax, UChar_t *image,Drawable_t wid); 3452{; 3453 const int maxSegment = 20;; 3454 int i, n, x, y, xcur, x1, x2, y1, y2;; 3455 unsigned char *jimg, *jbase, icol;; 3456 int nlines[256];; 3457 XSegment lines[256][maxSegment];; 3458 Drawable_t id;; 3459 ; 3460 if (wid) {; 3461 id = wid;; 3462 } else {; 3463 id = gCws->fDrawing;; 3464 }; 3465 ; 3466 for",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:113260,Energy Efficiency,green,green,113260,"e;; 3391 Int_t ncol, maxcol, i;; 3392 ; 3393 if (gXimage) {; 3394 XDestroyImage(gXimage);; 3395 gXimage = nullptr;; 3396 }; 3397 ; 3398 gXimage = XGetImage((Display*)fDisplay, gCws->fDrawing, 0, 0,; 3399 gCws->fWidth, gCws->fHeight,; 3400 AllPlanes, ZPixmap);; 3401 ; 3402 ImgPickPalette((RXImage*)gXimage, ncol, red, green, blue);; 3403 ; 3404 if (ncol > 256) {; 3405 //GIFquantize(...);; 3406 Error(""WriteGIF"", ""Cannot create GIF of image containing more than 256 colors. Try in batch mode."");; 3407 delete [] red;; 3408 delete [] green;; 3409 delete [] blue;; 3410 return 0;; 3411 }; 3412 ; 3413 maxcol = 0;; 3414 for (i = 0; i < ncol; i++) {; 3415 if (maxcol < red[i] ) maxcol = red[i];; 3416 if (maxcol < green[i] ) maxcol = green[i];; 3417 if (maxcol < blue[i] ) maxcol = blue[i];; 3418 r[i] = 0;; 3419 g[i] = 0;; 3420 b[i] = 0;; 3421 }; 3422 if (maxcol != 0) {; 3423 for (i = 0; i < ncol; i++) {; 3424 r[i] = red[i] * 255/maxcol;; 3425 g[i] = green[i] * 255/maxcol;; 3426 b[i] = blue[i] * 255/maxcol;; 3427 }; 3428 }; 3429 ; 3430 gOut = fopen(name, ""w+"");; 3431 ; 3432 if (gOut) {; 3433 GIFencode(gCws->fWidth, gCws->fHeight,; 3434 ncol, r, g, b, scline, ::GetPixel, PutByte);; 3435 fclose(gOut);; 3436 i = 1;; 3437 } else {; 3438 Error(""WriteGIF"",""cannot write file: %s"",name);; 3439 i = 0;; 3440 }; 3441 delete [] red;; 3442 delete [] green;; 3443 delete [] blue;; 3444 return i;; 3445}; 3446 ; 3447////////////////////////////////////////////////////////////////////////////////; 3448/// Draw image.; 3449 ; 3450void TGX11::PutImage(Int_t offset,Int_t itran,Int_t x0,Int_t y0,Int_t nx,Int_t ny,Int_t xmin,; 3451 Int_t ymin,Int_t xmax,Int_t ymax, UChar_t *image,Drawable_t wid); 3452{; 3453 const int maxSegment = 20;; 3454 int i, n, x, y, xcur, x1, x2, y1, y2;; 3455 unsigned char *jimg, *jbase, icol;; 3456 int nlines[256];; 3457 XSegment lines[256][maxSegment];; 3458 Drawable_t id;; 3459 ; 3460 if (wid) {; 3461 id = wid;; 3462 } else {; 3463 id = gCws->fDrawing;; 3464 }; 3465 ; 3466 for",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:113280,Energy Efficiency,green,green,113280,"e;; 3391 Int_t ncol, maxcol, i;; 3392 ; 3393 if (gXimage) {; 3394 XDestroyImage(gXimage);; 3395 gXimage = nullptr;; 3396 }; 3397 ; 3398 gXimage = XGetImage((Display*)fDisplay, gCws->fDrawing, 0, 0,; 3399 gCws->fWidth, gCws->fHeight,; 3400 AllPlanes, ZPixmap);; 3401 ; 3402 ImgPickPalette((RXImage*)gXimage, ncol, red, green, blue);; 3403 ; 3404 if (ncol > 256) {; 3405 //GIFquantize(...);; 3406 Error(""WriteGIF"", ""Cannot create GIF of image containing more than 256 colors. Try in batch mode."");; 3407 delete [] red;; 3408 delete [] green;; 3409 delete [] blue;; 3410 return 0;; 3411 }; 3412 ; 3413 maxcol = 0;; 3414 for (i = 0; i < ncol; i++) {; 3415 if (maxcol < red[i] ) maxcol = red[i];; 3416 if (maxcol < green[i] ) maxcol = green[i];; 3417 if (maxcol < blue[i] ) maxcol = blue[i];; 3418 r[i] = 0;; 3419 g[i] = 0;; 3420 b[i] = 0;; 3421 }; 3422 if (maxcol != 0) {; 3423 for (i = 0; i < ncol; i++) {; 3424 r[i] = red[i] * 255/maxcol;; 3425 g[i] = green[i] * 255/maxcol;; 3426 b[i] = blue[i] * 255/maxcol;; 3427 }; 3428 }; 3429 ; 3430 gOut = fopen(name, ""w+"");; 3431 ; 3432 if (gOut) {; 3433 GIFencode(gCws->fWidth, gCws->fHeight,; 3434 ncol, r, g, b, scline, ::GetPixel, PutByte);; 3435 fclose(gOut);; 3436 i = 1;; 3437 } else {; 3438 Error(""WriteGIF"",""cannot write file: %s"",name);; 3439 i = 0;; 3440 }; 3441 delete [] red;; 3442 delete [] green;; 3443 delete [] blue;; 3444 return i;; 3445}; 3446 ; 3447////////////////////////////////////////////////////////////////////////////////; 3448/// Draw image.; 3449 ; 3450void TGX11::PutImage(Int_t offset,Int_t itran,Int_t x0,Int_t y0,Int_t nx,Int_t ny,Int_t xmin,; 3451 Int_t ymin,Int_t xmax,Int_t ymax, UChar_t *image,Drawable_t wid); 3452{; 3453 const int maxSegment = 20;; 3454 int i, n, x, y, xcur, x1, x2, y1, y2;; 3455 unsigned char *jimg, *jbase, icol;; 3456 int nlines[256];; 3457 XSegment lines[256][maxSegment];; 3458 Drawable_t id;; 3459 ; 3460 if (wid) {; 3461 id = wid;; 3462 } else {; 3463 id = gCws->fDrawing;; 3464 }; 3465 ; 3466 for",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:113500,Energy Efficiency,green,green,113500,"e;; 3391 Int_t ncol, maxcol, i;; 3392 ; 3393 if (gXimage) {; 3394 XDestroyImage(gXimage);; 3395 gXimage = nullptr;; 3396 }; 3397 ; 3398 gXimage = XGetImage((Display*)fDisplay, gCws->fDrawing, 0, 0,; 3399 gCws->fWidth, gCws->fHeight,; 3400 AllPlanes, ZPixmap);; 3401 ; 3402 ImgPickPalette((RXImage*)gXimage, ncol, red, green, blue);; 3403 ; 3404 if (ncol > 256) {; 3405 //GIFquantize(...);; 3406 Error(""WriteGIF"", ""Cannot create GIF of image containing more than 256 colors. Try in batch mode."");; 3407 delete [] red;; 3408 delete [] green;; 3409 delete [] blue;; 3410 return 0;; 3411 }; 3412 ; 3413 maxcol = 0;; 3414 for (i = 0; i < ncol; i++) {; 3415 if (maxcol < red[i] ) maxcol = red[i];; 3416 if (maxcol < green[i] ) maxcol = green[i];; 3417 if (maxcol < blue[i] ) maxcol = blue[i];; 3418 r[i] = 0;; 3419 g[i] = 0;; 3420 b[i] = 0;; 3421 }; 3422 if (maxcol != 0) {; 3423 for (i = 0; i < ncol; i++) {; 3424 r[i] = red[i] * 255/maxcol;; 3425 g[i] = green[i] * 255/maxcol;; 3426 b[i] = blue[i] * 255/maxcol;; 3427 }; 3428 }; 3429 ; 3430 gOut = fopen(name, ""w+"");; 3431 ; 3432 if (gOut) {; 3433 GIFencode(gCws->fWidth, gCws->fHeight,; 3434 ncol, r, g, b, scline, ::GetPixel, PutByte);; 3435 fclose(gOut);; 3436 i = 1;; 3437 } else {; 3438 Error(""WriteGIF"",""cannot write file: %s"",name);; 3439 i = 0;; 3440 }; 3441 delete [] red;; 3442 delete [] green;; 3443 delete [] blue;; 3444 return i;; 3445}; 3446 ; 3447////////////////////////////////////////////////////////////////////////////////; 3448/// Draw image.; 3449 ; 3450void TGX11::PutImage(Int_t offset,Int_t itran,Int_t x0,Int_t y0,Int_t nx,Int_t ny,Int_t xmin,; 3451 Int_t ymin,Int_t xmax,Int_t ymax, UChar_t *image,Drawable_t wid); 3452{; 3453 const int maxSegment = 20;; 3454 int i, n, x, y, xcur, x1, x2, y1, y2;; 3455 unsigned char *jimg, *jbase, icol;; 3456 int nlines[256];; 3457 XSegment lines[256][maxSegment];; 3458 Drawable_t id;; 3459 ; 3460 if (wid) {; 3461 id = wid;; 3462 } else {; 3463 id = gCws->fDrawing;; 3464 }; 3465 ; 3466 for",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:113894,Energy Efficiency,green,green,113894,"e;; 3391 Int_t ncol, maxcol, i;; 3392 ; 3393 if (gXimage) {; 3394 XDestroyImage(gXimage);; 3395 gXimage = nullptr;; 3396 }; 3397 ; 3398 gXimage = XGetImage((Display*)fDisplay, gCws->fDrawing, 0, 0,; 3399 gCws->fWidth, gCws->fHeight,; 3400 AllPlanes, ZPixmap);; 3401 ; 3402 ImgPickPalette((RXImage*)gXimage, ncol, red, green, blue);; 3403 ; 3404 if (ncol > 256) {; 3405 //GIFquantize(...);; 3406 Error(""WriteGIF"", ""Cannot create GIF of image containing more than 256 colors. Try in batch mode."");; 3407 delete [] red;; 3408 delete [] green;; 3409 delete [] blue;; 3410 return 0;; 3411 }; 3412 ; 3413 maxcol = 0;; 3414 for (i = 0; i < ncol; i++) {; 3415 if (maxcol < red[i] ) maxcol = red[i];; 3416 if (maxcol < green[i] ) maxcol = green[i];; 3417 if (maxcol < blue[i] ) maxcol = blue[i];; 3418 r[i] = 0;; 3419 g[i] = 0;; 3420 b[i] = 0;; 3421 }; 3422 if (maxcol != 0) {; 3423 for (i = 0; i < ncol; i++) {; 3424 r[i] = red[i] * 255/maxcol;; 3425 g[i] = green[i] * 255/maxcol;; 3426 b[i] = blue[i] * 255/maxcol;; 3427 }; 3428 }; 3429 ; 3430 gOut = fopen(name, ""w+"");; 3431 ; 3432 if (gOut) {; 3433 GIFencode(gCws->fWidth, gCws->fHeight,; 3434 ncol, r, g, b, scline, ::GetPixel, PutByte);; 3435 fclose(gOut);; 3436 i = 1;; 3437 } else {; 3438 Error(""WriteGIF"",""cannot write file: %s"",name);; 3439 i = 0;; 3440 }; 3441 delete [] red;; 3442 delete [] green;; 3443 delete [] blue;; 3444 return i;; 3445}; 3446 ; 3447////////////////////////////////////////////////////////////////////////////////; 3448/// Draw image.; 3449 ; 3450void TGX11::PutImage(Int_t offset,Int_t itran,Int_t x0,Int_t y0,Int_t nx,Int_t ny,Int_t xmin,; 3451 Int_t ymin,Int_t xmax,Int_t ymax, UChar_t *image,Drawable_t wid); 3452{; 3453 const int maxSegment = 20;; 3454 int i, n, x, y, xcur, x1, x2, y1, y2;; 3455 unsigned char *jimg, *jbase, icol;; 3456 int nlines[256];; 3457 XSegment lines[256][maxSegment];; 3458 Drawable_t id;; 3459 ; 3460 if (wid) {; 3461 id = wid;; 3462 } else {; 3463 id = gCws->fDrawing;; 3464 }; 3465 ; 3466 for",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:116323,Energy Efficiency,green,green,116323,"//////////////////////////////////; 3512/// If id is NULL - loads the specified gif file at position [x0,y0] in the; 3513/// current window. Otherwise creates pixmap from gif file; 3514 ; 3515Pixmap_t TGX11::ReadGIF(int x0, int y0, const char *file, Window_t id); 3516{; 3517 FILE *fd;; 3518 Seek_t filesize = 0;; 3519 unsigned char *gifArr, *pixArr, red[256], green[256], blue[256], *j1, *j2, icol;; 3520 int i, j, k, width, height, ncolor, irep, offset;; 3521 float rr, gg, bb;; 3522 Pixmap_t pic = 0;; 3523 ; 3524 fd = fopen(file, ""r"");; 3525 if (!fd) {; 3526 Error(""ReadGIF"", ""unable to open GIF file"");; 3527 return pic;; 3528 }; 3529 ; 3530 fseek(fd, 0L, 2);; 3531 long ft = ftell(fd);; 3532 if (ft <=0) {; 3533 Error(""ReadGIF"", ""unable to open GIF file"");; 3534 fclose(fd);; 3535 return pic;; 3536 } else {; 3537 filesize = Seek_t(ft);; 3538 }; 3539 fseek(fd, 0L, 0);; 3540 ; 3541 if (!(gifArr = (unsigned char *) calloc(filesize+256,1))) {; 3542 Error(""ReadGIF"", ""unable to allocate array for gif"");; 3543 fclose(fd);; 3544 return pic;; 3545 }; 3546 ; 3547 if (fread(gifArr, filesize, 1, fd) != 1) {; 3548 Error(""ReadGIF"", ""GIF file read failed"");; 3549 free(gifArr);; 3550 fclose(fd);; 3551 return pic;; 3552 }; 3553 fclose(fd);; 3554 ; 3555 irep = GIFinfo(gifArr, &width, &height, &ncolor);; 3556 if (irep != 0) {; 3557 free(gifArr);; 3558 return pic;; 3559 }; 3560 ; 3561 if (!(pixArr = (unsigned char *) calloc((width*height),1))) {; 3562 Error(""ReadGIF"", ""unable to allocate array for image"");; 3563 free(gifArr);; 3564 return pic;; 3565 }; 3566 ; 3567 irep = GIFdecode(gifArr, pixArr, &width, &height, &ncolor, red, green, blue);; 3568 if (irep != 0) {; 3569 free(gifArr);; 3570 free(pixArr);; 3571 return pic;; 3572 }; 3573 ; 3574 // S E T P A L E T T E; 3575 ; 3576 offset = 8;; 3577 ; 3578 for (i = 0; i < ncolor; i++) {; 3579 rr = red[i]/255.;; 3580 gg = green[i]/255.;; 3581 bb = blue[i]/255.;; 3582 j = i+offset;; 3583 SetRGB(j,rr,gg,bb);; 3584 }; 3585 ; 3586 // O U T P U T I M A",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:116944,Energy Efficiency,allocate,allocate,116944,"//////////////////////////////////; 3512/// If id is NULL - loads the specified gif file at position [x0,y0] in the; 3513/// current window. Otherwise creates pixmap from gif file; 3514 ; 3515Pixmap_t TGX11::ReadGIF(int x0, int y0, const char *file, Window_t id); 3516{; 3517 FILE *fd;; 3518 Seek_t filesize = 0;; 3519 unsigned char *gifArr, *pixArr, red[256], green[256], blue[256], *j1, *j2, icol;; 3520 int i, j, k, width, height, ncolor, irep, offset;; 3521 float rr, gg, bb;; 3522 Pixmap_t pic = 0;; 3523 ; 3524 fd = fopen(file, ""r"");; 3525 if (!fd) {; 3526 Error(""ReadGIF"", ""unable to open GIF file"");; 3527 return pic;; 3528 }; 3529 ; 3530 fseek(fd, 0L, 2);; 3531 long ft = ftell(fd);; 3532 if (ft <=0) {; 3533 Error(""ReadGIF"", ""unable to open GIF file"");; 3534 fclose(fd);; 3535 return pic;; 3536 } else {; 3537 filesize = Seek_t(ft);; 3538 }; 3539 fseek(fd, 0L, 0);; 3540 ; 3541 if (!(gifArr = (unsigned char *) calloc(filesize+256,1))) {; 3542 Error(""ReadGIF"", ""unable to allocate array for gif"");; 3543 fclose(fd);; 3544 return pic;; 3545 }; 3546 ; 3547 if (fread(gifArr, filesize, 1, fd) != 1) {; 3548 Error(""ReadGIF"", ""GIF file read failed"");; 3549 free(gifArr);; 3550 fclose(fd);; 3551 return pic;; 3552 }; 3553 fclose(fd);; 3554 ; 3555 irep = GIFinfo(gifArr, &width, &height, &ncolor);; 3556 if (irep != 0) {; 3557 free(gifArr);; 3558 return pic;; 3559 }; 3560 ; 3561 if (!(pixArr = (unsigned char *) calloc((width*height),1))) {; 3562 Error(""ReadGIF"", ""unable to allocate array for image"");; 3563 free(gifArr);; 3564 return pic;; 3565 }; 3566 ; 3567 irep = GIFdecode(gifArr, pixArr, &width, &height, &ncolor, red, green, blue);; 3568 if (irep != 0) {; 3569 free(gifArr);; 3570 free(pixArr);; 3571 return pic;; 3572 }; 3573 ; 3574 // S E T P A L E T T E; 3575 ; 3576 offset = 8;; 3577 ; 3578 for (i = 0; i < ncolor; i++) {; 3579 rr = red[i]/255.;; 3580 gg = green[i]/255.;; 3581 bb = blue[i]/255.;; 3582 j = i+offset;; 3583 SetRGB(j,rr,gg,bb);; 3584 }; 3585 ; 3586 // O U T P U T I M A",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:117441,Energy Efficiency,allocate,allocate,117441,"//////////////////////////////////; 3512/// If id is NULL - loads the specified gif file at position [x0,y0] in the; 3513/// current window. Otherwise creates pixmap from gif file; 3514 ; 3515Pixmap_t TGX11::ReadGIF(int x0, int y0, const char *file, Window_t id); 3516{; 3517 FILE *fd;; 3518 Seek_t filesize = 0;; 3519 unsigned char *gifArr, *pixArr, red[256], green[256], blue[256], *j1, *j2, icol;; 3520 int i, j, k, width, height, ncolor, irep, offset;; 3521 float rr, gg, bb;; 3522 Pixmap_t pic = 0;; 3523 ; 3524 fd = fopen(file, ""r"");; 3525 if (!fd) {; 3526 Error(""ReadGIF"", ""unable to open GIF file"");; 3527 return pic;; 3528 }; 3529 ; 3530 fseek(fd, 0L, 2);; 3531 long ft = ftell(fd);; 3532 if (ft <=0) {; 3533 Error(""ReadGIF"", ""unable to open GIF file"");; 3534 fclose(fd);; 3535 return pic;; 3536 } else {; 3537 filesize = Seek_t(ft);; 3538 }; 3539 fseek(fd, 0L, 0);; 3540 ; 3541 if (!(gifArr = (unsigned char *) calloc(filesize+256,1))) {; 3542 Error(""ReadGIF"", ""unable to allocate array for gif"");; 3543 fclose(fd);; 3544 return pic;; 3545 }; 3546 ; 3547 if (fread(gifArr, filesize, 1, fd) != 1) {; 3548 Error(""ReadGIF"", ""GIF file read failed"");; 3549 free(gifArr);; 3550 fclose(fd);; 3551 return pic;; 3552 }; 3553 fclose(fd);; 3554 ; 3555 irep = GIFinfo(gifArr, &width, &height, &ncolor);; 3556 if (irep != 0) {; 3557 free(gifArr);; 3558 return pic;; 3559 }; 3560 ; 3561 if (!(pixArr = (unsigned char *) calloc((width*height),1))) {; 3562 Error(""ReadGIF"", ""unable to allocate array for image"");; 3563 free(gifArr);; 3564 return pic;; 3565 }; 3566 ; 3567 irep = GIFdecode(gifArr, pixArr, &width, &height, &ncolor, red, green, blue);; 3568 if (irep != 0) {; 3569 free(gifArr);; 3570 free(pixArr);; 3571 return pic;; 3572 }; 3573 ; 3574 // S E T P A L E T T E; 3575 ; 3576 offset = 8;; 3577 ; 3578 for (i = 0; i < ncolor; i++) {; 3579 rr = red[i]/255.;; 3580 gg = green[i]/255.;; 3581 bb = blue[i]/255.;; 3582 j = i+offset;; 3583 SetRGB(j,rr,gg,bb);; 3584 }; 3585 ; 3586 // O U T P U T I M A",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:117592,Energy Efficiency,green,green,117592,"//////////////////////////////////; 3512/// If id is NULL - loads the specified gif file at position [x0,y0] in the; 3513/// current window. Otherwise creates pixmap from gif file; 3514 ; 3515Pixmap_t TGX11::ReadGIF(int x0, int y0, const char *file, Window_t id); 3516{; 3517 FILE *fd;; 3518 Seek_t filesize = 0;; 3519 unsigned char *gifArr, *pixArr, red[256], green[256], blue[256], *j1, *j2, icol;; 3520 int i, j, k, width, height, ncolor, irep, offset;; 3521 float rr, gg, bb;; 3522 Pixmap_t pic = 0;; 3523 ; 3524 fd = fopen(file, ""r"");; 3525 if (!fd) {; 3526 Error(""ReadGIF"", ""unable to open GIF file"");; 3527 return pic;; 3528 }; 3529 ; 3530 fseek(fd, 0L, 2);; 3531 long ft = ftell(fd);; 3532 if (ft <=0) {; 3533 Error(""ReadGIF"", ""unable to open GIF file"");; 3534 fclose(fd);; 3535 return pic;; 3536 } else {; 3537 filesize = Seek_t(ft);; 3538 }; 3539 fseek(fd, 0L, 0);; 3540 ; 3541 if (!(gifArr = (unsigned char *) calloc(filesize+256,1))) {; 3542 Error(""ReadGIF"", ""unable to allocate array for gif"");; 3543 fclose(fd);; 3544 return pic;; 3545 }; 3546 ; 3547 if (fread(gifArr, filesize, 1, fd) != 1) {; 3548 Error(""ReadGIF"", ""GIF file read failed"");; 3549 free(gifArr);; 3550 fclose(fd);; 3551 return pic;; 3552 }; 3553 fclose(fd);; 3554 ; 3555 irep = GIFinfo(gifArr, &width, &height, &ncolor);; 3556 if (irep != 0) {; 3557 free(gifArr);; 3558 return pic;; 3559 }; 3560 ; 3561 if (!(pixArr = (unsigned char *) calloc((width*height),1))) {; 3562 Error(""ReadGIF"", ""unable to allocate array for image"");; 3563 free(gifArr);; 3564 return pic;; 3565 }; 3566 ; 3567 irep = GIFdecode(gifArr, pixArr, &width, &height, &ncolor, red, green, blue);; 3568 if (irep != 0) {; 3569 free(gifArr);; 3570 free(pixArr);; 3571 return pic;; 3572 }; 3573 ; 3574 // S E T P A L E T T E; 3575 ; 3576 offset = 8;; 3577 ; 3578 for (i = 0; i < ncolor; i++) {; 3579 rr = red[i]/255.;; 3580 gg = green[i]/255.;; 3581 bb = blue[i]/255.;; 3582 j = i+offset;; 3583 SetRGB(j,rr,gg,bb);; 3584 }; 3585 ; 3586 // O U T P U T I M A",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:117835,Energy Efficiency,green,green,117835,";; 3540 ; 3541 if (!(gifArr = (unsigned char *) calloc(filesize+256,1))) {; 3542 Error(""ReadGIF"", ""unable to allocate array for gif"");; 3543 fclose(fd);; 3544 return pic;; 3545 }; 3546 ; 3547 if (fread(gifArr, filesize, 1, fd) != 1) {; 3548 Error(""ReadGIF"", ""GIF file read failed"");; 3549 free(gifArr);; 3550 fclose(fd);; 3551 return pic;; 3552 }; 3553 fclose(fd);; 3554 ; 3555 irep = GIFinfo(gifArr, &width, &height, &ncolor);; 3556 if (irep != 0) {; 3557 free(gifArr);; 3558 return pic;; 3559 }; 3560 ; 3561 if (!(pixArr = (unsigned char *) calloc((width*height),1))) {; 3562 Error(""ReadGIF"", ""unable to allocate array for image"");; 3563 free(gifArr);; 3564 return pic;; 3565 }; 3566 ; 3567 irep = GIFdecode(gifArr, pixArr, &width, &height, &ncolor, red, green, blue);; 3568 if (irep != 0) {; 3569 free(gifArr);; 3570 free(pixArr);; 3571 return pic;; 3572 }; 3573 ; 3574 // S E T P A L E T T E; 3575 ; 3576 offset = 8;; 3577 ; 3578 for (i = 0; i < ncolor; i++) {; 3579 rr = red[i]/255.;; 3580 gg = green[i]/255.;; 3581 bb = blue[i]/255.;; 3582 j = i+offset;; 3583 SetRGB(j,rr,gg,bb);; 3584 }; 3585 ; 3586 // O U T P U T I M A G E; 3587 ; 3588 for (i = 1; i <= height/2; i++) {; 3589 j1 = pixArr + (i-1)*width;; 3590 j2 = pixArr + (height-i)*width;; 3591 for (k = 0; k < width; k++) {; 3592 icol = *j1; *j1++ = *j2; *j2++ = icol;; 3593 }; 3594 }; 3595 if (id) pic = CreatePixmap(id, width, height);; 3596 PutImage(offset,-1,x0,y0,width,height,0,0,width-1,height-1,pixArr,pic);; 3597 ; 3598 free(gifArr);; 3599 free(pixArr);; 3600 ; 3601 if (pic); 3602 return pic;; 3603 else if (gCws->fDrawing); 3604 return (Pixmap_t)gCws->fDrawing;; 3605 return 0;; 3606}; 3607 ; 3608////////////////////////////////////////////////////////////////////////////////; 3609/// Returns an array of pixels created from a part of drawable; 3610/// (defined by x, y, w, h) in format:; 3611/// `b1, g1, r1, 0, b2, g2, r2, 0, ..., bn, gn, rn, 0`.; 3612///; 3613/// Pixels are numbered from left to right and from top to bot",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:136047,Energy Efficiency,green,green,136047,"gcDefinition TGWin32VirtualXProxy.cxx:130; textOption_t Option_t TPoint TPoint const char textDefinition TGWin32VirtualXProxy.cxx:68; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; PutBytestatic void PutByte(Byte_t b)Put byte b in output stream.Definition TGWin32.cxx:4312; KeySymunsigned long KeySymDefinition TGWin32.h:50; XRotTextExtentsXPoint * XRotTextExtents(Display *, XFontStruct *, float, int, int, char *, int)Calculate the bounding box some text will have when painted.Definition Rotated.cxx:1335; gFillHollowstatic Int_t gFillHollowDefinition TGX11.cxx:101; gMarkerJoinStylestatic int gMarkerJoinStyleDefinition TGX11.cxx:128; gOutstatic FILE * gOutDefinition TGX11.cxx:3293; gMarkerLineStylestatic int gMarkerLineStyleDefinition TGX11.cxx:126; XRotVersionfloat XRotVersion(char *, int)Return version/copyright information.Definition Rotated.cxx:232; GIFquantizeint GIFquantize(UInt_t width, UInt_t height, Int_t *ncol, Byte_t *red, Byte_t *green, Byte_t *blue, Byte_t *outputBuf, Byte_t *outputCmap); gKeybdMaskstatic ULong_t gKeybdMaskDefinition TGX11.cxx:149; XRotSetMagnificationvoid XRotSetMagnification(float)Set the font magnification factor for all subsequent operations.Definition Rotated.cxx:242; gFontstatic struct @56 gFont[kMAXFONT]; gCapStylestatic int gCapStyleDefinition TGX11.cxx:135; gGCfillstatic GC * gGCfillDefinition TGX11.cxx:93; gGCechostatic GC gGCechoDefinition TGX11.cxx:99; idXFontStruct * idDefinition TGX11.cxx:109; gGCinvtstatic GC * gGCinvtDefinition TGX11.cxx:95; GetPixelstatic void GetPixel(int y, int width, Byte_t *scline)Get pixels in line y and put in array scline.Definition TGX11.cxx:3308; gFillPatternstatic Pixmap gFillPatternDefinition TGX11.cxx:102; gNullCursorstatic Cursor gNullCursorDefinition TGX11.cxx:159; namechar name[80]Definition TGX11.cxx:110; gTwsstatic XWindow_t * gTwsDefinition TGX11.cxx:82; gMarkerstatic struct @57 gMarker; kMAXGCconst int kMAXGCDefinition TGX11.cxx:89; GIFdecodeint GI",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:144375,Energy Efficiency,allocate,allocate,144375," resource.Definition TEnv.cxx:491; TExMapIterDefinition TExMap.h:85; TExMapIter::NextBool_t Next(ULong64_t &hash, Long64_t &key, Long64_t &value)Get next entry from TExMap. Returns kFALSE at end of map.Definition TExMap.cxx:412; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TGX11This class is the basic interface to the X11 (Xlib) graphics system.Definition TGX11.h:80; TGX11::DrawFillAreavoid DrawFillArea(Int_t n, TPoint *xy) overrideFill area described by polygon.Definition TGX11.cxx:589; TGX11::fDisplayvoid * fDisplayPointer to display.Definition TGX11.h:125; TGX11::MakeOpaqueColorsvoid MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors)Get RGB values for orgcolors, add percent neutral to the RGB and allocate fNewColors.Definition TGX11.cxx:2974; TGX11::SetLineColorvoid SetLineColor(Color_t cindex) overrideSet color index for lines.Definition TGX11.cxx:2276; TGX11::GetGeometryvoid GetGeometry(Int_t wid, Int_t &x, Int_t &y, UInt_t &w, UInt_t &h) overrideReturn position and size of window wid.Definition TGX11.cxx:961; TGX11::fColormapColormap fColormapDefault colormap, 0 if b/w.Definition TGX11.h:129; TGX11::GetWindowIDWindow_t GetWindowID(Int_t wid) overrideReturn the X11 window identifier.Definition TGX11.cxx:1068; TGX11::WriteGIFInt_t WriteGIF(char *name) overrideWrites the current window into GIF file.Definition TGX11.cxx:3387; TGX11::SetFillColorvoid SetFillColor(Color_t cindex) overrideSet color index for fill areas.Definition TGX11.cxx:2183; TGX11::ResizeWindowvoid ResizeWindow(Int_t wid) overrideResize the current window if necessary.Definition TGX11.cxx:1919; TGX11::SetTextAlignvoid SetTextAlign(Short_t",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:150061,Energy Efficiency,green,green,150061,"x)Clear the pixmap pix.Definition TGX11.cxx:407; TGX11::fTextMagnitudeFloat_t fTextMagnitudeText Magnitude.Definition TGX11.h:138; TGX11::SetCharacterUpvoid SetCharacterUp(Float_t chupx, Float_t chupy) overrideSet character up vector.Definition TGX11.cxx:1983; TGX11::fRootWinDrawable fRootWinRoot window used as parent of all windows.Definition TGX11.h:127; TGX11::WritePixmapvoid WritePixmap(Int_t wid, UInt_t w, UInt_t h, char *pxname) overrideWrite the pixmap wid in the bitmap file pxname.Definition TGX11.cxx:3278; TGX11::SetInputvoid SetInput(Int_t inp)Set input on or off.Definition TGX11.cxx:2257; TGX11::GetPlanesvoid GetPlanes(Int_t &nplanes) overrideGet maximum number of planes.Definition TGX11.cxx:1019; TGX11::fTextAlignHInt_t fTextAlignHText Alignment Horizontal.Definition TGX11.h:133; TGX11::ClearWindowvoid ClearWindow() overrideClear current window.Definition TGX11.cxx:422; TGX11::fXEventvoid * fXEventCurrent native (X11) event.Definition TGX11.h:87; TGX11::fGreenShiftInt_t fGreenShiftBits to left shift green.Definition TGX11.h:144; TGX11::DrawBoxvoid DrawBox(Int_t x1, Int_t y1, Int_t x2, Int_t y2, EBoxMode mode) overrideDraw a box.Definition TGX11.cxx:525; TGX11::CopyPixmapvoid CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos) overrideCopy the pixmap wid at the position xpos, ypos in the current window.Definition TGX11.cxx:496; TGX11::SetOpacityvoid SetOpacity(Int_t percent) overrideSet opacity of a window.Definition TGX11.cxx:2884; TGX11::OpenPixmapInt_t OpenPixmap(UInt_t w, UInt_t h) overrideOpen a new pixmap.Definition TGX11.cxx:1243; TGX11::GetColorXColor_t & GetColor(Int_t cid)Return reference to internal color structure associated to color index cid.Definition TGX11.cxx:909; TGX11::fBlueDivInt_t fBlueDivBlue value divider.Definition TGX11.h:142; TGX11::DrawPolyMarkervoid DrawPolyMarker(Int_t n, TPoint *xy) overrideDraw n markers with the current attributes at position x, y.Definition TGX11.cxx:676; TGX11::CloseWindowvoid CloseWindow() overrideDelete curre",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:159066,Energy Efficiency,allocate,allocate,159066,"re used.Definition TGX11.h:146; TGX11::SelectWindowvoid SelectWindow(Int_t wid) overrideSelect window to which subsequent output is directed.Definition TGX11.cxx:1958; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjStringCollectable string class.Definition TObjString.h:28; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPointDefinition TPoint.h:31; TStorage::Allocstatic void * Alloc(size_t size)Allocate a block of memory, that later can be resized using TStorage::ReAlloc().Definition TStorage.cxx:152; TStorage::Deallocstatic void Dealloc(void *ptr)De-allocate block of memory, that was allocated via TStorage::Alloc().Definition TStorage.cxx:170; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TStringBasic string class.Definition TString.h:139; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TStyle::GetLineStyleStringconst char * GetLineStyleString(Int_t i=1) constReturn line style string (used by PostScript).Definition TStyle.cxx:1166; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; TVirtualX::EDrawModeEDrawModeDefinition TVirtualX.h:49; TVirtualX::kXor@ kXorDefinition TVirtualX.h:49; TVirtualX::kCopy@ kCopyDefinition TVirtualX.h:49; TVirtualX::kInvert@ kInvertDefinition TVirtualX.h:49; TVirtualX::ETextModeETextModeDefinition TVirtualX.h:51; TVirtualX::kOpaque@ kOpaqueDefinition TVir",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:159101,Energy Efficiency,allocate,allocated,159101,"re used.Definition TGX11.h:146; TGX11::SelectWindowvoid SelectWindow(Int_t wid) overrideSelect window to which subsequent output is directed.Definition TGX11.cxx:1958; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjStringCollectable string class.Definition TObjString.h:28; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPointDefinition TPoint.h:31; TStorage::Allocstatic void * Alloc(size_t size)Allocate a block of memory, that later can be resized using TStorage::ReAlloc().Definition TStorage.cxx:152; TStorage::Deallocstatic void Dealloc(void *ptr)De-allocate block of memory, that was allocated via TStorage::Alloc().Definition TStorage.cxx:170; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TStringBasic string class.Definition TString.h:139; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TStyle::GetLineStyleStringconst char * GetLineStyleString(Int_t i=1) constReturn line style string (used by PostScript).Definition TStyle.cxx:1166; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; TVirtualX::EDrawModeEDrawModeDefinition TVirtualX.h:49; TVirtualX::kXor@ kXorDefinition TVirtualX.h:49; TVirtualX::kCopy@ kCopyDefinition TVirtualX.h:49; TVirtualX::kInvert@ kInvertDefinition TVirtualX.h:49; TVirtualX::ETextModeETextModeDefinition TVirtualX.h:51; TVirtualX::kOpaque@ kOpaqueDefinition TVir",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:818,Integrability,interface,interface,818,". ROOT: graf2d/x11/src/TGX11.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGX11.cxx. Go to the documentation of this file. 1// @(#)root/x11:$Id$; 2// Author: Rene Brun, Olivier Couet, Fons Rademakers 28/11/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/// \defgroup x11 X11 backend; 13/// \brief Interface to X11 graphics.; 14/// \ingroup GraphicsBackends; 15 ; 16/** \class TGX11; 17\ingroup x11; 18This class is the basic interface to the X11 (Xlib) graphics system.; 19It is an implementation of the abstract TVirtualX class.; 20 ; 21This class gives access to basic X11 graphics, pixmap, text and font handling; 22routines.; 23 ; 24The companion class for Win32 is TGWin32.; 25 ; 26The file G11Gui.cxx contains the implementation of the GUI methods of the; 27TGX11 class. Most of the methods are used by the machine independent; 28GUI classes (libGUI.so).; 29 ; 30This code was initially developed in the context of HIGZ and PAW; 31by Olivier Couet (package X11INT).; 32*/; 33 ; 34#include ""TROOT.h""; 35#include ""TColor.h""; 36#include ""TGX11.h""; 37#include ""TPoint.h""; 38#include ""TMath.h""; 39#include ""TStorage.h""; 40#include ""TStyle.h""; 41#include ""TExMap.h""; 42#include ""TEnv.h""; 43#include ""TString.h""; 44#include ""TObjString.h""; 45#include ""TObjArray.h""; 46#include ""RStipples.h""; 47#include ""strlcpy.h""; 48 ; 49#include <X11/Xlib.h>; 50#include <X11/Xutil.h>; 51#include <X11/Xatom.h>; 52#include <X11/cursorfont.h>; 53#include <X11/keysym.h>; 54#include <X11/xpm.h>; 55 ; 56#include <cstdio>; 57#include <cstring>; 58#include <cstdlib>; 59#include <cctype>; 60#include <unistd.h>; 61#ifdef R__AIX",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:34000,Integrability,message,message,34000," of planes.; 1018 ; 1019void TGX11::GetPlanes(int &nplanes); 1020{; 1021 nplanes = fDepth;; 1022}; 1023 ; 1024////////////////////////////////////////////////////////////////////////////////; 1025/// Get rgb values for color ""index"".; 1026 ; 1027void TGX11::GetRGB(int index, float &r, float &g, float &b); 1028{; 1029 if (index == 0) {; 1030 r = g = b = 1.0;; 1031 } else if (index == 1) {; 1032 r = g = b = 0.0;; 1033 } else {; 1034 XColor_t &col = GetColor(index);; 1035 r = ((float) col.fRed) / ((float) kBIGGEST_RGB_VALUE);; 1036 g = ((float) col.fGreen) / ((float) kBIGGEST_RGB_VALUE);; 1037 b = ((float) col.fBlue) / ((float) kBIGGEST_RGB_VALUE);; 1038 }; 1039}; 1040 ; 1041////////////////////////////////////////////////////////////////////////////////; 1042/// Return the size of a character string.; 1043///; 1044/// \param [in] w : text width; 1045/// \param [in] h : text height; 1046/// \param [in] mess : message; 1047 ; 1048void TGX11::GetTextExtent(UInt_t &w, UInt_t &h, char *mess); 1049{; 1050 w=0; h=0;; 1051 if (strlen(mess)==0) return;; 1052 ; 1053 XPoint *cBox;; 1054 XRotSetMagnification(fTextMagnitude);; 1055 cBox = XRotTextExtents((Display*)fDisplay, gTextFont, 0., 0, 0, mess, 0);; 1056 if (cBox) {; 1057 w = cBox[2].x;; 1058 h = -cBox[2].y;; 1059 free((char *)cBox);; 1060 }; 1061}; 1062 ; 1063////////////////////////////////////////////////////////////////////////////////; 1064/// Return the X11 window identifier.; 1065///; 1066/// \param [in] wid : Workstation identifier (input); 1067 ; 1068Window_t TGX11::GetWindowID(int wid); 1069{; 1070 return (Window_t) fWindows[wid].fWindow;; 1071}; 1072 ; 1073////////////////////////////////////////////////////////////////////////////////; 1074/// Move the window wid.; 1075///; 1076/// \param [in] wid : Window identifier.; 1077/// \param [in] x : x new window position; 1078/// \param [in] y : y new window position; 1079 ; 1080void TGX11::MoveWindow(Int_t wid, Int_t x, Int_t y); 1081{; 1082 gTws = &fWindows[wid];; 108",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:95911,Integrability,rout,routine,95911,"imx*1.005;; 2854 shape[1].x =-imx; shape[1].y = -im;; 2855 shape[2].x = imx; shape[2].y = -im;; 2856 shape[3].x = imx; shape[3].y =-imx;; 2857 shape[4].x = im; shape[4].y =-imx;; 2858 shape[5].x = im; shape[5].y = imx;; 2859 shape[6].x = imx; shape[6].y = imx;; 2860 shape[7].x = imx; shape[7].y = im;; 2861 shape[8].x =-imx; shape[8].y = im;; 2862 shape[9].x =-imx; shape[9].y = imx;; 2863 shape[10].x = -im; shape[10].y = imx;; 2864 shape[11].x = -im; shape[11].y =-imx;; 2865 shape[12].x =-imx; shape[12].y =-imx*0.995;; 2866 shape[13].x =-imx; shape[13].y = imx;; 2867 shape[14].x = imx; shape[14].y = imx;; 2868 shape[15].x = imx; shape[15].y =-imx;; 2869 shape[16].x =-imx; shape[16].y =-imx*1.005;; 2870 SetMarkerType(3,17,shape);; 2871 } else {; 2872 // single dot; 2873 SetMarkerType(0,0,shape);; 2874 }; 2875}; 2876 ; 2877////////////////////////////////////////////////////////////////////////////////; 2878/// Set opacity of a window. This image manipulation routine works; 2879/// by adding to a percent amount of neutral to each pixels RGB.; 2880/// Since it requires quite some additional color map entries is it; 2881/// only supported on displays with more than > 8 color planes (> 256; 2882/// colors).; 2883 ; 2884void TGX11::SetOpacity(Int_t percent); 2885{; 2886 if (fDepth <= 8) return;; 2887 if (percent == 0) return;; 2888 // if 100 percent then just make white; 2889 ; 2890 ULong_t *orgcolors = nullptr, *tmpc = nullptr;; 2891 Int_t maxcolors = 0, ncolors = 0, ntmpc = 0;; 2892 ; 2893 // save previous allocated colors, delete at end when not used anymore; 2894 if (gCws->fNewColors) {; 2895 tmpc = gCws->fNewColors;; 2896 ntmpc = gCws->fNcolors;; 2897 }; 2898 ; 2899 // get pixmap from server as image; 2900 XImage *image = XGetImage((Display*)fDisplay, gCws->fDrawing, 0, 0, gCws->fWidth,; 2901 gCws->fHeight, AllPlanes, ZPixmap);; 2902 if (!image) return;; 2903 // collect different image colors; 2904 int x, y;; 2905 for (y = 0; y < (int) gCws->fHeight; y++) {; 2906 for ",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:143953,Integrability,interface,interface,143953,"hod returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::GetBlueFloat_t GetBlue() constDefinition TColor.h:62; TColor::GetGreenFloat_t GetGreen() constDefinition TColor.h:61; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TExMapIterDefinition TExMap.h:85; TExMapIter::NextBool_t Next(ULong64_t &hash, Long64_t &key, Long64_t &value)Get next entry from TExMap. Returns kFALSE at end of map.Definition TExMap.cxx:412; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TGX11This class is the basic interface to the X11 (Xlib) graphics system.Definition TGX11.h:80; TGX11::DrawFillAreavoid DrawFillArea(Int_t n, TPoint *xy) overrideFill area described by polygon.Definition TGX11.cxx:589; TGX11::fDisplayvoid * fDisplayPointer to display.Definition TGX11.h:125; TGX11::MakeOpaqueColorsvoid MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors)Get RGB values for orgcolors, add percent neutral to the RGB and allocate fNewColors.Definition TGX11.cxx:2974; TGX11::SetLineColorvoid SetLineColor(Color_t cindex) overrideSet color index for lines.Definition TGX11.cxx:2276; TGX11::GetGeometryvoid GetGeometry(Int_t wid, Int_t &x, Int_t &y, UInt_t &w, UInt_t &h) overrideReturn position and size of window wid.Definition TGX11.cxx:961; TGX11::fColormapColormap fColormapDefault colormap, 0 if b/w.Definition TGX11.h:129; TGX11::GetWindowIDWindow_t GetWindowID(Int_t wid) overrideReturn the X11 window identifier.Definition TGX11.cxx:1068; TGX11::WriteGIFInt_t WriteGIF(char *name) overrideWrites",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:158664,Integrability,message,message,158664,"specified gif file at position [x0,y0] in the current window.Definition TGX11.cxx:3515; TGX11::AddWindowInt_t AddWindow(ULong_t qwid, UInt_t w, UInt_t h) overrideRegister a window created by Qt as a ROOT window (like InitWindow()).Definition TGX11.cxx:1378; TGX11::fCharacterUpYFloat_t fCharacterUpYCharacter Up vector along Y.Definition TGX11.h:137; TGX11::fHasTTFontsBool_t fHasTTFontsTrue when TrueType fonts are used.Definition TGX11.h:146; TGX11::SelectWindowvoid SelectWindow(Int_t wid) overrideSelect window to which subsequent output is directed.Definition TGX11.cxx:1958; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjStringCollectable string class.Definition TObjString.h:28; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPointDefinition TPoint.h:31; TStorage::Allocstatic void * Alloc(size_t size)Allocate a block of memory, that later can be resized using TStorage::ReAlloc().Definition TStorage.cxx:152; TStorage::Deallocstatic void Dealloc(void *ptr)De-allocate block of memory, that was allocated via TStorage::Alloc().Definition TStorage.cxx:170; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TStringBasic string class.Definition TString.h:139; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TStyle::GetLineStyleStringconst char * GetLineStyleString(Int_t i=1) constReturn line style string (used by PostScript).Definition TStyle.cxx:1166; TVirtualXSemi-Ab",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:158794,Integrability,message,message,158794,"d, UInt_t w, UInt_t h) overrideRegister a window created by Qt as a ROOT window (like InitWindow()).Definition TGX11.cxx:1378; TGX11::fCharacterUpYFloat_t fCharacterUpYCharacter Up vector along Y.Definition TGX11.h:137; TGX11::fHasTTFontsBool_t fHasTTFontsTrue when TrueType fonts are used.Definition TGX11.h:146; TGX11::SelectWindowvoid SelectWindow(Int_t wid) overrideSelect window to which subsequent output is directed.Definition TGX11.cxx:1958; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjStringCollectable string class.Definition TObjString.h:28; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPointDefinition TPoint.h:31; TStorage::Allocstatic void * Alloc(size_t size)Allocate a block of memory, that later can be resized using TStorage::ReAlloc().Definition TStorage.cxx:152; TStorage::Deallocstatic void Dealloc(void *ptr)De-allocate block of memory, that was allocated via TStorage::Alloc().Definition TStorage.cxx:170; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TStringBasic string class.Definition TString.h:139; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TStyle::GetLineStyleStringconst char * GetLineStyleString(Int_t i=1) constReturn line style string (used by PostScript).Definition TStyle.cxx:1166; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; TVirtualX::EDrawModeEDraw",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:159695,Integrability,interface,interface,159695,"TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPointDefinition TPoint.h:31; TStorage::Allocstatic void * Alloc(size_t size)Allocate a block of memory, that later can be resized using TStorage::ReAlloc().Definition TStorage.cxx:152; TStorage::Deallocstatic void Dealloc(void *ptr)De-allocate block of memory, that was allocated via TStorage::Alloc().Definition TStorage.cxx:170; TStorage::ReAllocstatic void * ReAlloc(void *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:183; TStringBasic string class.Definition TString.h:139; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TStyle::GetLineStyleStringconst char * GetLineStyleString(Int_t i=1) constReturn line style string (used by PostScript).Definition TStyle.cxx:1166; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; TVirtualX::EDrawModeEDrawModeDefinition TVirtualX.h:49; TVirtualX::kXor@ kXorDefinition TVirtualX.h:49; TVirtualX::kCopy@ kCopyDefinition TVirtualX.h:49; TVirtualX::kInvert@ kInvertDefinition TVirtualX.h:49; TVirtualX::ETextModeETextModeDefinition TVirtualX.h:51; TVirtualX::kOpaque@ kOpaqueDefinition TVirtualX.h:51; TVirtualX::kClear@ kClearDefinition TVirtualX.h:51; TVirtualX::fDrawModeEDrawMode fDrawModeDefinition TVirtualX.h:55; TVirtualX::EBoxModeEBoxModeDefinition TVirtualX.h:50; TVirtualX::kFilled@ kFilledDefinition TVirtualX.h:50; TVirtualX::kHollow@ kHollowDefinition TVirtualX.h:50; TVirtualX::ETextSetModeETextSetModeDefinition TVirtualX.h:52; TVirtualX::kLoad@ kLoadDefinition TVirtualX.h:52; Visual; XColor; XGCValues; XImage; XSetWindowAttributes; XVisualInfo; bool; int; unsigned int; ptTPaveText * ptDefinition entrylist_figure1.C:7; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition l",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:3718,Performance,load,loaded,3718,XWindow_t *gCws; // gCws: pointer to the current window; 82static XWindow_t *gTws; // gTws: temporary pointer; 83 ; 84const Int_t kBIGGEST_RGB_VALUE = 65535;; 85 ; 86//; 87// Primitives Graphic Contexts global for all windows; 88//; 89const int kMAXGC = 7;; 90static GC gGClist[kMAXGC];; 91static GC *gGCline = &gGClist[0]; // PolyLines; 92static GC *gGCmark = &gGClist[1]; // PolyMarker; 93static GC *gGCfill = &gGClist[2]; // Fill areas; 94static GC *gGCtext = &gGClist[3]; // Text; 95static GC *gGCinvt = &gGClist[4]; // Inverse text; 96static GC *gGCdash = &gGClist[5]; // Dashed lines; 97static GC *gGCpxmp = &gGClist[6]; // Pixmap management; 98 ; 99static GC gGCecho; // Input echo; 100 ; 101static Int_t gFillHollow; // Flag if fill style is hollow; 102static Pixmap gFillPattern = 0; // Fill pattern; 103 ; 104//; 105// Text management; 106//; 107const Int_t kMAXFONT = 4;; 108static struct {; 109 XFontStruct *id;; 110 char name[80]; // Font name; 111} gFont[kMAXFONT]; // List of fonts loaded; 112 ; 113static XFontStruct *gTextFont; // Current font; 114static Int_t gCurrentFontNumber = 0; // Current font number in gFont[]; 115 ; 116//; 117// Markers; 118//; 119const Int_t kMAXMK = 100;; 120static struct {; 121 int type;; 122 int n;; 123 XPoint xy[kMAXMK];; 124} gMarker; // Point list to draw marker; 125static int gMarkerLineWidth = 0;; 126static int gMarkerLineStyle = LineSolid;; 127static int gMarkerCapStyle = CapRound;; 128static int gMarkerJoinStyle = JoinRound;; 129 ; 130//; 131// Keep style values for line GC; 132//; 133static int gLineWidth = 0;; 134static int gLineStyle = LineSolid;; 135static int gCapStyle = CapButt;; 136static int gJoinStyle = JoinMiter;; 137static char gDashList[10];; 138static int gDashLength = 0;; 139static int gDashOffset = 0;; 140static int gDashSize = 0;; 141 ; 142//; 143// Event masks; 144//; 145static ULong_t gMouseMask = ButtonPressMask | ButtonReleaseMask |; 146 EnterWindowMask | LeaveWindowMask |; 147 PointerMotionMask | KeyPressMask ,MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:38242,Performance,load,loaded,38242,,MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:104223,Performance,load,loading,104223,"; 3121 ; 3122////////////////////////////////////////////////////////////////////////////////; 3123/// Set color index for text.; 3124 ; 3125void TGX11::SetTextColor(Color_t cindex); 3126{; 3127 if (cindex < 0) return;; 3128 ; 3129 TAttText::SetTextColor(cindex);; 3130 ; 3131 SetColor(gGCtext, Int_t(cindex));; 3132 ; 3133 XGCValues values;; 3134 if (XGetGCValues((Display*)fDisplay, *gGCtext, GCForeground | GCBackground, &values)) {; 3135 XSetForeground( (Display*)fDisplay, *gGCinvt, values.background );; 3136 XSetBackground( (Display*)fDisplay, *gGCinvt, values.foreground );; 3137 } else {; 3138 Error(""SetTextColor"", ""cannot get GC values"");; 3139 }; 3140 XSetBackground((Display*)fDisplay, *gGCtext, GetColor(0).fPixel);; 3141}; 3142 ; 3143////////////////////////////////////////////////////////////////////////////////; 3144/// Set text font to specified name.; 3145///; 3146/// \param [in] fontname font name; 3147/// \param [in] mode loading flag; 3148/// - mode=0 search if the font exist (kCheck); 3149/// - mode=1 search the font and load it if it exists (kLoad); 3150///; 3151/// Set text font to specified name. This function returns 0 if; 3152/// the specified font is found, 1 if not.; 3153 ; 3154Int_t TGX11::SetTextFont(char *fontname, ETextSetMode mode); 3155{; 3156 char **fontlist;; 3157 int fontcount;; 3158 int i;; 3159 ; 3160 if (mode == kLoad) {; 3161 for (i = 0; i < kMAXFONT; i++) {; 3162 if (strcmp(fontname, gFont[i].name) == 0) {; 3163 gTextFont = gFont[i].id;; 3164 XSetFont((Display*)fDisplay, *gGCtext, gTextFont->fid);; 3165 XSetFont((Display*)fDisplay, *gGCinvt, gTextFont->fid);; 3166 return 0;; 3167 }; 3168 }; 3169 }; 3170 ; 3171 fontlist = XListFonts((Display*)fDisplay, fontname, 1, &fontcount);; 3172 ; 3173 if (fontlist && fontcount != 0) {; 3174 if (mode == kLoad) {; 3175 if (gFont[gCurrentFontNumber].id); 3176 XFreeFont((Display*)fDisplay, gFont[gCurrentFontNumber].id);; 3177 gTextFont = XLoadQueryFont((Display*)fDisplay, fontlist[0]);; 3178 XSetFo",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:104326,Performance,load,load,104326,"; 3121 ; 3122////////////////////////////////////////////////////////////////////////////////; 3123/// Set color index for text.; 3124 ; 3125void TGX11::SetTextColor(Color_t cindex); 3126{; 3127 if (cindex < 0) return;; 3128 ; 3129 TAttText::SetTextColor(cindex);; 3130 ; 3131 SetColor(gGCtext, Int_t(cindex));; 3132 ; 3133 XGCValues values;; 3134 if (XGetGCValues((Display*)fDisplay, *gGCtext, GCForeground | GCBackground, &values)) {; 3135 XSetForeground( (Display*)fDisplay, *gGCinvt, values.background );; 3136 XSetBackground( (Display*)fDisplay, *gGCinvt, values.foreground );; 3137 } else {; 3138 Error(""SetTextColor"", ""cannot get GC values"");; 3139 }; 3140 XSetBackground((Display*)fDisplay, *gGCtext, GetColor(0).fPixel);; 3141}; 3142 ; 3143////////////////////////////////////////////////////////////////////////////////; 3144/// Set text font to specified name.; 3145///; 3146/// \param [in] fontname font name; 3147/// \param [in] mode loading flag; 3148/// - mode=0 search if the font exist (kCheck); 3149/// - mode=1 search the font and load it if it exists (kLoad); 3150///; 3151/// Set text font to specified name. This function returns 0 if; 3152/// the specified font is found, 1 if not.; 3153 ; 3154Int_t TGX11::SetTextFont(char *fontname, ETextSetMode mode); 3155{; 3156 char **fontlist;; 3157 int fontcount;; 3158 int i;; 3159 ; 3160 if (mode == kLoad) {; 3161 for (i = 0; i < kMAXFONT; i++) {; 3162 if (strcmp(fontname, gFont[i].name) == 0) {; 3163 gTextFont = gFont[i].id;; 3164 XSetFont((Display*)fDisplay, *gGCtext, gTextFont->fid);; 3165 XSetFont((Display*)fDisplay, *gGCinvt, gTextFont->fid);; 3166 return 0;; 3167 }; 3168 }; 3169 }; 3170 ; 3171 fontlist = XListFonts((Display*)fDisplay, fontname, 1, &fontcount);; 3172 ; 3173 if (fontlist && fontcount != 0) {; 3174 if (mode == kLoad) {; 3175 if (gFont[gCurrentFontNumber].id); 3176 XFreeFont((Display*)fDisplay, gFont[gCurrentFontNumber].id);; 3177 gTextFont = XLoadQueryFont((Display*)fDisplay, fontlist[0]);; 3178 XSetFo",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:116022,Performance,load,loads,116022,"; jbase += nx;; 3474 for (jimg = jbase, icol = *jimg++, x = x1+1; x <= x2; jimg++, x++) {; 3475 if (icol != *jimg) {; 3476 if (icol != itran) {; 3477 n = nlines[icol]++;; 3478 lines[icol][n].x1 = xcur; lines[icol][n].y1 = y;; 3479 lines[icol][n].x2 = x-1; lines[icol][n].y2 = y;; 3480 if (nlines[icol] == maxSegment) {; 3481 SetColor(gGCline,(int)icol+offset);; 3482 XDrawSegments((Display*)fDisplay,id,*gGCline,&lines[icol][0],; 3483 maxSegment);; 3484 nlines[icol] = 0;; 3485 }; 3486 }; 3487 icol = *jimg; xcur = x;; 3488 }; 3489 }; 3490 if (icol != itran) {; 3491 n = nlines[icol]++;; 3492 lines[icol][n].x1 = xcur; lines[icol][n].y1 = y;; 3493 lines[icol][n].x2 = x-1; lines[icol][n].y2 = y;; 3494 if (nlines[icol] == maxSegment) {; 3495 SetColor(gGCline,(int)icol+offset);; 3496 XDrawSegments((Display*)fDisplay,id,*gGCline,&lines[icol][0],; 3497 maxSegment);; 3498 nlines[icol] = 0;; 3499 }; 3500 }; 3501 }; 3502 ; 3503 for (i = 0; i < 256; i++) {; 3504 if (nlines[i] != 0) {; 3505 SetColor(gGCline,i+offset);; 3506 XDrawSegments((Display*)fDisplay,id,*gGCline,&lines[i][0],nlines[i]);; 3507 }; 3508 }; 3509}; 3510 ; 3511////////////////////////////////////////////////////////////////////////////////; 3512/// If id is NULL - loads the specified gif file at position [x0,y0] in the; 3513/// current window. Otherwise creates pixmap from gif file; 3514 ; 3515Pixmap_t TGX11::ReadGIF(int x0, int y0, const char *file, Window_t id); 3516{; 3517 FILE *fd;; 3518 Seek_t filesize = 0;; 3519 unsigned char *gifArr, *pixArr, red[256], green[256], blue[256], *j1, *j2, icol;; 3520 int i, j, k, width, height, ncolor, irep, offset;; 3521 float rr, gg, bb;; 3522 Pixmap_t pic = 0;; 3523 ; 3524 fd = fopen(file, ""r"");; 3525 if (!fd) {; 3526 Error(""ReadGIF"", ""unable to open GIF file"");; 3527 return pic;; 3528 }; 3529 ; 3530 fseek(fd, 0L, 2);; 3531 long ft = ftell(fd);; 3532 if (ft <=0) {; 3533 Error(""ReadGIF"", ""unable to open GIF file"");; 3534 fclose(fd);; 3535 return pic;; 3536 } else {; 3537 filesize",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:157647,Performance,load,loads,157647,"e width.Definition TGX11.cxx:2362; TGX11::fWindowsXWindow_t * fWindowsList of windows.Definition TGX11.h:84; TGX11::PutImagevoid PutImage(Int_t offset, Int_t itran, Int_t x0, Int_t y0, Int_t nx, Int_t ny, Int_t xmin, Int_t ymin, Int_t xmax, Int_t ymax, UChar_t *image, Drawable_t id)Draw image.Definition TGX11.cxx:3450; TGX11::GetDoubleBufferInt_t GetDoubleBuffer(Int_t wid) overrideQuery the double buffer value for the window wid.Definition TGX11.cxx:943; TGX11::FindBestVisualvoid FindBestVisual()Find best visual, i.e.Definition TGX11.cxx:780; TGX11::SetDrawModevoid SetDrawMode(EDrawMode mode) overrideSet the drawing mode.Definition TGX11.cxx:2159; TGX11::SetColorvoid SetColor(void *gc, Int_t ci)Set the foreground color in GC.Definition TGX11.cxx:2043; TGX11::DisplayNameconst char * DisplayName(const char *dpyName=nullptr) overrideReturn hostname on which the display is opened.Definition TGX11.cxx:996; TGX11::ReadGIFPixmap_t ReadGIF(Int_t x0, Int_t y0, const char *file, Window_t id=0) overrideIf id is NULL - loads the specified gif file at position [x0,y0] in the current window.Definition TGX11.cxx:3515; TGX11::AddWindowInt_t AddWindow(ULong_t qwid, UInt_t w, UInt_t h) overrideRegister a window created by Qt as a ROOT window (like InitWindow()).Definition TGX11.cxx:1378; TGX11::fCharacterUpYFloat_t fCharacterUpYCharacter Up vector along Y.Definition TGX11.h:137; TGX11::fHasTTFontsBool_t fHasTTFontsTrue when TrueType fonts are used.Definition TGX11.h:146; TGX11::SelectWindowvoid SelectWindow(Int_t wid) overrideSelect window to which subsequent output is directed.Definition TGX11.cxx:1958; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjStringCollectable string class.Definition TObjString.h:28; TObject::Warningvirtual void Warning(const char *method, con",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:948,Security,access,access,948,". ROOT: graf2d/x11/src/TGX11.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGX11.cxx. Go to the documentation of this file. 1// @(#)root/x11:$Id$; 2// Author: Rene Brun, Olivier Couet, Fons Rademakers 28/11/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/// \defgroup x11 X11 backend; 13/// \brief Interface to X11 graphics.; 14/// \ingroup GraphicsBackends; 15 ; 16/** \class TGX11; 17\ingroup x11; 18This class is the basic interface to the X11 (Xlib) graphics system.; 19It is an implementation of the abstract TVirtualX class.; 20 ; 21This class gives access to basic X11 graphics, pixmap, text and font handling; 22routines.; 23 ; 24The companion class for Win32 is TGWin32.; 25 ; 26The file G11Gui.cxx contains the implementation of the GUI methods of the; 27TGX11 class. Most of the methods are used by the machine independent; 28GUI classes (libGUI.so).; 29 ; 30This code was initially developed in the context of HIGZ and PAW; 31by Olivier Couet (package X11INT).; 32*/; 33 ; 34#include ""TROOT.h""; 35#include ""TColor.h""; 36#include ""TGX11.h""; 37#include ""TPoint.h""; 38#include ""TMath.h""; 39#include ""TStorage.h""; 40#include ""TStyle.h""; 41#include ""TExMap.h""; 42#include ""TEnv.h""; 43#include ""TString.h""; 44#include ""TObjString.h""; 45#include ""TObjArray.h""; 46#include ""RStipples.h""; 47#include ""strlcpy.h""; 48 ; 49#include <X11/Xlib.h>; 50#include <X11/Xutil.h>; 51#include <X11/Xatom.h>; 52#include <X11/cursorfont.h>; 53#include <X11/keysym.h>; 54#include <X11/xpm.h>; 55 ; 56#include <cstdio>; 57#include <cstring>; 58#include <cstdlib>; 59#include <cctype>; 60#include <unistd.h>; 61#ifdef R__AIX",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:143410,Security,hash,hash,143410,"ext.h:42; TAttText::fTextAngleFloat_t fTextAngleText angle.Definition TAttText.h:21; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::fTextFontFont_t fTextFontText font.Definition TAttText.h:25; TAttText::fTextSizeFloat_t fTextSizeText size.Definition TAttText.h:22; TColorThe color creation and management class.Definition TColor.h:21; TColor::GetRedFloat_t GetRed() constDefinition TColor.h:60; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::GetBlueFloat_t GetBlue() constDefinition TColor.h:62; TColor::GetGreenFloat_t GetGreen() constDefinition TColor.h:61; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TExMapIterDefinition TExMap.h:85; TExMapIter::NextBool_t Next(ULong64_t &hash, Long64_t &key, Long64_t &value)Get next entry from TExMap. Returns kFALSE at end of map.Definition TExMap.cxx:412; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TGX11This class is the basic interface to the X11 (Xlib) graphics system.Definition TGX11.h:80; TGX11::DrawFillAreavoid DrawFillArea(Int_t n, TPoint *xy) overrideFill area described by polygon.Definition TGX11.cxx:589; TGX11::fDisplayvoid * fDisplayPointer to display.Definition TGX11.h:125; TGX11::MakeOpaqueColorsvoid MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors)Get RGB values for orgcolors, add percent neutral to the RGB and allocate fNewColors.Definition TGX11.cxx:2974",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:143592,Security,hash,hash,143592," tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::fTextFontFont_t fTextFontText font.Definition TAttText.h:25; TAttText::fTextSizeFloat_t fTextSizeText size.Definition TAttText.h:22; TColorThe color creation and management class.Definition TColor.h:21; TColor::GetRedFloat_t GetRed() constDefinition TColor.h:60; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::GetBlueFloat_t GetBlue() constDefinition TColor.h:62; TColor::GetGreenFloat_t GetGreen() constDefinition TColor.h:61; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TExMapIterDefinition TExMap.h:85; TExMapIter::NextBool_t Next(ULong64_t &hash, Long64_t &key, Long64_t &value)Get next entry from TExMap. Returns kFALSE at end of map.Definition TExMap.cxx:412; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TGX11This class is the basic interface to the X11 (Xlib) graphics system.Definition TGX11.h:80; TGX11::DrawFillAreavoid DrawFillArea(Int_t n, TPoint *xy) overrideFill area described by polygon.Definition TGX11.cxx:589; TGX11::fDisplayvoid * fDisplayPointer to display.Definition TGX11.h:125; TGX11::MakeOpaqueColorsvoid MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors)Get RGB values for orgcolors, add percent neutral to the RGB and allocate fNewColors.Definition TGX11.cxx:2974; TGX11::SetLineColorvoid SetLineColor(Color_t cindex) overrideSet color index for lines.Definition TGX11.cxx:2276; TGX11::GetGeometryvoid G",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:143651,Security,hash,hash,143651," TAttText.h:25; TAttText::fTextSizeFloat_t fTextSizeText size.Definition TAttText.h:22; TColorThe color creation and management class.Definition TColor.h:21; TColor::GetRedFloat_t GetRed() constDefinition TColor.h:60; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::GetBlueFloat_t GetBlue() constDefinition TColor.h:62; TColor::GetGreenFloat_t GetGreen() constDefinition TColor.h:61; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TExMapIterDefinition TExMap.h:85; TExMapIter::NextBool_t Next(ULong64_t &hash, Long64_t &key, Long64_t &value)Get next entry from TExMap. Returns kFALSE at end of map.Definition TExMap.cxx:412; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TGX11This class is the basic interface to the X11 (Xlib) graphics system.Definition TGX11.h:80; TGX11::DrawFillAreavoid DrawFillArea(Int_t n, TPoint *xy) overrideFill area described by polygon.Definition TGX11.cxx:589; TGX11::fDisplayvoid * fDisplayPointer to display.Definition TGX11.h:125; TGX11::MakeOpaqueColorsvoid MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors)Get RGB values for orgcolors, add percent neutral to the RGB and allocate fNewColors.Definition TGX11.cxx:2974; TGX11::SetLineColorvoid SetLineColor(Color_t cindex) overrideSet color index for lines.Definition TGX11.cxx:2276; TGX11::GetGeometryvoid GetGeometry(Int_t wid, Int_t &x, Int_t &y, UInt_t &w, UInt_t &h) overrideReturn position and size of window wi",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:143819,Security,hash,hash,143819,"r::GetRedFloat_t GetRed() constDefinition TColor.h:60; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::GetBlueFloat_t GetBlue() constDefinition TColor.h:62; TColor::GetGreenFloat_t GetGreen() constDefinition TColor.h:61; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TExMapIterDefinition TExMap.h:85; TExMapIter::NextBool_t Next(ULong64_t &hash, Long64_t &key, Long64_t &value)Get next entry from TExMap. Returns kFALSE at end of map.Definition TExMap.cxx:412; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TGX11This class is the basic interface to the X11 (Xlib) graphics system.Definition TGX11.h:80; TGX11::DrawFillAreavoid DrawFillArea(Int_t n, TPoint *xy) overrideFill area described by polygon.Definition TGX11.cxx:589; TGX11::fDisplayvoid * fDisplayPointer to display.Definition TGX11.h:125; TGX11::MakeOpaqueColorsvoid MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors)Get RGB values for orgcolors, add percent neutral to the RGB and allocate fNewColors.Definition TGX11.cxx:2974; TGX11::SetLineColorvoid SetLineColor(Color_t cindex) overrideSet color index for lines.Definition TGX11.cxx:2276; TGX11::GetGeometryvoid GetGeometry(Int_t wid, Int_t &x, Int_t &y, UInt_t &w, UInt_t &h) overrideReturn position and size of window wid.Definition TGX11.cxx:961; TGX11::fColormapColormap fColormapDefault colormap, 0 if b/w.Definition TGX11.h:129; TGX11::GetWindowIDWindow_t GetWindowID(Int_t wid) ",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:143886,Security,hash,hash,143886,"r::GetRedFloat_t GetRed() constDefinition TColor.h:60; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::GetBlueFloat_t GetBlue() constDefinition TColor.h:62; TColor::GetGreenFloat_t GetGreen() constDefinition TColor.h:61; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TExMapIterDefinition TExMap.h:85; TExMapIter::NextBool_t Next(ULong64_t &hash, Long64_t &key, Long64_t &value)Get next entry from TExMap. Returns kFALSE at end of map.Definition TExMap.cxx:412; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::Addvoid Add(ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table. The key should be unique.Definition TExMap.cxx:88; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TGX11This class is the basic interface to the X11 (Xlib) graphics system.Definition TGX11.h:80; TGX11::DrawFillAreavoid DrawFillArea(Int_t n, TPoint *xy) overrideFill area described by polygon.Definition TGX11.cxx:589; TGX11::fDisplayvoid * fDisplayPointer to display.Definition TGX11.h:125; TGX11::MakeOpaqueColorsvoid MakeOpaqueColors(Int_t percent, ULong_t *orgcolors, Int_t ncolors)Get RGB values for orgcolors, add percent neutral to the RGB and allocate fNewColors.Definition TGX11.cxx:2974; TGX11::SetLineColorvoid SetLineColor(Color_t cindex) overrideSet color index for lines.Definition TGX11.cxx:2276; TGX11::GetGeometryvoid GetGeometry(Int_t wid, Int_t &x, Int_t &y, UInt_t &w, UInt_t &h) overrideReturn position and size of window wid.Definition TGX11.cxx:961; TGX11::fColormapColormap fColormapDefault colormap, 0 if b/w.Definition TGX11.h:129; TGX11::GetWindowIDWindow_t GetWindowID(Int_t wid) ",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:27289,Usability,usab,usable,27289,"fDisplay, fScreenNumber);; 819 ; 820 if (!fVisual) {; 821 fDepth = DefaultDepth((Display*)fDisplay, fScreenNumber);; 822 fVisual = (RVisual*)DefaultVisual((Display*)fDisplay, fScreenNumber);; 823 fVisRootWin = fRootWin;; 824 if (fDepth > 1); 825 fColormap = DefaultColormap((Display*)fDisplay, fScreenNumber);; 826 fBlackPixel = BlackPixel((Display*)fDisplay, fScreenNumber);; 827 fWhitePixel = WhitePixel((Display*)fDisplay, fScreenNumber);; 828 }; 829 if (gDebug > 1); 830 Printf(""Selected visual 0x%lx: depth %d, class %d, colormap: %s"",; 831 fVisual->visualid, fDepth, fVisual->c_class,; 832 fColormap == DefaultColormap((Display*)fDisplay, fScreenNumber) ? ""default"" :; 833 ""custom"");; 834}; 835 ; 836////////////////////////////////////////////////////////////////////////////////; 837/// Dummy error handler for X11. Used by FindUsableVisual().; 838 ; 839static Int_t DummyX11ErrorHandler(Display *, XErrorEvent *); 840{; 841 return 0;; 842}; 843 ; 844////////////////////////////////////////////////////////////////////////////////; 845/// Check if visual is usable, if so set fVisual, fDepth, fColormap,; 846/// fBlackPixel and fWhitePixel.; 847 ; 848void TGX11::FindUsableVisual(RXVisualInfo *vlist, Int_t nitems); 849{; 850 Int_t (*oldErrorHandler)(Display *, XErrorEvent *) =; 851 XSetErrorHandler(DummyX11ErrorHandler);; 852 ; 853 XSetWindowAttributes attr;; 854 memset(&attr, 0, sizeof(attr));; 855 ; 856 Window root = RootWindow((Display*)fDisplay, fScreenNumber);; 857 ; 858 for (Int_t i = 0; i < nitems; i++) {; 859 Window w = None, wjunk;; 860 UInt_t width, height, ujunk;; 861 Int_t junk;; 862 ; 863 // try and use default colormap when possible; 864 if (vlist[i].visual == DefaultVisual((Display*)fDisplay, fScreenNumber)) {; 865 attr.colormap = DefaultColormap((Display*)fDisplay, fScreenNumber);; 866 } else {; 867 attr.colormap = XCreateColormap((Display*)fDisplay, root, vlist[i].visual, AllocNone);; 868 }; 869 ; 870 static XColor black_xcol = { 0, 0x0000, 0x0000, 0x0000, Do",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TGX11_8cxx_source.html:154718,Usability,usab,usable,154718,"r(Int_t mode, Int_t ctyp, Int_t &x, Int_t &y) overrideRequest Locator position.Definition TGX11.cxx:1505; TGX11::OpenDisplayInt_t OpenDisplay(void *display)Open the display. Return -1 if the opening fails, 0 when ok.Definition TGX11.cxx:1091; TGX11::DrawPolyLinevoid DrawPolyLine(Int_t n, TPoint *xy) overrideDraw a line through all points.Definition TGX11.cxx:624; TGX11::RemovePixmapvoid RemovePixmap(Drawable *pix)Remove the pixmap pix.Definition TGX11.cxx:1472; TGX11::SetClipRegionvoid SetClipRegion(Int_t wid, Int_t x, Int_t y, UInt_t w, UInt_t h) overrideSet clipping region for the window wid.Definition TGX11.cxx:2020; TGX11::AddPixmapInt_t AddPixmap(ULong_t pixid, UInt_t w, UInt_t h) overrideRegister pixmap created by gVirtualGL.Definition TGX11.cxx:3645; TGX11::SetRGBvoid SetRGB(Int_t cindex, Float_t r, Float_t g, Float_t b) overrideSet color intensities for given color index.Definition TGX11.cxx:3035; TGX11::FindUsableVisualvoid FindUsableVisual(RXVisualInfo *vlist, Int_t nitems)Check if visual is usable, if so set fVisual, fDepth, fColormap, fBlackPixel and fWhitePixel.Definition TGX11.cxx:848; TGX11::GetCharacterUpvoid GetCharacterUp(Float_t &chupx, Float_t &chupy) overrideReturn character up vector.Definition TGX11.cxx:899; TGX11::SetDoubleBuffervoid SetDoubleBuffer(Int_t wid, Int_t mode) overrideSet the double buffer on/off on window wid.Definition TGX11.cxx:2091; TGX11::fMaxNumberOfWindowsInt_t fMaxNumberOfWindowsMaximum number of windows.Definition TGX11.h:83; TGX11::SetMarkerStylevoid SetMarkerStyle(Style_t markerstyle) overrideSet marker style.Definition TGX11.cxx:2435; TGX11::GetRGBvoid GetRGB(Int_t index, Float_t &r, Float_t &g, Float_t &b) overrideGet rgb values for color ""index"".Definition TGX11.cxx:1027; TGX11::ImgPickPalettevoid ImgPickPalette(RXImage *image, Int_t &ncol, Int_t *&R, Int_t *&G, Int_t *&B)Returns in R G B the ncol colors of the palette used by the image.Definition TGX11.cxx:3331; TGX11::FindColorInt_t FindColor(ULong_t pixel, ULong_t",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
https://root.cern/doc/master/TH1F_8h.html:175,Integrability,depend,dependency,175,". ROOT: hist/hist/inc/TH1F.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TH1F.h File Reference. #include ""TH1.h"". Include dependency graph for TH1F.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. histhistincTH1F.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TH1F_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1F_8h.html
https://root.cern/doc/master/TH1I_8h.html:175,Integrability,depend,dependency,175,". ROOT: hist/hist/inc/TH1I.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TH1I.h File Reference. #include ""TH1.h"". Include dependency graph for TH1I.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. histhistincTH1I.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TH1I_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1I_8h.html
https://root.cern/doc/master/TH1_8cxx.html:1176,Integrability,depend,dependency,1176,"ence. #include <array>; #include <cctype>; #include <climits>; #include <cmath>; #include <cstdio>; #include <cstdlib>; #include <cstring>; #include <iostream>; #include <sstream>; #include <fstream>; #include ""TROOT.h""; #include ""TBuffer.h""; #include ""TEnv.h""; #include ""TClass.h""; #include ""TMath.h""; #include ""THashList.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TH3.h""; #include ""TF2.h""; #include ""TF3.h""; #include ""TPluginManager.h""; #include ""TVirtualPad.h""; #include ""TRandom.h""; #include ""TVirtualFitter.h""; #include ""THLimitsFinder.h""; #include ""TProfile.h""; #include ""TStyle.h""; #include ""TVectorF.h""; #include ""TVectorD.h""; #include ""TBrowser.h""; #include ""TError.h""; #include ""TVirtualHistPainter.h""; #include ""TVirtualFFT.h""; #include ""TVirtualPaveStats.h""; #include ""HFitInterface.h""; #include ""Fit/DataRange.h""; #include ""Fit/BinData.h""; #include ""Math/GoFTest.h""; #include ""Math/MinimizerOptions.h""; #include ""Math/QuantFuncMathCore.h""; #include ""TH1Merger.h"". Include dependency graph for TH1.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Functions; static Bool_t AlmostEqual (Double_t a, Double_t b, Double_t epsilon=0.00000001);  Test if two double are almost equal. ;  ; static Bool_t AlmostInteger (Double_t a, Double_t epsilon=0.00000001);  Test if a double is almost an integer. ;  ; void H1InitExpo ();  Compute Initial values of parameters for an exponential. ;  ; void H1InitGaus ();  Compute Initial values of parameters for a gaussian. ;  ; void H1InitPolynom ();  Compute Initial values of parameters for a polynom. ;  ; void H1LeastSquareFit (Int_t n, Int_t m, Double_t *a);  Least squares lpolynomial fitting without weights. ;  ; void H1LeastSquareLinearFit (Int_t ndata, Double_t &a0, Double_t &a1, Int_t &ifail);  Least sq",MatchSource.WIKI,doc/master/TH1_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx.html
https://root.cern/doc/master/TH1_8cxx.html:2355,Integrability,rout,routine,2355,"Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Functions; static Bool_t AlmostEqual (Double_t a, Double_t b, Double_t epsilon=0.00000001);  Test if two double are almost equal. ;  ; static Bool_t AlmostInteger (Double_t a, Double_t epsilon=0.00000001);  Test if a double is almost an integer. ;  ; void H1InitExpo ();  Compute Initial values of parameters for an exponential. ;  ; void H1InitGaus ();  Compute Initial values of parameters for a gaussian. ;  ; void H1InitPolynom ();  Compute Initial values of parameters for a polynom. ;  ; void H1LeastSquareFit (Int_t n, Int_t m, Double_t *a);  Least squares lpolynomial fitting without weights. ;  ; void H1LeastSquareLinearFit (Int_t ndata, Double_t &a0, Double_t &a1, Int_t &ifail);  Least square linear fit without weights. ;  ; void H1LeastSquareSeqnd (Int_t n, Double_t *a, Int_t idim, Int_t &ifail, Int_t k, Double_t *b);  Extracted from CERN Program library routine DSEQN. ;  ; static bool IsEquidistantBinning (const TAxis &axis);  Test if the binning is equidistant. ;  ; TH1C operator* (const TH1C &h1, const TH1C &h2);  Operator *. ;  ; TH1D operator* (const TH1D &h1, const TH1D &h2);  Operator *. ;  ; TH1F operator* (const TH1F &h1, const TH1F &h2);  Operator *. ;  ; TH1I operator* (const TH1I &h1, const TH1I &h2);  Operator *. ;  ; TH1L operator* (const TH1L &h1, const TH1L &h2);  Operator *. ;  ; TH1S operator* (const TH1S &h1, const TH1S &h2);  Operator *. ;  ; TH1C operator* (Double_t c1, const TH1C &h1);  Operator *. ;  ; TH1D operator* (Double_t c1, const TH1D &h1);  Operator *. ;  ; TH1F operator* (Double_t c1, const TH1F &h1);  Operator *. ;  ; TH1I operator* (Double_t c1, const TH1I &h1);  Operator *. ;  ; TH1L operator* (Double_t c1, const TH1L &h1);  Operator *. ;  ; TH1S operator* (Double_t c1, const TH1S &h1);  Operator *. ;  ; TH1C operator+ (const TH1C &h1, cons",MatchSource.WIKI,doc/master/TH1_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx.html
https://root.cern/doc/master/TH1_8cxx.html:5792,Integrability,rout,routine,5792,"0001 . ). inlinestatic . Test if two double are almost equal. ; Definition at line 5861 of file TH1.cxx. ◆ AlmostInteger(). static Bool_t AlmostInteger ; (; Double_t ; a, . Double_t ; epsilon = 0.00000001 . ). inlinestatic . Test if a double is almost an integer. ; Definition at line 5869 of file TH1.cxx. ◆ H1InitExpo(). void H1InitExpo ; (; ). Compute Initial values of parameters for an exponential. ; Definition at line 4717 of file TH1.cxx. ◆ H1InitGaus(). void H1InitGaus ; (; ). Compute Initial values of parameters for a gaussian. ; Definition at line 4661 of file TH1.cxx. ◆ H1InitPolynom(). void H1InitPolynom ; (; ). Compute Initial values of parameters for a polynom. ; Definition at line 4737 of file TH1.cxx. ◆ H1LeastSquareFit(). void H1LeastSquareFit ; (; Int_t ; n, . Int_t ; m, . Double_t * ; a . ). Least squares lpolynomial fitting without weights. ; Parameters. [in]nnumber of points to fit ; [in]mnumber of parameters ; [in]aarray of parameters. based on CERNLIB routine LSQ: Translated to C++ by Rene Brun (E.Keil. revised by B.Schorr, 23.10.1981.) ; Definition at line 4767 of file TH1.cxx. ◆ H1LeastSquareLinearFit(). void H1LeastSquareLinearFit ; (; Int_t ; ndata, . Double_t & ; a0, . Double_t & ; a1, . Int_t & ; ifail . ). Least square linear fit without weights. ; extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun (added to LSQ by B. Schorr, 15.02.1982.) ; Definition at line 4826 of file TH1.cxx. ◆ H1LeastSquareSeqnd(). void H1LeastSquareSeqnd ; (; Int_t ; n, . Double_t * ; a, . Int_t ; idim, . Int_t & ; ifail, . Int_t ; k, . Double_t * ; b . ). Extracted from CERN Program library routine DSEQN. ; Translated to C++ by Rene Brun ; Definition at line 4872 of file TH1.cxx. ◆ IsEquidistantBinning(). static bool IsEquidistantBinning ; (; const TAxis & ; axis). inlinestatic . Test if the binning is equidistant. ; Definition at line 5878 of file TH1.cxx. ◆ operator*() [1/12]. TH1C operator* ; (; const TH1C & ; h1, . const TH1C & ; h2 . ). Operator *. ; D",MatchSource.WIKI,doc/master/TH1_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx.html
https://root.cern/doc/master/TH1_8cxx.html:6434,Integrability,rout,routine,6434,"ynom ; (; ). Compute Initial values of parameters for a polynom. ; Definition at line 4737 of file TH1.cxx. ◆ H1LeastSquareFit(). void H1LeastSquareFit ; (; Int_t ; n, . Int_t ; m, . Double_t * ; a . ). Least squares lpolynomial fitting without weights. ; Parameters. [in]nnumber of points to fit ; [in]mnumber of parameters ; [in]aarray of parameters. based on CERNLIB routine LSQ: Translated to C++ by Rene Brun (E.Keil. revised by B.Schorr, 23.10.1981.) ; Definition at line 4767 of file TH1.cxx. ◆ H1LeastSquareLinearFit(). void H1LeastSquareLinearFit ; (; Int_t ; ndata, . Double_t & ; a0, . Double_t & ; a1, . Int_t & ; ifail . ). Least square linear fit without weights. ; extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun (added to LSQ by B. Schorr, 15.02.1982.) ; Definition at line 4826 of file TH1.cxx. ◆ H1LeastSquareSeqnd(). void H1LeastSquareSeqnd ; (; Int_t ; n, . Double_t * ; a, . Int_t ; idim, . Int_t & ; ifail, . Int_t ; k, . Double_t * ; b . ). Extracted from CERN Program library routine DSEQN. ; Translated to C++ by Rene Brun ; Definition at line 4872 of file TH1.cxx. ◆ IsEquidistantBinning(). static bool IsEquidistantBinning ; (; const TAxis & ; axis). inlinestatic . Test if the binning is equidistant. ; Definition at line 5878 of file TH1.cxx. ◆ operator*() [1/12]. TH1C operator* ; (; const TH1C & ; h1, . const TH1C & ; h2 . ). Operator *. ; Definition at line 9630 of file TH1.cxx. ◆ operator*() [2/12]. TH1D operator* ; (; const TH1D & ; h1, . const TH1D & ; h2 . ). Operator *. ; Definition at line 10555 of file TH1.cxx. ◆ operator*() [3/12]. TH1F operator* ; (; const TH1F & ; h1, . const TH1F & ; h2 . ). Operator *. ; Definition at line 10373 of file TH1.cxx. ◆ operator*() [4/12]. TH1I operator* ; (; const TH1I & ; h1, . const TH1I & ; h2 . ). Operator *. ; Definition at line 10004 of file TH1.cxx. ◆ operator*() [5/12]. TH1L operator* ; (; const TH1L & ; h1, . const TH1L & ; h2 . ). Operator *. ; Definition at line 10192 of file TH1.cxx. ◆ operat",MatchSource.WIKI,doc/master/TH1_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx.html
https://root.cern/doc/master/TH1_8cxx_source.html:2933,Availability,error,errors,2933,"\brief 1-D histogram with a double per channel (see TH1 documentation); 72@}; 73*/; 74 ; 75/** \class TH1; 76 \ingroup Histograms; 77TH1 is the base class of all histogram classes in %ROOT.; 78 ; 79It provides the common interface for operations such as binning, filling, drawing, which; 80will be detailed below.; 81 ; 82-# [Creating histograms](\ref creating-histograms); 83 - [Labelling axes](\ref labelling-axis); 84-# [Binning](\ref binning); 85 - [Fix or variable bin size](\ref fix-var); 86 - [Convention for numbering bins](\ref convention); 87 - [Alphanumeric Bin Labels](\ref alpha); 88 - [Histograms with automatic bins](\ref auto-bin); 89 - [Rebinning](\ref rebinning); 90-# [Filling histograms](\ref filling-histograms); 91 - [Associated errors](\ref associated-errors); 92 - [Associated functions](\ref associated-functions); 93 - [Projections of histograms](\ref prof-hist); 94 - [Random Numbers and histograms](\ref random-numbers); 95 - [Making a copy of a histogram](\ref making-a-copy); 96 - [Normalizing histograms](\ref normalizing); 97-# [Drawing histograms](\ref drawing-histograms); 98 - [Setting Drawing histogram contour levels (2-D hists only)](\ref cont-level); 99 - [Setting histogram graphics attributes](\ref graph-att); 100 - [Customising how axes are drawn](\ref axis-drawing); 101-# [Fitting histograms](\ref fitting-histograms); 102-# [Saving/reading histograms to/from a ROOT file](\ref saving-histograms); 103-# [Operations on histograms](\ref operations-on-histograms); 104-# [Miscellaneous operations](\ref misc); 105 ; 106ROOT supports the following histogram types:; 107 ; 108 - 1-D histograms:; 109 - TH1C : histograms with one byte per channel. Maximum bin content = 127; 110 - TH1S : histograms with one short per channel. Maximum bin content = 32767; 111 - TH1I : histograms with one int per channel. Maximum bin content = INT_MAX (\ref intmax ""*""); 112 - TH1L : histograms with one long64 per channel. Maximum bin content = LLONG_MAX (\ref llongmax ""**"")",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:2957,Availability,error,errors,2957,"\brief 1-D histogram with a double per channel (see TH1 documentation); 72@}; 73*/; 74 ; 75/** \class TH1; 76 \ingroup Histograms; 77TH1 is the base class of all histogram classes in %ROOT.; 78 ; 79It provides the common interface for operations such as binning, filling, drawing, which; 80will be detailed below.; 81 ; 82-# [Creating histograms](\ref creating-histograms); 83 - [Labelling axes](\ref labelling-axis); 84-# [Binning](\ref binning); 85 - [Fix or variable bin size](\ref fix-var); 86 - [Convention for numbering bins](\ref convention); 87 - [Alphanumeric Bin Labels](\ref alpha); 88 - [Histograms with automatic bins](\ref auto-bin); 89 - [Rebinning](\ref rebinning); 90-# [Filling histograms](\ref filling-histograms); 91 - [Associated errors](\ref associated-errors); 92 - [Associated functions](\ref associated-functions); 93 - [Projections of histograms](\ref prof-hist); 94 - [Random Numbers and histograms](\ref random-numbers); 95 - [Making a copy of a histogram](\ref making-a-copy); 96 - [Normalizing histograms](\ref normalizing); 97-# [Drawing histograms](\ref drawing-histograms); 98 - [Setting Drawing histogram contour levels (2-D hists only)](\ref cont-level); 99 - [Setting histogram graphics attributes](\ref graph-att); 100 - [Customising how axes are drawn](\ref axis-drawing); 101-# [Fitting histograms](\ref fitting-histograms); 102-# [Saving/reading histograms to/from a ROOT file](\ref saving-histograms); 103-# [Operations on histograms](\ref operations-on-histograms); 104-# [Miscellaneous operations](\ref misc); 105 ; 106ROOT supports the following histogram types:; 107 ; 108 - 1-D histograms:; 109 - TH1C : histograms with one byte per channel. Maximum bin content = 127; 110 - TH1S : histograms with one short per channel. Maximum bin content = 32767; 111 - TH1I : histograms with one int per channel. Maximum bin content = INT_MAX (\ref intmax ""*""); 112 - TH1L : histograms with one long64 per channel. Maximum bin content = LLONG_MAX (\ref llongmax ""**"")",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:10924,Availability,error,error,10924," contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; 220 To access the axis parameters, use:; 221~~~ {.cpp}; 222 TAxis *xaxis = h->GetXaxis(); etc.; 223 Double_t binCenter = xaxis->GetBinCenter(bin), etc.; 224~~~; 225 See class TAxis for a description of all the access functions.; 226 The axis range is always stored internally in double precision.; 227 ; 228\anchor convention; 229### Convention for numbering bins; 230 ; 231 For all histogram types: nbins, xlow, xup; 232~~~ {.cpp}; 233 bin = 0; underflow bin; 234 bin = 1; first bin with low-edge xlow INCLUDED; 235 bin = nbins; last bin with upper-edge xup EXCLUDED; 236 bin = nbins+1; overflow bin; 237~~~; 238 In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; 239 For example, assuming a 3-D histogram with (binx, biny, binz), the function; 240~~~ {.cpp}; 241 Int_t gbin = h->GetBin(binx, biny, binz);; 242~~~; 243 returns a global/linearized gbin number. This global gbin is useful; 244 to access the bin content/error information independently of the dimension.; 245 Note that to access the information other than bin content and errors; 246 one should use the TAxis object directly with e.g.:; 247~~~ {.cpp}; 248 Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);; 249~~~; 250 returns the center along z of bin number 27 (not the global bin); 251 in the 3-D histogram h3.; 252 ; 253\anchor alpha; 254### Alphanumeric Bin Labels; 255 ; 256 By default, a histogram axis is drawn with its numeric bin labels.; 257 One can specify alphanumeric labels instead with:; 258 ; 259 - call TAxis::SetBinLabel(bin, label);; 260 This can always be done before or after filling.; 261 When the histogram is drawn, bin labels will be automatically drawn.; 262 See examples labels1.C and labels2.C; 263 - call to a Fill function with one of the arguments being a string, e.g.; 264~~~ {.cpp}; 265 hist1->Fill(somename, weight);; 266 hist2->Fill(x, somename, weight);; 267 hist2->Fill(somename, y, weight);; 268 hist2->Fill",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:11042,Availability,error,errors,11042,"cpp}; 222 TAxis *xaxis = h->GetXaxis(); etc.; 223 Double_t binCenter = xaxis->GetBinCenter(bin), etc.; 224~~~; 225 See class TAxis for a description of all the access functions.; 226 The axis range is always stored internally in double precision.; 227 ; 228\anchor convention; 229### Convention for numbering bins; 230 ; 231 For all histogram types: nbins, xlow, xup; 232~~~ {.cpp}; 233 bin = 0; underflow bin; 234 bin = 1; first bin with low-edge xlow INCLUDED; 235 bin = nbins; last bin with upper-edge xup EXCLUDED; 236 bin = nbins+1; overflow bin; 237~~~; 238 In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; 239 For example, assuming a 3-D histogram with (binx, biny, binz), the function; 240~~~ {.cpp}; 241 Int_t gbin = h->GetBin(binx, biny, binz);; 242~~~; 243 returns a global/linearized gbin number. This global gbin is useful; 244 to access the bin content/error information independently of the dimension.; 245 Note that to access the information other than bin content and errors; 246 one should use the TAxis object directly with e.g.:; 247~~~ {.cpp}; 248 Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);; 249~~~; 250 returns the center along z of bin number 27 (not the global bin); 251 in the 3-D histogram h3.; 252 ; 253\anchor alpha; 254### Alphanumeric Bin Labels; 255 ; 256 By default, a histogram axis is drawn with its numeric bin labels.; 257 One can specify alphanumeric labels instead with:; 258 ; 259 - call TAxis::SetBinLabel(bin, label);; 260 This can always be done before or after filling.; 261 When the histogram is drawn, bin labels will be automatically drawn.; 262 See examples labels1.C and labels2.C; 263 - call to a Fill function with one of the arguments being a string, e.g.; 264~~~ {.cpp}; 265 hist1->Fill(somename, weight);; 266 hist2->Fill(x, somename, weight);; 267 hist2->Fill(somename, y, weight);; 268 hist2->Fill(somenamex, somenamey, weight);; 269~~~; 270 See examples hlabels1.C and hlabels2.C; 271 - via TTree::Draw. see for exa",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:13023,Availability,down,down,13023,"ename, weight);; 266 hist2->Fill(x, somename, weight);; 267 hist2->Fill(somename, y, weight);; 268 hist2->Fill(somenamex, somenamey, weight);; 269~~~; 270 See examples hlabels1.C and hlabels2.C; 271 - via TTree::Draw. see for example cernstaff.C; 272~~~ {.cpp}; 273 tree.Draw(""Nation::Division"");; 274~~~; 275 where ""Nation"" and ""Division"" are two branches of a Tree.; 276 ; 277When using the options 2 or 3 above, the labels are automatically; 278 added to the list (THashList) of labels for a given axis.; 279 By default, an axis is drawn with the order of bins corresponding; 280 to the filling sequence. It is possible to reorder the axis; 281 ; 282 - alphabetically; 283 - by increasing or decreasing values; 284 ; 285 The reordering can be triggered via the TAxis context menu by selecting; 286 the menu item ""LabelsOption"" or by calling directly; 287 TH1::LabelsOption(option, axis) where; 288 ; 289 - axis may be ""X"", ""Y"" or ""Z""; 290 - option may be:; 291 - ""a"" sort by alphabetic order; 292 - "">"" sort by decreasing values; 293 - ""<"" sort by increasing values; 294 - ""h"" draw labels horizontal; 295 - ""v"" draw labels vertical; 296 - ""u"" draw labels up (end of label right adjusted); 297 - ""d"" draw labels down (start of label left adjusted); 298 ; 299 When using the option 2 above, new labels are added by doubling the current; 300 number of bins in case one label does not exist yet.; 301 When the Filling is terminated, it is possible to trim the number; 302 of bins to match the number of active labels by calling; 303~~~ {.cpp}; 304 TH1::LabelsDeflate(axis) with axis = ""X"", ""Y"" or ""Z""; 305~~~; 306 This operation is automatic when using TTree::Draw.; 307 Once bin labels have been created, they become persistent if the histogram; 308 is written to a file or when generating the C++ code via SavePrimitive.; 309 ; 310\anchor auto-bin; 311### Histograms with automatic bins; 312 ; 313 When a histogram is created with an axis lower limit greater or equal; 314 to its upper limit, the Set",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:14328,Availability,error,errors,14328,"304 TH1::LabelsDeflate(axis) with axis = ""X"", ""Y"" or ""Z""; 305~~~; 306 This operation is automatic when using TTree::Draw.; 307 Once bin labels have been created, they become persistent if the histogram; 308 is written to a file or when generating the C++ code via SavePrimitive.; 309 ; 310\anchor auto-bin; 311### Histograms with automatic bins; 312 ; 313 When a histogram is created with an axis lower limit greater or equal; 314 to its upper limit, the SetBuffer is automatically called with an; 315 argument fBufferSize equal to fgBufferSize (default value=1000).; 316 fgBufferSize may be reset via the static function TH1::SetDefaultBufferSize.; 317 The axis limits will be automatically computed when the buffer will; 318 be full or when the function BufferEmpty is called.; 319 ; 320\anchor rebinning; 321### Rebinning; 322 ; 323 At any time, a histogram can be rebinned via TH1::Rebin. This function; 324 returns a new histogram with the rebinned contents.; 325 If bin errors were stored, they are recomputed during the rebinning.; 326 ; 327 ; 328\anchor filling-histograms; 329## Filling histograms; 330 ; 331 A histogram is typically filled with statements like:; 332~~~ {.cpp}; 333 h1->Fill(x);; 334 h1->Fill(x, w); //fill with weight; 335 h2->Fill(x, y); 336 h2->Fill(x, y, w); 337 h3->Fill(x, y, z); 338 h3->Fill(x, y, z, w); 339~~~; 340 or via one of the Fill functions accepting names described above.; 341 The Fill functions compute the bin number corresponding to the given; 342 x, y or z argument and increment this bin by the given weight.; 343 The Fill functions return the bin number for 1-D histograms or global; 344 bin number for 2-D and 3-D histograms.; 345 If TH1::Sumw2 has been called before filling, the sum of squares of; 346 weights is also stored.; 347 One can also increment directly a bin number via TH1::AddBinContent; 348 or replace the existing content via TH1::SetBinContent. Passing an; 349 out-of-range bin to TH1::AddBinContent leads to undefined behavior.; 35",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:16586,Availability,error,errors,16586,"58 h->SetCanExtend(TH1::kAllAxes);; 359~~~; 360 then, the Fill Function will automatically extend the axis range to; 361 accomodate the new value specified in the Fill argument. The method; 362 used is to double the bin size until the new value fits in the range,; 363 merging bins two by two. This automatic binning options is extensively; 364 used by the TTree::Draw function when histogramming Tree variables; 365 with an unknown range.; 366 This automatic binning option is supported for 1-D, 2-D and 3-D histograms.; 367 ; 368 During filling, some statistics parameters are incremented to compute; 369 the mean value and Root Mean Square with the maximum precision.; 370 ; 371 In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; 372 a check is made that the bin contents do not exceed the maximum positive; 373 capacity (127 or 32767). Histograms of all types may have positive; 374 or/and negative bin contents.; 375 ; 376\anchor associated-errors; 377### Associated errors; 378 By default, for each bin, the sum of weights is computed at fill time.; 379 One can also call TH1::Sumw2 to force the storage and computation; 380 of the sum of the square of weights per bin.; 381 If Sumw2 has been called, the error per bin is computed as the; 382 sqrt(sum of squares of weights), otherwise the error is set equal; 383 to the sqrt(bin content).; 384 To return the error for a given bin number, do:; 385~~~ {.cpp}; 386 Double_t error = h->GetBinError(bin);; 387~~~; 388 ; 389\anchor associated-functions; 390### Associated functions; 391 One or more object (typically a TF1*) can be added to the list; 392 of functions (fFunctions) associated to each histogram.; 393 When TH1::Fit is invoked, the fitted function is added to this list.; 394 Given a histogram h, one can retrieve an associated function; 395 with:; 396~~~ {.cpp}; 397 TF1 *myfunc = h->GetFunction(""myfunc"");; 398~~~; 399 ; 400 ; 401\anchor operations-on-histograms; 402## Operations on histograms; 403 ; 404 Many types o",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:16612,Availability,error,errors,16612,"58 h->SetCanExtend(TH1::kAllAxes);; 359~~~; 360 then, the Fill Function will automatically extend the axis range to; 361 accomodate the new value specified in the Fill argument. The method; 362 used is to double the bin size until the new value fits in the range,; 363 merging bins two by two. This automatic binning options is extensively; 364 used by the TTree::Draw function when histogramming Tree variables; 365 with an unknown range.; 366 This automatic binning option is supported for 1-D, 2-D and 3-D histograms.; 367 ; 368 During filling, some statistics parameters are incremented to compute; 369 the mean value and Root Mean Square with the maximum precision.; 370 ; 371 In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; 372 a check is made that the bin contents do not exceed the maximum positive; 373 capacity (127 or 32767). Histograms of all types may have positive; 374 or/and negative bin contents.; 375 ; 376\anchor associated-errors; 377### Associated errors; 378 By default, for each bin, the sum of weights is computed at fill time.; 379 One can also call TH1::Sumw2 to force the storage and computation; 380 of the sum of the square of weights per bin.; 381 If Sumw2 has been called, the error per bin is computed as the; 382 sqrt(sum of squares of weights), otherwise the error is set equal; 383 to the sqrt(bin content).; 384 To return the error for a given bin number, do:; 385~~~ {.cpp}; 386 Double_t error = h->GetBinError(bin);; 387~~~; 388 ; 389\anchor associated-functions; 390### Associated functions; 391 One or more object (typically a TF1*) can be added to the list; 392 of functions (fFunctions) associated to each histogram.; 393 When TH1::Fit is invoked, the fitted function is added to this list.; 394 Given a histogram h, one can retrieve an associated function; 395 with:; 396~~~ {.cpp}; 397 TF1 *myfunc = h->GetFunction(""myfunc"");; 398~~~; 399 ; 400 ; 401\anchor operations-on-histograms; 402## Operations on histograms; 403 ; 404 Many types o",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:16851,Availability,error,error,16851,"g bins two by two. This automatic binning options is extensively; 364 used by the TTree::Draw function when histogramming Tree variables; 365 with an unknown range.; 366 This automatic binning option is supported for 1-D, 2-D and 3-D histograms.; 367 ; 368 During filling, some statistics parameters are incremented to compute; 369 the mean value and Root Mean Square with the maximum precision.; 370 ; 371 In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; 372 a check is made that the bin contents do not exceed the maximum positive; 373 capacity (127 or 32767). Histograms of all types may have positive; 374 or/and negative bin contents.; 375 ; 376\anchor associated-errors; 377### Associated errors; 378 By default, for each bin, the sum of weights is computed at fill time.; 379 One can also call TH1::Sumw2 to force the storage and computation; 380 of the sum of the square of weights per bin.; 381 If Sumw2 has been called, the error per bin is computed as the; 382 sqrt(sum of squares of weights), otherwise the error is set equal; 383 to the sqrt(bin content).; 384 To return the error for a given bin number, do:; 385~~~ {.cpp}; 386 Double_t error = h->GetBinError(bin);; 387~~~; 388 ; 389\anchor associated-functions; 390### Associated functions; 391 One or more object (typically a TF1*) can be added to the list; 392 of functions (fFunctions) associated to each histogram.; 393 When TH1::Fit is invoked, the fitted function is added to this list.; 394 Given a histogram h, one can retrieve an associated function; 395 with:; 396~~~ {.cpp}; 397 TF1 *myfunc = h->GetFunction(""myfunc"");; 398~~~; 399 ; 400 ; 401\anchor operations-on-histograms; 402## Operations on histograms; 403 ; 404 Many types of operations are supported on histograms or between histograms; 405 ; 406 - Addition of a histogram to the current histogram.; 407 - Additions of two histograms with coefficients and storage into the current; 408 histogram.; 409 - Multiplications and Divisions are supported ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:16936,Availability,error,error,16936,"g bins two by two. This automatic binning options is extensively; 364 used by the TTree::Draw function when histogramming Tree variables; 365 with an unknown range.; 366 This automatic binning option is supported for 1-D, 2-D and 3-D histograms.; 367 ; 368 During filling, some statistics parameters are incremented to compute; 369 the mean value and Root Mean Square with the maximum precision.; 370 ; 371 In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; 372 a check is made that the bin contents do not exceed the maximum positive; 373 capacity (127 or 32767). Histograms of all types may have positive; 374 or/and negative bin contents.; 375 ; 376\anchor associated-errors; 377### Associated errors; 378 By default, for each bin, the sum of weights is computed at fill time.; 379 One can also call TH1::Sumw2 to force the storage and computation; 380 of the sum of the square of weights per bin.; 381 If Sumw2 has been called, the error per bin is computed as the; 382 sqrt(sum of squares of weights), otherwise the error is set equal; 383 to the sqrt(bin content).; 384 To return the error for a given bin number, do:; 385~~~ {.cpp}; 386 Double_t error = h->GetBinError(bin);; 387~~~; 388 ; 389\anchor associated-functions; 390### Associated functions; 391 One or more object (typically a TF1*) can be added to the list; 392 of functions (fFunctions) associated to each histogram.; 393 When TH1::Fit is invoked, the fitted function is added to this list.; 394 Given a histogram h, one can retrieve an associated function; 395 with:; 396~~~ {.cpp}; 397 TF1 *myfunc = h->GetFunction(""myfunc"");; 398~~~; 399 ; 400 ; 401\anchor operations-on-histograms; 402## Operations on histograms; 403 ; 404 Many types of operations are supported on histograms or between histograms; 405 ; 406 - Addition of a histogram to the current histogram.; 407 - Additions of two histograms with coefficients and storage into the current; 408 histogram.; 409 - Multiplications and Divisions are supported ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:17005,Availability,error,error,17005,"ming Tree variables; 365 with an unknown range.; 366 This automatic binning option is supported for 1-D, 2-D and 3-D histograms.; 367 ; 368 During filling, some statistics parameters are incremented to compute; 369 the mean value and Root Mean Square with the maximum precision.; 370 ; 371 In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; 372 a check is made that the bin contents do not exceed the maximum positive; 373 capacity (127 or 32767). Histograms of all types may have positive; 374 or/and negative bin contents.; 375 ; 376\anchor associated-errors; 377### Associated errors; 378 By default, for each bin, the sum of weights is computed at fill time.; 379 One can also call TH1::Sumw2 to force the storage and computation; 380 of the sum of the square of weights per bin.; 381 If Sumw2 has been called, the error per bin is computed as the; 382 sqrt(sum of squares of weights), otherwise the error is set equal; 383 to the sqrt(bin content).; 384 To return the error for a given bin number, do:; 385~~~ {.cpp}; 386 Double_t error = h->GetBinError(bin);; 387~~~; 388 ; 389\anchor associated-functions; 390### Associated functions; 391 One or more object (typically a TF1*) can be added to the list; 392 of functions (fFunctions) associated to each histogram.; 393 When TH1::Fit is invoked, the fitted function is added to this list.; 394 Given a histogram h, one can retrieve an associated function; 395 with:; 396~~~ {.cpp}; 397 TF1 *myfunc = h->GetFunction(""myfunc"");; 398~~~; 399 ; 400 ; 401\anchor operations-on-histograms; 402## Operations on histograms; 403 ; 404 Many types of operations are supported on histograms or between histograms; 405 ; 406 - Addition of a histogram to the current histogram.; 407 - Additions of two histograms with coefficients and storage into the current; 408 histogram.; 409 - Multiplications and Divisions are supported in the same way as additions.; 410 - The Add, Divide and Multiply functions also exist to add, divide or multiply; 41",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:17068,Availability,error,error,17068,"me statistics parameters are incremented to compute; 369 the mean value and Root Mean Square with the maximum precision.; 370 ; 371 In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; 372 a check is made that the bin contents do not exceed the maximum positive; 373 capacity (127 or 32767). Histograms of all types may have positive; 374 or/and negative bin contents.; 375 ; 376\anchor associated-errors; 377### Associated errors; 378 By default, for each bin, the sum of weights is computed at fill time.; 379 One can also call TH1::Sumw2 to force the storage and computation; 380 of the sum of the square of weights per bin.; 381 If Sumw2 has been called, the error per bin is computed as the; 382 sqrt(sum of squares of weights), otherwise the error is set equal; 383 to the sqrt(bin content).; 384 To return the error for a given bin number, do:; 385~~~ {.cpp}; 386 Double_t error = h->GetBinError(bin);; 387~~~; 388 ; 389\anchor associated-functions; 390### Associated functions; 391 One or more object (typically a TF1*) can be added to the list; 392 of functions (fFunctions) associated to each histogram.; 393 When TH1::Fit is invoked, the fitted function is added to this list.; 394 Given a histogram h, one can retrieve an associated function; 395 with:; 396~~~ {.cpp}; 397 TF1 *myfunc = h->GetFunction(""myfunc"");; 398~~~; 399 ; 400 ; 401\anchor operations-on-histograms; 402## Operations on histograms; 403 ; 404 Many types of operations are supported on histograms or between histograms; 405 ; 406 - Addition of a histogram to the current histogram.; 407 - Additions of two histograms with coefficients and storage into the current; 408 histogram.; 409 - Multiplications and Divisions are supported in the same way as additions.; 410 - The Add, Divide and Multiply functions also exist to add, divide or multiply; 411 a histogram by a function.; 412 ; 413 If a histogram has associated error bars (TH1::Sumw2 has been called),; 414 the resulting error bars are also computed",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:18087,Availability,error,error,18087,"ociated-functions; 390### Associated functions; 391 One or more object (typically a TF1*) can be added to the list; 392 of functions (fFunctions) associated to each histogram.; 393 When TH1::Fit is invoked, the fitted function is added to this list.; 394 Given a histogram h, one can retrieve an associated function; 395 with:; 396~~~ {.cpp}; 397 TF1 *myfunc = h->GetFunction(""myfunc"");; 398~~~; 399 ; 400 ; 401\anchor operations-on-histograms; 402## Operations on histograms; 403 ; 404 Many types of operations are supported on histograms or between histograms; 405 ; 406 - Addition of a histogram to the current histogram.; 407 - Additions of two histograms with coefficients and storage into the current; 408 histogram.; 409 - Multiplications and Divisions are supported in the same way as additions.; 410 - The Add, Divide and Multiply functions also exist to add, divide or multiply; 411 a histogram by a function.; 412 ; 413 If a histogram has associated error bars (TH1::Sumw2 has been called),; 414 the resulting error bars are also computed assuming independent histograms.; 415 In case of divisions, Binomial errors are also supported.; 416 One can mark a histogram to be an ""average"" histogram by setting its bit kIsAverage via; 417 myhist.SetBit(TH1::kIsAverage);; 418 When adding (see TH1::Add) average histograms, the histograms are averaged and not summed.; 419 ; 420 ; 421\anchor prof-hist; 422### Projections of histograms; 423 ; 424 One can:; 425 ; 426 - make a 1-D projection of a 2-D histogram or Profile; 427 see functions TH2::ProjectionX,Y, TH2::ProfileX,Y, TProfile::ProjectionX; 428 - make a 1-D, 2-D or profile out of a 3-D histogram; 429 see functions TH3::ProjectionZ, TH3::Project3D.; 430 ; 431 One can fit these projections via:; 432~~~ {.cpp}; 433 TH2::FitSlicesX,Y, TH3::FitSlicesZ.; 434~~~; 435 ; 436\anchor random-numbers; 437### Random Numbers and histograms; 438 ; 439 TH1::FillRandom can be used to randomly fill a histogram using; 440 the contents of an existing ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:18147,Availability,error,error,18147,"ociated-functions; 390### Associated functions; 391 One or more object (typically a TF1*) can be added to the list; 392 of functions (fFunctions) associated to each histogram.; 393 When TH1::Fit is invoked, the fitted function is added to this list.; 394 Given a histogram h, one can retrieve an associated function; 395 with:; 396~~~ {.cpp}; 397 TF1 *myfunc = h->GetFunction(""myfunc"");; 398~~~; 399 ; 400 ; 401\anchor operations-on-histograms; 402## Operations on histograms; 403 ; 404 Many types of operations are supported on histograms or between histograms; 405 ; 406 - Addition of a histogram to the current histogram.; 407 - Additions of two histograms with coefficients and storage into the current; 408 histogram.; 409 - Multiplications and Divisions are supported in the same way as additions.; 410 - The Add, Divide and Multiply functions also exist to add, divide or multiply; 411 a histogram by a function.; 412 ; 413 If a histogram has associated error bars (TH1::Sumw2 has been called),; 414 the resulting error bars are also computed assuming independent histograms.; 415 In case of divisions, Binomial errors are also supported.; 416 One can mark a histogram to be an ""average"" histogram by setting its bit kIsAverage via; 417 myhist.SetBit(TH1::kIsAverage);; 418 When adding (see TH1::Add) average histograms, the histograms are averaged and not summed.; 419 ; 420 ; 421\anchor prof-hist; 422### Projections of histograms; 423 ; 424 One can:; 425 ; 426 - make a 1-D projection of a 2-D histogram or Profile; 427 see functions TH2::ProjectionX,Y, TH2::ProfileX,Y, TProfile::ProjectionX; 428 - make a 1-D, 2-D or profile out of a 3-D histogram; 429 see functions TH3::ProjectionZ, TH3::Project3D.; 430 ; 431 One can fit these projections via:; 432~~~ {.cpp}; 433 TH2::FitSlicesX,Y, TH3::FitSlicesZ.; 434~~~; 435 ; 436\anchor random-numbers; 437### Random Numbers and histograms; 438 ; 439 TH1::FillRandom can be used to randomly fill a histogram using; 440 the contents of an existing ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:18245,Availability,error,errors,18245,"t; 392 of functions (fFunctions) associated to each histogram.; 393 When TH1::Fit is invoked, the fitted function is added to this list.; 394 Given a histogram h, one can retrieve an associated function; 395 with:; 396~~~ {.cpp}; 397 TF1 *myfunc = h->GetFunction(""myfunc"");; 398~~~; 399 ; 400 ; 401\anchor operations-on-histograms; 402## Operations on histograms; 403 ; 404 Many types of operations are supported on histograms or between histograms; 405 ; 406 - Addition of a histogram to the current histogram.; 407 - Additions of two histograms with coefficients and storage into the current; 408 histogram.; 409 - Multiplications and Divisions are supported in the same way as additions.; 410 - The Add, Divide and Multiply functions also exist to add, divide or multiply; 411 a histogram by a function.; 412 ; 413 If a histogram has associated error bars (TH1::Sumw2 has been called),; 414 the resulting error bars are also computed assuming independent histograms.; 415 In case of divisions, Binomial errors are also supported.; 416 One can mark a histogram to be an ""average"" histogram by setting its bit kIsAverage via; 417 myhist.SetBit(TH1::kIsAverage);; 418 When adding (see TH1::Add) average histograms, the histograms are averaged and not summed.; 419 ; 420 ; 421\anchor prof-hist; 422### Projections of histograms; 423 ; 424 One can:; 425 ; 426 - make a 1-D projection of a 2-D histogram or Profile; 427 see functions TH2::ProjectionX,Y, TH2::ProfileX,Y, TProfile::ProjectionX; 428 - make a 1-D, 2-D or profile out of a 3-D histogram; 429 see functions TH3::ProjectionZ, TH3::Project3D.; 430 ; 431 One can fit these projections via:; 432~~~ {.cpp}; 433 TH2::FitSlicesX,Y, TH3::FitSlicesZ.; 434~~~; 435 ; 436\anchor random-numbers; 437### Random Numbers and histograms; 438 ; 439 TH1::FillRandom can be used to randomly fill a histogram using; 440 the contents of an existing TF1 function or another; 441 TH1 histogram (for all dimensions).; 442 For example, the following two statements c",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:19827,Availability,error,errors,19827,"unctions TH3::ProjectionZ, TH3::Project3D.; 430 ; 431 One can fit these projections via:; 432~~~ {.cpp}; 433 TH2::FitSlicesX,Y, TH3::FitSlicesZ.; 434~~~; 435 ; 436\anchor random-numbers; 437### Random Numbers and histograms; 438 ; 439 TH1::FillRandom can be used to randomly fill a histogram using; 440 the contents of an existing TF1 function or another; 441 TH1 histogram (for all dimensions).; 442 For example, the following two statements create and fill a histogram; 443 10000 times with a default gaussian distribution of mean 0 and sigma 1:; 444~~~ {.cpp}; 445 TH1F h1(""h1"", ""histo from a gaussian"", 100, -3, 3);; 446 h1.FillRandom(""gaus"", 10000);; 447~~~; 448 TH1::GetRandom can be used to return a random number distributed; 449 according to the contents of a histogram.; 450 ; 451\anchor making-a-copy; 452### Making a copy of a histogram; 453 Like for any other ROOT object derived from TObject, one can use; 454 the Clone() function. This makes an identical copy of the original; 455 histogram including all associated errors and functions, e.g.:; 456~~~ {.cpp}; 457 TH1F *hnew = (TH1F*)h->Clone(""hnew"");; 458~~~; 459 ; 460\anchor normalizing; 461### Normalizing histograms; 462 ; 463 One can scale a histogram such that the bins integral is equal to; 464 the normalization parameter via TH1::Scale(Double_t norm), where norm; 465 is the desired normalization divided by the integral of the histogram.; 466 ; 467 ; 468\anchor drawing-histograms; 469## Drawing histograms; 470 ; 471 Histograms are drawn via the THistPainter class. Each histogram has; 472 a pointer to its own painter (to be usable in a multithreaded program).; 473 Many drawing options are supported.; 474 See THistPainter::Paint() for more details.; 475 ; 476 The same histogram can be drawn with different options in different pads.; 477 When a histogram drawn in a pad is deleted, the histogram is; 478 automatically removed from the pad or pads where it was drawn.; 479 If a histogram is drawn in a pad, then filled a",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:24541,Availability,error,errors,24541,"38 ; 539 The following statements create a ROOT file and store a histogram; 540 on the file. Because TH1 derives from TNamed, the key identifier on; 541 the file is the histogram name:; 542~~~ {.cpp}; 543 TFile f(""histos.root"", ""new"");; 544 TH1F h1(""hgaus"", ""histo from a gaussian"", 100, -3, 3);; 545 h1.FillRandom(""gaus"", 10000);; 546 h1->Write();; 547~~~; 548 To read this histogram in another Root session, do:; 549~~~ {.cpp}; 550 TFile f(""histos.root"");; 551 TH1F *h = (TH1F*)f.Get(""hgaus"");; 552~~~; 553 One can save all histograms in memory to the file by:; 554~~~ {.cpp}; 555 file->Write();; 556~~~; 557 ; 558 ; 559\anchor misc; 560## Miscellaneous operations; 561 ; 562~~~ {.cpp}; 563 TH1::KolmogorovTest(): statistical test of compatibility in shape; 564 between two histograms; 565 TH1::Smooth() smooths the bin contents of a 1-d histogram; 566 TH1::Integral() returns the integral of bin contents in a given bin range; 567 TH1::GetMean(int axis) returns the mean value along axis; 568 TH1::GetStdDev(int axis) returns the sigma distribution along axis; 569 TH1::GetEntries() returns the number of entries; 570 TH1::Reset() resets the bin contents and errors of a histogram; 571~~~; 572 IMPORTANT NOTE: The returned values for GetMean and GetStdDev depend on how the; 573 histogram statistics are calculated. By default, if no range has been set, the; 574 returned values are the (unbinned) ones calculated at fill time. If a range has been; 575 set, however, the values are calculated using the bins in range; THIS IS TRUE EVEN; 576 IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset the range.; 577 To ensure that the returned values are always those of the binned data stored in the; 578 histogram, call TH1::ResetStats. See TH1::GetStats.; 579*/; 580 ; 581TF1 *gF1=nullptr; //left for back compatibility (use TVirtualFitter::GetUserFunc instead); 582 ; 583Int_t TH1::fgBufferSize = 1000;; 584Bool_t TH1::fgAddDirectory = kTRUE;; 585Bool_t TH1::fgDefaultSumw2 = kFALSE;; 5",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:32768,Availability,error,errors,32768,"767 ; 768////////////////////////////////////////////////////////////////////////////////; 769/// Creates histogram basic data structure.; 770 ; 771void TH1::Build(); 772{; 773 fDirectory = nullptr;; 774 fPainter = nullptr;; 775 fIntegral = nullptr;; 776 fEntries = 0;; 777 fNormFactor = 0;; 778 fTsumw = fTsumw2=fTsumwx=fTsumwx2=0;; 779 fMaximum = -1111;; 780 fMinimum = -1111;; 781 fBufferSize = 0;; 782 fBuffer = nullptr;; 783 fBinStatErrOpt = kNormal;; 784 fStatOverflows = EStatOverflows::kNeutral;; 785 fXaxis.SetName(""xaxis"");; 786 fYaxis.SetName(""yaxis"");; 787 fZaxis.SetName(""zaxis"");; 788 fYaxis.Set(1,0.,1.);; 789 fZaxis.Set(1,0.,1.);; 790 fXaxis.SetParent(this);; 791 fYaxis.SetParent(this);; 792 fZaxis.SetParent(this);; 793 ; 794 SetTitle(fTitle.Data());; 795 ; 796 fFunctions = new TList;; 797 ; 798 UseCurrentStyle();; 799 ; 800 if (TH1::AddDirectoryStatus()) {; 801 fDirectory = gDirectory;; 802 if (fDirectory) {; 803 fFunctions->UseRWLock();; 804 fDirectory->Append(this,kTRUE);; 805 }; 806 }; 807}; 808 ; 809////////////////////////////////////////////////////////////////////////////////; 810/// Performs the operation: `this = this + c1*f1`; 811/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 812///; 813/// By default, the function is computed at the centre of the bin.; 814/// if option ""I"" is specified (1-d histogram only), the integral of the; 815/// function in each bin is used instead of the value of the function at; 816/// the centre of the bin.; 817///; 818/// Only bins inside the function range are recomputed.; 819///; 820/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 821/// you should call Sumw2 before making this operation.; 822/// This is particularly important if you fit the histogram after TH1::Add; 823///; 824/// The function return kFALSE if the Add operation failed; 825 ; 826Bool_t TH1::Add(TF1 *f1, Double_t c1, Option_t *option); 827{; 828 if (!f1) {; 829 Error(""Add"",""Attempt to add a non-ex",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:32805,Availability,error,errors,32805,"767 ; 768////////////////////////////////////////////////////////////////////////////////; 769/// Creates histogram basic data structure.; 770 ; 771void TH1::Build(); 772{; 773 fDirectory = nullptr;; 774 fPainter = nullptr;; 775 fIntegral = nullptr;; 776 fEntries = 0;; 777 fNormFactor = 0;; 778 fTsumw = fTsumw2=fTsumwx=fTsumwx2=0;; 779 fMaximum = -1111;; 780 fMinimum = -1111;; 781 fBufferSize = 0;; 782 fBuffer = nullptr;; 783 fBinStatErrOpt = kNormal;; 784 fStatOverflows = EStatOverflows::kNeutral;; 785 fXaxis.SetName(""xaxis"");; 786 fYaxis.SetName(""yaxis"");; 787 fZaxis.SetName(""zaxis"");; 788 fYaxis.Set(1,0.,1.);; 789 fZaxis.Set(1,0.,1.);; 790 fXaxis.SetParent(this);; 791 fYaxis.SetParent(this);; 792 fZaxis.SetParent(this);; 793 ; 794 SetTitle(fTitle.Data());; 795 ; 796 fFunctions = new TList;; 797 ; 798 UseCurrentStyle();; 799 ; 800 if (TH1::AddDirectoryStatus()) {; 801 fDirectory = gDirectory;; 802 if (fDirectory) {; 803 fFunctions->UseRWLock();; 804 fDirectory->Append(this,kTRUE);; 805 }; 806 }; 807}; 808 ; 809////////////////////////////////////////////////////////////////////////////////; 810/// Performs the operation: `this = this + c1*f1`; 811/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 812///; 813/// By default, the function is computed at the centre of the bin.; 814/// if option ""I"" is specified (1-d histogram only), the integral of the; 815/// function in each bin is used instead of the value of the function at; 816/// the centre of the bin.; 817///; 818/// Only bins inside the function range are recomputed.; 819///; 820/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 821/// you should call Sumw2 before making this operation.; 822/// This is particularly important if you fit the histogram after TH1::Add; 823///; 824/// The function return kFALSE if the Add operation failed; 825 ; 826Bool_t TH1::Add(TF1 *f1, Double_t c1, Option_t *option); 827{; 828 if (!f1) {; 829 Error(""Add"",""Attempt to add a non-ex",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:33224,Availability,error,errors,33224," 790 fXaxis.SetParent(this);; 791 fYaxis.SetParent(this);; 792 fZaxis.SetParent(this);; 793 ; 794 SetTitle(fTitle.Data());; 795 ; 796 fFunctions = new TList;; 797 ; 798 UseCurrentStyle();; 799 ; 800 if (TH1::AddDirectoryStatus()) {; 801 fDirectory = gDirectory;; 802 if (fDirectory) {; 803 fFunctions->UseRWLock();; 804 fDirectory->Append(this,kTRUE);; 805 }; 806 }; 807}; 808 ; 809////////////////////////////////////////////////////////////////////////////////; 810/// Performs the operation: `this = this + c1*f1`; 811/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 812///; 813/// By default, the function is computed at the centre of the bin.; 814/// if option ""I"" is specified (1-d histogram only), the integral of the; 815/// function in each bin is used instead of the value of the function at; 816/// the centre of the bin.; 817///; 818/// Only bins inside the function range are recomputed.; 819///; 820/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 821/// you should call Sumw2 before making this operation.; 822/// This is particularly important if you fit the histogram after TH1::Add; 823///; 824/// The function return kFALSE if the Add operation failed; 825 ; 826Bool_t TH1::Add(TF1 *f1, Double_t c1, Option_t *option); 827{; 828 if (!f1) {; 829 Error(""Add"",""Attempt to add a non-existing function"");; 830 return kFALSE;; 831 }; 832 ; 833 TString opt = option;; 834 opt.ToLower();; 835 Bool_t integral = kFALSE;; 836 if (opt.Contains(""i"") && fDimension == 1) integral = kTRUE;; 837 ; 838 Int_t ncellsx = GetNbinsX() + 2; // cells = normal bins + underflow bin + overflow bin; 839 Int_t ncellsy = GetNbinsY() + 2;; 840 Int_t ncellsz = GetNbinsZ() + 2;; 841 if (fDimension < 2) ncellsy = 1;; 842 if (fDimension < 3) ncellsz = 1;; 843 ; 844 // delete buffer if it is there since it will become invalid; 845 if (fBuffer) BufferEmpty(1);; 846 ; 847 // - Add statistics; 848 Double_t s1[10];; 849 for (Int_t i = 0; i < 10; ++i) s1[i] ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:36754,Availability,error,errors,36754,"cu = c1*f1->Integral(fXaxis.GetBinLowEdge(binx), fXaxis.GetBinUpEdge(binx), 0.) / fXaxis.GetBinWidth(binx);; 871 } else {; 872 cu = c1*f1->EvalPar(xx);; 873 }; 874 if (TF1::RejectedPoint()) continue;; 875 AddBinContent(bin,cu);; 876 }; 877 }; 878 }; 879 ; 880 return kTRUE;; 881}; 882 ; 883int TH1::LoggedInconsistency(const char *name, const TH1 *h1, const TH1 *h2, bool useMerge) const; 884{; 885 const auto inconsistency = CheckConsistency(h1, h2);; 886 ; 887 if (inconsistency & kDifferentDimensions) {; 888 if (useMerge); 889 Info(name, ""Histograms have different dimensions - trying to use TH1::Merge"");; 890 else {; 891 Error(name, ""Histograms have different dimensions"");; 892 }; 893 } else if (inconsistency & kDifferentNumberOfBins) {; 894 if (useMerge); 895 Info(name, ""Histograms have different number of bins - trying to use TH1::Merge"");; 896 else {; 897 Error(name, ""Histograms have different number of bins"");; 898 }; 899 } else if (inconsistency & kDifferentAxisLimits) {; 900 if (useMerge); 901 Info(name, ""Histograms have different axis limits - trying to use TH1::Merge"");; 902 else; 903 Warning(name, ""Histograms have different axis limits"");; 904 } else if (inconsistency & kDifferentBinLimits) {; 905 if (useMerge); 906 Info(name, ""Histograms have different bin limits - trying to use TH1::Merge"");; 907 else; 908 Warning(name, ""Histograms have different bin limits"");; 909 } else if (inconsistency & kDifferentLabels) {; 910 // in case of different labels -; 911 if (useMerge); 912 Info(name, ""Histograms have different labels - trying to use TH1::Merge"");; 913 else; 914 Info(name, ""Histograms have different labels"");; 915 }; 916 ; 917 return inconsistency;; 918}; 919 ; 920////////////////////////////////////////////////////////////////////////////////; 921/// Performs the operation: `this = this + c1*h1`; 922/// If errors are defined (see TH1::Sumw2), errors are also recalculated.; 923///; 924/// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; 9",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:36791,Availability,error,errors,36791,"cu = c1*f1->Integral(fXaxis.GetBinLowEdge(binx), fXaxis.GetBinUpEdge(binx), 0.) / fXaxis.GetBinWidth(binx);; 871 } else {; 872 cu = c1*f1->EvalPar(xx);; 873 }; 874 if (TF1::RejectedPoint()) continue;; 875 AddBinContent(bin,cu);; 876 }; 877 }; 878 }; 879 ; 880 return kTRUE;; 881}; 882 ; 883int TH1::LoggedInconsistency(const char *name, const TH1 *h1, const TH1 *h2, bool useMerge) const; 884{; 885 const auto inconsistency = CheckConsistency(h1, h2);; 886 ; 887 if (inconsistency & kDifferentDimensions) {; 888 if (useMerge); 889 Info(name, ""Histograms have different dimensions - trying to use TH1::Merge"");; 890 else {; 891 Error(name, ""Histograms have different dimensions"");; 892 }; 893 } else if (inconsistency & kDifferentNumberOfBins) {; 894 if (useMerge); 895 Info(name, ""Histograms have different number of bins - trying to use TH1::Merge"");; 896 else {; 897 Error(name, ""Histograms have different number of bins"");; 898 }; 899 } else if (inconsistency & kDifferentAxisLimits) {; 900 if (useMerge); 901 Info(name, ""Histograms have different axis limits - trying to use TH1::Merge"");; 902 else; 903 Warning(name, ""Histograms have different axis limits"");; 904 } else if (inconsistency & kDifferentBinLimits) {; 905 if (useMerge); 906 Info(name, ""Histograms have different bin limits - trying to use TH1::Merge"");; 907 else; 908 Warning(name, ""Histograms have different bin limits"");; 909 } else if (inconsistency & kDifferentLabels) {; 910 // in case of different labels -; 911 if (useMerge); 912 Info(name, ""Histograms have different labels - trying to use TH1::Merge"");; 913 else; 914 Info(name, ""Histograms have different labels"");; 915 }; 916 ; 917 return inconsistency;; 918}; 919 ; 920////////////////////////////////////////////////////////////////////////////////; 921/// Performs the operation: `this = this + c1*h1`; 922/// If errors are defined (see TH1::Sumw2), errors are also recalculated.; 923///; 924/// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; 9",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:37634,Availability,error,errors,37634,"9 ; 920////////////////////////////////////////////////////////////////////////////////; 921/// Performs the operation: `this = this + c1*h1`; 922/// If errors are defined (see TH1::Sumw2), errors are also recalculated.; 923///; 924/// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; 925/// if not already set.; 926///; 927/// Note also that adding histogram with labels is not supported, histogram will be; 928/// added merging them by bin number independently of the labels.; 929/// For adding histogram with labels one should use TH1::Merge; 930///; 931/// SPECIAL CASE (Average/Efficiency histograms); 932/// For histograms representing averages or efficiencies, one should compute the average; 933/// of the two histograms and not the sum. One can mark a histogram to be an average; 934/// histogram by setting its bit kIsAverage with; 935/// myhist.SetBit(TH1::kIsAverage);; 936/// Note that the two histograms must have their kIsAverage bit set; 937///; 938/// IMPORTANT NOTE1: If you intend to use the errors of this histogram later; 939/// you should call Sumw2 before making this operation.; 940/// This is particularly important if you fit the histogram after TH1::Add; 941///; 942/// IMPORTANT NOTE2: if h1 has a normalisation factor, the normalisation factor; 943/// is used , ie this = this + c1*factor*h1; 944/// Use the other TH1::Add function if you do not want this feature; 945///; 946/// IMPORTANT NOTE3: You should be careful about the statistics of the; 947/// returned histogram, whose statistics may be binned or unbinned,; 948/// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; 949/// and whether TH1::ResetStats has been called on either this or h1.; 950/// See TH1::GetStats.; 951///; 952/// The function return kFALSE if the Add operation failed; 953 ; 954Bool_t TH1::Add(const TH1 *h1, Double_t c1); 955{; 956 if (!h1) {; 957 Error(""Add"",""Attempt to add a non-existing histogram"");; 958 return kFALSE;; 959 }; 960 ; 961 // d",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:40844,Availability,error,errors,40844,"e_t s2[kNstat] = {0};; 994 if (!resetStats) {; 995 // need to initialize to zero s1 and s2 since; 996 // GetStats fills only used elements depending on dimension and type; 997 GetStats(s1);; 998 h1->GetStats(s2);; 999 }; 1000 ; 1001 SetMinimum();; 1002 SetMaximum();; 1003 ; 1004 // - Loop on bins (including underflows/overflows); 1005 Double_t factor = 1;; 1006 if (h1->GetNormFactor() != 0) factor = h1->GetNormFactor()/h1->GetSumOfWeights();; 1007 Double_t c1sq = c1 * c1;; 1008 Double_t factsq = factor * factor;; 1009 ; 1010 for (Int_t bin = 0; bin < fNcells; ++bin) {; 1011 //special case where histograms have the kIsAverage bit set; 1012 if (this->TestBit(kIsAverage) && h1->TestBit(kIsAverage)) {; 1013 Double_t y1 = h1->RetrieveBinContent(bin);; 1014 Double_t y2 = this->RetrieveBinContent(bin);; 1015 Double_t e1sq = h1->GetBinErrorSqUnchecked(bin);; 1016 Double_t e2sq = this->GetBinErrorSqUnchecked(bin);; 1017 Double_t w1 = 1., w2 = 1.;; 1018 ; 1019 // consider all special cases when bin errors are zero; 1020 // see http://root-forum.cern.ch/viewtopic.php?f=3&t=13299; 1021 if (e1sq) w1 = 1. / e1sq;; 1022 else if (h1->fSumw2.fN) {; 1023 w1 = 1.E200; // use an arbitrary huge value; 1024 if (y1 == 0) {; 1025 // use an estimated error from the global histogram scale; 1026 double sf = (s2[0] != 0) ? s2[1]/s2[0] : 1;; 1027 w1 = 1./(sf*sf);; 1028 }; 1029 }; 1030 if (e2sq) w2 = 1. / e2sq;; 1031 else if (fSumw2.fN) {; 1032 w2 = 1.E200; // use an arbitrary huge value; 1033 if (y2 == 0) {; 1034 // use an estimated error from the global histogram scale; 1035 double sf = (s1[0] != 0) ? s1[1]/s1[0] : 1;; 1036 w2 = 1./(sf*sf);; 1037 }; 1038 }; 1039 ; 1040 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1041 UpdateBinContent(bin, y);; 1042 if (fSumw2.fN) {; 1043 double err2 = 1./(w1 + w2);; 1044 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1045 fSumw2.fArray[bin] = err2;; 1046 }; 1047 } else { // normal case of addition between histograms; 1048 AddBinConten",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:41086,Availability,error,error,41086,"etMaximum();; 1003 ; 1004 // - Loop on bins (including underflows/overflows); 1005 Double_t factor = 1;; 1006 if (h1->GetNormFactor() != 0) factor = h1->GetNormFactor()/h1->GetSumOfWeights();; 1007 Double_t c1sq = c1 * c1;; 1008 Double_t factsq = factor * factor;; 1009 ; 1010 for (Int_t bin = 0; bin < fNcells; ++bin) {; 1011 //special case where histograms have the kIsAverage bit set; 1012 if (this->TestBit(kIsAverage) && h1->TestBit(kIsAverage)) {; 1013 Double_t y1 = h1->RetrieveBinContent(bin);; 1014 Double_t y2 = this->RetrieveBinContent(bin);; 1015 Double_t e1sq = h1->GetBinErrorSqUnchecked(bin);; 1016 Double_t e2sq = this->GetBinErrorSqUnchecked(bin);; 1017 Double_t w1 = 1., w2 = 1.;; 1018 ; 1019 // consider all special cases when bin errors are zero; 1020 // see http://root-forum.cern.ch/viewtopic.php?f=3&t=13299; 1021 if (e1sq) w1 = 1. / e1sq;; 1022 else if (h1->fSumw2.fN) {; 1023 w1 = 1.E200; // use an arbitrary huge value; 1024 if (y1 == 0) {; 1025 // use an estimated error from the global histogram scale; 1026 double sf = (s2[0] != 0) ? s2[1]/s2[0] : 1;; 1027 w1 = 1./(sf*sf);; 1028 }; 1029 }; 1030 if (e2sq) w2 = 1. / e2sq;; 1031 else if (fSumw2.fN) {; 1032 w2 = 1.E200; // use an arbitrary huge value; 1033 if (y2 == 0) {; 1034 // use an estimated error from the global histogram scale; 1035 double sf = (s1[0] != 0) ? s1[1]/s1[0] : 1;; 1036 w2 = 1./(sf*sf);; 1037 }; 1038 }; 1039 ; 1040 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1041 UpdateBinContent(bin, y);; 1042 if (fSumw2.fN) {; 1043 double err2 = 1./(w1 + w2);; 1044 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1045 fSumw2.fArray[bin] = err2;; 1046 }; 1047 } else { // normal case of addition between histograms; 1048 AddBinContent(bin, c1 * factor * h1->RetrieveBinContent(bin));; 1049 if (fSumw2.fN) fSumw2.fArray[bin] += c1sq * factsq * h1->GetBinErrorSqUnchecked(bin);; 1050 }; 1051 }; 1052 ; 1053 // update statistics (do here to avoid changes by SetBinContent); 1054 if (resetSt",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:41370,Availability,error,error,41370,"t_t bin = 0; bin < fNcells; ++bin) {; 1011 //special case where histograms have the kIsAverage bit set; 1012 if (this->TestBit(kIsAverage) && h1->TestBit(kIsAverage)) {; 1013 Double_t y1 = h1->RetrieveBinContent(bin);; 1014 Double_t y2 = this->RetrieveBinContent(bin);; 1015 Double_t e1sq = h1->GetBinErrorSqUnchecked(bin);; 1016 Double_t e2sq = this->GetBinErrorSqUnchecked(bin);; 1017 Double_t w1 = 1., w2 = 1.;; 1018 ; 1019 // consider all special cases when bin errors are zero; 1020 // see http://root-forum.cern.ch/viewtopic.php?f=3&t=13299; 1021 if (e1sq) w1 = 1. / e1sq;; 1022 else if (h1->fSumw2.fN) {; 1023 w1 = 1.E200; // use an arbitrary huge value; 1024 if (y1 == 0) {; 1025 // use an estimated error from the global histogram scale; 1026 double sf = (s2[0] != 0) ? s2[1]/s2[0] : 1;; 1027 w1 = 1./(sf*sf);; 1028 }; 1029 }; 1030 if (e2sq) w2 = 1. / e2sq;; 1031 else if (fSumw2.fN) {; 1032 w2 = 1.E200; // use an arbitrary huge value; 1033 if (y2 == 0) {; 1034 // use an estimated error from the global histogram scale; 1035 double sf = (s1[0] != 0) ? s1[1]/s1[0] : 1;; 1036 w2 = 1./(sf*sf);; 1037 }; 1038 }; 1039 ; 1040 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1041 UpdateBinContent(bin, y);; 1042 if (fSumw2.fN) {; 1043 double err2 = 1./(w1 + w2);; 1044 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1045 fSumw2.fArray[bin] = err2;; 1046 }; 1047 } else { // normal case of addition between histograms; 1048 AddBinContent(bin, c1 * factor * h1->RetrieveBinContent(bin));; 1049 if (fSumw2.fN) fSumw2.fArray[bin] += c1sq * factsq * h1->GetBinErrorSqUnchecked(bin);; 1050 }; 1051 }; 1052 ; 1053 // update statistics (do here to avoid changes by SetBinContent); 1054 if (resetStats) {; 1055 // statistics need to be reset in case coefficient are negative; 1056 ResetStats();; 1057 }; 1058 else {; 1059 for (Int_t i=0;i<kNstat;i++) {; 1060 if (i == 1) s1[i] += c1*c1*s2[i];; 1061 else s1[i] += c1*s2[i];; 1062 }; 1063 PutStats(s1);; 1064 SetEntries(entries);; 106",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:42630,Availability,error,errors,42630,"alue when e1=0 AND e2=0; 1045 fSumw2.fArray[bin] = err2;; 1046 }; 1047 } else { // normal case of addition between histograms; 1048 AddBinContent(bin, c1 * factor * h1->RetrieveBinContent(bin));; 1049 if (fSumw2.fN) fSumw2.fArray[bin] += c1sq * factsq * h1->GetBinErrorSqUnchecked(bin);; 1050 }; 1051 }; 1052 ; 1053 // update statistics (do here to avoid changes by SetBinContent); 1054 if (resetStats) {; 1055 // statistics need to be reset in case coefficient are negative; 1056 ResetStats();; 1057 }; 1058 else {; 1059 for (Int_t i=0;i<kNstat;i++) {; 1060 if (i == 1) s1[i] += c1*c1*s2[i];; 1061 else s1[i] += c1*s2[i];; 1062 }; 1063 PutStats(s1);; 1064 SetEntries(entries);; 1065 }; 1066 return kTRUE;; 1067}; 1068 ; 1069////////////////////////////////////////////////////////////////////////////////; 1070/// Replace contents of this histogram by the addition of h1 and h2.; 1071///; 1072/// `this = c1*h1 + c2*h2`; 1073/// if errors are defined (see TH1::Sumw2), errors are also recalculated; 1074///; 1075/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 1076/// if not already set.; 1077///; 1078/// Note also that adding histogram with labels is not supported, histogram will be; 1079/// added merging them by bin number independently of the labels.; 1080/// For adding histogram ith labels one should use TH1::Merge; 1081///; 1082/// SPECIAL CASE (Average/Efficiency histograms); 1083/// For histograms representing averages or efficiencies, one should compute the average; 1084/// of the two histograms and not the sum. One can mark a histogram to be an average; 1085/// histogram by setting its bit kIsAverage with; 1086/// myhist.SetBit(TH1::kIsAverage);; 1087/// Note that the two histograms must have their kIsAverage bit set; 1088///; 1089/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 1090/// you should call Sumw2 before making this operation.; 1091/// This is particularly important if you fit the histogram after TH1::",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:42667,Availability,error,errors,42667,"alue when e1=0 AND e2=0; 1045 fSumw2.fArray[bin] = err2;; 1046 }; 1047 } else { // normal case of addition between histograms; 1048 AddBinContent(bin, c1 * factor * h1->RetrieveBinContent(bin));; 1049 if (fSumw2.fN) fSumw2.fArray[bin] += c1sq * factsq * h1->GetBinErrorSqUnchecked(bin);; 1050 }; 1051 }; 1052 ; 1053 // update statistics (do here to avoid changes by SetBinContent); 1054 if (resetStats) {; 1055 // statistics need to be reset in case coefficient are negative; 1056 ResetStats();; 1057 }; 1058 else {; 1059 for (Int_t i=0;i<kNstat;i++) {; 1060 if (i == 1) s1[i] += c1*c1*s2[i];; 1061 else s1[i] += c1*s2[i];; 1062 }; 1063 PutStats(s1);; 1064 SetEntries(entries);; 1065 }; 1066 return kTRUE;; 1067}; 1068 ; 1069////////////////////////////////////////////////////////////////////////////////; 1070/// Replace contents of this histogram by the addition of h1 and h2.; 1071///; 1072/// `this = c1*h1 + c2*h2`; 1073/// if errors are defined (see TH1::Sumw2), errors are also recalculated; 1074///; 1075/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 1076/// if not already set.; 1077///; 1078/// Note also that adding histogram with labels is not supported, histogram will be; 1079/// added merging them by bin number independently of the labels.; 1080/// For adding histogram ith labels one should use TH1::Merge; 1081///; 1082/// SPECIAL CASE (Average/Efficiency histograms); 1083/// For histograms representing averages or efficiencies, one should compute the average; 1084/// of the two histograms and not the sum. One can mark a histogram to be an average; 1085/// histogram by setting its bit kIsAverage with; 1086/// myhist.SetBit(TH1::kIsAverage);; 1087/// Note that the two histograms must have their kIsAverage bit set; 1088///; 1089/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 1090/// you should call Sumw2 before making this operation.; 1091/// This is particularly important if you fit the histogram after TH1::",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:43530,Availability,error,errors,43530,"/////; 1070/// Replace contents of this histogram by the addition of h1 and h2.; 1071///; 1072/// `this = c1*h1 + c2*h2`; 1073/// if errors are defined (see TH1::Sumw2), errors are also recalculated; 1074///; 1075/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 1076/// if not already set.; 1077///; 1078/// Note also that adding histogram with labels is not supported, histogram will be; 1079/// added merging them by bin number independently of the labels.; 1080/// For adding histogram ith labels one should use TH1::Merge; 1081///; 1082/// SPECIAL CASE (Average/Efficiency histograms); 1083/// For histograms representing averages or efficiencies, one should compute the average; 1084/// of the two histograms and not the sum. One can mark a histogram to be an average; 1085/// histogram by setting its bit kIsAverage with; 1086/// myhist.SetBit(TH1::kIsAverage);; 1087/// Note that the two histograms must have their kIsAverage bit set; 1088///; 1089/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 1090/// you should call Sumw2 before making this operation.; 1091/// This is particularly important if you fit the histogram after TH1::Add; 1092///; 1093/// IMPORTANT NOTE2: You should be careful about the statistics of the; 1094/// returned histogram, whose statistics may be binned or unbinned,; 1095/// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; 1096/// and whether TH1::ResetStats has been called on either this or h1.; 1097/// See TH1::GetStats.; 1098///; 1099/// ANOTHER SPECIAL CASE : h1 = h2 and c2 < 0; 1100/// do a scaling this = c1 * h1 / (bin Volume); 1101///; 1102/// The function returns kFALSE if the Add operation failed; 1103 ; 1104Bool_t TH1::Add(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2); 1105{; 1106 ; 1107 if (!h1 || !h2) {; 1108 Error(""Add"",""Attempt to add a non-existing histogram"");; 1109 return kFALSE;; 1110 }; 1111 ; 1112 // delete buffer if it is there since it ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:48323,Availability,error,errors,48323,"binz);; 1190 for (biny = 0; biny < nbinsy; ++biny) {; 1191 Double_t wy = h1->GetYaxis()->GetBinWidth(biny);; 1192 for (binx = 0; binx < nbinsx; ++binx) {; 1193 Double_t wx = h1->GetXaxis()->GetBinWidth(binx);; 1194 bin = GetBin(binx, biny, binz);; 1195 Double_t w = wx*wy*wz;; 1196 UpdateBinContent(bin, c1 * h1->RetrieveBinContent(bin) / w);; 1197 if (fSumw2.fN) {; 1198 Double_t e1 = h1->GetBinError(bin)/w;; 1199 fSumw2.fArray[bin] = c1*c1*e1*e1;; 1200 }; 1201 }; 1202 }; 1203 }; 1204 } else if (h1->TestBit(kIsAverage) && h2->TestBit(kIsAverage)) {; 1205 for (Int_t i = 0; i < fNcells; ++i) { // loop on cells (bins including underflow / overflow); 1206 // special case where histograms have the kIsAverage bit set; 1207 Double_t y1 = h1->RetrieveBinContent(i);; 1208 Double_t y2 = h2->RetrieveBinContent(i);; 1209 Double_t e1sq = h1->GetBinErrorSqUnchecked(i);; 1210 Double_t e2sq = h2->GetBinErrorSqUnchecked(i);; 1211 Double_t w1 = 1., w2 = 1.;; 1212 ; 1213 // consider all special cases when bin errors are zero; 1214 // see http://root-forum.cern.ch/viewtopic.php?f=3&t=13299; 1215 if (e1sq) w1 = 1./ e1sq;; 1216 else if (h1->fSumw2.fN) {; 1217 w1 = 1.E200; // use an arbitrary huge value; 1218 if (y1 == 0 ) { // use an estimated error from the global histogram scale; 1219 double sf = (s1[0] != 0) ? s1[1]/s1[0] : 1;; 1220 w1 = 1./(sf*sf);; 1221 }; 1222 }; 1223 if (e2sq) w2 = 1./ e2sq;; 1224 else if (h2->fSumw2.fN) {; 1225 w2 = 1.E200; // use an arbitrary huge value; 1226 if (y2 == 0) { // use an estimated error from the global histogram scale; 1227 double sf = (s2[0] != 0) ? s2[1]/s2[0] : 1;; 1228 w2 = 1./(sf*sf);; 1229 }; 1230 }; 1231 ; 1232 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1233 UpdateBinContent(i, y);; 1234 if (fSumw2.fN) {; 1235 double err2 = 1./(w1 + w2);; 1236 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1237 fSumw2.fArray[i] = err2;; 1238 }; 1239 }; 1240 } else { // case of simple histogram addition; 1241 Double_t c1sq = c1 * c1;; ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:48559,Availability,error,error,48559,"5 Double_t w = wx*wy*wz;; 1196 UpdateBinContent(bin, c1 * h1->RetrieveBinContent(bin) / w);; 1197 if (fSumw2.fN) {; 1198 Double_t e1 = h1->GetBinError(bin)/w;; 1199 fSumw2.fArray[bin] = c1*c1*e1*e1;; 1200 }; 1201 }; 1202 }; 1203 }; 1204 } else if (h1->TestBit(kIsAverage) && h2->TestBit(kIsAverage)) {; 1205 for (Int_t i = 0; i < fNcells; ++i) { // loop on cells (bins including underflow / overflow); 1206 // special case where histograms have the kIsAverage bit set; 1207 Double_t y1 = h1->RetrieveBinContent(i);; 1208 Double_t y2 = h2->RetrieveBinContent(i);; 1209 Double_t e1sq = h1->GetBinErrorSqUnchecked(i);; 1210 Double_t e2sq = h2->GetBinErrorSqUnchecked(i);; 1211 Double_t w1 = 1., w2 = 1.;; 1212 ; 1213 // consider all special cases when bin errors are zero; 1214 // see http://root-forum.cern.ch/viewtopic.php?f=3&t=13299; 1215 if (e1sq) w1 = 1./ e1sq;; 1216 else if (h1->fSumw2.fN) {; 1217 w1 = 1.E200; // use an arbitrary huge value; 1218 if (y1 == 0 ) { // use an estimated error from the global histogram scale; 1219 double sf = (s1[0] != 0) ? s1[1]/s1[0] : 1;; 1220 w1 = 1./(sf*sf);; 1221 }; 1222 }; 1223 if (e2sq) w2 = 1./ e2sq;; 1224 else if (h2->fSumw2.fN) {; 1225 w2 = 1.E200; // use an arbitrary huge value; 1226 if (y2 == 0) { // use an estimated error from the global histogram scale; 1227 double sf = (s2[0] != 0) ? s2[1]/s2[0] : 1;; 1228 w2 = 1./(sf*sf);; 1229 }; 1230 }; 1231 ; 1232 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1233 UpdateBinContent(i, y);; 1234 if (fSumw2.fN) {; 1235 double err2 = 1./(w1 + w2);; 1236 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1237 fSumw2.fArray[i] = err2;; 1238 }; 1239 }; 1240 } else { // case of simple histogram addition; 1241 Double_t c1sq = c1 * c1;; 1242 Double_t c2sq = c2 * c2;; 1243 for (Int_t i = 0; i < fNcells; ++i) { // Loop on cells (bins including underflows/overflows); 1244 UpdateBinContent(i, c1 * h1->RetrieveBinContent(i) + c2 * h2->RetrieveBinContent(i));; 1245 if (fSumw2.fN) {; 1246 ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:48840,Availability,error,error,48840,"stBit(kIsAverage)) {; 1205 for (Int_t i = 0; i < fNcells; ++i) { // loop on cells (bins including underflow / overflow); 1206 // special case where histograms have the kIsAverage bit set; 1207 Double_t y1 = h1->RetrieveBinContent(i);; 1208 Double_t y2 = h2->RetrieveBinContent(i);; 1209 Double_t e1sq = h1->GetBinErrorSqUnchecked(i);; 1210 Double_t e2sq = h2->GetBinErrorSqUnchecked(i);; 1211 Double_t w1 = 1., w2 = 1.;; 1212 ; 1213 // consider all special cases when bin errors are zero; 1214 // see http://root-forum.cern.ch/viewtopic.php?f=3&t=13299; 1215 if (e1sq) w1 = 1./ e1sq;; 1216 else if (h1->fSumw2.fN) {; 1217 w1 = 1.E200; // use an arbitrary huge value; 1218 if (y1 == 0 ) { // use an estimated error from the global histogram scale; 1219 double sf = (s1[0] != 0) ? s1[1]/s1[0] : 1;; 1220 w1 = 1./(sf*sf);; 1221 }; 1222 }; 1223 if (e2sq) w2 = 1./ e2sq;; 1224 else if (h2->fSumw2.fN) {; 1225 w2 = 1.E200; // use an arbitrary huge value; 1226 if (y2 == 0) { // use an estimated error from the global histogram scale; 1227 double sf = (s2[0] != 0) ? s2[1]/s2[0] : 1;; 1228 w2 = 1./(sf*sf);; 1229 }; 1230 }; 1231 ; 1232 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1233 UpdateBinContent(i, y);; 1234 if (fSumw2.fN) {; 1235 double err2 = 1./(w1 + w2);; 1236 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1237 fSumw2.fArray[i] = err2;; 1238 }; 1239 }; 1240 } else { // case of simple histogram addition; 1241 Double_t c1sq = c1 * c1;; 1242 Double_t c2sq = c2 * c2;; 1243 for (Int_t i = 0; i < fNcells; ++i) { // Loop on cells (bins including underflows/overflows); 1244 UpdateBinContent(i, c1 * h1->RetrieveBinContent(i) + c2 * h2->RetrieveBinContent(i));; 1245 if (fSumw2.fN) {; 1246 fSumw2.fArray[i] = c1sq * h1->GetBinErrorSqUnchecked(i) + c2sq * h2->GetBinErrorSqUnchecked(i);; 1247 }; 1248 }; 1249 }; 1250 ; 1251 if (resetStats) {; 1252 // statistics need to be reset in case coefficient are negative; 1253 ResetStats();; 1254 }; 1255 else {; 1256 // update stat",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:74613,Availability,down,down,74613,"}^{2} \f$ is the variance of the weight wi.; 1859/// If we replace the variance \f$ \sigma_{i}^{2} \f$; 1860/// with estimate \f$ s_{i}^{2} \f$ (sum of squares of weights of; 1861/// events in the ith bin) and the hypothesis of identity is valid, then the; 1862/// maximum likelihood estimator of pi,i=1,...,r, is; 1863///\f[; 1864/// \hat{p}_{i} = \frac{Ww_{i}-Ns_{i}^{2}+\sqrt{(Ww_{i}-Ns_{i}^{2})^{2}+4W^{2}s_{i}^{2}n_{i}}}{2W^{2}}; 1865///\f]; 1866/// We may then use the test statistic; 1867///\f[; 1868/// X^{2} = \sum_{i=1}^{r} \frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r} \frac{(w_{i}-W\hat{p}_{i})^{2}}{s_{i}^{2}}; 1869///\f]; 1870/// and it has approximately a \f$ \sigma^{2}_{(r-1)} \f$ distribution [2]. This test, as well; 1871/// as the original one [3], has a restriction on the expected frequencies. The; 1872/// expected frequencies recommended for the weighted histogram is more than 25.; 1873/// The value of the minimal expected frequency can be decreased down to 10 for; 1874/// the case when the weights of the events are close to constant. In the case; 1875/// of a weighted histogram if the number of events is unknown, then we can; 1876/// apply this recommendation for the equivalent number of events as; 1877///\f[; 1878/// n_{i}^{equiv} = \frac{ w_{i}^{2} }{ s_{i}^{2} }; 1879///\f]; 1880/// The minimal expected frequency for an unweighted histogram must be 1. Notice; 1881/// that any usual (unweighted) histogram can be considered as a weighted; 1882/// histogram with events that have constant weights equal to 1.; 1883/// The variance \f$ z_{i}^{2} \f$ of the difference between the weight wi; 1884/// and the estimated expectation value of the weight is approximately equal to:; 1885///\f[; 1886/// z_{i}^{2} = Var(w_{i}-W\hat{p}_{i}) = N\hat{p}_{i}(1-N\hat{p}_{i})\left(\frac{Ws_{i}^{2}}{\sqrt{(Ns_{i}^{2}-w_{i}W)^{2}+4W^{2}s_{i}^{2}n_{i}}}\right)^{2}+\frac{s_{i}^{2}}{4}\left(1+\frac{Ns_{i}^{2}-w_{i}W}{\sqrt{(Ns_{i}^{2}-w_{i}W)^{2}+4W^{2}s_{i}^{2}",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:82007,Availability,robust,robustness,82007,"hi^{2} \f$.; 1989///; 1990/// #### References:; 1991///; 1992/// - [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; 1993/// Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; 1994/// Series No. 1, London.; 1995/// - [2] Gagunashvili, N., 2006. \f$ \sigma^{2} \f$ test for comparison; 1996/// of weighted and unweighted histograms. Statistical Problems in Particle; 1997/// Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; 1998/// Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; 1999/// Gagunashvili,N., Comparison of weighted and unweighted histograms,; 2000/// arXiv:physics/0605123, 2006.; 2001/// - [3] Cramer, H., 1946. Mathematical methods of statistics.; 2002/// Princeton University Press, Princeton.; 2003/// - [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; 2004/// Biometrics 29, 205-220.; 2005/// - [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; 2006/// test in 2xN tables. Biometrics 21, 19-33.; 2007/// - [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; 2008/// John Wiley & Sons Inc., New York.; 2009 ; 2010Double_t TH1::Chi2Test(const TH1* h2, Option_t *option, Double_t *res) const; 2011{; 2012 Double_t chi2 = 0;; 2013 Int_t ndf = 0, igood = 0;; 2014 ; 2015 TString opt = option;; 2016 opt.ToUpper();; 2017 ; 2018 Double_t prob = Chi2TestX(h2,chi2,ndf,igood,option,res);; 2019 ; 2020 if(opt.Contains(""P"")) {; 2021 printf(""Chi2 = %f, Prob = %g, NDF = %d, igood = %d\n"", chi2,prob,ndf,igood);; 2022 }; 2023 if(opt.Contains(""CHI2/NDF"")) {; 2024 if (ndf == 0) return 0;; 2025 return chi2/ndf;; 2026 }; 2027 if(opt.Contains(""CHI2"")) {; 2028 return chi2;; 2029 }; 2030 ; 2031 return prob;; 2032}; 2033 ; 2034////////////////////////////////////////////////////////////////////////////////; 2035/// The computation routine of the Chisquare test. For the method description,; 2036/// see Chi2Test() function.; 2037///; 2038/// \re",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:89550,Availability,error,errors,89550,"1) >= 1) {; 2182 Warning(""Chi2TestX"",""First histogram is not unweighted and option UW has been requested"");; 2183 }; 2184 }; 2185 if ( (!scaledHistogram && comparisonUU) ) {; 2186 if ( ( TMath::Abs(sumBinContent1 - effEntries1) >= 1) || (TMath::Abs(sumBinContent2 - effEntries2) >= 1) ) {; 2187 Warning(""Chi2TestX"",""Both histograms are not unweighted and option UU has been requested"");; 2188 }; 2189 }; 2190 ; 2191 ; 2192 //get number of events in histogram; 2193 if (comparisonUU && scaledHistogram) {; 2194 for (Int_t i = i_start; i <= i_end; ++i) {; 2195 for (Int_t j = j_start; j <= j_end; ++j) {; 2196 for (Int_t k = k_start; k <= k_end; ++k) {; 2197 ; 2198 Int_t bin = GetBin(i, j, k);; 2199 ; 2200 Double_t cnt1 = RetrieveBinContent(bin);; 2201 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2202 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2203 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2204 ; 2205 if (e1sq > 0.0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2206 else cnt1 = 0.0;; 2207 ; 2208 if (e2sq > 0.0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2209 else cnt2 = 0.0;; 2210 ; 2211 // sum contents; 2212 sum1 += cnt1;; 2213 sum2 += cnt2;; 2214 sumw1 += e1sq;; 2215 sumw2 += e2sq;; 2216 }; 2217 }; 2218 }; 2219 if (sumw1 <= 0.0 || sumw2 <= 0.0) {; 2220 Error(""Chi2TestX"", ""Cannot use option NORM when one histogram has all zero errors"");; 2221 return 0.0;; 2222 }; 2223 ; 2224 } else {; 2225 for (Int_t i = i_start; i <= i_end; ++i) {; 2226 for (Int_t j = j_start; j <= j_end; ++j) {; 2227 for (Int_t k = k_start; k <= k_end; ++k) {; 2228 ; 2229 Int_t bin = GetBin(i, j, k);; 2230 ; 2231 sum1 += RetrieveBinContent(bin);; 2232 sum2 += h2->RetrieveBinContent(bin);; 2233 ; 2234 if ( comparisonWW ) sumw1 += GetBinErrorSqUnchecked(bin);; 2235 if ( comparisonUW || comparisonWW ) sumw2 += h2->GetBinErrorSqUnchecked(bin);; 2236 }; 2237 }; 2238 }; 2239 }; 2240 //checks that the histograms are not empty; 2241 if (sum1 == 0",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:89674,Availability,error,errors,89674," 2185 if ( (!scaledHistogram && comparisonUU) ) {; 2186 if ( ( TMath::Abs(sumBinContent1 - effEntries1) >= 1) || (TMath::Abs(sumBinContent2 - effEntries2) >= 1) ) {; 2187 Warning(""Chi2TestX"",""Both histograms are not unweighted and option UU has been requested"");; 2188 }; 2189 }; 2190 ; 2191 ; 2192 //get number of events in histogram; 2193 if (comparisonUU && scaledHistogram) {; 2194 for (Int_t i = i_start; i <= i_end; ++i) {; 2195 for (Int_t j = j_start; j <= j_end; ++j) {; 2196 for (Int_t k = k_start; k <= k_end; ++k) {; 2197 ; 2198 Int_t bin = GetBin(i, j, k);; 2199 ; 2200 Double_t cnt1 = RetrieveBinContent(bin);; 2201 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2202 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2203 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2204 ; 2205 if (e1sq > 0.0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2206 else cnt1 = 0.0;; 2207 ; 2208 if (e2sq > 0.0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2209 else cnt2 = 0.0;; 2210 ; 2211 // sum contents; 2212 sum1 += cnt1;; 2213 sum2 += cnt2;; 2214 sumw1 += e1sq;; 2215 sumw2 += e2sq;; 2216 }; 2217 }; 2218 }; 2219 if (sumw1 <= 0.0 || sumw2 <= 0.0) {; 2220 Error(""Chi2TestX"", ""Cannot use option NORM when one histogram has all zero errors"");; 2221 return 0.0;; 2222 }; 2223 ; 2224 } else {; 2225 for (Int_t i = i_start; i <= i_end; ++i) {; 2226 for (Int_t j = j_start; j <= j_end; ++j) {; 2227 for (Int_t k = k_start; k <= k_end; ++k) {; 2228 ; 2229 Int_t bin = GetBin(i, j, k);; 2230 ; 2231 sum1 += RetrieveBinContent(bin);; 2232 sum2 += h2->RetrieveBinContent(bin);; 2233 ; 2234 if ( comparisonWW ) sumw1 += GetBinErrorSqUnchecked(bin);; 2235 if ( comparisonUW || comparisonWW ) sumw2 += h2->GetBinErrorSqUnchecked(bin);; 2236 }; 2237 }; 2238 }; 2239 }; 2240 //checks that the histograms are not empty; 2241 if (sum1 == 0.0 || sum2 == 0.0) {; 2242 Error(""Chi2TestX"",""one histogram is empty"");; 2243 return 0.0;; 2244 }; 2245 ; 2246 if ( comparis",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:89962,Availability,error,errors,89962,"sted"");; 2188 }; 2189 }; 2190 ; 2191 ; 2192 //get number of events in histogram; 2193 if (comparisonUU && scaledHistogram) {; 2194 for (Int_t i = i_start; i <= i_end; ++i) {; 2195 for (Int_t j = j_start; j <= j_end; ++j) {; 2196 for (Int_t k = k_start; k <= k_end; ++k) {; 2197 ; 2198 Int_t bin = GetBin(i, j, k);; 2199 ; 2200 Double_t cnt1 = RetrieveBinContent(bin);; 2201 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2202 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2203 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2204 ; 2205 if (e1sq > 0.0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2206 else cnt1 = 0.0;; 2207 ; 2208 if (e2sq > 0.0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2209 else cnt2 = 0.0;; 2210 ; 2211 // sum contents; 2212 sum1 += cnt1;; 2213 sum2 += cnt2;; 2214 sumw1 += e1sq;; 2215 sumw2 += e2sq;; 2216 }; 2217 }; 2218 }; 2219 if (sumw1 <= 0.0 || sumw2 <= 0.0) {; 2220 Error(""Chi2TestX"", ""Cannot use option NORM when one histogram has all zero errors"");; 2221 return 0.0;; 2222 }; 2223 ; 2224 } else {; 2225 for (Int_t i = i_start; i <= i_end; ++i) {; 2226 for (Int_t j = j_start; j <= j_end; ++j) {; 2227 for (Int_t k = k_start; k <= k_end; ++k) {; 2228 ; 2229 Int_t bin = GetBin(i, j, k);; 2230 ; 2231 sum1 += RetrieveBinContent(bin);; 2232 sum2 += h2->RetrieveBinContent(bin);; 2233 ; 2234 if ( comparisonWW ) sumw1 += GetBinErrorSqUnchecked(bin);; 2235 if ( comparisonUW || comparisonWW ) sumw2 += h2->GetBinErrorSqUnchecked(bin);; 2236 }; 2237 }; 2238 }; 2239 }; 2240 //checks that the histograms are not empty; 2241 if (sum1 == 0.0 || sum2 == 0.0) {; 2242 Error(""Chi2TestX"",""one histogram is empty"");; 2243 return 0.0;; 2244 }; 2245 ; 2246 if ( comparisonWW && ( sumw1 <= 0.0 && sumw2 <= 0.0 ) ){; 2247 Error(""Chi2TestX"",""Hist1 and Hist2 have both all zero errors\n"");; 2248 return 0.0;; 2249 }; 2250 ; 2251 //THE TEST; 2252 Int_t m = 0, n = 0;; 2253 ; 2254 //Experiment - experiment comparison; 2255 if (com",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:90781,Availability,error,errors,90781,"m2 += cnt2;; 2214 sumw1 += e1sq;; 2215 sumw2 += e2sq;; 2216 }; 2217 }; 2218 }; 2219 if (sumw1 <= 0.0 || sumw2 <= 0.0) {; 2220 Error(""Chi2TestX"", ""Cannot use option NORM when one histogram has all zero errors"");; 2221 return 0.0;; 2222 }; 2223 ; 2224 } else {; 2225 for (Int_t i = i_start; i <= i_end; ++i) {; 2226 for (Int_t j = j_start; j <= j_end; ++j) {; 2227 for (Int_t k = k_start; k <= k_end; ++k) {; 2228 ; 2229 Int_t bin = GetBin(i, j, k);; 2230 ; 2231 sum1 += RetrieveBinContent(bin);; 2232 sum2 += h2->RetrieveBinContent(bin);; 2233 ; 2234 if ( comparisonWW ) sumw1 += GetBinErrorSqUnchecked(bin);; 2235 if ( comparisonUW || comparisonWW ) sumw2 += h2->GetBinErrorSqUnchecked(bin);; 2236 }; 2237 }; 2238 }; 2239 }; 2240 //checks that the histograms are not empty; 2241 if (sum1 == 0.0 || sum2 == 0.0) {; 2242 Error(""Chi2TestX"",""one histogram is empty"");; 2243 return 0.0;; 2244 }; 2245 ; 2246 if ( comparisonWW && ( sumw1 <= 0.0 && sumw2 <= 0.0 ) ){; 2247 Error(""Chi2TestX"",""Hist1 and Hist2 have both all zero errors\n"");; 2248 return 0.0;; 2249 }; 2250 ; 2251 //THE TEST; 2252 Int_t m = 0, n = 0;; 2253 ; 2254 //Experiment - experiment comparison; 2255 if (comparisonUU) {; 2256 Double_t sum = sum1 + sum2;; 2257 for (Int_t i = i_start; i <= i_end; ++i) {; 2258 for (Int_t j = j_start; j <= j_end; ++j) {; 2259 for (Int_t k = k_start; k <= k_end; ++k) {; 2260 ; 2261 Int_t bin = GetBin(i, j, k);; 2262 ; 2263 Double_t cnt1 = RetrieveBinContent(bin);; 2264 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2265 ; 2266 if (scaledHistogram) {; 2267 // scale bin value to effective bin entries; 2268 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2269 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2270 ; 2271 if (e1sq > 0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2272 else cnt1 = 0;; 2273 ; 2274 if (e2sq > 0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2275 else cnt2 = 0;; 2276 }; 2277 ; 2278 if (Int_t(cnt1) == 0 && Int_t(cnt2)",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:91557,Availability,error,errors,91557,"X"",""one histogram is empty"");; 2243 return 0.0;; 2244 }; 2245 ; 2246 if ( comparisonWW && ( sumw1 <= 0.0 && sumw2 <= 0.0 ) ){; 2247 Error(""Chi2TestX"",""Hist1 and Hist2 have both all zero errors\n"");; 2248 return 0.0;; 2249 }; 2250 ; 2251 //THE TEST; 2252 Int_t m = 0, n = 0;; 2253 ; 2254 //Experiment - experiment comparison; 2255 if (comparisonUU) {; 2256 Double_t sum = sum1 + sum2;; 2257 for (Int_t i = i_start; i <= i_end; ++i) {; 2258 for (Int_t j = j_start; j <= j_end; ++j) {; 2259 for (Int_t k = k_start; k <= k_end; ++k) {; 2260 ; 2261 Int_t bin = GetBin(i, j, k);; 2262 ; 2263 Double_t cnt1 = RetrieveBinContent(bin);; 2264 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2265 ; 2266 if (scaledHistogram) {; 2267 // scale bin value to effective bin entries; 2268 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2269 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2270 ; 2271 if (e1sq > 0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2272 else cnt1 = 0;; 2273 ; 2274 if (e2sq > 0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2275 else cnt2 = 0;; 2276 }; 2277 ; 2278 if (Int_t(cnt1) == 0 && Int_t(cnt2) == 0) --ndf; // no data means one degree of freedom less; 2279 else {; 2280 ; 2281 Double_t cntsum = cnt1 + cnt2;; 2282 Double_t nexp1 = cntsum * sum1 / sum;; 2283 //Double_t nexp2 = binsum*sum2/sum;; 2284 ; 2285 if (res) res[i - i_start] = (cnt1 - nexp1) / TMath::Sqrt(nexp1);; 2286 ; 2287 if (cnt1 < 1) ++m;; 2288 if (cnt2 < 1) ++n;; 2289 ; 2290 //Habermann correction for residuals; 2291 Double_t correc = (1. - sum1 / sum) * (1. - cntsum / sum);; 2292 if (res) res[i - i_start] /= TMath::Sqrt(correc);; 2293 ; 2294 Double_t delta = sum2 * cnt1 - sum1 * cnt2;; 2295 chi2 += delta * delta / cntsum;; 2296 }; 2297 }; 2298 }; 2299 }; 2300 chi2 /= sum1 * sum2;; 2301 ; 2302 // flag error only when of the two histogram is zero; 2303 if (m) {; 2304 igood += 1;; 2305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");;",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:91677,Availability,error,errors,91677,"ison; 2255 if (comparisonUU) {; 2256 Double_t sum = sum1 + sum2;; 2257 for (Int_t i = i_start; i <= i_end; ++i) {; 2258 for (Int_t j = j_start; j <= j_end; ++j) {; 2259 for (Int_t k = k_start; k <= k_end; ++k) {; 2260 ; 2261 Int_t bin = GetBin(i, j, k);; 2262 ; 2263 Double_t cnt1 = RetrieveBinContent(bin);; 2264 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2265 ; 2266 if (scaledHistogram) {; 2267 // scale bin value to effective bin entries; 2268 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2269 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2270 ; 2271 if (e1sq > 0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2272 else cnt1 = 0;; 2273 ; 2274 if (e2sq > 0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2275 else cnt2 = 0;; 2276 }; 2277 ; 2278 if (Int_t(cnt1) == 0 && Int_t(cnt2) == 0) --ndf; // no data means one degree of freedom less; 2279 else {; 2280 ; 2281 Double_t cntsum = cnt1 + cnt2;; 2282 Double_t nexp1 = cntsum * sum1 / sum;; 2283 //Double_t nexp2 = binsum*sum2/sum;; 2284 ; 2285 if (res) res[i - i_start] = (cnt1 - nexp1) / TMath::Sqrt(nexp1);; 2286 ; 2287 if (cnt1 < 1) ++m;; 2288 if (cnt2 < 1) ++n;; 2289 ; 2290 //Habermann correction for residuals; 2291 Double_t correc = (1. - sum1 / sum) * (1. - cntsum / sum);; 2292 if (res) res[i - i_start] /= TMath::Sqrt(correc);; 2293 ; 2294 Double_t delta = sum2 * cnt1 - sum1 * cnt2;; 2295 chi2 += delta * delta / cntsum;; 2296 }; 2297 }; 2298 }; 2299 }; 2300 chi2 /= sum1 * sum2;; 2301 ; 2302 // flag error only when of the two histogram is zero; 2303 if (m) {; 2304 igood += 1;; 2305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2306 }; 2307 if (n) {; 2308 igood += 2;; 2309 Info(""Chi2TestX"",""There is a bin in h2 with less than 1 event.\n"");; 2310 }; 2311 ; 2312 Double_t prob = TMath::Prob(chi2,ndf);; 2313 return prob;; 2314 ; 2315 }; 2316 ; 2317 // unweighted - weighted comparison; 2318 // case of error = 0 and content not zero is treated wit",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:92443,Availability,error,error,92443,"rSqUnchecked(bin);; 2269 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2270 ; 2271 if (e1sq > 0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2272 else cnt1 = 0;; 2273 ; 2274 if (e2sq > 0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2275 else cnt2 = 0;; 2276 }; 2277 ; 2278 if (Int_t(cnt1) == 0 && Int_t(cnt2) == 0) --ndf; // no data means one degree of freedom less; 2279 else {; 2280 ; 2281 Double_t cntsum = cnt1 + cnt2;; 2282 Double_t nexp1 = cntsum * sum1 / sum;; 2283 //Double_t nexp2 = binsum*sum2/sum;; 2284 ; 2285 if (res) res[i - i_start] = (cnt1 - nexp1) / TMath::Sqrt(nexp1);; 2286 ; 2287 if (cnt1 < 1) ++m;; 2288 if (cnt2 < 1) ++n;; 2289 ; 2290 //Habermann correction for residuals; 2291 Double_t correc = (1. - sum1 / sum) * (1. - cntsum / sum);; 2292 if (res) res[i - i_start] /= TMath::Sqrt(correc);; 2293 ; 2294 Double_t delta = sum2 * cnt1 - sum1 * cnt2;; 2295 chi2 += delta * delta / cntsum;; 2296 }; 2297 }; 2298 }; 2299 }; 2300 chi2 /= sum1 * sum2;; 2301 ; 2302 // flag error only when of the two histogram is zero; 2303 if (m) {; 2304 igood += 1;; 2305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2306 }; 2307 if (n) {; 2308 igood += 2;; 2309 Info(""Chi2TestX"",""There is a bin in h2 with less than 1 event.\n"");; 2310 }; 2311 ; 2312 Double_t prob = TMath::Prob(chi2,ndf);; 2313 return prob;; 2314 ; 2315 }; 2316 ; 2317 // unweighted - weighted comparison; 2318 // case of error = 0 and content not zero is treated without problems by excluding second chi2 sum; 2319 // and can be considered as a data-theory comparison; 2320 if ( comparisonUW ) {; 2321 for (Int_t i = i_start; i <= i_end; ++i) {; 2322 for (Int_t j = j_start; j <= j_end; ++j) {; 2323 for (Int_t k = k_start; k <= k_end; ++k) {; 2324 ; 2325 Int_t bin = GetBin(i, j, k);; 2326 ; 2327 Double_t cnt1 = RetrieveBinContent(bin);; 2328 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2329 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin)",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:92870,Availability,error,error,92870,"305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2306 }; 2307 if (n) {; 2308 igood += 2;; 2309 Info(""Chi2TestX"",""There is a bin in h2 with less than 1 event.\n"");; 2310 }; 2311 ; 2312 Double_t prob = TMath::Prob(chi2,ndf);; 2313 return prob;; 2314 ; 2315 }; 2316 ; 2317 // unweighted - weighted comparison; 2318 // case of error = 0 and content not zero is treated without problems by excluding second chi2 sum; 2319 // and can be considered as a data-theory comparison; 2320 if ( comparisonUW ) {; 2321 for (Int_t i = i_start; i <= i_end; ++i) {; 2322 for (Int_t j = j_start; j <= j_end; ++j) {; 2323 for (Int_t k = k_start; k <= k_end; ++k) {; 2324 ; 2325 Int_t bin = GetBin(i, j, k);; 2326 ; 2327 Double_t cnt1 = RetrieveBinContent(bin);; 2328 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2329 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2330 ; 2331 // case both histogram have zero bin contents; 2332 if (cnt1 * cnt1 == 0 && cnt2 * cnt2 == 0) {; 2333 --ndf; //no data means one degree of freedom less; 2334 continue;; 2335 }; 2336 ; 2337 // case weighted histogram has zero bin content and error; 2338 if (cnt2 * cnt2 == 0 && e2sq == 0) {; 2339 if (sumw2 > 0) {; 2340 // use as approximated error as 1 scaled by a scaling ratio; 2341 // estimated from the total sum weight and sum weight squared; 2342 e2sq = sumw2 / sum2;; 2343 }; 2344 else {; 2345 // return error because infinite discrepancy here:; 2346 // bin1 != 0 and bin2 =0 in a histogram with all errors zero; 2347 Error(""Chi2TestX"",""Hist2 has in bin (%d,%d,%d) zero content and zero errors\n"", i, j, k);; 2348 chi2 = 0; return 0;; 2349 }; 2350 }; 2351 ; 2352 if (cnt1 < 1) m++;; 2353 if (e2sq > 0 && cnt2 * cnt2 / e2sq < 10) n++;; 2354 ; 2355 Double_t var1 = sum2 * cnt2 - sum1 * e2sq;; 2356 Double_t var2 = var1 * var1 + 4. * sum2 * sum2 * cnt1 * e2sq;; 2357 ; 2358 // if cnt1 is zero and cnt2 = 1 and sum1 = sum2 var1 = 0 && var2 == 0; 2359 // approximate by incrementing cnt1; 2360 // LM (this need to ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:93648,Availability,error,error,93648,"305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2306 }; 2307 if (n) {; 2308 igood += 2;; 2309 Info(""Chi2TestX"",""There is a bin in h2 with less than 1 event.\n"");; 2310 }; 2311 ; 2312 Double_t prob = TMath::Prob(chi2,ndf);; 2313 return prob;; 2314 ; 2315 }; 2316 ; 2317 // unweighted - weighted comparison; 2318 // case of error = 0 and content not zero is treated without problems by excluding second chi2 sum; 2319 // and can be considered as a data-theory comparison; 2320 if ( comparisonUW ) {; 2321 for (Int_t i = i_start; i <= i_end; ++i) {; 2322 for (Int_t j = j_start; j <= j_end; ++j) {; 2323 for (Int_t k = k_start; k <= k_end; ++k) {; 2324 ; 2325 Int_t bin = GetBin(i, j, k);; 2326 ; 2327 Double_t cnt1 = RetrieveBinContent(bin);; 2328 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2329 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2330 ; 2331 // case both histogram have zero bin contents; 2332 if (cnt1 * cnt1 == 0 && cnt2 * cnt2 == 0) {; 2333 --ndf; //no data means one degree of freedom less; 2334 continue;; 2335 }; 2336 ; 2337 // case weighted histogram has zero bin content and error; 2338 if (cnt2 * cnt2 == 0 && e2sq == 0) {; 2339 if (sumw2 > 0) {; 2340 // use as approximated error as 1 scaled by a scaling ratio; 2341 // estimated from the total sum weight and sum weight squared; 2342 e2sq = sumw2 / sum2;; 2343 }; 2344 else {; 2345 // return error because infinite discrepancy here:; 2346 // bin1 != 0 and bin2 =0 in a histogram with all errors zero; 2347 Error(""Chi2TestX"",""Hist2 has in bin (%d,%d,%d) zero content and zero errors\n"", i, j, k);; 2348 chi2 = 0; return 0;; 2349 }; 2350 }; 2351 ; 2352 if (cnt1 < 1) m++;; 2353 if (e2sq > 0 && cnt2 * cnt2 / e2sq < 10) n++;; 2354 ; 2355 Double_t var1 = sum2 * cnt2 - sum1 * e2sq;; 2356 Double_t var2 = var1 * var1 + 4. * sum2 * sum2 * cnt1 * e2sq;; 2357 ; 2358 // if cnt1 is zero and cnt2 = 1 and sum1 = sum2 var1 = 0 && var2 == 0; 2359 // approximate by incrementing cnt1; 2360 // LM (this need to ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:93749,Availability,error,error,93749,"305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2306 }; 2307 if (n) {; 2308 igood += 2;; 2309 Info(""Chi2TestX"",""There is a bin in h2 with less than 1 event.\n"");; 2310 }; 2311 ; 2312 Double_t prob = TMath::Prob(chi2,ndf);; 2313 return prob;; 2314 ; 2315 }; 2316 ; 2317 // unweighted - weighted comparison; 2318 // case of error = 0 and content not zero is treated without problems by excluding second chi2 sum; 2319 // and can be considered as a data-theory comparison; 2320 if ( comparisonUW ) {; 2321 for (Int_t i = i_start; i <= i_end; ++i) {; 2322 for (Int_t j = j_start; j <= j_end; ++j) {; 2323 for (Int_t k = k_start; k <= k_end; ++k) {; 2324 ; 2325 Int_t bin = GetBin(i, j, k);; 2326 ; 2327 Double_t cnt1 = RetrieveBinContent(bin);; 2328 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2329 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2330 ; 2331 // case both histogram have zero bin contents; 2332 if (cnt1 * cnt1 == 0 && cnt2 * cnt2 == 0) {; 2333 --ndf; //no data means one degree of freedom less; 2334 continue;; 2335 }; 2336 ; 2337 // case weighted histogram has zero bin content and error; 2338 if (cnt2 * cnt2 == 0 && e2sq == 0) {; 2339 if (sumw2 > 0) {; 2340 // use as approximated error as 1 scaled by a scaling ratio; 2341 // estimated from the total sum weight and sum weight squared; 2342 e2sq = sumw2 / sum2;; 2343 }; 2344 else {; 2345 // return error because infinite discrepancy here:; 2346 // bin1 != 0 and bin2 =0 in a histogram with all errors zero; 2347 Error(""Chi2TestX"",""Hist2 has in bin (%d,%d,%d) zero content and zero errors\n"", i, j, k);; 2348 chi2 = 0; return 0;; 2349 }; 2350 }; 2351 ; 2352 if (cnt1 < 1) m++;; 2353 if (e2sq > 0 && cnt2 * cnt2 / e2sq < 10) n++;; 2354 ; 2355 Double_t var1 = sum2 * cnt2 - sum1 * e2sq;; 2356 Double_t var2 = var1 * var1 + 4. * sum2 * sum2 * cnt1 * e2sq;; 2357 ; 2358 // if cnt1 is zero and cnt2 = 1 and sum1 = sum2 var1 = 0 && var2 == 0; 2359 // approximate by incrementing cnt1; 2360 // LM (this need to ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:93918,Availability,error,error,93918,"305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2306 }; 2307 if (n) {; 2308 igood += 2;; 2309 Info(""Chi2TestX"",""There is a bin in h2 with less than 1 event.\n"");; 2310 }; 2311 ; 2312 Double_t prob = TMath::Prob(chi2,ndf);; 2313 return prob;; 2314 ; 2315 }; 2316 ; 2317 // unweighted - weighted comparison; 2318 // case of error = 0 and content not zero is treated without problems by excluding second chi2 sum; 2319 // and can be considered as a data-theory comparison; 2320 if ( comparisonUW ) {; 2321 for (Int_t i = i_start; i <= i_end; ++i) {; 2322 for (Int_t j = j_start; j <= j_end; ++j) {; 2323 for (Int_t k = k_start; k <= k_end; ++k) {; 2324 ; 2325 Int_t bin = GetBin(i, j, k);; 2326 ; 2327 Double_t cnt1 = RetrieveBinContent(bin);; 2328 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2329 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2330 ; 2331 // case both histogram have zero bin contents; 2332 if (cnt1 * cnt1 == 0 && cnt2 * cnt2 == 0) {; 2333 --ndf; //no data means one degree of freedom less; 2334 continue;; 2335 }; 2336 ; 2337 // case weighted histogram has zero bin content and error; 2338 if (cnt2 * cnt2 == 0 && e2sq == 0) {; 2339 if (sumw2 > 0) {; 2340 // use as approximated error as 1 scaled by a scaling ratio; 2341 // estimated from the total sum weight and sum weight squared; 2342 e2sq = sumw2 / sum2;; 2343 }; 2344 else {; 2345 // return error because infinite discrepancy here:; 2346 // bin1 != 0 and bin2 =0 in a histogram with all errors zero; 2347 Error(""Chi2TestX"",""Hist2 has in bin (%d,%d,%d) zero content and zero errors\n"", i, j, k);; 2348 chi2 = 0; return 0;; 2349 }; 2350 }; 2351 ; 2352 if (cnt1 < 1) m++;; 2353 if (e2sq > 0 && cnt2 * cnt2 / e2sq < 10) n++;; 2354 ; 2355 Double_t var1 = sum2 * cnt2 - sum1 * e2sq;; 2356 Double_t var2 = var1 * var1 + 4. * sum2 * sum2 * cnt1 * e2sq;; 2357 ; 2358 // if cnt1 is zero and cnt2 = 1 and sum1 = sum2 var1 = 0 && var2 == 0; 2359 // approximate by incrementing cnt1; 2360 // LM (this need to ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:94014,Availability,error,errors,94014,"305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2306 }; 2307 if (n) {; 2308 igood += 2;; 2309 Info(""Chi2TestX"",""There is a bin in h2 with less than 1 event.\n"");; 2310 }; 2311 ; 2312 Double_t prob = TMath::Prob(chi2,ndf);; 2313 return prob;; 2314 ; 2315 }; 2316 ; 2317 // unweighted - weighted comparison; 2318 // case of error = 0 and content not zero is treated without problems by excluding second chi2 sum; 2319 // and can be considered as a data-theory comparison; 2320 if ( comparisonUW ) {; 2321 for (Int_t i = i_start; i <= i_end; ++i) {; 2322 for (Int_t j = j_start; j <= j_end; ++j) {; 2323 for (Int_t k = k_start; k <= k_end; ++k) {; 2324 ; 2325 Int_t bin = GetBin(i, j, k);; 2326 ; 2327 Double_t cnt1 = RetrieveBinContent(bin);; 2328 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2329 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2330 ; 2331 // case both histogram have zero bin contents; 2332 if (cnt1 * cnt1 == 0 && cnt2 * cnt2 == 0) {; 2333 --ndf; //no data means one degree of freedom less; 2334 continue;; 2335 }; 2336 ; 2337 // case weighted histogram has zero bin content and error; 2338 if (cnt2 * cnt2 == 0 && e2sq == 0) {; 2339 if (sumw2 > 0) {; 2340 // use as approximated error as 1 scaled by a scaling ratio; 2341 // estimated from the total sum weight and sum weight squared; 2342 e2sq = sumw2 / sum2;; 2343 }; 2344 else {; 2345 // return error because infinite discrepancy here:; 2346 // bin1 != 0 and bin2 =0 in a histogram with all errors zero; 2347 Error(""Chi2TestX"",""Hist2 has in bin (%d,%d,%d) zero content and zero errors\n"", i, j, k);; 2348 chi2 = 0; return 0;; 2349 }; 2350 }; 2351 ; 2352 if (cnt1 < 1) m++;; 2353 if (e2sq > 0 && cnt2 * cnt2 / e2sq < 10) n++;; 2354 ; 2355 Double_t var1 = sum2 * cnt2 - sum1 * e2sq;; 2356 Double_t var2 = var1 * var1 + 4. * sum2 * sum2 * cnt1 * e2sq;; 2357 ; 2358 // if cnt1 is zero and cnt2 = 1 and sum1 = sum2 var1 = 0 && var2 == 0; 2359 // approximate by incrementing cnt1; 2360 // LM (this need to ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:94101,Availability,error,errors,94101,"305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2306 }; 2307 if (n) {; 2308 igood += 2;; 2309 Info(""Chi2TestX"",""There is a bin in h2 with less than 1 event.\n"");; 2310 }; 2311 ; 2312 Double_t prob = TMath::Prob(chi2,ndf);; 2313 return prob;; 2314 ; 2315 }; 2316 ; 2317 // unweighted - weighted comparison; 2318 // case of error = 0 and content not zero is treated without problems by excluding second chi2 sum; 2319 // and can be considered as a data-theory comparison; 2320 if ( comparisonUW ) {; 2321 for (Int_t i = i_start; i <= i_end; ++i) {; 2322 for (Int_t j = j_start; j <= j_end; ++j) {; 2323 for (Int_t k = k_start; k <= k_end; ++k) {; 2324 ; 2325 Int_t bin = GetBin(i, j, k);; 2326 ; 2327 Double_t cnt1 = RetrieveBinContent(bin);; 2328 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2329 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2330 ; 2331 // case both histogram have zero bin contents; 2332 if (cnt1 * cnt1 == 0 && cnt2 * cnt2 == 0) {; 2333 --ndf; //no data means one degree of freedom less; 2334 continue;; 2335 }; 2336 ; 2337 // case weighted histogram has zero bin content and error; 2338 if (cnt2 * cnt2 == 0 && e2sq == 0) {; 2339 if (sumw2 > 0) {; 2340 // use as approximated error as 1 scaled by a scaling ratio; 2341 // estimated from the total sum weight and sum weight squared; 2342 e2sq = sumw2 / sum2;; 2343 }; 2344 else {; 2345 // return error because infinite discrepancy here:; 2346 // bin1 != 0 and bin2 =0 in a histogram with all errors zero; 2347 Error(""Chi2TestX"",""Hist2 has in bin (%d,%d,%d) zero content and zero errors\n"", i, j, k);; 2348 chi2 = 0; return 0;; 2349 }; 2350 }; 2351 ; 2352 if (cnt1 < 1) m++;; 2353 if (e2sq > 0 && cnt2 * cnt2 / e2sq < 10) n++;; 2354 ; 2355 Double_t var1 = sum2 * cnt2 - sum1 * e2sq;; 2356 Double_t var2 = var1 * var1 + 4. * sum2 * sum2 * cnt1 * e2sq;; 2357 ; 2358 // if cnt1 is zero and cnt2 = 1 and sum1 = sum2 var1 = 0 && var2 == 0; 2359 // approximate by incrementing cnt1; 2360 // LM (this need to ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:94546,Availability,error,errors,94546,"means one degree of freedom less; 2334 continue;; 2335 }; 2336 ; 2337 // case weighted histogram has zero bin content and error; 2338 if (cnt2 * cnt2 == 0 && e2sq == 0) {; 2339 if (sumw2 > 0) {; 2340 // use as approximated error as 1 scaled by a scaling ratio; 2341 // estimated from the total sum weight and sum weight squared; 2342 e2sq = sumw2 / sum2;; 2343 }; 2344 else {; 2345 // return error because infinite discrepancy here:; 2346 // bin1 != 0 and bin2 =0 in a histogram with all errors zero; 2347 Error(""Chi2TestX"",""Hist2 has in bin (%d,%d,%d) zero content and zero errors\n"", i, j, k);; 2348 chi2 = 0; return 0;; 2349 }; 2350 }; 2351 ; 2352 if (cnt1 < 1) m++;; 2353 if (e2sq > 0 && cnt2 * cnt2 / e2sq < 10) n++;; 2354 ; 2355 Double_t var1 = sum2 * cnt2 - sum1 * e2sq;; 2356 Double_t var2 = var1 * var1 + 4. * sum2 * sum2 * cnt1 * e2sq;; 2357 ; 2358 // if cnt1 is zero and cnt2 = 1 and sum1 = sum2 var1 = 0 && var2 == 0; 2359 // approximate by incrementing cnt1; 2360 // LM (this need to be fixed for numerical errors); 2361 while (var1 * var1 + cnt1 == 0 || var1 + var2 == 0) {; 2362 sum1++;; 2363 cnt1++;; 2364 var1 = sum2 * cnt2 - sum1 * e2sq;; 2365 var2 = var1 * var1 + 4. * sum2 * sum2 * cnt1 * e2sq;; 2366 }; 2367 var2 = TMath::Sqrt(var2);; 2368 ; 2369 while (var1 + var2 == 0) {; 2370 sum1++;; 2371 cnt1++;; 2372 var1 = sum2 * cnt2 - sum1 * e2sq;; 2373 var2 = var1 * var1 + 4. * sum2 * sum2 * cnt1 * e2sq;; 2374 while (var1 * var1 + cnt1 == 0 || var1 + var2 == 0) {; 2375 sum1++;; 2376 cnt1++;; 2377 var1 = sum2 * cnt2 - sum1 * e2sq;; 2378 var2 = var1 * var1 + 4. * sum2 * sum2 * cnt1 * e2sq;; 2379 }; 2380 var2 = TMath::Sqrt(var2);; 2381 }; 2382 ; 2383 Double_t probb = (var1 + var2) / (2. * sum2 * sum2);; 2384 ; 2385 Double_t nexp1 = probb * sum1;; 2386 Double_t nexp2 = probb * sum2;; 2387 ; 2388 Double_t delta1 = cnt1 - nexp1;; 2389 Double_t delta2 = cnt2 - nexp2;; 2390 ; 2391 chi2 += delta1 * delta1 / nexp1;; 2392 ; 2393 if (e2sq > 0) {; 2394 chi2 += delta2 * delta2 / e2sq;; ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:96876,Availability,error,errors,96876,"exp1);; 2407 }; 2408 }; 2409 }; 2410 }; 2411 ; 2412 if (m) {; 2413 igood += 1;; 2414 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2415 }; 2416 if (n) {; 2417 igood += 2;; 2418 Info(""Chi2TestX"",""There is a bin in h2 with less than 10 effective events.\n"");; 2419 }; 2420 ; 2421 Double_t prob = TMath::Prob(chi2, ndf);; 2422 ; 2423 return prob;; 2424 }; 2425 ; 2426 // weighted - weighted comparison; 2427 if (comparisonWW) {; 2428 for (Int_t i = i_start; i <= i_end; ++i) {; 2429 for (Int_t j = j_start; j <= j_end; ++j) {; 2430 for (Int_t k = k_start; k <= k_end; ++k) {; 2431 ; 2432 Int_t bin = GetBin(i, j, k);; 2433 Double_t cnt1 = RetrieveBinContent(bin);; 2434 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2435 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2436 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2437 ; 2438 // case both histogram have zero bin contents; 2439 // (use square of content to avoid numerical errors); 2440 if (cnt1 * cnt1 == 0 && cnt2 * cnt2 == 0) {; 2441 --ndf; //no data means one degree of freedom less; 2442 continue;; 2443 }; 2444 ; 2445 if (e1sq == 0 && e2sq == 0) {; 2446 // cannot treat case of booth histogram have zero zero errors; 2447 Error(""Chi2TestX"",""h1 and h2 both have bin %d,%d,%d with all zero errors\n"", i,j,k);; 2448 chi2 = 0; return 0;; 2449 }; 2450 ; 2451 Double_t sigma = sum1 * sum1 * e2sq + sum2 * sum2 * e1sq;; 2452 Double_t delta = sum2 * cnt1 - sum1 * cnt2;; 2453 chi2 += delta * delta / sigma;; 2454 ; 2455 if (res) {; 2456 Double_t temp = cnt1 * sum1 * e2sq + cnt2 * sum2 * e1sq;; 2457 Double_t probb = temp / sigma;; 2458 Double_t z = 0;; 2459 if (e1sq > e2sq) {; 2460 Double_t d1 = cnt1 - sum1 * probb;; 2461 Double_t s1 = e1sq * ( 1. - e2sq * sum1 * sum1 / sigma );; 2462 z = d1 / TMath::Sqrt(s1);; 2463 }; 2464 else {; 2465 Double_t d2 = cnt2 - sum2 * probb;; 2466 Double_t s2 = e2sq * ( 1. - e1sq * sum2 * sum2 / sigma );; 2467 z = -d2 / TMath::Sqrt(s2);; 2468 }; 2469 res[i - i_start] = z;; 2470 }; 2471 ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:97118,Availability,error,errors,97118,"exp1);; 2407 }; 2408 }; 2409 }; 2410 }; 2411 ; 2412 if (m) {; 2413 igood += 1;; 2414 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2415 }; 2416 if (n) {; 2417 igood += 2;; 2418 Info(""Chi2TestX"",""There is a bin in h2 with less than 10 effective events.\n"");; 2419 }; 2420 ; 2421 Double_t prob = TMath::Prob(chi2, ndf);; 2422 ; 2423 return prob;; 2424 }; 2425 ; 2426 // weighted - weighted comparison; 2427 if (comparisonWW) {; 2428 for (Int_t i = i_start; i <= i_end; ++i) {; 2429 for (Int_t j = j_start; j <= j_end; ++j) {; 2430 for (Int_t k = k_start; k <= k_end; ++k) {; 2431 ; 2432 Int_t bin = GetBin(i, j, k);; 2433 Double_t cnt1 = RetrieveBinContent(bin);; 2434 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2435 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2436 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2437 ; 2438 // case both histogram have zero bin contents; 2439 // (use square of content to avoid numerical errors); 2440 if (cnt1 * cnt1 == 0 && cnt2 * cnt2 == 0) {; 2441 --ndf; //no data means one degree of freedom less; 2442 continue;; 2443 }; 2444 ; 2445 if (e1sq == 0 && e2sq == 0) {; 2446 // cannot treat case of booth histogram have zero zero errors; 2447 Error(""Chi2TestX"",""h1 and h2 both have bin %d,%d,%d with all zero errors\n"", i,j,k);; 2448 chi2 = 0; return 0;; 2449 }; 2450 ; 2451 Double_t sigma = sum1 * sum1 * e2sq + sum2 * sum2 * e1sq;; 2452 Double_t delta = sum2 * cnt1 - sum1 * cnt2;; 2453 chi2 += delta * delta / sigma;; 2454 ; 2455 if (res) {; 2456 Double_t temp = cnt1 * sum1 * e2sq + cnt2 * sum2 * e1sq;; 2457 Double_t probb = temp / sigma;; 2458 Double_t z = 0;; 2459 if (e1sq > e2sq) {; 2460 Double_t d1 = cnt1 - sum1 * probb;; 2461 Double_t s1 = e1sq * ( 1. - e2sq * sum1 * sum1 / sigma );; 2462 z = d1 / TMath::Sqrt(s1);; 2463 }; 2464 else {; 2465 Double_t d2 = cnt2 - sum2 * probb;; 2466 Double_t s2 = e2sq * ( 1. - e1sq * sum2 * sum2 / sigma );; 2467 z = -d2 / TMath::Sqrt(s2);; 2468 }; 2469 res[i - i_start] = z;; 2470 }; 2471 ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:97197,Availability,error,errors,97197,"exp1);; 2407 }; 2408 }; 2409 }; 2410 }; 2411 ; 2412 if (m) {; 2413 igood += 1;; 2414 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2415 }; 2416 if (n) {; 2417 igood += 2;; 2418 Info(""Chi2TestX"",""There is a bin in h2 with less than 10 effective events.\n"");; 2419 }; 2420 ; 2421 Double_t prob = TMath::Prob(chi2, ndf);; 2422 ; 2423 return prob;; 2424 }; 2425 ; 2426 // weighted - weighted comparison; 2427 if (comparisonWW) {; 2428 for (Int_t i = i_start; i <= i_end; ++i) {; 2429 for (Int_t j = j_start; j <= j_end; ++j) {; 2430 for (Int_t k = k_start; k <= k_end; ++k) {; 2431 ; 2432 Int_t bin = GetBin(i, j, k);; 2433 Double_t cnt1 = RetrieveBinContent(bin);; 2434 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2435 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2436 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2437 ; 2438 // case both histogram have zero bin contents; 2439 // (use square of content to avoid numerical errors); 2440 if (cnt1 * cnt1 == 0 && cnt2 * cnt2 == 0) {; 2441 --ndf; //no data means one degree of freedom less; 2442 continue;; 2443 }; 2444 ; 2445 if (e1sq == 0 && e2sq == 0) {; 2446 // cannot treat case of booth histogram have zero zero errors; 2447 Error(""Chi2TestX"",""h1 and h2 both have bin %d,%d,%d with all zero errors\n"", i,j,k);; 2448 chi2 = 0; return 0;; 2449 }; 2450 ; 2451 Double_t sigma = sum1 * sum1 * e2sq + sum2 * sum2 * e1sq;; 2452 Double_t delta = sum2 * cnt1 - sum1 * cnt2;; 2453 chi2 += delta * delta / sigma;; 2454 ; 2455 if (res) {; 2456 Double_t temp = cnt1 * sum1 * e2sq + cnt2 * sum2 * e1sq;; 2457 Double_t probb = temp / sigma;; 2458 Double_t z = 0;; 2459 if (e1sq > e2sq) {; 2460 Double_t d1 = cnt1 - sum1 * probb;; 2461 Double_t s1 = e1sq * ( 1. - e2sq * sum1 * sum1 / sigma );; 2462 z = d1 / TMath::Sqrt(s1);; 2463 }; 2464 else {; 2465 Double_t d2 = cnt2 - sum2 * probb;; 2466 Double_t s2 = e2sq * ( 1. - e1sq * sum2 * sum2 / sigma );; 2467 z = -d2 / TMath::Sqrt(s2);; 2468 }; 2469 res[i - i_start] = z;; 2470 }; 2471 ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:98657,Availability,error,error,98657,"t probb = temp / sigma;; 2458 Double_t z = 0;; 2459 if (e1sq > e2sq) {; 2460 Double_t d1 = cnt1 - sum1 * probb;; 2461 Double_t s1 = e1sq * ( 1. - e2sq * sum1 * sum1 / sigma );; 2462 z = d1 / TMath::Sqrt(s1);; 2463 }; 2464 else {; 2465 Double_t d2 = cnt2 - sum2 * probb;; 2466 Double_t s2 = e2sq * ( 1. - e1sq * sum2 * sum2 / sigma );; 2467 z = -d2 / TMath::Sqrt(s2);; 2468 }; 2469 res[i - i_start] = z;; 2470 }; 2471 ; 2472 if (e1sq > 0 && cnt1 * cnt1 / e1sq < 10) m++;; 2473 if (e2sq > 0 && cnt2 * cnt2 / e2sq < 10) n++;; 2474 }; 2475 }; 2476 }; 2477 if (m) {; 2478 igood += 1;; 2479 Info(""Chi2TestX"",""There is a bin in h1 with less than 10 effective events.\n"");; 2480 }; 2481 if (n) {; 2482 igood += 2;; 2483 Info(""Chi2TestX"",""There is a bin in h2 with less than 10 effective events.\n"");; 2484 }; 2485 Double_t prob = TMath::Prob(chi2, ndf);; 2486 return prob;; 2487 }; 2488 return 0;; 2489}; 2490////////////////////////////////////////////////////////////////////////////////; 2491/// Compute and return the chisquare of this histogram with respect to a function; 2492/// The chisquare is computed by weighting each histogram point by the bin error; 2493/// By default the full range of the histogram is used.; 2494/// Use option ""R"" for restricting the chisquare calculation to the given range of the function; 2495/// Use option ""L"" for using the chisquare based on the poisson likelihood (Baker-Cousins Chisquare); 2496/// Use option ""P"" for using the Pearson chisquare based on the expected bin errors; 2497 ; 2498Double_t TH1::Chisquare(TF1 * func, Option_t *option) const; 2499{; 2500 if (!func) {; 2501 Error(""Chisquare"",""Function pointer is Null - return -1"");; 2502 return -1;; 2503 }; 2504 ; 2505 TString opt(option); opt.ToUpper();; 2506 bool useRange = opt.Contains(""R"");; 2507 ROOT::Fit::EChisquareType type = ROOT::Fit::EChisquareType::kNeyman; // default chi2 with observed error; 2508 if (opt.Contains(""L"")) type = ROOT::Fit::EChisquareType::kPLikeRatio;; 2509 else if (opt.Conta",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:99013,Availability,error,errors,99013,"if (e2sq > 0 && cnt2 * cnt2 / e2sq < 10) n++;; 2474 }; 2475 }; 2476 }; 2477 if (m) {; 2478 igood += 1;; 2479 Info(""Chi2TestX"",""There is a bin in h1 with less than 10 effective events.\n"");; 2480 }; 2481 if (n) {; 2482 igood += 2;; 2483 Info(""Chi2TestX"",""There is a bin in h2 with less than 10 effective events.\n"");; 2484 }; 2485 Double_t prob = TMath::Prob(chi2, ndf);; 2486 return prob;; 2487 }; 2488 return 0;; 2489}; 2490////////////////////////////////////////////////////////////////////////////////; 2491/// Compute and return the chisquare of this histogram with respect to a function; 2492/// The chisquare is computed by weighting each histogram point by the bin error; 2493/// By default the full range of the histogram is used.; 2494/// Use option ""R"" for restricting the chisquare calculation to the given range of the function; 2495/// Use option ""L"" for using the chisquare based on the poisson likelihood (Baker-Cousins Chisquare); 2496/// Use option ""P"" for using the Pearson chisquare based on the expected bin errors; 2497 ; 2498Double_t TH1::Chisquare(TF1 * func, Option_t *option) const; 2499{; 2500 if (!func) {; 2501 Error(""Chisquare"",""Function pointer is Null - return -1"");; 2502 return -1;; 2503 }; 2504 ; 2505 TString opt(option); opt.ToUpper();; 2506 bool useRange = opt.Contains(""R"");; 2507 ROOT::Fit::EChisquareType type = ROOT::Fit::EChisquareType::kNeyman; // default chi2 with observed error; 2508 if (opt.Contains(""L"")) type = ROOT::Fit::EChisquareType::kPLikeRatio;; 2509 else if (opt.Contains(""P"")) type = ROOT::Fit::EChisquareType::kPearson;; 2510 ; 2511 return ROOT::Fit::Chisquare(*this, *func, useRange, type);; 2512}; 2513 ; 2514////////////////////////////////////////////////////////////////////////////////; 2515/// Remove all the content from the underflow and overflow bins, without changing the number of entries; 2516/// After calling this method, every undeflow and overflow bins will have content 0.0; 2517/// The Sumw2 is also cleared, since there is",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:99403,Availability,error,error,99403,"; 2486 return prob;; 2487 }; 2488 return 0;; 2489}; 2490////////////////////////////////////////////////////////////////////////////////; 2491/// Compute and return the chisquare of this histogram with respect to a function; 2492/// The chisquare is computed by weighting each histogram point by the bin error; 2493/// By default the full range of the histogram is used.; 2494/// Use option ""R"" for restricting the chisquare calculation to the given range of the function; 2495/// Use option ""L"" for using the chisquare based on the poisson likelihood (Baker-Cousins Chisquare); 2496/// Use option ""P"" for using the Pearson chisquare based on the expected bin errors; 2497 ; 2498Double_t TH1::Chisquare(TF1 * func, Option_t *option) const; 2499{; 2500 if (!func) {; 2501 Error(""Chisquare"",""Function pointer is Null - return -1"");; 2502 return -1;; 2503 }; 2504 ; 2505 TString opt(option); opt.ToUpper();; 2506 bool useRange = opt.Contains(""R"");; 2507 ROOT::Fit::EChisquareType type = ROOT::Fit::EChisquareType::kNeyman; // default chi2 with observed error; 2508 if (opt.Contains(""L"")) type = ROOT::Fit::EChisquareType::kPLikeRatio;; 2509 else if (opt.Contains(""P"")) type = ROOT::Fit::EChisquareType::kPearson;; 2510 ; 2511 return ROOT::Fit::Chisquare(*this, *func, useRange, type);; 2512}; 2513 ; 2514////////////////////////////////////////////////////////////////////////////////; 2515/// Remove all the content from the underflow and overflow bins, without changing the number of entries; 2516/// After calling this method, every undeflow and overflow bins will have content 0.0; 2517/// The Sumw2 is also cleared, since there is no more content in the bins; 2518 ; 2519void TH1::ClearUnderflowAndOverflow(); 2520{; 2521 for (Int_t bin = 0; bin < fNcells; ++bin); 2522 if (IsBinUnderflow(bin) || IsBinOverflow(bin)) {; 2523 UpdateBinContent(bin, 0.0);; 2524 if (fSumw2.fN) fSumw2.fArray[bin] = 0.0;; 2525 }; 2526}; 2527 ; 2528///////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:100860,Availability,error,error,100860,"andom functions.; 2531/// This function is automatically called by GetRandom when the fIntegral; 2532/// array does not exist or when the number of entries in the histogram; 2533/// has changed since the previous call to GetRandom.; 2534/// The resulting integral is normalized to 1.; 2535/// If the routine is called with the onlyPositive flag set an error will; 2536/// be produced in case of negative bin content and a NaN value returned; 2537/// \return 1 if success, 0 if integral is zero, NAN if onlyPositive-test fails; 2538 ; 2539Double_t TH1::ComputeIntegral(Bool_t onlyPositive); 2540{; 2541 if (fBuffer) BufferEmpty();; 2542 ; 2543 // delete previously computed integral (if any); 2544 if (fIntegral) delete [] fIntegral;; 2545 ; 2546 // - Allocate space to store the integral and compute integral; 2547 Int_t nbinsx = GetNbinsX();; 2548 Int_t nbinsy = GetNbinsY();; 2549 Int_t nbinsz = GetNbinsZ();; 2550 Int_t nbins = nbinsx * nbinsy * nbinsz;; 2551 ; 2552 fIntegral = new Double_t[nbins + 2];; 2553 Int_t ibin = 0; fIntegral[ibin] = 0;; 2554 ; 2555 for (Int_t binz=1; binz <= nbinsz; ++binz) {; 2556 for (Int_t biny=1; biny <= nbinsy; ++biny) {; 2557 for (Int_t binx=1; binx <= nbinsx; ++binx) {; 2558 ++ibin;; 2559 Double_t y = RetrieveBinContent(GetBin(binx, biny, binz));; 2560 if (onlyPositive && y < 0) {; 2561 Error(""ComputeIntegral"",""Bin content is negative - return a NaN value"");; 2562 fIntegral[nbins] = TMath::QuietNaN();; 2563 break;; 2564 }; 2565 fIntegral[ibin] = fIntegral[ibin - 1] + y;; 2566 }; 2567 }; 2568 }; 2569 ; 2570 // - Normalize integral to 1; 2571 if (fIntegral[nbins] == 0 ) {; 2572 Error(""ComputeIntegral"", ""Integral = 0, no hits in histogram bins (excluding over/underflow)."");; 2573 return 0;; 2574 }; 2575 for (Int_t bin=1; bin <= nbins; ++bin) fIntegral[bin] /= fIntegral[nbins];; 2576 fIntegral[nbins+1] = fEntries;; 2577 return fIntegral[nbins];; 2578}; 2579 ; 2580////////////////////////////////////////////////////////////////////////////////; 2581/",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:112523,Availability,error,errors,112523,"equires; 2800/// this object to be added to a directory (I.e. when being read from; 2801/// a TKey or being Cloned); 2802 ; 2803void TH1::DirectoryAutoAdd(TDirectory *dir); 2804{; 2805 Bool_t addStatus = TH1::AddDirectoryStatus();; 2806 if (addStatus) {; 2807 SetDirectory(dir);; 2808 if (dir) {; 2809 ResetBit(kCanDelete);; 2810 }; 2811 }; 2812}; 2813 ; 2814////////////////////////////////////////////////////////////////////////////////; 2815/// Compute distance from point px,py to a line.; 2816///; 2817/// Compute the closest distance of approach from point px,py to elements; 2818/// of a histogram.; 2819/// The distance is computed in pixels units.; 2820///; 2821/// #### Algorithm:; 2822/// Currently, this simple model computes the distance from the mouse; 2823/// to the histogram contour only.; 2824 ; 2825Int_t TH1::DistancetoPrimitive(Int_t px, Int_t py); 2826{; 2827 if (!fPainter) return 9999;; 2828 return fPainter->DistancetoPrimitive(px,py);; 2829}; 2830 ; 2831////////////////////////////////////////////////////////////////////////////////; 2832/// Performs the operation: `this = this/(c1*f1)`; 2833/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 2834///; 2835/// Only bins inside the function range are recomputed.; 2836/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2837/// you should call Sumw2 before making this operation.; 2838/// This is particularly important if you fit the histogram after TH1::Divide; 2839///; 2840/// The function return kFALSE if the divide operation failed; 2841 ; 2842Bool_t TH1::Divide(TF1 *f1, Double_t c1); 2843{; 2844 if (!f1) {; 2845 Error(""Divide"",""Attempt to divide by a non-existing function"");; 2846 return kFALSE;; 2847 }; 2848 ; 2849 // delete buffer if it is there since it will become invalid; 2850 if (fBuffer) BufferEmpty(1);; 2851 ; 2852 Int_t nx = GetNbinsX() + 2; // normal bins + uf / of; 2853 Int_t ny = GetNbinsY() + 2;; 2854 Int_t nz = GetNbinsZ() + 2;; 2855 if (fDime",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:112560,Availability,error,errors,112560,"equires; 2800/// this object to be added to a directory (I.e. when being read from; 2801/// a TKey or being Cloned); 2802 ; 2803void TH1::DirectoryAutoAdd(TDirectory *dir); 2804{; 2805 Bool_t addStatus = TH1::AddDirectoryStatus();; 2806 if (addStatus) {; 2807 SetDirectory(dir);; 2808 if (dir) {; 2809 ResetBit(kCanDelete);; 2810 }; 2811 }; 2812}; 2813 ; 2814////////////////////////////////////////////////////////////////////////////////; 2815/// Compute distance from point px,py to a line.; 2816///; 2817/// Compute the closest distance of approach from point px,py to elements; 2818/// of a histogram.; 2819/// The distance is computed in pixels units.; 2820///; 2821/// #### Algorithm:; 2822/// Currently, this simple model computes the distance from the mouse; 2823/// to the histogram contour only.; 2824 ; 2825Int_t TH1::DistancetoPrimitive(Int_t px, Int_t py); 2826{; 2827 if (!fPainter) return 9999;; 2828 return fPainter->DistancetoPrimitive(px,py);; 2829}; 2830 ; 2831////////////////////////////////////////////////////////////////////////////////; 2832/// Performs the operation: `this = this/(c1*f1)`; 2833/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 2834///; 2835/// Only bins inside the function range are recomputed.; 2836/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2837/// you should call Sumw2 before making this operation.; 2838/// This is particularly important if you fit the histogram after TH1::Divide; 2839///; 2840/// The function return kFALSE if the divide operation failed; 2841 ; 2842Bool_t TH1::Divide(TF1 *f1, Double_t c1); 2843{; 2844 if (!f1) {; 2845 Error(""Divide"",""Attempt to divide by a non-existing function"");; 2846 return kFALSE;; 2847 }; 2848 ; 2849 // delete buffer if it is there since it will become invalid; 2850 if (fBuffer) BufferEmpty(1);; 2851 ; 2852 Int_t nx = GetNbinsX() + 2; // normal bins + uf / of; 2853 Int_t ny = GetNbinsY() + 2;; 2854 Int_t nz = GetNbinsZ() + 2;; 2855 if (fDime",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:112710,Availability,error,errors,112710,"1 }; 2812}; 2813 ; 2814////////////////////////////////////////////////////////////////////////////////; 2815/// Compute distance from point px,py to a line.; 2816///; 2817/// Compute the closest distance of approach from point px,py to elements; 2818/// of a histogram.; 2819/// The distance is computed in pixels units.; 2820///; 2821/// #### Algorithm:; 2822/// Currently, this simple model computes the distance from the mouse; 2823/// to the histogram contour only.; 2824 ; 2825Int_t TH1::DistancetoPrimitive(Int_t px, Int_t py); 2826{; 2827 if (!fPainter) return 9999;; 2828 return fPainter->DistancetoPrimitive(px,py);; 2829}; 2830 ; 2831////////////////////////////////////////////////////////////////////////////////; 2832/// Performs the operation: `this = this/(c1*f1)`; 2833/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 2834///; 2835/// Only bins inside the function range are recomputed.; 2836/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2837/// you should call Sumw2 before making this operation.; 2838/// This is particularly important if you fit the histogram after TH1::Divide; 2839///; 2840/// The function return kFALSE if the divide operation failed; 2841 ; 2842Bool_t TH1::Divide(TF1 *f1, Double_t c1); 2843{; 2844 if (!f1) {; 2845 Error(""Divide"",""Attempt to divide by a non-existing function"");; 2846 return kFALSE;; 2847 }; 2848 ; 2849 // delete buffer if it is there since it will become invalid; 2850 if (fBuffer) BufferEmpty(1);; 2851 ; 2852 Int_t nx = GetNbinsX() + 2; // normal bins + uf / of; 2853 Int_t ny = GetNbinsY() + 2;; 2854 Int_t nz = GetNbinsZ() + 2;; 2855 if (fDimension < 2) ny = 1;; 2856 if (fDimension < 3) nz = 1;; 2857 ; 2858 ; 2859 SetMinimum();; 2860 SetMaximum();; 2861 ; 2862 // - Loop on bins (including underflows/overflows); 2863 Int_t bin, binx, biny, binz;; 2864 Double_t cu, w;; 2865 Double_t xx[3];; 2866 Double_t *params = nullptr;; 2867 f1->InitArgs(xx,params);; 2868 for (binz = 0;",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:114643,Availability,error,errors,114643,"ouble_t *params = nullptr;; 2867 f1->InitArgs(xx,params);; 2868 for (binz = 0; binz < nz; ++binz) {; 2869 xx[2] = fZaxis.GetBinCenter(binz);; 2870 for (biny = 0; biny < ny; ++biny) {; 2871 xx[1] = fYaxis.GetBinCenter(biny);; 2872 for (binx = 0; binx < nx; ++binx) {; 2873 xx[0] = fXaxis.GetBinCenter(binx);; 2874 if (!f1->IsInside(xx)) continue;; 2875 TF1::RejectPoint(kFALSE);; 2876 bin = binx + nx * (biny + ny * binz);; 2877 cu = c1 * f1->EvalPar(xx);; 2878 if (TF1::RejectedPoint()) continue;; 2879 if (cu) w = RetrieveBinContent(bin) / cu;; 2880 else w = 0;; 2881 UpdateBinContent(bin, w);; 2882 if (fSumw2.fN) {; 2883 if (cu != 0) fSumw2.fArray[bin] = GetBinErrorSqUnchecked(bin) / (cu * cu);; 2884 else fSumw2.fArray[bin] = 0;; 2885 }; 2886 }; 2887 }; 2888 }; 2889 ResetStats();; 2890 return kTRUE;; 2891}; 2892 ; 2893////////////////////////////////////////////////////////////////////////////////; 2894/// Divide this histogram by h1.; 2895///; 2896/// `this = this/h1`; 2897/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 2898/// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; 2899/// if not already set.; 2900/// The resulting errors are calculated assuming uncorrelated histograms.; 2901/// See the other TH1::Divide that gives the possibility to optionally; 2902/// compute binomial errors.; 2903///; 2904/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2905/// you should call Sumw2 before making this operation.; 2906/// This is particularly important if you fit the histogram after TH1::Scale; 2907///; 2908/// The function return kFALSE if the divide operation failed; 2909 ; 2910Bool_t TH1::Divide(const TH1 *h1); 2911{; 2912 if (!h1) {; 2913 Error(""Divide"", ""Input histogram passed does not exist (NULL)."");; 2914 return kFALSE;; 2915 }; 2916 ; 2917 // delete buffer if it is there since it will become invalid; 2918 if (fBuffer) BufferEmpty(1);; 2919 ; 2920 if (LoggedInconsistency(""Divide"", this, h1)",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:114680,Availability,error,errors,114680,"ouble_t *params = nullptr;; 2867 f1->InitArgs(xx,params);; 2868 for (binz = 0; binz < nz; ++binz) {; 2869 xx[2] = fZaxis.GetBinCenter(binz);; 2870 for (biny = 0; biny < ny; ++biny) {; 2871 xx[1] = fYaxis.GetBinCenter(biny);; 2872 for (binx = 0; binx < nx; ++binx) {; 2873 xx[0] = fXaxis.GetBinCenter(binx);; 2874 if (!f1->IsInside(xx)) continue;; 2875 TF1::RejectPoint(kFALSE);; 2876 bin = binx + nx * (biny + ny * binz);; 2877 cu = c1 * f1->EvalPar(xx);; 2878 if (TF1::RejectedPoint()) continue;; 2879 if (cu) w = RetrieveBinContent(bin) / cu;; 2880 else w = 0;; 2881 UpdateBinContent(bin, w);; 2882 if (fSumw2.fN) {; 2883 if (cu != 0) fSumw2.fArray[bin] = GetBinErrorSqUnchecked(bin) / (cu * cu);; 2884 else fSumw2.fArray[bin] = 0;; 2885 }; 2886 }; 2887 }; 2888 }; 2889 ResetStats();; 2890 return kTRUE;; 2891}; 2892 ; 2893////////////////////////////////////////////////////////////////////////////////; 2894/// Divide this histogram by h1.; 2895///; 2896/// `this = this/h1`; 2897/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 2898/// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; 2899/// if not already set.; 2900/// The resulting errors are calculated assuming uncorrelated histograms.; 2901/// See the other TH1::Divide that gives the possibility to optionally; 2902/// compute binomial errors.; 2903///; 2904/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2905/// you should call Sumw2 before making this operation.; 2906/// This is particularly important if you fit the histogram after TH1::Scale; 2907///; 2908/// The function return kFALSE if the divide operation failed; 2909 ; 2910Bool_t TH1::Divide(const TH1 *h1); 2911{; 2912 if (!h1) {; 2913 Error(""Divide"", ""Input histogram passed does not exist (NULL)."");; 2914 return kFALSE;; 2915 }; 2916 ; 2917 // delete buffer if it is there since it will become invalid; 2918 if (fBuffer) BufferEmpty(1);; 2919 ; 2920 if (LoggedInconsistency(""Divide"", this, h1)",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:114841,Availability,error,errors,114841,"GetBinCenter(biny);; 2872 for (binx = 0; binx < nx; ++binx) {; 2873 xx[0] = fXaxis.GetBinCenter(binx);; 2874 if (!f1->IsInside(xx)) continue;; 2875 TF1::RejectPoint(kFALSE);; 2876 bin = binx + nx * (biny + ny * binz);; 2877 cu = c1 * f1->EvalPar(xx);; 2878 if (TF1::RejectedPoint()) continue;; 2879 if (cu) w = RetrieveBinContent(bin) / cu;; 2880 else w = 0;; 2881 UpdateBinContent(bin, w);; 2882 if (fSumw2.fN) {; 2883 if (cu != 0) fSumw2.fArray[bin] = GetBinErrorSqUnchecked(bin) / (cu * cu);; 2884 else fSumw2.fArray[bin] = 0;; 2885 }; 2886 }; 2887 }; 2888 }; 2889 ResetStats();; 2890 return kTRUE;; 2891}; 2892 ; 2893////////////////////////////////////////////////////////////////////////////////; 2894/// Divide this histogram by h1.; 2895///; 2896/// `this = this/h1`; 2897/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 2898/// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; 2899/// if not already set.; 2900/// The resulting errors are calculated assuming uncorrelated histograms.; 2901/// See the other TH1::Divide that gives the possibility to optionally; 2902/// compute binomial errors.; 2903///; 2904/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2905/// you should call Sumw2 before making this operation.; 2906/// This is particularly important if you fit the histogram after TH1::Scale; 2907///; 2908/// The function return kFALSE if the divide operation failed; 2909 ; 2910Bool_t TH1::Divide(const TH1 *h1); 2911{; 2912 if (!h1) {; 2913 Error(""Divide"", ""Input histogram passed does not exist (NULL)."");; 2914 return kFALSE;; 2915 }; 2916 ; 2917 // delete buffer if it is there since it will become invalid; 2918 if (fBuffer) BufferEmpty(1);; 2919 ; 2920 if (LoggedInconsistency(""Divide"", this, h1) >= kDifferentNumberOfBins) {; 2921 return false;; 2922 }; 2923 ; 2924 // Create Sumw2 if h1 has Sumw2 set; 2925 if (fSumw2.fN == 0 && h1->GetSumw2N() != 0) Sumw2();; 2926 ; 2927 // - Loop on bins (includi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:114999,Availability,error,errors,114999,"(binx);; 2874 if (!f1->IsInside(xx)) continue;; 2875 TF1::RejectPoint(kFALSE);; 2876 bin = binx + nx * (biny + ny * binz);; 2877 cu = c1 * f1->EvalPar(xx);; 2878 if (TF1::RejectedPoint()) continue;; 2879 if (cu) w = RetrieveBinContent(bin) / cu;; 2880 else w = 0;; 2881 UpdateBinContent(bin, w);; 2882 if (fSumw2.fN) {; 2883 if (cu != 0) fSumw2.fArray[bin] = GetBinErrorSqUnchecked(bin) / (cu * cu);; 2884 else fSumw2.fArray[bin] = 0;; 2885 }; 2886 }; 2887 }; 2888 }; 2889 ResetStats();; 2890 return kTRUE;; 2891}; 2892 ; 2893////////////////////////////////////////////////////////////////////////////////; 2894/// Divide this histogram by h1.; 2895///; 2896/// `this = this/h1`; 2897/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 2898/// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; 2899/// if not already set.; 2900/// The resulting errors are calculated assuming uncorrelated histograms.; 2901/// See the other TH1::Divide that gives the possibility to optionally; 2902/// compute binomial errors.; 2903///; 2904/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2905/// you should call Sumw2 before making this operation.; 2906/// This is particularly important if you fit the histogram after TH1::Scale; 2907///; 2908/// The function return kFALSE if the divide operation failed; 2909 ; 2910Bool_t TH1::Divide(const TH1 *h1); 2911{; 2912 if (!h1) {; 2913 Error(""Divide"", ""Input histogram passed does not exist (NULL)."");; 2914 return kFALSE;; 2915 }; 2916 ; 2917 // delete buffer if it is there since it will become invalid; 2918 if (fBuffer) BufferEmpty(1);; 2919 ; 2920 if (LoggedInconsistency(""Divide"", this, h1) >= kDifferentNumberOfBins) {; 2921 return false;; 2922 }; 2923 ; 2924 // Create Sumw2 if h1 has Sumw2 set; 2925 if (fSumw2.fN == 0 && h1->GetSumw2N() != 0) Sumw2();; 2926 ; 2927 // - Loop on bins (including underflows/overflows); 2928 for (Int_t i = 0; i < fNcells; ++i) {; 2929 Double_t c0 = Retri",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:115066,Availability,error,errors,115066,"u = c1 * f1->EvalPar(xx);; 2878 if (TF1::RejectedPoint()) continue;; 2879 if (cu) w = RetrieveBinContent(bin) / cu;; 2880 else w = 0;; 2881 UpdateBinContent(bin, w);; 2882 if (fSumw2.fN) {; 2883 if (cu != 0) fSumw2.fArray[bin] = GetBinErrorSqUnchecked(bin) / (cu * cu);; 2884 else fSumw2.fArray[bin] = 0;; 2885 }; 2886 }; 2887 }; 2888 }; 2889 ResetStats();; 2890 return kTRUE;; 2891}; 2892 ; 2893////////////////////////////////////////////////////////////////////////////////; 2894/// Divide this histogram by h1.; 2895///; 2896/// `this = this/h1`; 2897/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 2898/// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; 2899/// if not already set.; 2900/// The resulting errors are calculated assuming uncorrelated histograms.; 2901/// See the other TH1::Divide that gives the possibility to optionally; 2902/// compute binomial errors.; 2903///; 2904/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2905/// you should call Sumw2 before making this operation.; 2906/// This is particularly important if you fit the histogram after TH1::Scale; 2907///; 2908/// The function return kFALSE if the divide operation failed; 2909 ; 2910Bool_t TH1::Divide(const TH1 *h1); 2911{; 2912 if (!h1) {; 2913 Error(""Divide"", ""Input histogram passed does not exist (NULL)."");; 2914 return kFALSE;; 2915 }; 2916 ; 2917 // delete buffer if it is there since it will become invalid; 2918 if (fBuffer) BufferEmpty(1);; 2919 ; 2920 if (LoggedInconsistency(""Divide"", this, h1) >= kDifferentNumberOfBins) {; 2921 return false;; 2922 }; 2923 ; 2924 // Create Sumw2 if h1 has Sumw2 set; 2925 if (fSumw2.fN == 0 && h1->GetSumw2N() != 0) Sumw2();; 2926 ; 2927 // - Loop on bins (including underflows/overflows); 2928 for (Int_t i = 0; i < fNcells; ++i) {; 2929 Double_t c0 = RetrieveBinContent(i);; 2930 Double_t c1 = h1->RetrieveBinContent(i);; 2931 if (c1) UpdateBinContent(i, c0 / c1);; 2932 else UpdateBinCo",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:116620,Availability,error,errors,116620,") {; 2921 return false;; 2922 }; 2923 ; 2924 // Create Sumw2 if h1 has Sumw2 set; 2925 if (fSumw2.fN == 0 && h1->GetSumw2N() != 0) Sumw2();; 2926 ; 2927 // - Loop on bins (including underflows/overflows); 2928 for (Int_t i = 0; i < fNcells; ++i) {; 2929 Double_t c0 = RetrieveBinContent(i);; 2930 Double_t c1 = h1->RetrieveBinContent(i);; 2931 if (c1) UpdateBinContent(i, c0 / c1);; 2932 else UpdateBinContent(i, 0);; 2933 ; 2934 if(fSumw2.fN) {; 2935 if (c1 == 0) { fSumw2.fArray[i] = 0; continue; }; 2936 Double_t c1sq = c1 * c1;; 2937 fSumw2.fArray[i] = (GetBinErrorSqUnchecked(i) * c1sq + h1->GetBinErrorSqUnchecked(i) * c0 * c0) / (c1sq * c1sq);; 2938 }; 2939 }; 2940 ResetStats();; 2941 return kTRUE;; 2942}; 2943 ; 2944////////////////////////////////////////////////////////////////////////////////; 2945/// Replace contents of this histogram by the division of h1 by h2.; 2946///; 2947/// `this = c1*h1/(c2*h2)`; 2948///; 2949/// If errors are defined (see TH1::Sumw2), errors are also recalculated; 2950/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 2951/// if not already set.; 2952/// The resulting errors are calculated assuming uncorrelated histograms.; 2953/// However, if option =""B"" is specified, Binomial errors are computed.; 2954/// In this case c1 and c2 do not make real sense and they are ignored.; 2955///; 2956/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2957/// you should call Sumw2 before making this operation.; 2958/// This is particularly important if you fit the histogram after TH1::Divide; 2959///; 2960/// Please note also that in the binomial case errors are calculated using standard; 2961/// binomial statistics, which means when b1 = b2, the error is zero.; 2962/// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; 2963/// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; 2964/// error for the case",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:116657,Availability,error,errors,116657,") {; 2921 return false;; 2922 }; 2923 ; 2924 // Create Sumw2 if h1 has Sumw2 set; 2925 if (fSumw2.fN == 0 && h1->GetSumw2N() != 0) Sumw2();; 2926 ; 2927 // - Loop on bins (including underflows/overflows); 2928 for (Int_t i = 0; i < fNcells; ++i) {; 2929 Double_t c0 = RetrieveBinContent(i);; 2930 Double_t c1 = h1->RetrieveBinContent(i);; 2931 if (c1) UpdateBinContent(i, c0 / c1);; 2932 else UpdateBinContent(i, 0);; 2933 ; 2934 if(fSumw2.fN) {; 2935 if (c1 == 0) { fSumw2.fArray[i] = 0; continue; }; 2936 Double_t c1sq = c1 * c1;; 2937 fSumw2.fArray[i] = (GetBinErrorSqUnchecked(i) * c1sq + h1->GetBinErrorSqUnchecked(i) * c0 * c0) / (c1sq * c1sq);; 2938 }; 2939 }; 2940 ResetStats();; 2941 return kTRUE;; 2942}; 2943 ; 2944////////////////////////////////////////////////////////////////////////////////; 2945/// Replace contents of this histogram by the division of h1 by h2.; 2946///; 2947/// `this = c1*h1/(c2*h2)`; 2948///; 2949/// If errors are defined (see TH1::Sumw2), errors are also recalculated; 2950/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 2951/// if not already set.; 2952/// The resulting errors are calculated assuming uncorrelated histograms.; 2953/// However, if option =""B"" is specified, Binomial errors are computed.; 2954/// In this case c1 and c2 do not make real sense and they are ignored.; 2955///; 2956/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2957/// you should call Sumw2 before making this operation.; 2958/// This is particularly important if you fit the histogram after TH1::Divide; 2959///; 2960/// Please note also that in the binomial case errors are calculated using standard; 2961/// binomial statistics, which means when b1 = b2, the error is zero.; 2962/// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; 2963/// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; 2964/// error for the case",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:116824,Availability,error,errors,116824,"p on bins (including underflows/overflows); 2928 for (Int_t i = 0; i < fNcells; ++i) {; 2929 Double_t c0 = RetrieveBinContent(i);; 2930 Double_t c1 = h1->RetrieveBinContent(i);; 2931 if (c1) UpdateBinContent(i, c0 / c1);; 2932 else UpdateBinContent(i, 0);; 2933 ; 2934 if(fSumw2.fN) {; 2935 if (c1 == 0) { fSumw2.fArray[i] = 0; continue; }; 2936 Double_t c1sq = c1 * c1;; 2937 fSumw2.fArray[i] = (GetBinErrorSqUnchecked(i) * c1sq + h1->GetBinErrorSqUnchecked(i) * c0 * c0) / (c1sq * c1sq);; 2938 }; 2939 }; 2940 ResetStats();; 2941 return kTRUE;; 2942}; 2943 ; 2944////////////////////////////////////////////////////////////////////////////////; 2945/// Replace contents of this histogram by the division of h1 by h2.; 2946///; 2947/// `this = c1*h1/(c2*h2)`; 2948///; 2949/// If errors are defined (see TH1::Sumw2), errors are also recalculated; 2950/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 2951/// if not already set.; 2952/// The resulting errors are calculated assuming uncorrelated histograms.; 2953/// However, if option =""B"" is specified, Binomial errors are computed.; 2954/// In this case c1 and c2 do not make real sense and they are ignored.; 2955///; 2956/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2957/// you should call Sumw2 before making this operation.; 2958/// This is particularly important if you fit the histogram after TH1::Divide; 2959///; 2960/// Please note also that in the binomial case errors are calculated using standard; 2961/// binomial statistics, which means when b1 = b2, the error is zero.; 2962/// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; 2963/// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; 2964/// error for the case b1=b2.; 2965///; 2966/// The function return kFALSE if the divide operation failed; 2967 ; 2968Bool_t TH1::Divide(const TH1 *h1, const TH1 *h2, Double_t c1, Dou",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:116936,Availability,error,errors,116936,"; ++i) {; 2929 Double_t c0 = RetrieveBinContent(i);; 2930 Double_t c1 = h1->RetrieveBinContent(i);; 2931 if (c1) UpdateBinContent(i, c0 / c1);; 2932 else UpdateBinContent(i, 0);; 2933 ; 2934 if(fSumw2.fN) {; 2935 if (c1 == 0) { fSumw2.fArray[i] = 0; continue; }; 2936 Double_t c1sq = c1 * c1;; 2937 fSumw2.fArray[i] = (GetBinErrorSqUnchecked(i) * c1sq + h1->GetBinErrorSqUnchecked(i) * c0 * c0) / (c1sq * c1sq);; 2938 }; 2939 }; 2940 ResetStats();; 2941 return kTRUE;; 2942}; 2943 ; 2944////////////////////////////////////////////////////////////////////////////////; 2945/// Replace contents of this histogram by the division of h1 by h2.; 2946///; 2947/// `this = c1*h1/(c2*h2)`; 2948///; 2949/// If errors are defined (see TH1::Sumw2), errors are also recalculated; 2950/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 2951/// if not already set.; 2952/// The resulting errors are calculated assuming uncorrelated histograms.; 2953/// However, if option =""B"" is specified, Binomial errors are computed.; 2954/// In this case c1 and c2 do not make real sense and they are ignored.; 2955///; 2956/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2957/// you should call Sumw2 before making this operation.; 2958/// This is particularly important if you fit the histogram after TH1::Divide; 2959///; 2960/// Please note also that in the binomial case errors are calculated using standard; 2961/// binomial statistics, which means when b1 = b2, the error is zero.; 2962/// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; 2963/// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; 2964/// error for the case b1=b2.; 2965///; 2966/// The function return kFALSE if the divide operation failed; 2967 ; 2968Bool_t TH1::Divide(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 2969{; 2970 ; 2971 TString opt = option;; 2972 op",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:117093,Availability,error,errors,117093,"if(fSumw2.fN) {; 2935 if (c1 == 0) { fSumw2.fArray[i] = 0; continue; }; 2936 Double_t c1sq = c1 * c1;; 2937 fSumw2.fArray[i] = (GetBinErrorSqUnchecked(i) * c1sq + h1->GetBinErrorSqUnchecked(i) * c0 * c0) / (c1sq * c1sq);; 2938 }; 2939 }; 2940 ResetStats();; 2941 return kTRUE;; 2942}; 2943 ; 2944////////////////////////////////////////////////////////////////////////////////; 2945/// Replace contents of this histogram by the division of h1 by h2.; 2946///; 2947/// `this = c1*h1/(c2*h2)`; 2948///; 2949/// If errors are defined (see TH1::Sumw2), errors are also recalculated; 2950/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 2951/// if not already set.; 2952/// The resulting errors are calculated assuming uncorrelated histograms.; 2953/// However, if option =""B"" is specified, Binomial errors are computed.; 2954/// In this case c1 and c2 do not make real sense and they are ignored.; 2955///; 2956/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2957/// you should call Sumw2 before making this operation.; 2958/// This is particularly important if you fit the histogram after TH1::Divide; 2959///; 2960/// Please note also that in the binomial case errors are calculated using standard; 2961/// binomial statistics, which means when b1 = b2, the error is zero.; 2962/// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; 2963/// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; 2964/// error for the case b1=b2.; 2965///; 2966/// The function return kFALSE if the divide operation failed; 2967 ; 2968Bool_t TH1::Divide(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 2969{; 2970 ; 2971 TString opt = option;; 2972 opt.ToLower();; 2973 Bool_t binomial = kFALSE;; 2974 if (opt.Contains(""b"")) binomial = kTRUE;; 2975 if (!h1 || !h2) {; 2976 Error(""Divide"", ""At least one of the input histograms passed does not",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:117329,Availability,error,errors,117329,"/ (c1sq * c1sq);; 2938 }; 2939 }; 2940 ResetStats();; 2941 return kTRUE;; 2942}; 2943 ; 2944////////////////////////////////////////////////////////////////////////////////; 2945/// Replace contents of this histogram by the division of h1 by h2.; 2946///; 2947/// `this = c1*h1/(c2*h2)`; 2948///; 2949/// If errors are defined (see TH1::Sumw2), errors are also recalculated; 2950/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 2951/// if not already set.; 2952/// The resulting errors are calculated assuming uncorrelated histograms.; 2953/// However, if option =""B"" is specified, Binomial errors are computed.; 2954/// In this case c1 and c2 do not make real sense and they are ignored.; 2955///; 2956/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2957/// you should call Sumw2 before making this operation.; 2958/// This is particularly important if you fit the histogram after TH1::Divide; 2959///; 2960/// Please note also that in the binomial case errors are calculated using standard; 2961/// binomial statistics, which means when b1 = b2, the error is zero.; 2962/// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; 2963/// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; 2964/// error for the case b1=b2.; 2965///; 2966/// The function return kFALSE if the divide operation failed; 2967 ; 2968Bool_t TH1::Divide(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 2969{; 2970 ; 2971 TString opt = option;; 2972 opt.ToLower();; 2973 Bool_t binomial = kFALSE;; 2974 if (opt.Contains(""b"")) binomial = kTRUE;; 2975 if (!h1 || !h2) {; 2976 Error(""Divide"", ""At least one of the input histograms passed does not exist (NULL)."");; 2977 return kFALSE;; 2978 }; 2979 ; 2980 // delete buffer if it is there since it will become invalid; 2981 if (fBuffer) BufferEmpty(1);; 2982 ; 2983 if (LoggedInconsistency(""Divide"", ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:117426,Availability,error,error,117426,"/ (c1sq * c1sq);; 2938 }; 2939 }; 2940 ResetStats();; 2941 return kTRUE;; 2942}; 2943 ; 2944////////////////////////////////////////////////////////////////////////////////; 2945/// Replace contents of this histogram by the division of h1 by h2.; 2946///; 2947/// `this = c1*h1/(c2*h2)`; 2948///; 2949/// If errors are defined (see TH1::Sumw2), errors are also recalculated; 2950/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 2951/// if not already set.; 2952/// The resulting errors are calculated assuming uncorrelated histograms.; 2953/// However, if option =""B"" is specified, Binomial errors are computed.; 2954/// In this case c1 and c2 do not make real sense and they are ignored.; 2955///; 2956/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2957/// you should call Sumw2 before making this operation.; 2958/// This is particularly important if you fit the histogram after TH1::Divide; 2959///; 2960/// Please note also that in the binomial case errors are calculated using standard; 2961/// binomial statistics, which means when b1 = b2, the error is zero.; 2962/// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; 2963/// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; 2964/// error for the case b1=b2.; 2965///; 2966/// The function return kFALSE if the divide operation failed; 2967 ; 2968Bool_t TH1::Divide(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 2969{; 2970 ; 2971 TString opt = option;; 2972 opt.ToLower();; 2973 Bool_t binomial = kFALSE;; 2974 if (opt.Contains(""b"")) binomial = kTRUE;; 2975 if (!h1 || !h2) {; 2976 Error(""Divide"", ""At least one of the input histograms passed does not exist (NULL)."");; 2977 return kFALSE;; 2978 }; 2979 ; 2980 // delete buffer if it is there since it will become invalid; 2981 if (fBuffer) BufferEmpty(1);; 2982 ; 2983 if (LoggedInconsistency(""Divide"", ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:117483,Availability,error,errors,117483,"///; 2947/// `this = c1*h1/(c2*h2)`; 2948///; 2949/// If errors are defined (see TH1::Sumw2), errors are also recalculated; 2950/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 2951/// if not already set.; 2952/// The resulting errors are calculated assuming uncorrelated histograms.; 2953/// However, if option =""B"" is specified, Binomial errors are computed.; 2954/// In this case c1 and c2 do not make real sense and they are ignored.; 2955///; 2956/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2957/// you should call Sumw2 before making this operation.; 2958/// This is particularly important if you fit the histogram after TH1::Divide; 2959///; 2960/// Please note also that in the binomial case errors are calculated using standard; 2961/// binomial statistics, which means when b1 = b2, the error is zero.; 2962/// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; 2963/// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; 2964/// error for the case b1=b2.; 2965///; 2966/// The function return kFALSE if the divide operation failed; 2967 ; 2968Bool_t TH1::Divide(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 2969{; 2970 ; 2971 TString opt = option;; 2972 opt.ToLower();; 2973 Bool_t binomial = kFALSE;; 2974 if (opt.Contains(""b"")) binomial = kTRUE;; 2975 if (!h1 || !h2) {; 2976 Error(""Divide"", ""At least one of the input histograms passed does not exist (NULL)."");; 2977 return kFALSE;; 2978 }; 2979 ; 2980 // delete buffer if it is there since it will become invalid; 2981 if (fBuffer) BufferEmpty(1);; 2982 ; 2983 if (LoggedInconsistency(""Divide"", this, h1) >= kDifferentNumberOfBins ||; 2984 LoggedInconsistency(""Divide"", h1, h2) >= kDifferentNumberOfBins) {; 2985 return false;; 2986 }; 2987 ; 2988 if (!c2) {; 2989 Error(""Divide"",""Coefficient of dividing histogram cannot be zero"");; 2990 return ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:117661,Availability,error,error,117661,"///; 2947/// `this = c1*h1/(c2*h2)`; 2948///; 2949/// If errors are defined (see TH1::Sumw2), errors are also recalculated; 2950/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 2951/// if not already set.; 2952/// The resulting errors are calculated assuming uncorrelated histograms.; 2953/// However, if option =""B"" is specified, Binomial errors are computed.; 2954/// In this case c1 and c2 do not make real sense and they are ignored.; 2955///; 2956/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2957/// you should call Sumw2 before making this operation.; 2958/// This is particularly important if you fit the histogram after TH1::Divide; 2959///; 2960/// Please note also that in the binomial case errors are calculated using standard; 2961/// binomial statistics, which means when b1 = b2, the error is zero.; 2962/// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; 2963/// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; 2964/// error for the case b1=b2.; 2965///; 2966/// The function return kFALSE if the divide operation failed; 2967 ; 2968Bool_t TH1::Divide(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 2969{; 2970 ; 2971 TString opt = option;; 2972 opt.ToLower();; 2973 Bool_t binomial = kFALSE;; 2974 if (opt.Contains(""b"")) binomial = kTRUE;; 2975 if (!h1 || !h2) {; 2976 Error(""Divide"", ""At least one of the input histograms passed does not exist (NULL)."");; 2977 return kFALSE;; 2978 }; 2979 ; 2980 // delete buffer if it is there since it will become invalid; 2981 if (fBuffer) BufferEmpty(1);; 2982 ; 2983 if (LoggedInconsistency(""Divide"", this, h1) >= kDifferentNumberOfBins ||; 2984 LoggedInconsistency(""Divide"", h1, h2) >= kDifferentNumberOfBins) {; 2985 return false;; 2986 }; 2987 ; 2988 if (!c2) {; 2989 Error(""Divide"",""Coefficient of dividing histogram cannot be zero"");; 2990 return ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:118651,Availability,error,errors,118651,"n b1 = b2, the error is zero.; 2962/// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; 2963/// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; 2964/// error for the case b1=b2.; 2965///; 2966/// The function return kFALSE if the divide operation failed; 2967 ; 2968Bool_t TH1::Divide(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 2969{; 2970 ; 2971 TString opt = option;; 2972 opt.ToLower();; 2973 Bool_t binomial = kFALSE;; 2974 if (opt.Contains(""b"")) binomial = kTRUE;; 2975 if (!h1 || !h2) {; 2976 Error(""Divide"", ""At least one of the input histograms passed does not exist (NULL)."");; 2977 return kFALSE;; 2978 }; 2979 ; 2980 // delete buffer if it is there since it will become invalid; 2981 if (fBuffer) BufferEmpty(1);; 2982 ; 2983 if (LoggedInconsistency(""Divide"", this, h1) >= kDifferentNumberOfBins ||; 2984 LoggedInconsistency(""Divide"", h1, h2) >= kDifferentNumberOfBins) {; 2985 return false;; 2986 }; 2987 ; 2988 if (!c2) {; 2989 Error(""Divide"",""Coefficient of dividing histogram cannot be zero"");; 2990 return kFALSE;; 2991 }; 2992 ; 2993 // Create Sumw2 if h1 or h2 have Sumw2 set, or if binomial errors are explicitly requested; 2994 if (fSumw2.fN == 0 && (h1->GetSumw2N() != 0 || h2->GetSumw2N() != 0 || binomial)) Sumw2();; 2995 ; 2996 SetMinimum();; 2997 SetMaximum();; 2998 ; 2999 // - Loop on bins (including underflows/overflows); 3000 for (Int_t i = 0; i < fNcells; ++i) {; 3001 Double_t b1 = h1->RetrieveBinContent(i);; 3002 Double_t b2 = h2->RetrieveBinContent(i);; 3003 if (b2) UpdateBinContent(i, c1 * b1 / (c2 * b2));; 3004 else UpdateBinContent(i, 0);; 3005 ; 3006 if (fSumw2.fN) {; 3007 if (b2 == 0) { fSumw2.fArray[i] = 0; continue; }; 3008 Double_t b1sq = b1 * b1; Double_t b2sq = b2 * b2;; 3009 Double_t c1sq = c1 * c1; Double_t c2sq = c2 * c2;; 3010 Double_t e1sq = h1->GetBinErrorSqUnchecked(i);; 3011 Double_t e2sq = h2->GetBinErrorSqUnc",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:120019,Availability,error,error,120019,"if (b2) UpdateBinContent(i, c1 * b1 / (c2 * b2));; 3004 else UpdateBinContent(i, 0);; 3005 ; 3006 if (fSumw2.fN) {; 3007 if (b2 == 0) { fSumw2.fArray[i] = 0; continue; }; 3008 Double_t b1sq = b1 * b1; Double_t b2sq = b2 * b2;; 3009 Double_t c1sq = c1 * c1; Double_t c2sq = c2 * c2;; 3010 Double_t e1sq = h1->GetBinErrorSqUnchecked(i);; 3011 Double_t e2sq = h2->GetBinErrorSqUnchecked(i);; 3012 if (binomial) {; 3013 if (b1 != b2) {; 3014 // in the case of binomial statistics c1 and c2 must be 1 otherwise it does not make sense; 3015 // c1 and c2 are ignored; 3016 //fSumw2.fArray[bin] = TMath::Abs(w*(1-w)/(c2*b2));//this is the formula in Hbook/Hoper1; 3017 //fSumw2.fArray[bin] = TMath::Abs(w*(1-w)/b2); // old formula from G. Flucke; 3018 // formula which works also for weighted histogram (see http://root-forum.cern.ch/viewtopic.php?t=3753 ); 3019 fSumw2.fArray[i] = TMath::Abs( ( (1. - 2.* b1 / b2) * e1sq + b1sq * e2sq / b2sq ) / b2sq );; 3020 } else {; 3021 //in case b1=b2 error is zero; 3022 //use TGraphAsymmErrors::BayesDivide for getting the asymmetric error not equal to zero; 3023 fSumw2.fArray[i] = 0;; 3024 }; 3025 } else {; 3026 fSumw2.fArray[i] = c1sq * c2sq * (e1sq * b2sq + e2sq * b1sq) / (c2sq * c2sq * b2sq * b2sq);; 3027 }; 3028 }; 3029 }; 3030 ResetStats();; 3031 if (binomial); 3032 // in case of binomial division use denominator for number of entries; 3033 SetEntries ( h2->GetEntries() );; 3034 ; 3035 return kTRUE;; 3036}; 3037 ; 3038////////////////////////////////////////////////////////////////////////////////; 3039/// Draw this histogram with options.; 3040///; 3041/// Histograms are drawn via the THistPainter class. Each histogram has; 3042/// a pointer to its own painter (to be usable in a multithreaded program).; 3043/// The same histogram can be drawn with different options in different pads.; 3044/// When a histogram drawn in a pad is deleted, the histogram is; 3045/// automatically removed from the pad or pads where it was drawn.; 3046/// If a histo",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:120103,Availability,error,error,120103,"if (b2) UpdateBinContent(i, c1 * b1 / (c2 * b2));; 3004 else UpdateBinContent(i, 0);; 3005 ; 3006 if (fSumw2.fN) {; 3007 if (b2 == 0) { fSumw2.fArray[i] = 0; continue; }; 3008 Double_t b1sq = b1 * b1; Double_t b2sq = b2 * b2;; 3009 Double_t c1sq = c1 * c1; Double_t c2sq = c2 * c2;; 3010 Double_t e1sq = h1->GetBinErrorSqUnchecked(i);; 3011 Double_t e2sq = h2->GetBinErrorSqUnchecked(i);; 3012 if (binomial) {; 3013 if (b1 != b2) {; 3014 // in the case of binomial statistics c1 and c2 must be 1 otherwise it does not make sense; 3015 // c1 and c2 are ignored; 3016 //fSumw2.fArray[bin] = TMath::Abs(w*(1-w)/(c2*b2));//this is the formula in Hbook/Hoper1; 3017 //fSumw2.fArray[bin] = TMath::Abs(w*(1-w)/b2); // old formula from G. Flucke; 3018 // formula which works also for weighted histogram (see http://root-forum.cern.ch/viewtopic.php?t=3753 ); 3019 fSumw2.fArray[i] = TMath::Abs( ( (1. - 2.* b1 / b2) * e1sq + b1sq * e2sq / b2sq ) / b2sq );; 3020 } else {; 3021 //in case b1=b2 error is zero; 3022 //use TGraphAsymmErrors::BayesDivide for getting the asymmetric error not equal to zero; 3023 fSumw2.fArray[i] = 0;; 3024 }; 3025 } else {; 3026 fSumw2.fArray[i] = c1sq * c2sq * (e1sq * b2sq + e2sq * b1sq) / (c2sq * c2sq * b2sq * b2sq);; 3027 }; 3028 }; 3029 }; 3030 ResetStats();; 3031 if (binomial); 3032 // in case of binomial division use denominator for number of entries; 3033 SetEntries ( h2->GetEntries() );; 3034 ; 3035 return kTRUE;; 3036}; 3037 ; 3038////////////////////////////////////////////////////////////////////////////////; 3039/// Draw this histogram with options.; 3040///; 3041/// Histograms are drawn via the THistPainter class. Each histogram has; 3042/// a pointer to its own painter (to be usable in a multithreaded program).; 3043/// The same histogram can be drawn with different options in different pads.; 3044/// When a histogram drawn in a pad is deleted, the histogram is; 3045/// automatically removed from the pad or pads where it was drawn.; 3046/// If a histo",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:125764,Availability,error,error,125764,"and drawn with option.; 3135/// A pointer to the normalized histogram is returned.; 3136/// The contents of the histogram copy are scaled such that the new; 3137/// sum of weights (excluding under and overflow) is equal to norm.; 3138/// Note that the returned normalized histogram is not added to the list; 3139/// of histograms in the current directory in memory.; 3140/// It is the user's responsibility to delete this histogram.; 3141/// The kCanDelete bit is set for the returned object. If a pad containing; 3142/// this copy is cleared, the histogram will be automatically deleted.; 3143///; 3144/// See Draw for the list of options; 3145 ; 3146TH1 *TH1::DrawNormalized(Option_t *option, Double_t norm) const; 3147{; 3148 Double_t sum = GetSumOfWeights();; 3149 if (sum == 0) {; 3150 Error(""DrawNormalized"",""Sum of weights is null. Cannot normalize histogram: %s"",GetName());; 3151 return nullptr;; 3152 }; 3153 Bool_t addStatus = TH1::AddDirectoryStatus();; 3154 TH1::AddDirectory(kFALSE);; 3155 TH1 *h = (TH1*)Clone();; 3156 h->SetBit(kCanDelete);; 3157 // in case of drawing with error options - scale correctly the error; 3158 TString opt(option); opt.ToUpper();; 3159 if (fSumw2.fN == 0) {; 3160 h->Sumw2();; 3161 // do not use in this case the ""Error option "" for drawing which is enabled by default since the normalized histogram has now errors; 3162 if (opt.IsNull() || opt == ""SAME"") opt += ""HIST"";; 3163 }; 3164 h->Scale(norm/sum);; 3165 if (TMath::Abs(fMaximum+1111) > 1e-3) h->SetMaximum(fMaximum*norm/sum);; 3166 if (TMath::Abs(fMinimum+1111) > 1e-3) h->SetMinimum(fMinimum*norm/sum);; 3167 h->Draw(opt);; 3168 TH1::AddDirectory(addStatus);; 3169 return h;; 3170}; 3171 ; 3172////////////////////////////////////////////////////////////////////////////////; 3173/// Display a panel with all histogram drawing options.; 3174///; 3175/// See class TDrawPanelHist for example; 3176 ; 3177void TH1::DrawPanel(); 3178{; 3179 if (!fPainter) {Draw(); if (gPad) gPad->Update();}; 3180 if (",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:125800,Availability,error,error,125800,"and drawn with option.; 3135/// A pointer to the normalized histogram is returned.; 3136/// The contents of the histogram copy are scaled such that the new; 3137/// sum of weights (excluding under and overflow) is equal to norm.; 3138/// Note that the returned normalized histogram is not added to the list; 3139/// of histograms in the current directory in memory.; 3140/// It is the user's responsibility to delete this histogram.; 3141/// The kCanDelete bit is set for the returned object. If a pad containing; 3142/// this copy is cleared, the histogram will be automatically deleted.; 3143///; 3144/// See Draw for the list of options; 3145 ; 3146TH1 *TH1::DrawNormalized(Option_t *option, Double_t norm) const; 3147{; 3148 Double_t sum = GetSumOfWeights();; 3149 if (sum == 0) {; 3150 Error(""DrawNormalized"",""Sum of weights is null. Cannot normalize histogram: %s"",GetName());; 3151 return nullptr;; 3152 }; 3153 Bool_t addStatus = TH1::AddDirectoryStatus();; 3154 TH1::AddDirectory(kFALSE);; 3155 TH1 *h = (TH1*)Clone();; 3156 h->SetBit(kCanDelete);; 3157 // in case of drawing with error options - scale correctly the error; 3158 TString opt(option); opt.ToUpper();; 3159 if (fSumw2.fN == 0) {; 3160 h->Sumw2();; 3161 // do not use in this case the ""Error option "" for drawing which is enabled by default since the normalized histogram has now errors; 3162 if (opt.IsNull() || opt == ""SAME"") opt += ""HIST"";; 3163 }; 3164 h->Scale(norm/sum);; 3165 if (TMath::Abs(fMaximum+1111) > 1e-3) h->SetMaximum(fMaximum*norm/sum);; 3166 if (TMath::Abs(fMinimum+1111) > 1e-3) h->SetMinimum(fMinimum*norm/sum);; 3167 h->Draw(opt);; 3168 TH1::AddDirectory(addStatus);; 3169 return h;; 3170}; 3171 ; 3172////////////////////////////////////////////////////////////////////////////////; 3173/// Display a panel with all histogram drawing options.; 3174///; 3175/// See class TDrawPanelHist for example; 3176 ; 3177void TH1::DrawPanel(); 3178{; 3179 if (!fPainter) {Draw(); if (gPad) gPad->Update();}; 3180 if (",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:126026,Availability,error,errors,126026,"is not added to the list; 3139/// of histograms in the current directory in memory.; 3140/// It is the user's responsibility to delete this histogram.; 3141/// The kCanDelete bit is set for the returned object. If a pad containing; 3142/// this copy is cleared, the histogram will be automatically deleted.; 3143///; 3144/// See Draw for the list of options; 3145 ; 3146TH1 *TH1::DrawNormalized(Option_t *option, Double_t norm) const; 3147{; 3148 Double_t sum = GetSumOfWeights();; 3149 if (sum == 0) {; 3150 Error(""DrawNormalized"",""Sum of weights is null. Cannot normalize histogram: %s"",GetName());; 3151 return nullptr;; 3152 }; 3153 Bool_t addStatus = TH1::AddDirectoryStatus();; 3154 TH1::AddDirectory(kFALSE);; 3155 TH1 *h = (TH1*)Clone();; 3156 h->SetBit(kCanDelete);; 3157 // in case of drawing with error options - scale correctly the error; 3158 TString opt(option); opt.ToUpper();; 3159 if (fSumw2.fN == 0) {; 3160 h->Sumw2();; 3161 // do not use in this case the ""Error option "" for drawing which is enabled by default since the normalized histogram has now errors; 3162 if (opt.IsNull() || opt == ""SAME"") opt += ""HIST"";; 3163 }; 3164 h->Scale(norm/sum);; 3165 if (TMath::Abs(fMaximum+1111) > 1e-3) h->SetMaximum(fMaximum*norm/sum);; 3166 if (TMath::Abs(fMinimum+1111) > 1e-3) h->SetMinimum(fMinimum*norm/sum);; 3167 h->Draw(opt);; 3168 TH1::AddDirectory(addStatus);; 3169 return h;; 3170}; 3171 ; 3172////////////////////////////////////////////////////////////////////////////////; 3173/// Display a panel with all histogram drawing options.; 3174///; 3175/// See class TDrawPanelHist for example; 3176 ; 3177void TH1::DrawPanel(); 3178{; 3179 if (!fPainter) {Draw(); if (gPad) gPad->Update();}; 3180 if (fPainter) fPainter->DrawPanel();; 3181}; 3182 ; 3183////////////////////////////////////////////////////////////////////////////////; 3184/// Evaluate function f1 at the center of bins of this histogram.; 3185///; 3186/// - If option ""R"" is specified, the function is evaluated onl",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:153302,Availability,avail,available,153302,"n binz;; 3848 }; 3849 }; 3850 }; 3851 }; 3852 ; 3853 return -1;; 3854}; 3855 ; 3856////////////////////////////////////////////////////////////////////////////////; 3857/// Search object named name in the list of functions.; 3858 ; 3859TObject *TH1::FindObject(const char *name) const; 3860{; 3861 if (fFunctions) return fFunctions->FindObject(name);; 3862 return nullptr;; 3863}; 3864 ; 3865////////////////////////////////////////////////////////////////////////////////; 3866/// Search object obj in the list of functions.; 3867 ; 3868TObject *TH1::FindObject(const TObject *obj) const; 3869{; 3870 if (fFunctions) return fFunctions->FindObject(obj);; 3871 return nullptr;; 3872}; 3873 ; 3874////////////////////////////////////////////////////////////////////////////////; 3875/// Fit histogram with function fname.; 3876///; 3877///; 3878/// fname is the name of a function available in the global ROOT list of functions; 3879/// `gROOT->GetListOfFunctions`; 3880/// The list include any TF1 object created by the user plus some pre-defined functions; 3881/// which are automatically created by ROOT the first time a pre-defined function is requested from `gROOT`; 3882/// (i.e. when calling `gROOT->GetFunction(const char *name)`).; 3883/// These pre-defined functions are:; 3884/// - `gaus, gausn` where gausn is the normalized Gaussian; 3885/// - `landau, landaun`; 3886/// - `expo`; 3887/// - `pol1,...9, chebyshev1,...9`.; 3888///; 3889/// For printing the list of all available functions do:; 3890///; 3891/// TF1::InitStandardFunctions(); // not needed if `gROOT->GetFunction` is called before; 3892/// gROOT->GetListOfFunctions()->ls(); 3893///; 3894/// `fname` can also be a formula that is accepted by the linear fitter containing the special operator `++`,; 3895/// representing linear components separated by `++` sign, for example `x++sin(x)` for fitting `[0]*x+[1]*sin(x)`; 3896///; 3897/// This function finds a pointer to the TF1 object with name `fname` and calls TH1::Fit(TF1 *",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:153902,Availability,avail,available,153902,"////////////////////////////////; 3875/// Fit histogram with function fname.; 3876///; 3877///; 3878/// fname is the name of a function available in the global ROOT list of functions; 3879/// `gROOT->GetListOfFunctions`; 3880/// The list include any TF1 object created by the user plus some pre-defined functions; 3881/// which are automatically created by ROOT the first time a pre-defined function is requested from `gROOT`; 3882/// (i.e. when calling `gROOT->GetFunction(const char *name)`).; 3883/// These pre-defined functions are:; 3884/// - `gaus, gausn` where gausn is the normalized Gaussian; 3885/// - `landau, landaun`; 3886/// - `expo`; 3887/// - `pol1,...9, chebyshev1,...9`.; 3888///; 3889/// For printing the list of all available functions do:; 3890///; 3891/// TF1::InitStandardFunctions(); // not needed if `gROOT->GetFunction` is called before; 3892/// gROOT->GetListOfFunctions()->ls(); 3893///; 3894/// `fname` can also be a formula that is accepted by the linear fitter containing the special operator `++`,; 3895/// representing linear components separated by `++` sign, for example `x++sin(x)` for fitting `[0]*x+[1]*sin(x)`; 3896///; 3897/// This function finds a pointer to the TF1 object with name `fname` and calls TH1::Fit(TF1 *, Option_t *, Option_t *,; 3898/// Double_t, Double_t). See there for the fitting options and the details about fitting histograms; 3899 ; 3900TFitResultPtr TH1::Fit(const char *fname ,Option_t *option ,Option_t *goption, Double_t xxmin, Double_t xxmax); 3901{; 3902 char *linear;; 3903 linear= (char*)strstr(fname, ""++"");; 3904 Int_t ndim=GetDimension();; 3905 if (linear){; 3906 if (ndim<2){; 3907 TF1 f1(fname, fname, xxmin, xxmax);; 3908 return Fit(&f1,option,goption,xxmin,xxmax);; 3909 }; 3910 else if (ndim<3){; 3911 TF2 f2(fname, fname);; 3912 return Fit(&f2,option,goption,xxmin,xxmax);; 3913 }; 3914 else{; 3915 TF3 f3(fname, fname);; 3916 return Fit(&f3,option,goption,xxmin,xxmax);; 3917 }; 3918 }; 3919 else{; 3920 TF1 * f1 = (TF1",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:156621,Availability,error,errors,156621,"ion specify a list of graphics options. See TH1::Draw for a complete list of these options.; 3932/// \param[in] xxmin lower fitting range; 3933/// \param[in] xxmax upper fitting range; 3934/// \return A smart pointer to the TFitResult class; 3935///; 3936/// \anchor HFitOpt; 3937/// ### Histogram Fitting Options; 3938///; 3939/// Here is the full list of fit options that can be given in the parameter `option`.; 3940/// Several options can be used together by concatanating the strings without the need of any delimiters.; 3941///; 3942/// option | description; 3943/// -------|------------; 3944/// ""L"" | Uses a log likelihood method (default is chi-square method). To be used when the histogram represents counts.; 3945/// ""WL"" | Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1. This is needed for getting correct parameter uncertainties for weighted fits.; 3946/// ""P"" | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.; 3947/// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; 3948/// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; 3949/// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; 3950/// ""I"" | Uses the integral of function in the bin instead of the default bin center value.; 3951/// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; 3952/// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; 3953/// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; 3954/// ""M"" | Uses the IMPRO",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:156685,Availability,error,error,156685,"these options.; 3932/// \param[in] xxmin lower fitting range; 3933/// \param[in] xxmax upper fitting range; 3934/// \return A smart pointer to the TFitResult class; 3935///; 3936/// \anchor HFitOpt; 3937/// ### Histogram Fitting Options; 3938///; 3939/// Here is the full list of fit options that can be given in the parameter `option`.; 3940/// Several options can be used together by concatanating the strings without the need of any delimiters.; 3941///; 3942/// option | description; 3943/// -------|------------; 3944/// ""L"" | Uses a log likelihood method (default is chi-square method). To be used when the histogram represents counts.; 3945/// ""WL"" | Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1. This is needed for getting correct parameter uncertainties for weighted fits.; 3946/// ""P"" | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.; 3947/// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; 3948/// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; 3949/// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; 3950/// ""I"" | Uses the integral of function in the bin instead of the default bin center value.; 3951/// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; 3952/// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; 3953/// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; 3954/// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve th",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:157542,Availability,error,errors,157542,"parameter uncertainties for weighted fits.; 3946/// ""P"" | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.; 3947/// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; 3948/// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; 3949/// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; 3950/// ""I"" | Uses the integral of function in the bin instead of the default bin center value.; 3951/// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; 3952/// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; 3953/// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; 3954/// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; 3955/// ""S"" | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT::Math::FitResult`.; 3956/// ""Q"" | Quiet mode (minimum printing); 3957/// ""V"" | Verbose mode (default is between Q and V); 3958/// ""+"" | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.; 3959/// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; 3960/// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; 3961",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:157653,Availability,avail,available,157653,"bserved one (default case). The expected error is instead estimated from the square-root of the bin function value.; 3947/// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; 3948/// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; 3949/// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; 3950/// ""I"" | Uses the integral of function in the bin instead of the default bin center value.; 3951/// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; 3952/// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; 3953/// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; 3954/// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; 3955/// ""S"" | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT::Math::FitResult`.; 3956/// ""Q"" | Quiet mode (minimum printing); 3957/// ""V"" | Verbose mode (default is between Q and V); 3958/// ""+"" | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.; 3959/// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; 3960/// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; 3961/// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; 3962/// ""B"" | Use this option when yo",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:159721,Availability,error,errors,159721,"eters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; 3963/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 3964/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 3965/// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); 3966/// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; 3967/// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; 3968///; 3969/// The default fitting of an histogram (when no option is given) is perfomed as following:; 3970/// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; 3971/// - the full range of the histogram is used;; 3972/// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; 3973/// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; 3974/// - only the status of the fit is returned;; 3975/// - the fit is performed in Multithread whenever is enabled in ROOT;; 3976/// - only the last fitted function is saved in the histogram;; 3977/// - the histogram is drawn after fitting overalyed with the resulting fitting function; 3978///; 3979/// \anchor HFitMinimizer; 3980/// ### Minimizer Configuration; 3981///; 3982/// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; 3983/// It is possible to change the default minimizer and its configuration parameters by calling thes",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:159757,Availability,error,errors,159757,"eters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; 3963/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 3964/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 3965/// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); 3966/// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; 3967/// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; 3968///; 3969/// The default fitting of an histogram (when no option is given) is perfomed as following:; 3970/// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; 3971/// - the full range of the histogram is used;; 3972/// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; 3973/// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; 3974/// - only the status of the fit is returned;; 3975/// - the fit is performed in Multithread whenever is enabled in ROOT;; 3976/// - only the last fitted function is saved in the histogram;; 3977/// - the histogram is drawn after fitting overalyed with the resulting fitting function; 3978///; 3979/// \anchor HFitMinimizer; 3980/// ### Minimizer Configuration; 3981///; 3982/// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; 3983/// It is possible to change the default minimizer and its configuration parameters by calling thes",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:161227,Availability,avail,available,161227,"d in ROOT;; 3976/// - only the last fitted function is saved in the histogram;; 3977/// - the histogram is drawn after fitting overalyed with the resulting fitting function; 3978///; 3979/// \anchor HFitMinimizer; 3980/// ### Minimizer Configuration; 3981///; 3982/// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; 3983/// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; 3984/// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; 3985/// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; 3986/// The current defaults are (""Minuit"",""Migrad"").; 3987/// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; 3988/// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; 3989/// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; 3990/// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; 3991///; 3992/// Other options are possible depending on the Minimizer used, see the corresponding documentation.; 3993/// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; 3994///; 3995/// ~~~ {.cpp}; 3996/// Root.Fitter: Minuit2; 3997/// ~~~; 3998///; 3999/// \anchor HFitChi2; 4000/// ### Chi-square Fits; 4001///; 4002/// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; 4003/// is used where the resid",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:161379,Availability,toler,tolerance,161379,"yed with the resulting fitting function; 3978///; 3979/// \anchor HFitMinimizer; 3980/// ### Minimizer Configuration; 3981///; 3982/// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; 3983/// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; 3984/// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; 3985/// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; 3986/// The current defaults are (""Minuit"",""Migrad"").; 3987/// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; 3988/// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; 3989/// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; 3990/// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; 3991///; 3992/// Other options are possible depending on the Minimizer used, see the corresponding documentation.; 3993/// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; 3994///; 3995/// ~~~ {.cpp}; 3996/// Root.Fitter: Minuit2; 3997/// ~~~; 3998///; 3999/// \anchor HFitChi2; 4000/// ### Chi-square Fits; 4001///; 4002/// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; 4003/// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; 4004///; 4005/// \f[; 4",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:162258,Availability,error,error,162258,"tolerance value for the minimization.; 3989/// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; 3990/// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; 3991///; 3992/// Other options are possible depending on the Minimizer used, see the corresponding documentation.; 3993/// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; 3994///; 3995/// ~~~ {.cpp}; 3996/// Root.Fitter: Minuit2; 3997/// ~~~; 3998///; 3999/// \anchor HFitChi2; 4000/// ### Chi-square Fits; 4001///; 4002/// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; 4003/// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; 4004///; 4005/// \f[; 4006/// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; 4007/// \f]; 4008///; 4009/// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; 4010/// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; 4011/// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; 4012/// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; 4013/// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; 4014/// In this case empty bins are considered in the fit.; 4015/// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; 4016/// because they could return a biased result.; 4017///; 4018/// \anchor HFitNLL; 4019/// ### Likelihood Fits; 4020///; 4021/// W",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:162292,Availability,error,error,162292,"tolerance value for the minimization.; 3989/// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; 3990/// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; 3991///; 3992/// Other options are possible depending on the Minimizer used, see the corresponding documentation.; 3993/// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; 3994///; 3995/// ~~~ {.cpp}; 3996/// Root.Fitter: Minuit2; 3997/// ~~~; 3998///; 3999/// \anchor HFitChi2; 4000/// ### Chi-square Fits; 4001///; 4002/// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; 4003/// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; 4004///; 4005/// \f[; 4006/// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; 4007/// \f]; 4008///; 4009/// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; 4010/// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; 4011/// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; 4012/// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; 4013/// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; 4014/// In this case empty bins are considered in the fit.; 4015/// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; 4016/// because they could return a biased result.; 4017///; 4018/// \anchor HFitNLL; 4019/// ### Likelihood Fits; 4020///; 4021/// W",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:162557,Availability,error,error,162557,"tolerance value for the minimization.; 3989/// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; 3990/// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; 3991///; 3992/// Other options are possible depending on the Minimizer used, see the corresponding documentation.; 3993/// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; 3994///; 3995/// ~~~ {.cpp}; 3996/// Root.Fitter: Minuit2; 3997/// ~~~; 3998///; 3999/// \anchor HFitChi2; 4000/// ### Chi-square Fits; 4001///; 4002/// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; 4003/// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; 4004///; 4005/// \f[; 4006/// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; 4007/// \f]; 4008///; 4009/// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; 4010/// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; 4011/// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; 4012/// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; 4013/// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; 4014/// In this case empty bins are considered in the fit.; 4015/// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; 4016/// because they could return a biased result.; 4017///; 4018/// \anchor HFitNLL; 4019/// ### Likelihood Fits; 4020///; 4021/// W",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:162631,Availability,error,errors,162631," from level=0 (minimal printing) to level=3 maximum printing; 3991///; 3992/// Other options are possible depending on the Minimizer used, see the corresponding documentation.; 3993/// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; 3994///; 3995/// ~~~ {.cpp}; 3996/// Root.Fitter: Minuit2; 3997/// ~~~; 3998///; 3999/// \anchor HFitChi2; 4000/// ### Chi-square Fits; 4001///; 4002/// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; 4003/// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; 4004///; 4005/// \f[; 4006/// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; 4007/// \f]; 4008///; 4009/// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; 4010/// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; 4011/// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; 4012/// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; 4013/// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; 4014/// In this case empty bins are considered in the fit.; 4015/// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; 4016/// because they could return a biased result.; 4017///; 4018/// \anchor HFitNLL; 4019/// ### Likelihood Fits; 4020///; 4021/// When using option ""L"" a likelihood fit is used instead of the default chi-square fit.; 4022/// The likelihood is built assuming a Poisson probability density function for each bin.; 4023/// The negative log-likelihood to be minimized is; 4024///; 4025/// \f[; 4",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:163001,Availability,error,error,163001,"/; 3999/// \anchor HFitChi2; 4000/// ### Chi-square Fits; 4001///; 4002/// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; 4003/// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; 4004///; 4005/// \f[; 4006/// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; 4007/// \f]; 4008///; 4009/// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; 4010/// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; 4011/// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; 4012/// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; 4013/// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; 4014/// In this case empty bins are considered in the fit.; 4015/// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; 4016/// because they could return a biased result.; 4017///; 4018/// \anchor HFitNLL; 4019/// ### Likelihood Fits; 4020///; 4021/// When using option ""L"" a likelihood fit is used instead of the default chi-square fit.; 4022/// The likelihood is built assuming a Poisson probability density function for each bin.; 4023/// The negative log-likelihood to be minimized is; 4024///; 4025/// \f[; 4026/// NLL = - \sum_{i}{ \log {\mathrm P} ( y(i) | f(x(i) | p ) ) }; 4027/// \f]; 4028/// where `P(y|f)` is the Poisson distribution of observing a count `y(i)` in the bin when the expected count is `f(x(i)|p)`.; 4029/// The exact likelihood used is the Poisson likelihood described in this paper:; 4030/// S. Baker and R. D. Cousins, “Clarification of the",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:164427,Availability,error,errors,164427,"the default chi-square fit.; 4022/// The likelihood is built assuming a Poisson probability density function for each bin.; 4023/// The negative log-likelihood to be minimized is; 4024///; 4025/// \f[; 4026/// NLL = - \sum_{i}{ \log {\mathrm P} ( y(i) | f(x(i) | p ) ) }; 4027/// \f]; 4028/// where `P(y|f)` is the Poisson distribution of observing a count `y(i)` in the bin when the expected count is `f(x(i)|p)`.; 4029/// The exact likelihood used is the Poisson likelihood described in this paper:; 4030/// S. Baker and R. D. Cousins, “Clarification of the use of chi-square and likelihood functions in fits to histograms,”; 4031/// Nucl. Instrum. Meth. 221 (1984) 437.; 4032///; 4033/// \f[; 4034/// NLL = \sum_{i}{( f(x(i) | p ) + y(i)\log(y(i)/ f(x(i) | p )) - y(i)) }; 4035/// \f]; 4036/// By using this formulation, `2*NLL` can be interpreted as the chi-square resulting from the fit.; 4037///; 4038/// This method should be always used when the bin content represents counts (i.e. errors are sqrt(N) ).; 4039/// The likelihood method has the advantage of treating correctly bins with low statistics. In case of high; 4040/// statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit; 4041/// give the same result.; 4042///; 4043/// The likelihood method, although a bit slower, it is therefore the recommended method,; 4044/// when the histogram represent counts (Poisson statistics), where the chi-square methods may; 4045/// give incorrect results, especially in case of low statistics.; 4046/// In case of a weighted histogram, it is possible to perform also a likelihood fit by using the; 4047/// option ""WL"". Note a weighted histogram is a histogram which has been filled with weights and it; 4048/// has the information on the sum of the weight square for each bin ( TH1::Sumw2() has been called).; 4049/// The bin error for a weighted histogram is the square root of the sum of the weight square.; 4050///; 4051/// \anchor HF",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:165326,Availability,error,error,165326,"d should be always used when the bin content represents counts (i.e. errors are sqrt(N) ).; 4039/// The likelihood method has the advantage of treating correctly bins with low statistics. In case of high; 4040/// statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit; 4041/// give the same result.; 4042///; 4043/// The likelihood method, although a bit slower, it is therefore the recommended method,; 4044/// when the histogram represent counts (Poisson statistics), where the chi-square methods may; 4045/// give incorrect results, especially in case of low statistics.; 4046/// In case of a weighted histogram, it is possible to perform also a likelihood fit by using the; 4047/// option ""WL"". Note a weighted histogram is a histogram which has been filled with weights and it; 4048/// has the information on the sum of the weight square for each bin ( TH1::Sumw2() has been called).; 4049/// The bin error for a weighted histogram is the square root of the sum of the weight square.; 4050///; 4051/// \anchor HFitRes; 4052/// ### Fit Result; 4053///; 4054/// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; 4055/// By default the TFitResultPtr contains only the status of the fit which is return by an; 4056/// automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; 4057///; 4058/// ~~~ {.cpp}; 4059/// Int_t fitStatus = h->Fit(myFunc);; 4060/// ~~~; 4061///; 4062/// If the option ""S"" is instead used, TFitResultPtr behaves as a smart; 4063/// pointer to the TFitResult object. This is useful for retrieving the full result information from the fit, such as the covariance matrix,; 4064/// as shown in this example code:; 4065///; 4066/// ~~~ {.cpp}; 4067/// TFitResultPtr r = h->Fit(myFunc,""S"");; 4068/// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; 4069/// Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; 40",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:166496,Availability,error,error,166496,"urns a TFitResultPtr which can hold a pointer to a TFitResult object.; 4055/// By default the TFitResultPtr contains only the status of the fit which is return by an; 4056/// automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; 4057///; 4058/// ~~~ {.cpp}; 4059/// Int_t fitStatus = h->Fit(myFunc);; 4060/// ~~~; 4061///; 4062/// If the option ""S"" is instead used, TFitResultPtr behaves as a smart; 4063/// pointer to the TFitResult object. This is useful for retrieving the full result information from the fit, such as the covariance matrix,; 4064/// as shown in this example code:; 4065///; 4066/// ~~~ {.cpp}; 4067/// TFitResultPtr r = h->Fit(myFunc,""S"");; 4068/// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; 4069/// Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; 4070/// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; 4071/// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; 4072/// r->Print(""V""); // print full information of fit including covariance matrix; 4073/// r->Write(); // store the result in a file; 4074/// ~~~; 4075///; 4076/// The fit parameters, error and chi-square (but not covariance matrix) can be retrieved also; 4077/// directly from the fitted function that is passed to this call.; 4078/// Given a pointer to an associated fitted function `myfunc`, one can retrieve the function/fit; 4079/// parameters with calls such as:; 4080///; 4081/// ~~~ {.cpp}; 4082/// Double_t chi2 = myfunc->GetChisquare();; 4083/// Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; 4084/// Double_t err0 = myfunc->GetParError(0); //error on first parameter; 4085/// ~~~; 4086///; 4087/// ##### Associated functions; 4088///; 4089/// One or more object ( can be added to the list; 4090/// of functions (fFunctions) associated to each histogram.; 4091/// When TH1::Fit is invoked, the fitted function is added to the histogram list of fu",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:166709,Availability,error,error,166709,"urns a TFitResultPtr which can hold a pointer to a TFitResult object.; 4055/// By default the TFitResultPtr contains only the status of the fit which is return by an; 4056/// automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; 4057///; 4058/// ~~~ {.cpp}; 4059/// Int_t fitStatus = h->Fit(myFunc);; 4060/// ~~~; 4061///; 4062/// If the option ""S"" is instead used, TFitResultPtr behaves as a smart; 4063/// pointer to the TFitResult object. This is useful for retrieving the full result information from the fit, such as the covariance matrix,; 4064/// as shown in this example code:; 4065///; 4066/// ~~~ {.cpp}; 4067/// TFitResultPtr r = h->Fit(myFunc,""S"");; 4068/// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; 4069/// Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; 4070/// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; 4071/// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; 4072/// r->Print(""V""); // print full information of fit including covariance matrix; 4073/// r->Write(); // store the result in a file; 4074/// ~~~; 4075///; 4076/// The fit parameters, error and chi-square (but not covariance matrix) can be retrieved also; 4077/// directly from the fitted function that is passed to this call.; 4078/// Given a pointer to an associated fitted function `myfunc`, one can retrieve the function/fit; 4079/// parameters with calls such as:; 4080///; 4081/// ~~~ {.cpp}; 4082/// Double_t chi2 = myfunc->GetChisquare();; 4083/// Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; 4084/// Double_t err0 = myfunc->GetParError(0); //error on first parameter; 4085/// ~~~; 4086///; 4087/// ##### Associated functions; 4088///; 4089/// One or more object ( can be added to the list; 4090/// of functions (fFunctions) associated to each histogram.; 4091/// When TH1::Fit is invoked, the fitted function is added to the histogram list of fu",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:167198,Availability,error,error,167198,"MatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; 4069/// Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; 4070/// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; 4071/// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; 4072/// r->Print(""V""); // print full information of fit including covariance matrix; 4073/// r->Write(); // store the result in a file; 4074/// ~~~; 4075///; 4076/// The fit parameters, error and chi-square (but not covariance matrix) can be retrieved also; 4077/// directly from the fitted function that is passed to this call.; 4078/// Given a pointer to an associated fitted function `myfunc`, one can retrieve the function/fit; 4079/// parameters with calls such as:; 4080///; 4081/// ~~~ {.cpp}; 4082/// Double_t chi2 = myfunc->GetChisquare();; 4083/// Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; 4084/// Double_t err0 = myfunc->GetParError(0); //error on first parameter; 4085/// ~~~; 4086///; 4087/// ##### Associated functions; 4088///; 4089/// One or more object ( can be added to the list; 4090/// of functions (fFunctions) associated to each histogram.; 4091/// When TH1::Fit is invoked, the fitted function is added to the histogram list of functions (fFunctions).; 4092/// If the histogram is made persistent, the list of associated functions is also persistent.; 4093/// Given a histogram h, one can retrieve an associated function with:; 4094///; 4095/// ~~~ {.cpp}; 4096/// TF1 *myfunc = h->GetFunction(""myfunc"");; 4097/// ~~~; 4098/// or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; 4099///; 4100/// \anchor HFitStatus; 4101/// ### Fit status; 4102///; 4103/// The status of the fit is obtained converting the TFitResultPtr to an integer; 4104/// independently if the fit option ""S"" is used or not:; 4105///; 4106/// ~~~ {.cpp}; 4107/// TFitResultPtr r = h->Fit(myFunc,opt);; 4108/// Int_t fitStatus = r;; 4109/// ~~~; ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:168296,Availability,error,error,168296,"e or more object ( can be added to the list; 4090/// of functions (fFunctions) associated to each histogram.; 4091/// When TH1::Fit is invoked, the fitted function is added to the histogram list of functions (fFunctions).; 4092/// If the histogram is made persistent, the list of associated functions is also persistent.; 4093/// Given a histogram h, one can retrieve an associated function with:; 4094///; 4095/// ~~~ {.cpp}; 4096/// TF1 *myfunc = h->GetFunction(""myfunc"");; 4097/// ~~~; 4098/// or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; 4099///; 4100/// \anchor HFitStatus; 4101/// ### Fit status; 4102///; 4103/// The status of the fit is obtained converting the TFitResultPtr to an integer; 4104/// independently if the fit option ""S"" is used or not:; 4105///; 4106/// ~~~ {.cpp}; 4107/// TFitResultPtr r = h->Fit(myFunc,opt);; 4108/// Int_t fitStatus = r;; 4109/// ~~~; 4110///; 4111/// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; 4112/// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; 4113/// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; 4114/// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; 4115/// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; 4116/// only in Minos but not in Migrad a fitStatus of 40 will be returned.; 4117/// Minuit2 returns 0 in case of success and different values in migrad,minos or; 4118/// hesse depending on the error. See in this case the documentation of; 4119/// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; 4120/// minos return status and Minuit2Minimizer::Hesse for the hesse return status.; 4121/// If other minimize",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:168351,Availability,error,error,168351," associated to each histogram.; 4091/// When TH1::Fit is invoked, the fitted function is added to the histogram list of functions (fFunctions).; 4092/// If the histogram is made persistent, the list of associated functions is also persistent.; 4093/// Given a histogram h, one can retrieve an associated function with:; 4094///; 4095/// ~~~ {.cpp}; 4096/// TF1 *myfunc = h->GetFunction(""myfunc"");; 4097/// ~~~; 4098/// or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; 4099///; 4100/// \anchor HFitStatus; 4101/// ### Fit status; 4102///; 4103/// The status of the fit is obtained converting the TFitResultPtr to an integer; 4104/// independently if the fit option ""S"" is used or not:; 4105///; 4106/// ~~~ {.cpp}; 4107/// TFitResultPtr r = h->Fit(myFunc,opt);; 4108/// Int_t fitStatus = r;; 4109/// ~~~; 4110///; 4111/// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; 4112/// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; 4113/// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; 4114/// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; 4115/// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; 4116/// only in Minos but not in Migrad a fitStatus of 40 will be returned.; 4117/// Minuit2 returns 0 in case of success and different values in migrad,minos or; 4118/// hesse depending on the error. See in this case the documentation of; 4119/// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; 4120/// minos return status and Minuit2Minimizer::Hesse for the hesse return status.; 4121/// If other minimizers are used see their specific documentation for the status code returned.; 4",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:168768,Availability,error,error,168768,"myfunc = h->GetFunction(""myfunc"");; 4097/// ~~~; 4098/// or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; 4099///; 4100/// \anchor HFitStatus; 4101/// ### Fit status; 4102///; 4103/// The status of the fit is obtained converting the TFitResultPtr to an integer; 4104/// independently if the fit option ""S"" is used or not:; 4105///; 4106/// ~~~ {.cpp}; 4107/// TFitResultPtr r = h->Fit(myFunc,opt);; 4108/// Int_t fitStatus = r;; 4109/// ~~~; 4110///; 4111/// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; 4112/// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; 4113/// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; 4114/// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; 4115/// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; 4116/// only in Minos but not in Migrad a fitStatus of 40 will be returned.; 4117/// Minuit2 returns 0 in case of success and different values in migrad,minos or; 4118/// hesse depending on the error. See in this case the documentation of; 4119/// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; 4120/// minos return status and Minuit2Minimizer::Hesse for the hesse return status.; 4121/// If other minimizers are used see their specific documentation for the status code returned.; 4122/// For example in the case of Fumili, see TFumili::Minimize.; 4123///; 4124/// \anchor HFitRange; 4125/// ### Fitting in a range; 4126///; 4127/// In order to fit in a sub-range of the histogram you have two options:; 4128/// - pass to this function the lower (`xxmin`) and upper (`xxmax`) values for the fitting range;; 4129/// - define a specific range in t",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:168838,Availability,error,error,168838,"ctions`.; 4099///; 4100/// \anchor HFitStatus; 4101/// ### Fit status; 4102///; 4103/// The status of the fit is obtained converting the TFitResultPtr to an integer; 4104/// independently if the fit option ""S"" is used or not:; 4105///; 4106/// ~~~ {.cpp}; 4107/// TFitResultPtr r = h->Fit(myFunc,opt);; 4108/// Int_t fitStatus = r;; 4109/// ~~~; 4110///; 4111/// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; 4112/// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; 4113/// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; 4114/// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; 4115/// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; 4116/// only in Minos but not in Migrad a fitStatus of 40 will be returned.; 4117/// Minuit2 returns 0 in case of success and different values in migrad,minos or; 4118/// hesse depending on the error. See in this case the documentation of; 4119/// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; 4120/// minos return status and Minuit2Minimizer::Hesse for the hesse return status.; 4121/// If other minimizers are used see their specific documentation for the status code returned.; 4122/// For example in the case of Fumili, see TFumili::Minimize.; 4123///; 4124/// \anchor HFitRange; 4125/// ### Fitting in a range; 4126///; 4127/// In order to fit in a sub-range of the histogram you have two options:; 4128/// - pass to this function the lower (`xxmin`) and upper (`xxmax`) values for the fitting range;; 4129/// - define a specific range in the fitted function and use the fitting option ""R"".; 4130/// For example, if your histogram has a defined range between -4 and 4",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:169039,Availability,error,error,169039,"btained converting the TFitResultPtr to an integer; 4104/// independently if the fit option ""S"" is used or not:; 4105///; 4106/// ~~~ {.cpp}; 4107/// TFitResultPtr r = h->Fit(myFunc,opt);; 4108/// Int_t fitStatus = r;; 4109/// ~~~; 4110///; 4111/// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; 4112/// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; 4113/// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; 4114/// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; 4115/// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; 4116/// only in Minos but not in Migrad a fitStatus of 40 will be returned.; 4117/// Minuit2 returns 0 in case of success and different values in migrad,minos or; 4118/// hesse depending on the error. See in this case the documentation of; 4119/// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; 4120/// minos return status and Minuit2Minimizer::Hesse for the hesse return status.; 4121/// If other minimizers are used see their specific documentation for the status code returned.; 4122/// For example in the case of Fumili, see TFumili::Minimize.; 4123///; 4124/// \anchor HFitRange; 4125/// ### Fitting in a range; 4126///; 4127/// In order to fit in a sub-range of the histogram you have two options:; 4128/// - pass to this function the lower (`xxmin`) and upper (`xxmax`) values for the fitting range;; 4129/// - define a specific range in the fitted function and use the fitting option ""R"".; 4130/// For example, if your histogram has a defined range between -4 and 4 and you want to fit a gaussian; 4131/// only in the interval 1 to 3, you can do:; 4132///; 4133/// ~~~ {.cpp}; 41",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:172296,Availability,error,errors,172296," 3.1, 1.e-6, -8, 0, 100);; 4164/// func->SetParLimits(3, -10, -4);; 4165/// func->FixParameter(4, 0);; 4166/// func->SetParLimits(5, 1, 1);; 4167/// ~~~; 4168///; 4169/// With this setup, parameters 0->2 can vary freely; 4170/// Parameter 3 has boundaries [-10,-4] with initial value -8; 4171/// Parameter 4 is fixed to 0; 4172/// Parameter 5 is fixed to 100.; 4173/// When the lower limit and upper limit are equal, the parameter is fixed.; 4174/// However to fix a parameter to 0, one must call the FixParameter function.; 4175///; 4176/// \anchor HFitStatBox; 4177/// ### Fit Statistics Box; 4178///; 4179/// The statistics box can display the result of the fit.; 4180/// You can change the statistics box to display the fit parameters with; 4181/// the TStyle::SetOptFit(mode) method. This mode has four digits.; 4182/// mode = pcev (default = 0111); 4183///; 4184/// v = 1; print name/values of parameters; 4185/// e = 1; print errors (if e=1, v must be 1); 4186/// c = 1; print Chisquare/Number of degrees of freedom; 4187/// p = 1; print Probability; 4188///; 4189/// For example: gStyle->SetOptFit(1011);; 4190/// prints the fit probability, parameter names/values, and errors.; 4191/// You can change the position of the statistics box with these lines; 4192/// (where g is a pointer to the TGraph):; 4193///; 4194/// TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats"");; 4195/// st->SetX1NDC(newx1); //new x start position; 4196/// st->SetX2NDC(newx2); //new x end position; 4197///; 4198/// \anchor HFitExtra; 4199/// ### Additional Notes on Fitting; 4200///; 4201/// #### Fitting a histogram of dimension N with a function of dimension N-1; 4202///; 4203/// It is possible to fit a TH2 with a TF1 or a TH3 with a TF2.; 4204/// In this case the chi-square is computed from the squared error distance between the function values and the bin centers weighted by the bin content.; 4205/// For correct error scaling, the obtained parameter error are corrected as in the ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:172541,Availability,error,errors,172541," 3.1, 1.e-6, -8, 0, 100);; 4164/// func->SetParLimits(3, -10, -4);; 4165/// func->FixParameter(4, 0);; 4166/// func->SetParLimits(5, 1, 1);; 4167/// ~~~; 4168///; 4169/// With this setup, parameters 0->2 can vary freely; 4170/// Parameter 3 has boundaries [-10,-4] with initial value -8; 4171/// Parameter 4 is fixed to 0; 4172/// Parameter 5 is fixed to 100.; 4173/// When the lower limit and upper limit are equal, the parameter is fixed.; 4174/// However to fix a parameter to 0, one must call the FixParameter function.; 4175///; 4176/// \anchor HFitStatBox; 4177/// ### Fit Statistics Box; 4178///; 4179/// The statistics box can display the result of the fit.; 4180/// You can change the statistics box to display the fit parameters with; 4181/// the TStyle::SetOptFit(mode) method. This mode has four digits.; 4182/// mode = pcev (default = 0111); 4183///; 4184/// v = 1; print name/values of parameters; 4185/// e = 1; print errors (if e=1, v must be 1); 4186/// c = 1; print Chisquare/Number of degrees of freedom; 4187/// p = 1; print Probability; 4188///; 4189/// For example: gStyle->SetOptFit(1011);; 4190/// prints the fit probability, parameter names/values, and errors.; 4191/// You can change the position of the statistics box with these lines; 4192/// (where g is a pointer to the TGraph):; 4193///; 4194/// TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats"");; 4195/// st->SetX1NDC(newx1); //new x start position; 4196/// st->SetX2NDC(newx2); //new x end position; 4197///; 4198/// \anchor HFitExtra; 4199/// ### Additional Notes on Fitting; 4200///; 4201/// #### Fitting a histogram of dimension N with a function of dimension N-1; 4202///; 4203/// It is possible to fit a TH2 with a TF1 or a TH3 with a TF2.; 4204/// In this case the chi-square is computed from the squared error distance between the function values and the bin centers weighted by the bin content.; 4205/// For correct error scaling, the obtained parameter error are corrected as in the ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:173182,Availability,error,error,173182," pcev (default = 0111); 4183///; 4184/// v = 1; print name/values of parameters; 4185/// e = 1; print errors (if e=1, v must be 1); 4186/// c = 1; print Chisquare/Number of degrees of freedom; 4187/// p = 1; print Probability; 4188///; 4189/// For example: gStyle->SetOptFit(1011);; 4190/// prints the fit probability, parameter names/values, and errors.; 4191/// You can change the position of the statistics box with these lines; 4192/// (where g is a pointer to the TGraph):; 4193///; 4194/// TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats"");; 4195/// st->SetX1NDC(newx1); //new x start position; 4196/// st->SetX2NDC(newx2); //new x end position; 4197///; 4198/// \anchor HFitExtra; 4199/// ### Additional Notes on Fitting; 4200///; 4201/// #### Fitting a histogram of dimension N with a function of dimension N-1; 4202///; 4203/// It is possible to fit a TH2 with a TF1 or a TH3 with a TF2.; 4204/// In this case the chi-square is computed from the squared error distance between the function values and the bin centers weighted by the bin content.; 4205/// For correct error scaling, the obtained parameter error are corrected as in the case when the; 4206/// option ""W"" is used.; 4207///; 4208/// #### User defined objective functions; 4209///; 4210/// By default when fitting a chi square function is used for fitting. When option ""L"" is used; 4211/// a Poisson likelihood function is used. Using option ""MULTI"" a multinomial likelihood fit is used.; 4212/// Thes functions are defined in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they; 4213/// are implemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in; 4214/// the file math/mathcore/src/FitUtil.cxx.; 4215/// It is possible to specify a user defined fitting function, using option ""U"" and; 4216/// calling the following functions:; 4217///; 4218/// ~~~ {.cpp}; 4219/// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; 4220/// ~~~; 4221///; 4222/// where",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:173295,Availability,error,error,173295,"; print Chisquare/Number of degrees of freedom; 4187/// p = 1; print Probability; 4188///; 4189/// For example: gStyle->SetOptFit(1011);; 4190/// prints the fit probability, parameter names/values, and errors.; 4191/// You can change the position of the statistics box with these lines; 4192/// (where g is a pointer to the TGraph):; 4193///; 4194/// TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats"");; 4195/// st->SetX1NDC(newx1); //new x start position; 4196/// st->SetX2NDC(newx2); //new x end position; 4197///; 4198/// \anchor HFitExtra; 4199/// ### Additional Notes on Fitting; 4200///; 4201/// #### Fitting a histogram of dimension N with a function of dimension N-1; 4202///; 4203/// It is possible to fit a TH2 with a TF1 or a TH3 with a TF2.; 4204/// In this case the chi-square is computed from the squared error distance between the function values and the bin centers weighted by the bin content.; 4205/// For correct error scaling, the obtained parameter error are corrected as in the case when the; 4206/// option ""W"" is used.; 4207///; 4208/// #### User defined objective functions; 4209///; 4210/// By default when fitting a chi square function is used for fitting. When option ""L"" is used; 4211/// a Poisson likelihood function is used. Using option ""MULTI"" a multinomial likelihood fit is used.; 4212/// Thes functions are defined in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they; 4213/// are implemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in; 4214/// the file math/mathcore/src/FitUtil.cxx.; 4215/// It is possible to specify a user defined fitting function, using option ""U"" and; 4216/// calling the following functions:; 4217///; 4218/// ~~~ {.cpp}; 4219/// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; 4220/// ~~~; 4221///; 4222/// where MyFittingFunction is of type:; 4223///; 4224/// ~~~ {.cpp}; 4225/// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Doubl",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:173333,Availability,error,error,173333,"; print Chisquare/Number of degrees of freedom; 4187/// p = 1; print Probability; 4188///; 4189/// For example: gStyle->SetOptFit(1011);; 4190/// prints the fit probability, parameter names/values, and errors.; 4191/// You can change the position of the statistics box with these lines; 4192/// (where g is a pointer to the TGraph):; 4193///; 4194/// TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats"");; 4195/// st->SetX1NDC(newx1); //new x start position; 4196/// st->SetX2NDC(newx2); //new x end position; 4197///; 4198/// \anchor HFitExtra; 4199/// ### Additional Notes on Fitting; 4200///; 4201/// #### Fitting a histogram of dimension N with a function of dimension N-1; 4202///; 4203/// It is possible to fit a TH2 with a TF1 or a TH3 with a TF2.; 4204/// In this case the chi-square is computed from the squared error distance between the function values and the bin centers weighted by the bin content.; 4205/// For correct error scaling, the obtained parameter error are corrected as in the case when the; 4206/// option ""W"" is used.; 4207///; 4208/// #### User defined objective functions; 4209///; 4210/// By default when fitting a chi square function is used for fitting. When option ""L"" is used; 4211/// a Poisson likelihood function is used. Using option ""MULTI"" a multinomial likelihood fit is used.; 4212/// Thes functions are defined in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they; 4213/// are implemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in; 4214/// the file math/mathcore/src/FitUtil.cxx.; 4215/// It is possible to specify a user defined fitting function, using option ""U"" and; 4216/// calling the following functions:; 4217///; 4218/// ~~~ {.cpp}; 4219/// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; 4220/// ~~~; 4221///; 4222/// where MyFittingFunction is of type:; 4223///; 4224/// ~~~ {.cpp}; 4225/// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Doubl",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:174499,Availability,error,error,174499,"fined objective functions; 4209///; 4210/// By default when fitting a chi square function is used for fitting. When option ""L"" is used; 4211/// a Poisson likelihood function is used. Using option ""MULTI"" a multinomial likelihood fit is used.; 4212/// Thes functions are defined in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they; 4213/// are implemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in; 4214/// the file math/mathcore/src/FitUtil.cxx.; 4215/// It is possible to specify a user defined fitting function, using option ""U"" and; 4216/// calling the following functions:; 4217///; 4218/// ~~~ {.cpp}; 4219/// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; 4220/// ~~~; 4221///; 4222/// where MyFittingFunction is of type:; 4223///; 4224/// ~~~ {.cpp}; 4225/// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 4226/// ~~~; 4227///; 4228/// #### Note on treatment of empty bins; 4229///; 4230/// Empty bins, which have the content equal to zero AND error equal to zero,; 4231/// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; 4232/// since they affect the likelihood if the function value in these bins is not negligible.; 4233/// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; 4234/// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; 4235/// In general, one should not fit a histogram with non-empty bins and zero errors.; 4236///; 4237/// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; 4238/// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; 4239/// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; 4240/",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:174804,Availability,error,errors,174804,"plemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in; 4214/// the file math/mathcore/src/FitUtil.cxx.; 4215/// It is possible to specify a user defined fitting function, using option ""U"" and; 4216/// calling the following functions:; 4217///; 4218/// ~~~ {.cpp}; 4219/// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; 4220/// ~~~; 4221///; 4222/// where MyFittingFunction is of type:; 4223///; 4224/// ~~~ {.cpp}; 4225/// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 4226/// ~~~; 4227///; 4228/// #### Note on treatment of empty bins; 4229///; 4230/// Empty bins, which have the content equal to zero AND error equal to zero,; 4231/// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; 4232/// since they affect the likelihood if the function value in these bins is not negligible.; 4233/// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; 4234/// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; 4235/// In general, one should not fit a histogram with non-empty bins and zero errors.; 4236///; 4237/// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; 4238/// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; 4239/// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; 4240/// are corrected by the obtained chi2 value using this scaling expression:; 4241/// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; 4242/// no point errors.; 4243///; 4244/// #### Excluding points; 4245///; 4246/// You can use TF1::RejectPoint inside your fitting function to exclude some points; 4247/// within a certain range ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:174893,Availability,error,error,174893,"itUtil.cxx.; 4215/// It is possible to specify a user defined fitting function, using option ""U"" and; 4216/// calling the following functions:; 4217///; 4218/// ~~~ {.cpp}; 4219/// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; 4220/// ~~~; 4221///; 4222/// where MyFittingFunction is of type:; 4223///; 4224/// ~~~ {.cpp}; 4225/// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 4226/// ~~~; 4227///; 4228/// #### Note on treatment of empty bins; 4229///; 4230/// Empty bins, which have the content equal to zero AND error equal to zero,; 4231/// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; 4232/// since they affect the likelihood if the function value in these bins is not negligible.; 4233/// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; 4234/// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; 4235/// In general, one should not fit a histogram with non-empty bins and zero errors.; 4236///; 4237/// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; 4238/// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; 4239/// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; 4240/// are corrected by the obtained chi2 value using this scaling expression:; 4241/// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; 4242/// no point errors.; 4243///; 4244/// #### Excluding points; 4245///; 4246/// You can use TF1::RejectPoint inside your fitting function to exclude some points; 4247/// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; 4248///; 4249///; 4250/// #### Warning when using the option ""0""; 4251/",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:175049,Availability,error,errors,175049,"""U"" and; 4216/// calling the following functions:; 4217///; 4218/// ~~~ {.cpp}; 4219/// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; 4220/// ~~~; 4221///; 4222/// where MyFittingFunction is of type:; 4223///; 4224/// ~~~ {.cpp}; 4225/// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 4226/// ~~~; 4227///; 4228/// #### Note on treatment of empty bins; 4229///; 4230/// Empty bins, which have the content equal to zero AND error equal to zero,; 4231/// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; 4232/// since they affect the likelihood if the function value in these bins is not negligible.; 4233/// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; 4234/// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; 4235/// In general, one should not fit a histogram with non-empty bins and zero errors.; 4236///; 4237/// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; 4238/// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; 4239/// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; 4240/// are corrected by the obtained chi2 value using this scaling expression:; 4241/// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; 4242/// no point errors.; 4243///; 4244/// #### Excluding points; 4245///; 4246/// You can use TF1::RejectPoint inside your fitting function to exclude some points; 4247/// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; 4248///; 4249///; 4250/// #### Warning when using the option ""0""; 4251///; 4252/// When selecting the option ""0"", the fitted function is added to; 4253/// the list o",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:175086,Availability,error,errors,175086,"ittingFunction);; 4220/// ~~~; 4221///; 4222/// where MyFittingFunction is of type:; 4223///; 4224/// ~~~ {.cpp}; 4225/// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 4226/// ~~~; 4227///; 4228/// #### Note on treatment of empty bins; 4229///; 4230/// Empty bins, which have the content equal to zero AND error equal to zero,; 4231/// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; 4232/// since they affect the likelihood if the function value in these bins is not negligible.; 4233/// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; 4234/// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; 4235/// In general, one should not fit a histogram with non-empty bins and zero errors.; 4236///; 4237/// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; 4238/// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; 4239/// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; 4240/// are corrected by the obtained chi2 value using this scaling expression:; 4241/// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; 4242/// no point errors.; 4243///; 4244/// #### Excluding points; 4245///; 4246/// You can use TF1::RejectPoint inside your fitting function to exclude some points; 4247/// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; 4248///; 4249///; 4250/// #### Warning when using the option ""0""; 4251///; 4252/// When selecting the option ""0"", the fitted function is added to; 4253/// the list of functions of the histogram, but it is not drawn when the histogram is drawn.; 4254/// You can undo this behaviour resetting its ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:175320,Availability,error,error,175320,"ttingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 4226/// ~~~; 4227///; 4228/// #### Note on treatment of empty bins; 4229///; 4230/// Empty bins, which have the content equal to zero AND error equal to zero,; 4231/// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; 4232/// since they affect the likelihood if the function value in these bins is not negligible.; 4233/// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; 4234/// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; 4235/// In general, one should not fit a histogram with non-empty bins and zero errors.; 4236///; 4237/// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; 4238/// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; 4239/// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; 4240/// are corrected by the obtained chi2 value using this scaling expression:; 4241/// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; 4242/// no point errors.; 4243///; 4244/// #### Excluding points; 4245///; 4246/// You can use TF1::RejectPoint inside your fitting function to exclude some points; 4247/// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; 4248///; 4249///; 4250/// #### Warning when using the option ""0""; 4251///; 4252/// When selecting the option ""0"", the fitted function is added to; 4253/// the list of functions of the histogram, but it is not drawn when the histogram is drawn.; 4254/// You can undo this behaviour resetting its corresponding bit in the TF1 object as following:; 4255///; 4256/// ~~~ {.cpp}; 4257/// h.Fit(""myFunction"", ""0""); // fit, store function ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:175424,Availability,error,errors,175424,"ent equal to zero AND error equal to zero,; 4231/// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; 4232/// since they affect the likelihood if the function value in these bins is not negligible.; 4233/// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; 4234/// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; 4235/// In general, one should not fit a histogram with non-empty bins and zero errors.; 4236///; 4237/// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; 4238/// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; 4239/// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; 4240/// are corrected by the obtained chi2 value using this scaling expression:; 4241/// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; 4242/// no point errors.; 4243///; 4244/// #### Excluding points; 4245///; 4246/// You can use TF1::RejectPoint inside your fitting function to exclude some points; 4247/// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; 4248///; 4249///; 4250/// #### Warning when using the option ""0""; 4251///; 4252/// When selecting the option ""0"", the fitted function is added to; 4253/// the list of functions of the histogram, but it is not drawn when the histogram is drawn.; 4254/// You can undo this behaviour resetting its corresponding bit in the TF1 object as following:; 4255///; 4256/// ~~~ {.cpp}; 4257/// h.Fit(""myFunction"", ""0""); // fit, store function but do not draw; 4258/// h.Draw(); // function is not drawn; 4259/// h.GetFunction(""myFunction"")->ResetBit(TF1::kNotDraw);; 4260/// h.Draw(); // function is visible again; 4261/// ~~~; 4262///; 4263",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:175522,Availability,error,errorp,175522,"ent equal to zero AND error equal to zero,; 4231/// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; 4232/// since they affect the likelihood if the function value in these bins is not negligible.; 4233/// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; 4234/// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; 4235/// In general, one should not fit a histogram with non-empty bins and zero errors.; 4236///; 4237/// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; 4238/// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; 4239/// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; 4240/// are corrected by the obtained chi2 value using this scaling expression:; 4241/// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; 4242/// no point errors.; 4243///; 4244/// #### Excluding points; 4245///; 4246/// You can use TF1::RejectPoint inside your fitting function to exclude some points; 4247/// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; 4248///; 4249///; 4250/// #### Warning when using the option ""0""; 4251///; 4252/// When selecting the option ""0"", the fitted function is added to; 4253/// the list of functions of the histogram, but it is not drawn when the histogram is drawn.; 4254/// You can undo this behaviour resetting its corresponding bit in the TF1 object as following:; 4255///; 4256/// ~~~ {.cpp}; 4257/// h.Fit(""myFunction"", ""0""); // fit, store function but do not draw; 4258/// h.Draw(); // function is not drawn; 4259/// h.GetFunction(""myFunction"")->ResetBit(TF1::kNotDraw);; 4260/// h.Draw(); // function is visible again; 4261/// ~~~; 4262///; 4263",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:175616,Availability,error,errors,175616,"ent equal to zero AND error equal to zero,; 4231/// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; 4232/// since they affect the likelihood if the function value in these bins is not negligible.; 4233/// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; 4234/// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; 4235/// In general, one should not fit a histogram with non-empty bins and zero errors.; 4236///; 4237/// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; 4238/// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; 4239/// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; 4240/// are corrected by the obtained chi2 value using this scaling expression:; 4241/// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; 4242/// no point errors.; 4243///; 4244/// #### Excluding points; 4245///; 4246/// You can use TF1::RejectPoint inside your fitting function to exclude some points; 4247/// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; 4248///; 4249///; 4250/// #### Warning when using the option ""0""; 4251///; 4252/// When selecting the option ""0"", the fitted function is added to; 4253/// the list of functions of the histogram, but it is not drawn when the histogram is drawn.; 4254/// You can undo this behaviour resetting its corresponding bit in the TF1 object as following:; 4255///; 4256/// ~~~ {.cpp}; 4257/// h.Fit(""myFunction"", ""0""); // fit, store function but do not draw; 4258/// h.Draw(); // function is not drawn; 4259/// h.GetFunction(""myFunction"")->ResetBit(TF1::kNotDraw);; 4260/// h.Draw(); // function is visible again; 4261/// ~~~; 4262///; 4263",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:178474,Availability,error,error,178474," 4288 if (!gPad); 4289 gROOT->MakeDefCanvas();; 4290 ; 4291 if (!gPad) {; 4292 Error(""FitPanel"", ""Unable to create a default canvas"");; 4293 return;; 4294 }; 4295 ; 4296 ; 4297 // use plugin manager to create instance of TFitEditor; 4298 TPluginHandler *handler = gROOT->GetPluginManager()->FindHandler(""TFitEditor"");; 4299 if (handler && handler->LoadPlugin() != -1) {; 4300 if (handler->ExecPlugin(2, gPad, this) == 0); 4301 Error(""FitPanel"", ""Unable to create the FitPanel"");; 4302 }; 4303 else; 4304 Error(""FitPanel"", ""Unable to find the FitPanel plug-in"");; 4305}; 4306 ; 4307////////////////////////////////////////////////////////////////////////////////; 4308/// Return a histogram containing the asymmetry of this histogram with h2,; 4309/// where the asymmetry is defined as:; 4310///; 4311/// ~~~ {.cpp}; 4312/// Asymmetry = (h1 - h2)/(h1 + h2) where h1 = this; 4313/// ~~~; 4314///; 4315/// works for 1D, 2D, etc. histograms; 4316/// c2 is an optional argument that gives a relative weight between the two; 4317/// histograms, and dc2 is the error on this weight. This is useful, for example,; 4318/// when forming an asymmetry between two histograms from 2 different data sets that; 4319/// need to be normalized to each other in some way. The function calculates; 4320/// the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).; 4321///; 4322/// example: assuming 'h1' and 'h2' are already filled; 4323///; 4324/// ~~~ {.cpp}; 4325/// h3 = h1->GetAsymmetry(h2); 4326/// ~~~; 4327///; 4328/// then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; 4329/// h1 and h2 are left intact.; 4330///; 4331/// Note that it is the user's responsibility to manage the created histogram.; 4332/// The name of the returned histogram will be `Asymmetry_nameOfh1-nameOfh2`; 4333///; 4334/// code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun; 4335///; 4336/// clone the histograms so top and bottom will have the; 4337/// correct dimensions:; 43",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:178710,Availability,error,errors,178710,"tEditor"");; 4299 if (handler && handler->LoadPlugin() != -1) {; 4300 if (handler->ExecPlugin(2, gPad, this) == 0); 4301 Error(""FitPanel"", ""Unable to create the FitPanel"");; 4302 }; 4303 else; 4304 Error(""FitPanel"", ""Unable to find the FitPanel plug-in"");; 4305}; 4306 ; 4307////////////////////////////////////////////////////////////////////////////////; 4308/// Return a histogram containing the asymmetry of this histogram with h2,; 4309/// where the asymmetry is defined as:; 4310///; 4311/// ~~~ {.cpp}; 4312/// Asymmetry = (h1 - h2)/(h1 + h2) where h1 = this; 4313/// ~~~; 4314///; 4315/// works for 1D, 2D, etc. histograms; 4316/// c2 is an optional argument that gives a relative weight between the two; 4317/// histograms, and dc2 is the error on this weight. This is useful, for example,; 4318/// when forming an asymmetry between two histograms from 2 different data sets that; 4319/// need to be normalized to each other in some way. The function calculates; 4320/// the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).; 4321///; 4322/// example: assuming 'h1' and 'h2' are already filled; 4323///; 4324/// ~~~ {.cpp}; 4325/// h3 = h1->GetAsymmetry(h2); 4326/// ~~~; 4327///; 4328/// then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; 4329/// h1 and h2 are left intact.; 4330///; 4331/// Note that it is the user's responsibility to manage the created histogram.; 4332/// The name of the returned histogram will be `Asymmetry_nameOfh1-nameOfh2`; 4333///; 4334/// code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun; 4335///; 4336/// clone the histograms so top and bottom will have the; 4337/// correct dimensions:; 4338/// Sumw2 just makes sure the errors will be computed properly; 4339/// when we form sums and ratios below.; 4340 ; 4341TH1 *TH1::GetAsymmetry(TH1* h2, Double_t c2, Double_t dc2); 4342{; 4343 TH1 *h1 = this;; 4344 TString name = TString::Format(""Asymmetry_%s-%s"",h1->GetName(),h2->GetName() );; 4345 TH1 *",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:179452,Availability,error,errors,179452,"t between the two; 4317/// histograms, and dc2 is the error on this weight. This is useful, for example,; 4318/// when forming an asymmetry between two histograms from 2 different data sets that; 4319/// need to be normalized to each other in some way. The function calculates; 4320/// the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).; 4321///; 4322/// example: assuming 'h1' and 'h2' are already filled; 4323///; 4324/// ~~~ {.cpp}; 4325/// h3 = h1->GetAsymmetry(h2); 4326/// ~~~; 4327///; 4328/// then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; 4329/// h1 and h2 are left intact.; 4330///; 4331/// Note that it is the user's responsibility to manage the created histogram.; 4332/// The name of the returned histogram will be `Asymmetry_nameOfh1-nameOfh2`; 4333///; 4334/// code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun; 4335///; 4336/// clone the histograms so top and bottom will have the; 4337/// correct dimensions:; 4338/// Sumw2 just makes sure the errors will be computed properly; 4339/// when we form sums and ratios below.; 4340 ; 4341TH1 *TH1::GetAsymmetry(TH1* h2, Double_t c2, Double_t dc2); 4342{; 4343 TH1 *h1 = this;; 4344 TString name = TString::Format(""Asymmetry_%s-%s"",h1->GetName(),h2->GetName() );; 4345 TH1 *asym = (TH1*)Clone(name);; 4346 ; 4347 // set also the title; 4348 TString title = TString::Format(""(%s - %s)/(%s+%s)"",h1->GetName(),h2->GetName(),h1->GetName(),h2->GetName() );; 4349 asym->SetTitle(title);; 4350 ; 4351 asym->Sumw2();; 4352 Bool_t addStatus = TH1::AddDirectoryStatus();; 4353 TH1::AddDirectory(kFALSE);; 4354 TH1 *top = (TH1*)asym->Clone();; 4355 TH1 *bottom = (TH1*)asym->Clone();; 4356 TH1::AddDirectory(addStatus);; 4357 ; 4358 // form the top and bottom of the asymmetry, and then divide:; 4359 top->Add(h1,h2,1,-c2);; 4360 bottom->Add(h1,h2,1,c2);; 4361 asym->Divide(top,bottom);; 4362 ; 4363 Int_t xmax = asym->GetNbinsX();; 4364 Int_t ymax = asym->GetNbinsY();; 4365 Int",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:180654,Availability,error,errors,180654,"// correct dimensions:; 4338/// Sumw2 just makes sure the errors will be computed properly; 4339/// when we form sums and ratios below.; 4340 ; 4341TH1 *TH1::GetAsymmetry(TH1* h2, Double_t c2, Double_t dc2); 4342{; 4343 TH1 *h1 = this;; 4344 TString name = TString::Format(""Asymmetry_%s-%s"",h1->GetName(),h2->GetName() );; 4345 TH1 *asym = (TH1*)Clone(name);; 4346 ; 4347 // set also the title; 4348 TString title = TString::Format(""(%s - %s)/(%s+%s)"",h1->GetName(),h2->GetName(),h1->GetName(),h2->GetName() );; 4349 asym->SetTitle(title);; 4350 ; 4351 asym->Sumw2();; 4352 Bool_t addStatus = TH1::AddDirectoryStatus();; 4353 TH1::AddDirectory(kFALSE);; 4354 TH1 *top = (TH1*)asym->Clone();; 4355 TH1 *bottom = (TH1*)asym->Clone();; 4356 TH1::AddDirectory(addStatus);; 4357 ; 4358 // form the top and bottom of the asymmetry, and then divide:; 4359 top->Add(h1,h2,1,-c2);; 4360 bottom->Add(h1,h2,1,c2);; 4361 asym->Divide(top,bottom);; 4362 ; 4363 Int_t xmax = asym->GetNbinsX();; 4364 Int_t ymax = asym->GetNbinsY();; 4365 Int_t zmax = asym->GetNbinsZ();; 4366 ; 4367 if (h1->fBuffer) h1->BufferEmpty(1);; 4368 if (h2->fBuffer) h2->BufferEmpty(1);; 4369 if (bottom->fBuffer) bottom->BufferEmpty(1);; 4370 ; 4371 // now loop over bins to calculate the correct errors; 4372 // the reason this error calculation looks complex is because of c2; 4373 for(Int_t i=1; i<= xmax; i++){; 4374 for(Int_t j=1; j<= ymax; j++){; 4375 for(Int_t k=1; k<= zmax; k++){; 4376 Int_t bin = GetBin(i, j, k);; 4377 // here some bin contents are written into variables to make the error; 4378 // calculation a little more legible:; 4379 Double_t a = h1->RetrieveBinContent(bin);; 4380 Double_t b = h2->RetrieveBinContent(bin);; 4381 Double_t bot = bottom->RetrieveBinContent(bin);; 4382 ; 4383 // make sure there are some events, if not, then the errors are set = 0; 4384 // automatically.; 4385 //if(bot < 1){} was changed to the next line from recommendation of Jason Seely (28 Nov 2005); 4386 if(bot < 1e-6){}; 4387 else{",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:180686,Availability,error,error,180686,"// correct dimensions:; 4338/// Sumw2 just makes sure the errors will be computed properly; 4339/// when we form sums and ratios below.; 4340 ; 4341TH1 *TH1::GetAsymmetry(TH1* h2, Double_t c2, Double_t dc2); 4342{; 4343 TH1 *h1 = this;; 4344 TString name = TString::Format(""Asymmetry_%s-%s"",h1->GetName(),h2->GetName() );; 4345 TH1 *asym = (TH1*)Clone(name);; 4346 ; 4347 // set also the title; 4348 TString title = TString::Format(""(%s - %s)/(%s+%s)"",h1->GetName(),h2->GetName(),h1->GetName(),h2->GetName() );; 4349 asym->SetTitle(title);; 4350 ; 4351 asym->Sumw2();; 4352 Bool_t addStatus = TH1::AddDirectoryStatus();; 4353 TH1::AddDirectory(kFALSE);; 4354 TH1 *top = (TH1*)asym->Clone();; 4355 TH1 *bottom = (TH1*)asym->Clone();; 4356 TH1::AddDirectory(addStatus);; 4357 ; 4358 // form the top and bottom of the asymmetry, and then divide:; 4359 top->Add(h1,h2,1,-c2);; 4360 bottom->Add(h1,h2,1,c2);; 4361 asym->Divide(top,bottom);; 4362 ; 4363 Int_t xmax = asym->GetNbinsX();; 4364 Int_t ymax = asym->GetNbinsY();; 4365 Int_t zmax = asym->GetNbinsZ();; 4366 ; 4367 if (h1->fBuffer) h1->BufferEmpty(1);; 4368 if (h2->fBuffer) h2->BufferEmpty(1);; 4369 if (bottom->fBuffer) bottom->BufferEmpty(1);; 4370 ; 4371 // now loop over bins to calculate the correct errors; 4372 // the reason this error calculation looks complex is because of c2; 4373 for(Int_t i=1; i<= xmax; i++){; 4374 for(Int_t j=1; j<= ymax; j++){; 4375 for(Int_t k=1; k<= zmax; k++){; 4376 Int_t bin = GetBin(i, j, k);; 4377 // here some bin contents are written into variables to make the error; 4378 // calculation a little more legible:; 4379 Double_t a = h1->RetrieveBinContent(bin);; 4380 Double_t b = h2->RetrieveBinContent(bin);; 4381 Double_t bot = bottom->RetrieveBinContent(bin);; 4382 ; 4383 // make sure there are some events, if not, then the errors are set = 0; 4384 // automatically.; 4385 //if(bot < 1){} was changed to the next line from recommendation of Jason Seely (28 Nov 2005); 4386 if(bot < 1e-6){}; 4387 else{",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:180952,Availability,error,error,180952,"// correct dimensions:; 4338/// Sumw2 just makes sure the errors will be computed properly; 4339/// when we form sums and ratios below.; 4340 ; 4341TH1 *TH1::GetAsymmetry(TH1* h2, Double_t c2, Double_t dc2); 4342{; 4343 TH1 *h1 = this;; 4344 TString name = TString::Format(""Asymmetry_%s-%s"",h1->GetName(),h2->GetName() );; 4345 TH1 *asym = (TH1*)Clone(name);; 4346 ; 4347 // set also the title; 4348 TString title = TString::Format(""(%s - %s)/(%s+%s)"",h1->GetName(),h2->GetName(),h1->GetName(),h2->GetName() );; 4349 asym->SetTitle(title);; 4350 ; 4351 asym->Sumw2();; 4352 Bool_t addStatus = TH1::AddDirectoryStatus();; 4353 TH1::AddDirectory(kFALSE);; 4354 TH1 *top = (TH1*)asym->Clone();; 4355 TH1 *bottom = (TH1*)asym->Clone();; 4356 TH1::AddDirectory(addStatus);; 4357 ; 4358 // form the top and bottom of the asymmetry, and then divide:; 4359 top->Add(h1,h2,1,-c2);; 4360 bottom->Add(h1,h2,1,c2);; 4361 asym->Divide(top,bottom);; 4362 ; 4363 Int_t xmax = asym->GetNbinsX();; 4364 Int_t ymax = asym->GetNbinsY();; 4365 Int_t zmax = asym->GetNbinsZ();; 4366 ; 4367 if (h1->fBuffer) h1->BufferEmpty(1);; 4368 if (h2->fBuffer) h2->BufferEmpty(1);; 4369 if (bottom->fBuffer) bottom->BufferEmpty(1);; 4370 ; 4371 // now loop over bins to calculate the correct errors; 4372 // the reason this error calculation looks complex is because of c2; 4373 for(Int_t i=1; i<= xmax; i++){; 4374 for(Int_t j=1; j<= ymax; j++){; 4375 for(Int_t k=1; k<= zmax; k++){; 4376 Int_t bin = GetBin(i, j, k);; 4377 // here some bin contents are written into variables to make the error; 4378 // calculation a little more legible:; 4379 Double_t a = h1->RetrieveBinContent(bin);; 4380 Double_t b = h2->RetrieveBinContent(bin);; 4381 Double_t bot = bottom->RetrieveBinContent(bin);; 4382 ; 4383 // make sure there are some events, if not, then the errors are set = 0; 4384 // automatically.; 4385 //if(bot < 1){} was changed to the next line from recommendation of Jason Seely (28 Nov 2005); 4386 if(bot < 1e-6){}; 4387 else{",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:181218,Availability,error,errors,181218,"// correct dimensions:; 4338/// Sumw2 just makes sure the errors will be computed properly; 4339/// when we form sums and ratios below.; 4340 ; 4341TH1 *TH1::GetAsymmetry(TH1* h2, Double_t c2, Double_t dc2); 4342{; 4343 TH1 *h1 = this;; 4344 TString name = TString::Format(""Asymmetry_%s-%s"",h1->GetName(),h2->GetName() );; 4345 TH1 *asym = (TH1*)Clone(name);; 4346 ; 4347 // set also the title; 4348 TString title = TString::Format(""(%s - %s)/(%s+%s)"",h1->GetName(),h2->GetName(),h1->GetName(),h2->GetName() );; 4349 asym->SetTitle(title);; 4350 ; 4351 asym->Sumw2();; 4352 Bool_t addStatus = TH1::AddDirectoryStatus();; 4353 TH1::AddDirectory(kFALSE);; 4354 TH1 *top = (TH1*)asym->Clone();; 4355 TH1 *bottom = (TH1*)asym->Clone();; 4356 TH1::AddDirectory(addStatus);; 4357 ; 4358 // form the top and bottom of the asymmetry, and then divide:; 4359 top->Add(h1,h2,1,-c2);; 4360 bottom->Add(h1,h2,1,c2);; 4361 asym->Divide(top,bottom);; 4362 ; 4363 Int_t xmax = asym->GetNbinsX();; 4364 Int_t ymax = asym->GetNbinsY();; 4365 Int_t zmax = asym->GetNbinsZ();; 4366 ; 4367 if (h1->fBuffer) h1->BufferEmpty(1);; 4368 if (h2->fBuffer) h2->BufferEmpty(1);; 4369 if (bottom->fBuffer) bottom->BufferEmpty(1);; 4370 ; 4371 // now loop over bins to calculate the correct errors; 4372 // the reason this error calculation looks complex is because of c2; 4373 for(Int_t i=1; i<= xmax; i++){; 4374 for(Int_t j=1; j<= ymax; j++){; 4375 for(Int_t k=1; k<= zmax; k++){; 4376 Int_t bin = GetBin(i, j, k);; 4377 // here some bin contents are written into variables to make the error; 4378 // calculation a little more legible:; 4379 Double_t a = h1->RetrieveBinContent(bin);; 4380 Double_t b = h2->RetrieveBinContent(bin);; 4381 Double_t bot = bottom->RetrieveBinContent(bin);; 4382 ; 4383 // make sure there are some events, if not, then the errors are set = 0; 4384 // automatically.; 4385 //if(bot < 1){} was changed to the next line from recommendation of Jason Seely (28 Nov 2005); 4386 if(bot < 1e-6){}; 4387 else{",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:181420,Availability,error,errors,181420,"1; j<= ymax; j++){; 4375 for(Int_t k=1; k<= zmax; k++){; 4376 Int_t bin = GetBin(i, j, k);; 4377 // here some bin contents are written into variables to make the error; 4378 // calculation a little more legible:; 4379 Double_t a = h1->RetrieveBinContent(bin);; 4380 Double_t b = h2->RetrieveBinContent(bin);; 4381 Double_t bot = bottom->RetrieveBinContent(bin);; 4382 ; 4383 // make sure there are some events, if not, then the errors are set = 0; 4384 // automatically.; 4385 //if(bot < 1){} was changed to the next line from recommendation of Jason Seely (28 Nov 2005); 4386 if(bot < 1e-6){}; 4387 else{; 4388 // computation of errors by Christos Leonidopoulos; 4389 Double_t dasq = h1->GetBinErrorSqUnchecked(bin);; 4390 Double_t dbsq = h2->GetBinErrorSqUnchecked(bin);; 4391 Double_t error = 2*TMath::Sqrt(a*a*c2*c2*dbsq + c2*c2*b*b*dasq+a*a*b*b*dc2*dc2)/(bot*bot);; 4392 asym->SetBinError(i,j,k,error);; 4393 }; 4394 }; 4395 }; 4396 }; 4397 delete top;; 4398 delete bottom;; 4399 ; 4400 return asym;; 4401}; 4402 ; 4403////////////////////////////////////////////////////////////////////////////////; 4404/// Static function; 4405/// return the default buffer size for automatic histograms; 4406/// the parameter fgBufferSize may be changed via SetDefaultBufferSize; 4407 ; 4408Int_t TH1::GetDefaultBufferSize(); 4409{; 4410 return fgBufferSize;; 4411}; 4412 ; 4413////////////////////////////////////////////////////////////////////////////////; 4414/// Return kTRUE if TH1::Sumw2 must be called when creating new histograms.; 4415/// see TH1::SetDefaultSumw2.; 4416 ; 4417Bool_t TH1::GetDefaultSumw2(); 4418{; 4419 return fgDefaultSumw2;; 4420}; 4421 ; 4422////////////////////////////////////////////////////////////////////////////////; 4423/// Return the current number of entries.; 4424 ; 4425Double_t TH1::GetEntries() const; 4426{; 4427 if (fBuffer) {; 4428 Int_t nentries = (Int_t) fBuffer[0];; 4429 if (nentries > 0) return nentries;; 4430 }; 4431 ; 4432 return fEntries;; 4433}; 4434 ;",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:181578,Availability,error,error,181578,"1; j<= ymax; j++){; 4375 for(Int_t k=1; k<= zmax; k++){; 4376 Int_t bin = GetBin(i, j, k);; 4377 // here some bin contents are written into variables to make the error; 4378 // calculation a little more legible:; 4379 Double_t a = h1->RetrieveBinContent(bin);; 4380 Double_t b = h2->RetrieveBinContent(bin);; 4381 Double_t bot = bottom->RetrieveBinContent(bin);; 4382 ; 4383 // make sure there are some events, if not, then the errors are set = 0; 4384 // automatically.; 4385 //if(bot < 1){} was changed to the next line from recommendation of Jason Seely (28 Nov 2005); 4386 if(bot < 1e-6){}; 4387 else{; 4388 // computation of errors by Christos Leonidopoulos; 4389 Double_t dasq = h1->GetBinErrorSqUnchecked(bin);; 4390 Double_t dbsq = h2->GetBinErrorSqUnchecked(bin);; 4391 Double_t error = 2*TMath::Sqrt(a*a*c2*c2*dbsq + c2*c2*b*b*dasq+a*a*b*b*dc2*dc2)/(bot*bot);; 4392 asym->SetBinError(i,j,k,error);; 4393 }; 4394 }; 4395 }; 4396 }; 4397 delete top;; 4398 delete bottom;; 4399 ; 4400 return asym;; 4401}; 4402 ; 4403////////////////////////////////////////////////////////////////////////////////; 4404/// Static function; 4405/// return the default buffer size for automatic histograms; 4406/// the parameter fgBufferSize may be changed via SetDefaultBufferSize; 4407 ; 4408Int_t TH1::GetDefaultBufferSize(); 4409{; 4410 return fgBufferSize;; 4411}; 4412 ; 4413////////////////////////////////////////////////////////////////////////////////; 4414/// Return kTRUE if TH1::Sumw2 must be called when creating new histograms.; 4415/// see TH1::SetDefaultSumw2.; 4416 ; 4417Bool_t TH1::GetDefaultSumw2(); 4418{; 4419 return fgDefaultSumw2;; 4420}; 4421 ; 4422////////////////////////////////////////////////////////////////////////////////; 4423/// Return the current number of entries.; 4424 ; 4425Double_t TH1::GetEntries() const; 4426{; 4427 if (fBuffer) {; 4428 Int_t nentries = (Int_t) fBuffer[0];; 4429 if (nentries > 0) return nentries;; 4430 }; 4431 ; 4432 return fEntries;; 4433}; 4434 ;",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:181690,Availability,error,error,181690,"1; j<= ymax; j++){; 4375 for(Int_t k=1; k<= zmax; k++){; 4376 Int_t bin = GetBin(i, j, k);; 4377 // here some bin contents are written into variables to make the error; 4378 // calculation a little more legible:; 4379 Double_t a = h1->RetrieveBinContent(bin);; 4380 Double_t b = h2->RetrieveBinContent(bin);; 4381 Double_t bot = bottom->RetrieveBinContent(bin);; 4382 ; 4383 // make sure there are some events, if not, then the errors are set = 0; 4384 // automatically.; 4385 //if(bot < 1){} was changed to the next line from recommendation of Jason Seely (28 Nov 2005); 4386 if(bot < 1e-6){}; 4387 else{; 4388 // computation of errors by Christos Leonidopoulos; 4389 Double_t dasq = h1->GetBinErrorSqUnchecked(bin);; 4390 Double_t dbsq = h2->GetBinErrorSqUnchecked(bin);; 4391 Double_t error = 2*TMath::Sqrt(a*a*c2*c2*dbsq + c2*c2*b*b*dasq+a*a*b*b*dc2*dc2)/(bot*bot);; 4392 asym->SetBinError(i,j,k,error);; 4393 }; 4394 }; 4395 }; 4396 }; 4397 delete top;; 4398 delete bottom;; 4399 ; 4400 return asym;; 4401}; 4402 ; 4403////////////////////////////////////////////////////////////////////////////////; 4404/// Static function; 4405/// return the default buffer size for automatic histograms; 4406/// the parameter fgBufferSize may be changed via SetDefaultBufferSize; 4407 ; 4408Int_t TH1::GetDefaultBufferSize(); 4409{; 4410 return fgBufferSize;; 4411}; 4412 ; 4413////////////////////////////////////////////////////////////////////////////////; 4414/// Return kTRUE if TH1::Sumw2 must be called when creating new histograms.; 4415/// see TH1::SetDefaultSumw2.; 4416 ; 4417Bool_t TH1::GetDefaultSumw2(); 4418{; 4419 return fgDefaultSumw2;; 4420}; 4421 ; 4422////////////////////////////////////////////////////////////////////////////////; 4423/// Return the current number of entries.; 4424 ; 4425Double_t TH1::GetEntries() const; 4426{; 4427 if (fBuffer) {; 4428 Int_t nentries = (Int_t) fBuffer[0];; 4429 if (nentries > 0) return nentries;; 4430 }; 4431 ; 4432 return fEntries;; 4433}; 4434 ;",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:189960,Availability,avail,available,189960,"is()->SetTitle(""x"");; 4589/// h->GetYaxis()->SetTitle(""Counts"");; 4590///; 4591/// Double_t p[nq]; // probabilities where to evaluate the quantiles in [0,1]; 4592/// Double_t xp[nq]; // array of positions X to store the resulting quantiles; 4593/// for (Int_t i=0;i<nq;i++) p[i] = Float_t(i+1)/nq;; 4594/// h->GetQuantiles(nq,xp,p);; 4595///; 4596/// //show the original histogram in the top pad; 4597/// TCanvas *c1 = new TCanvas(""c1"",""demo quantiles"",10,10,700,900);; 4598/// c1->Divide(1,2);; 4599/// c1->cd(1);; 4600/// h->Draw();; 4601///; 4602/// // show the quantiles in the bottom pad; 4603/// c1->cd(2);; 4604/// gPad->SetGrid();; 4605/// TGraph *gr = new TGraph(nq,p,xp);; 4606/// gr->SetMarkerStyle(21);; 4607/// gr->GetXaxis()->SetTitle(""p"");; 4608/// gr->GetYaxis()->SetTitle(""x"");; 4609/// gr->Draw(""alp"");; 4610/// }; 4611/// ~~~; 4612 ; 4613Int_t TH1::GetQuantiles(Int_t n, Double_t *xp, const Double_t *p); 4614{; 4615 if (GetDimension() > 1) {; 4616 Error(""GetQuantiles"",""Only available for 1-d histograms"");; 4617 return 0;; 4618 }; 4619 ; 4620 const Int_t nbins = GetXaxis()->GetNbins();; 4621 if (!fIntegral) ComputeIntegral();; 4622 if (fIntegral[nbins+1] != fEntries) ComputeIntegral();; 4623 ; 4624 Int_t i, ibin;; 4625 Double_t *prob = (Double_t*)p;; 4626 Int_t nq = n;; 4627 if (p == nullptr) {; 4628 nq = nbins+1;; 4629 prob = new Double_t[nq];; 4630 prob[0] = 0;; 4631 for (i=1;i<nq;i++) {; 4632 prob[i] = fIntegral[i]/fIntegral[nbins];; 4633 }; 4634 }; 4635 ; 4636 for (i = 0; i < nq; i++) {; 4637 ibin = TMath::BinarySearch(nbins,fIntegral,prob[i]);; 4638 while (ibin < nbins-1 && fIntegral[ibin+1] == prob[i]) {; 4639 if (fIntegral[ibin+2] == prob[i]) ibin++;; 4640 else break;; 4641 }; 4642 xp[i] = GetBinLowEdge(ibin+1);; 4643 const Double_t dint = fIntegral[ibin+1]-fIntegral[ibin];; 4644 if (dint > 0) xp[i] += GetBinWidth(ibin+1)*(prob[i]-fIntegral[ibin])/dint;; 4645 }; 4646 ; 4647 if (!p) delete [] prob;; 4648 return nq;; 4649}; 4650 ; 4651/////////////////////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:212831,Availability,error,errors,212831,"242////////////////////////////////////////////////////////////////////////////////; 5243/// Reduce the number of bins for the axis passed in the option to the number of bins having a label.; 5244/// The method will remove only the extra bins existing after the last ""labeled"" bin.; 5245/// Note that if there are ""un-labeled"" bins present between ""labeled"" bins they will not be removed; 5246 ; 5247void TH1::LabelsDeflate(Option_t *ax); 5248{; 5249 Int_t iaxis = AxisChoice(ax);; 5250 TAxis *axis = nullptr;; 5251 if (iaxis == 1) axis = GetXaxis();; 5252 if (iaxis == 2) axis = GetYaxis();; 5253 if (iaxis == 3) axis = GetZaxis();; 5254 if (!axis) {; 5255 Error(""LabelsDeflate"",""Invalid axis option %s"",ax);; 5256 return;; 5257 }; 5258 if (!axis->GetLabels()) return;; 5259 ; 5260 // find bin with last labels; 5261 // bin number is object ID in list of labels; 5262 // therefore max bin number is number of bins of the deflated histograms; 5263 TIter next(axis->GetLabels());; 5264 TObject *obj;; 5265 Int_t nbins = 0;; 5266 while ((obj = next())) {; 5267 Int_t ibin = obj->GetUniqueID();; 5268 if (ibin > nbins) nbins = ibin;; 5269 }; 5270 if (nbins < 1) nbins = 1;; 5271 ; 5272 // Do nothing in case it was the last bin; 5273 if (nbins==axis->GetNbins()) return;; 5274 ; 5275 TH1 *hold = (TH1*)IsA()->New();; 5276 R__ASSERT(hold);; 5277 hold->SetDirectory(nullptr);; 5278 Copy(*hold);; 5279 ; 5280 Bool_t timedisp = axis->GetTimeDisplay();; 5281 Double_t xmin = axis->GetXmin();; 5282 Double_t xmax = axis->GetBinUpEdge(nbins);; 5283 if (xmax <= xmin) xmax = xmin +nbins;; 5284 axis->SetRange(0,0);; 5285 axis->Set(nbins,xmin,xmax);; 5286 SetBinsLength(-1); // reset the number of cells; 5287 Int_t errors = fSumw2.fN;; 5288 if (errors) fSumw2.Set(fNcells);; 5289 axis->SetTimeDisplay(timedisp);; 5290 // reset histogram content; 5291 Reset(""ICE"");; 5292 ; 5293 //now loop on all bins and refill; 5294 // NOTE that if the bins without labels have content; 5295 // it will be put in the underflow/",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:212861,Availability,error,errors,212861,"258 if (!axis->GetLabels()) return;; 5259 ; 5260 // find bin with last labels; 5261 // bin number is object ID in list of labels; 5262 // therefore max bin number is number of bins of the deflated histograms; 5263 TIter next(axis->GetLabels());; 5264 TObject *obj;; 5265 Int_t nbins = 0;; 5266 while ((obj = next())) {; 5267 Int_t ibin = obj->GetUniqueID();; 5268 if (ibin > nbins) nbins = ibin;; 5269 }; 5270 if (nbins < 1) nbins = 1;; 5271 ; 5272 // Do nothing in case it was the last bin; 5273 if (nbins==axis->GetNbins()) return;; 5274 ; 5275 TH1 *hold = (TH1*)IsA()->New();; 5276 R__ASSERT(hold);; 5277 hold->SetDirectory(nullptr);; 5278 Copy(*hold);; 5279 ; 5280 Bool_t timedisp = axis->GetTimeDisplay();; 5281 Double_t xmin = axis->GetXmin();; 5282 Double_t xmax = axis->GetBinUpEdge(nbins);; 5283 if (xmax <= xmin) xmax = xmin +nbins;; 5284 axis->SetRange(0,0);; 5285 axis->Set(nbins,xmin,xmax);; 5286 SetBinsLength(-1); // reset the number of cells; 5287 Int_t errors = fSumw2.fN;; 5288 if (errors) fSumw2.Set(fNcells);; 5289 axis->SetTimeDisplay(timedisp);; 5290 // reset histogram content; 5291 Reset(""ICE"");; 5292 ; 5293 //now loop on all bins and refill; 5294 // NOTE that if the bins without labels have content; 5295 // it will be put in the underflow/overflow.; 5296 // For this reason we use AddBinContent method; 5297 Double_t oldEntries = fEntries;; 5298 Int_t bin,binx,biny,binz;; 5299 for (bin=0; bin < hold->fNcells; ++bin) {; 5300 hold->GetBinXYZ(bin,binx,biny,binz);; 5301 Int_t ibin = GetBin(binx,biny,binz);; 5302 Double_t cu = hold->RetrieveBinContent(bin);; 5303 AddBinContent(ibin,cu);; 5304 if (errors) {; 5305 fSumw2.fArray[ibin] += hold->fSumw2.fArray[bin];; 5306 }; 5307 }; 5308 fEntries = oldEntries;; 5309 delete hold;; 5310}; 5311 ; 5312////////////////////////////////////////////////////////////////////////////////; 5313/// Double the number of bins for axis.; 5314/// Refill histogram.; 5315/// This function is called by TAxis::FindBin(const char *label); 5316",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:213486,Availability,error,errors,213486," in case it was the last bin; 5273 if (nbins==axis->GetNbins()) return;; 5274 ; 5275 TH1 *hold = (TH1*)IsA()->New();; 5276 R__ASSERT(hold);; 5277 hold->SetDirectory(nullptr);; 5278 Copy(*hold);; 5279 ; 5280 Bool_t timedisp = axis->GetTimeDisplay();; 5281 Double_t xmin = axis->GetXmin();; 5282 Double_t xmax = axis->GetBinUpEdge(nbins);; 5283 if (xmax <= xmin) xmax = xmin +nbins;; 5284 axis->SetRange(0,0);; 5285 axis->Set(nbins,xmin,xmax);; 5286 SetBinsLength(-1); // reset the number of cells; 5287 Int_t errors = fSumw2.fN;; 5288 if (errors) fSumw2.Set(fNcells);; 5289 axis->SetTimeDisplay(timedisp);; 5290 // reset histogram content; 5291 Reset(""ICE"");; 5292 ; 5293 //now loop on all bins and refill; 5294 // NOTE that if the bins without labels have content; 5295 // it will be put in the underflow/overflow.; 5296 // For this reason we use AddBinContent method; 5297 Double_t oldEntries = fEntries;; 5298 Int_t bin,binx,biny,binz;; 5299 for (bin=0; bin < hold->fNcells; ++bin) {; 5300 hold->GetBinXYZ(bin,binx,biny,binz);; 5301 Int_t ibin = GetBin(binx,biny,binz);; 5302 Double_t cu = hold->RetrieveBinContent(bin);; 5303 AddBinContent(ibin,cu);; 5304 if (errors) {; 5305 fSumw2.fArray[ibin] += hold->fSumw2.fArray[bin];; 5306 }; 5307 }; 5308 fEntries = oldEntries;; 5309 delete hold;; 5310}; 5311 ; 5312////////////////////////////////////////////////////////////////////////////////; 5313/// Double the number of bins for axis.; 5314/// Refill histogram.; 5315/// This function is called by TAxis::FindBin(const char *label); 5316 ; 5317void TH1::LabelsInflate(Option_t *ax); 5318{; 5319 Int_t iaxis = AxisChoice(ax);; 5320 TAxis *axis = nullptr;; 5321 if (iaxis == 1) axis = GetXaxis();; 5322 if (iaxis == 2) axis = GetYaxis();; 5323 if (iaxis == 3) axis = GetZaxis();; 5324 if (!axis) return;; 5325 ; 5326 TH1 *hold = (TH1*)IsA()->New();; 5327 hold->SetDirectory(nullptr);; 5328 Copy(*hold);; 5329 hold->ResetBit(kMustCleanup);; 5330 ; 5331 Bool_t timedisp = axis->GetTimeDisplay();; 5332 ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:214614,Availability,error,errors,214614,"dEntries = fEntries;; 5298 Int_t bin,binx,biny,binz;; 5299 for (bin=0; bin < hold->fNcells; ++bin) {; 5300 hold->GetBinXYZ(bin,binx,biny,binz);; 5301 Int_t ibin = GetBin(binx,biny,binz);; 5302 Double_t cu = hold->RetrieveBinContent(bin);; 5303 AddBinContent(ibin,cu);; 5304 if (errors) {; 5305 fSumw2.fArray[ibin] += hold->fSumw2.fArray[bin];; 5306 }; 5307 }; 5308 fEntries = oldEntries;; 5309 delete hold;; 5310}; 5311 ; 5312////////////////////////////////////////////////////////////////////////////////; 5313/// Double the number of bins for axis.; 5314/// Refill histogram.; 5315/// This function is called by TAxis::FindBin(const char *label); 5316 ; 5317void TH1::LabelsInflate(Option_t *ax); 5318{; 5319 Int_t iaxis = AxisChoice(ax);; 5320 TAxis *axis = nullptr;; 5321 if (iaxis == 1) axis = GetXaxis();; 5322 if (iaxis == 2) axis = GetYaxis();; 5323 if (iaxis == 3) axis = GetZaxis();; 5324 if (!axis) return;; 5325 ; 5326 TH1 *hold = (TH1*)IsA()->New();; 5327 hold->SetDirectory(nullptr);; 5328 Copy(*hold);; 5329 hold->ResetBit(kMustCleanup);; 5330 ; 5331 Bool_t timedisp = axis->GetTimeDisplay();; 5332 Int_t nbins = axis->GetNbins();; 5333 Double_t xmin = axis->GetXmin();; 5334 Double_t xmax = axis->GetXmax();; 5335 xmax = xmin + 2*(xmax-xmin);; 5336 axis->SetRange(0,0);; 5337 // double the bins and recompute ncells; 5338 axis->Set(2*nbins,xmin,xmax);; 5339 SetBinsLength(-1);; 5340 Int_t errors = fSumw2.fN;; 5341 if (errors) fSumw2.Set(fNcells);; 5342 axis->SetTimeDisplay(timedisp);; 5343 ; 5344 Reset(""ICE""); // reset content and error; 5345 ; 5346 //now loop on all bins and refill; 5347 Double_t oldEntries = fEntries;; 5348 Int_t bin,ibin,binx,biny,binz;; 5349 for (ibin =0; ibin < hold->fNcells; ibin++) {; 5350 // get the binx,y,z values . The x-y-z (axis) bin values will stay the same between new-old after the expanding; 5351 hold->GetBinXYZ(ibin,binx,biny,binz);; 5352 bin = GetBin(binx,biny,binz);; 5353 ; 5354 // underflow and overflow will be cleaned up because their",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:214644,Availability,error,errors,214644,"//////////////////////////////////////////////////////////////////////; 5313/// Double the number of bins for axis.; 5314/// Refill histogram.; 5315/// This function is called by TAxis::FindBin(const char *label); 5316 ; 5317void TH1::LabelsInflate(Option_t *ax); 5318{; 5319 Int_t iaxis = AxisChoice(ax);; 5320 TAxis *axis = nullptr;; 5321 if (iaxis == 1) axis = GetXaxis();; 5322 if (iaxis == 2) axis = GetYaxis();; 5323 if (iaxis == 3) axis = GetZaxis();; 5324 if (!axis) return;; 5325 ; 5326 TH1 *hold = (TH1*)IsA()->New();; 5327 hold->SetDirectory(nullptr);; 5328 Copy(*hold);; 5329 hold->ResetBit(kMustCleanup);; 5330 ; 5331 Bool_t timedisp = axis->GetTimeDisplay();; 5332 Int_t nbins = axis->GetNbins();; 5333 Double_t xmin = axis->GetXmin();; 5334 Double_t xmax = axis->GetXmax();; 5335 xmax = xmin + 2*(xmax-xmin);; 5336 axis->SetRange(0,0);; 5337 // double the bins and recompute ncells; 5338 axis->Set(2*nbins,xmin,xmax);; 5339 SetBinsLength(-1);; 5340 Int_t errors = fSumw2.fN;; 5341 if (errors) fSumw2.Set(fNcells);; 5342 axis->SetTimeDisplay(timedisp);; 5343 ; 5344 Reset(""ICE""); // reset content and error; 5345 ; 5346 //now loop on all bins and refill; 5347 Double_t oldEntries = fEntries;; 5348 Int_t bin,ibin,binx,biny,binz;; 5349 for (ibin =0; ibin < hold->fNcells; ibin++) {; 5350 // get the binx,y,z values . The x-y-z (axis) bin values will stay the same between new-old after the expanding; 5351 hold->GetBinXYZ(ibin,binx,biny,binz);; 5352 bin = GetBin(binx,biny,binz);; 5353 ; 5354 // underflow and overflow will be cleaned up because their meaning has been altered; 5355 if (hold->IsBinUnderflow(ibin,iaxis) || hold->IsBinOverflow(ibin,iaxis)) {; 5356 continue;; 5357 }; 5358 else {; 5359 AddBinContent(bin, hold->RetrieveBinContent(ibin));; 5360 if (errors) fSumw2.fArray[bin] += hold->fSumw2.fArray[ibin];; 5361 }; 5362 }; 5363 fEntries = oldEntries;; 5364 delete hold;; 5365}; 5366 ; 5367////////////////////////////////////////////////////////////////////////////////; 536",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:214759,Availability,error,error,214759,"led by TAxis::FindBin(const char *label); 5316 ; 5317void TH1::LabelsInflate(Option_t *ax); 5318{; 5319 Int_t iaxis = AxisChoice(ax);; 5320 TAxis *axis = nullptr;; 5321 if (iaxis == 1) axis = GetXaxis();; 5322 if (iaxis == 2) axis = GetYaxis();; 5323 if (iaxis == 3) axis = GetZaxis();; 5324 if (!axis) return;; 5325 ; 5326 TH1 *hold = (TH1*)IsA()->New();; 5327 hold->SetDirectory(nullptr);; 5328 Copy(*hold);; 5329 hold->ResetBit(kMustCleanup);; 5330 ; 5331 Bool_t timedisp = axis->GetTimeDisplay();; 5332 Int_t nbins = axis->GetNbins();; 5333 Double_t xmin = axis->GetXmin();; 5334 Double_t xmax = axis->GetXmax();; 5335 xmax = xmin + 2*(xmax-xmin);; 5336 axis->SetRange(0,0);; 5337 // double the bins and recompute ncells; 5338 axis->Set(2*nbins,xmin,xmax);; 5339 SetBinsLength(-1);; 5340 Int_t errors = fSumw2.fN;; 5341 if (errors) fSumw2.Set(fNcells);; 5342 axis->SetTimeDisplay(timedisp);; 5343 ; 5344 Reset(""ICE""); // reset content and error; 5345 ; 5346 //now loop on all bins and refill; 5347 Double_t oldEntries = fEntries;; 5348 Int_t bin,ibin,binx,biny,binz;; 5349 for (ibin =0; ibin < hold->fNcells; ibin++) {; 5350 // get the binx,y,z values . The x-y-z (axis) bin values will stay the same between new-old after the expanding; 5351 hold->GetBinXYZ(ibin,binx,biny,binz);; 5352 bin = GetBin(binx,biny,binz);; 5353 ; 5354 // underflow and overflow will be cleaned up because their meaning has been altered; 5355 if (hold->IsBinUnderflow(ibin,iaxis) || hold->IsBinOverflow(ibin,iaxis)) {; 5356 continue;; 5357 }; 5358 else {; 5359 AddBinContent(bin, hold->RetrieveBinContent(ibin));; 5360 if (errors) fSumw2.fArray[bin] += hold->fSumw2.fArray[ibin];; 5361 }; 5362 }; 5363 fEntries = oldEntries;; 5364 delete hold;; 5365}; 5366 ; 5367////////////////////////////////////////////////////////////////////////////////; 5368/// Sort bins with labels or set option(s) to draw axis with labels; 5369/// \param[in] option; 5370/// - ""a"" sort by alphabetic order; 5371/// - "">"" sort by decreasing v",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:215420,Availability,error,errors,215420,");; 5328 Copy(*hold);; 5329 hold->ResetBit(kMustCleanup);; 5330 ; 5331 Bool_t timedisp = axis->GetTimeDisplay();; 5332 Int_t nbins = axis->GetNbins();; 5333 Double_t xmin = axis->GetXmin();; 5334 Double_t xmax = axis->GetXmax();; 5335 xmax = xmin + 2*(xmax-xmin);; 5336 axis->SetRange(0,0);; 5337 // double the bins and recompute ncells; 5338 axis->Set(2*nbins,xmin,xmax);; 5339 SetBinsLength(-1);; 5340 Int_t errors = fSumw2.fN;; 5341 if (errors) fSumw2.Set(fNcells);; 5342 axis->SetTimeDisplay(timedisp);; 5343 ; 5344 Reset(""ICE""); // reset content and error; 5345 ; 5346 //now loop on all bins and refill; 5347 Double_t oldEntries = fEntries;; 5348 Int_t bin,ibin,binx,biny,binz;; 5349 for (ibin =0; ibin < hold->fNcells; ibin++) {; 5350 // get the binx,y,z values . The x-y-z (axis) bin values will stay the same between new-old after the expanding; 5351 hold->GetBinXYZ(ibin,binx,biny,binz);; 5352 bin = GetBin(binx,biny,binz);; 5353 ; 5354 // underflow and overflow will be cleaned up because their meaning has been altered; 5355 if (hold->IsBinUnderflow(ibin,iaxis) || hold->IsBinOverflow(ibin,iaxis)) {; 5356 continue;; 5357 }; 5358 else {; 5359 AddBinContent(bin, hold->RetrieveBinContent(ibin));; 5360 if (errors) fSumw2.fArray[bin] += hold->fSumw2.fArray[ibin];; 5361 }; 5362 }; 5363 fEntries = oldEntries;; 5364 delete hold;; 5365}; 5366 ; 5367////////////////////////////////////////////////////////////////////////////////; 5368/// Sort bins with labels or set option(s) to draw axis with labels; 5369/// \param[in] option; 5370/// - ""a"" sort by alphabetic order; 5371/// - "">"" sort by decreasing values; 5372/// - ""<"" sort by increasing values; 5373/// - ""h"" draw labels horizontal; 5374/// - ""v"" draw labels vertical; 5375/// - ""u"" draw labels up (end of label right adjusted); 5376/// - ""d"" draw labels down (start of label left adjusted); 5377///; 5378/// In case not all bins have labels sorting will work only in the case; 5379/// the first `n` consecutive bins have all labels an",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:216024,Availability,down,down,216024,"bin,ibin,binx,biny,binz;; 5349 for (ibin =0; ibin < hold->fNcells; ibin++) {; 5350 // get the binx,y,z values . The x-y-z (axis) bin values will stay the same between new-old after the expanding; 5351 hold->GetBinXYZ(ibin,binx,biny,binz);; 5352 bin = GetBin(binx,biny,binz);; 5353 ; 5354 // underflow and overflow will be cleaned up because their meaning has been altered; 5355 if (hold->IsBinUnderflow(ibin,iaxis) || hold->IsBinOverflow(ibin,iaxis)) {; 5356 continue;; 5357 }; 5358 else {; 5359 AddBinContent(bin, hold->RetrieveBinContent(ibin));; 5360 if (errors) fSumw2.fArray[bin] += hold->fSumw2.fArray[ibin];; 5361 }; 5362 }; 5363 fEntries = oldEntries;; 5364 delete hold;; 5365}; 5366 ; 5367////////////////////////////////////////////////////////////////////////////////; 5368/// Sort bins with labels or set option(s) to draw axis with labels; 5369/// \param[in] option; 5370/// - ""a"" sort by alphabetic order; 5371/// - "">"" sort by decreasing values; 5372/// - ""<"" sort by increasing values; 5373/// - ""h"" draw labels horizontal; 5374/// - ""v"" draw labels vertical; 5375/// - ""u"" draw labels up (end of label right adjusted); 5376/// - ""d"" draw labels down (start of label left adjusted); 5377///; 5378/// In case not all bins have labels sorting will work only in the case; 5379/// the first `n` consecutive bins have all labels and sorting will be performed on; 5380/// those label bins.; 5381///; 5382/// \param[in] ax axis; 5383 ; 5384void TH1::LabelsOption(Option_t *option, Option_t *ax); 5385{; 5386 Int_t iaxis = AxisChoice(ax);; 5387 TAxis *axis = nullptr;; 5388 if (iaxis == 1); 5389 axis = GetXaxis();; 5390 if (iaxis == 2); 5391 axis = GetYaxis();; 5392 if (iaxis == 3); 5393 axis = GetZaxis();; 5394 if (!axis); 5395 return;; 5396 THashList *labels = axis->GetLabels();; 5397 if (!labels) {; 5398 Warning(""LabelsOption"", ""Axis %s has no labels!"",axis->GetName());; 5399 return;; 5400 }; 5401 TString opt = option;; 5402 opt.ToLower();; 5403 Int_t iopt = -1;; 5404 if (opt.Conta",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:219207,Availability,error,error,219207,"ant to support this special case; 5447 // Int_t n = TMath::Min(axis->GetNbins(), labels->GetSize());; 5448 ; 5449 // support only cases where each bin has a labels (should be when axis is alphanumeric); 5450 Int_t n = labels->GetSize();; 5451 if (n != axis->GetNbins()) {; 5452 // check if labels are all consecutive and starts from the first bin; 5453 // in that case the current code will work fine; 5454 Int_t firstLabelBin = axis->GetNbins()+1;; 5455 Int_t lastLabelBin = -1;; 5456 for (Int_t i = 0; i < n; ++i) {; 5457 Int_t bin = labels->At(i)->GetUniqueID();; 5458 if (bin < firstLabelBin) firstLabelBin = bin;; 5459 if (bin > lastLabelBin) lastLabelBin = bin;; 5460 }; 5461 if (firstLabelBin != 1 || lastLabelBin-firstLabelBin +1 != n) {; 5462 Error(""LabelsOption"", ""%s of Histogram %s contains bins without labels. Sorting will not work correctly - return"",; 5463 axis->GetName(), GetName());; 5464 return;; 5465 }; 5466 // case where label bins are consecutive starting from first bin will work; 5467 // calling before a TH1::LabelsDeflate() will avoid this error message; 5468 Warning(""LabelsOption"", ""axis %s of Histogram %s has extra following bins without labels. Sorting will work only for first label bins"",; 5469 axis->GetName(), GetName());; 5470 }; 5471 std::vector<Int_t> a(n);; 5472 std::vector<Int_t> b(n);; 5473 ; 5474 ; 5475 Int_t i, j, k;; 5476 std::vector<Double_t> cont;; 5477 std::vector<Double_t> errors2;; 5478 THashList *labold = new THashList(labels->GetSize(), 1);; 5479 TIter nextold(labels);; 5480 TObject *obj = nullptr;; 5481 labold->AddAll(labels);; 5482 labels->Clear();; 5483 ; 5484 // delete buffer if it is there since bins will be reordered.; 5485 if (fBuffer); 5486 BufferEmpty(1);; 5487 ; 5488 if (sort > 0) {; 5489 //---sort by values of bins; 5490 if (GetDimension() == 1) {; 5491 cont.resize(n);; 5492 if (fSumw2.fN); 5493 errors2.resize(n);; 5494 for (i = 0; i < n; i++) {; 5495 cont[i] = RetrieveBinContent(i + 1);; 5496 if (!errors2.empty()); 5497 e",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:236741,Availability,error,errors,236741,"= (TMath::Ceil(delta) - delta)*width1;; 5954 ; 5955 ; 5956 delta = (xmax - anAxis.GetXmax())/width2;; 5957 if (!AlmostInteger(delta)); 5958 xmax += (TMath::Ceil(delta) - delta)*width2;; 5959 ; 5960 ; 5961 delta = (xmax - destAxis.GetXmax())/width1;; 5962 if (!AlmostInteger(delta)); 5963 return kFALSE;; 5964#ifdef DEBUG; 5965 if (!AlmostInteger((xmax - xmin) / width)) { // unnecessary check; 5966 printf(""TH1::RecomputeAxisLimits - Impossible\n"");; 5967 return kFALSE;; 5968 }; 5969#endif; 5970 ; 5971 ; 5972 destAxis.Set(TMath::Nint((xmax - xmin)/width), xmin, xmax);; 5973 ; 5974 //std::cout << ""New re-computed axis : [ "" << xmin << "" , "" << xmax << "" ] width = "" << width << "" nbins "" << destAxis.GetNbins() << std::endl;; 5975 ; 5976 return kTRUE;; 5977}; 5978 ; 5979////////////////////////////////////////////////////////////////////////////////; 5980/// Add all histograms in the collection to this histogram.; 5981/// This function computes the min/max for the x axis,; 5982/// compute a new number of bins, if necessary,; 5983/// add bin contents, errors and statistics.; 5984/// If all histograms have bin labels, bins with identical labels; 5985/// will be merged, no matter what their order is.; 5986/// If overflows are present and limits are different the function will fail.; 5987/// The function returns the total number of entries in the result histogram; 5988/// if the merge is successful, -1 otherwise.; 5989///; 5990/// Possible option:; 5991/// -NOL : the merger will ignore the labels and merge the histograms bin by bin using bin center values to match bins; 5992/// -NOCHECK: the histogram will not perform a check for duplicate labels in case of axes with labels. The check; 5993/// (enabled by default) slows down the merging; 5994///; 5995/// IMPORTANT remark. The axis x may have different number; 5996/// of bins and different limits, BUT the largest bin width must be; 5997/// a multiple of the smallest bin width and the upper limit must also; 5998/// be a multiple ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:237420,Availability,down,down,237420,"return kTRUE;; 5977}; 5978 ; 5979////////////////////////////////////////////////////////////////////////////////; 5980/// Add all histograms in the collection to this histogram.; 5981/// This function computes the min/max for the x axis,; 5982/// compute a new number of bins, if necessary,; 5983/// add bin contents, errors and statistics.; 5984/// If all histograms have bin labels, bins with identical labels; 5985/// will be merged, no matter what their order is.; 5986/// If overflows are present and limits are different the function will fail.; 5987/// The function returns the total number of entries in the result histogram; 5988/// if the merge is successful, -1 otherwise.; 5989///; 5990/// Possible option:; 5991/// -NOL : the merger will ignore the labels and merge the histograms bin by bin using bin center values to match bins; 5992/// -NOCHECK: the histogram will not perform a check for duplicate labels in case of axes with labels. The check; 5993/// (enabled by default) slows down the merging; 5994///; 5995/// IMPORTANT remark. The axis x may have different number; 5996/// of bins and different limits, BUT the largest bin width must be; 5997/// a multiple of the smallest bin width and the upper limit must also; 5998/// be a multiple of the bin width.; 5999/// Example:; 6000///; 6001/// ~~~ {.cpp}; 6002/// void atest() {; 6003/// TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; 6004/// TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; 6005/// TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; 6006/// TRandom r;; 6007/// for (Int_t i=0;i<10000;i++) {; 6008/// h1->Fill(r.Gaus(-55,10));; 6009/// h2->Fill(r.Gaus(55,10));; 6010/// h3->Fill(r.Gaus(0,10));; 6011/// }; 6012///; 6013/// TList *list = new TList;; 6014/// list->Add(h1);; 6015/// list->Add(h2);; 6016/// list->Add(h3);; 6017/// TH1F *h = (TH1F*)h1->Clone(""h"");; 6018/// h->Reset();; 6019/// h->Merge(list);; 6020/// h->Draw();; 6021/// }; 6022/// ~~~; 6023 ; 6024Long64_t TH1::Merge(TCollection *li,Option_t * opt); 6025{; 6026 i",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:238848,Availability,error,errors,238848,"ifferent number; 5996/// of bins and different limits, BUT the largest bin width must be; 5997/// a multiple of the smallest bin width and the upper limit must also; 5998/// be a multiple of the bin width.; 5999/// Example:; 6000///; 6001/// ~~~ {.cpp}; 6002/// void atest() {; 6003/// TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; 6004/// TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; 6005/// TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; 6006/// TRandom r;; 6007/// for (Int_t i=0;i<10000;i++) {; 6008/// h1->Fill(r.Gaus(-55,10));; 6009/// h2->Fill(r.Gaus(55,10));; 6010/// h3->Fill(r.Gaus(0,10));; 6011/// }; 6012///; 6013/// TList *list = new TList;; 6014/// list->Add(h1);; 6015/// list->Add(h2);; 6016/// list->Add(h3);; 6017/// TH1F *h = (TH1F*)h1->Clone(""h"");; 6018/// h->Reset();; 6019/// h->Merge(list);; 6020/// h->Draw();; 6021/// }; 6022/// ~~~; 6023 ; 6024Long64_t TH1::Merge(TCollection *li,Option_t * opt); 6025{; 6026 if (!li) return 0;; 6027 if (li->IsEmpty()) return (Long64_t) GetEntries();; 6028 ; 6029 // use TH1Merger class; 6030 TH1Merger merger(*this,*li,opt);; 6031 Bool_t ret = merger();; 6032 ; 6033 return (ret) ? GetEntries() : -1;; 6034}; 6035 ; 6036 ; 6037////////////////////////////////////////////////////////////////////////////////; 6038/// Performs the operation:; 6039///; 6040/// `this = this*c1*f1`; 6041///; 6042/// If errors are defined (see TH1::Sumw2), errors are also recalculated.; 6043///; 6044/// Only bins inside the function range are recomputed.; 6045/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 6046/// you should call Sumw2 before making this operation.; 6047/// This is particularly important if you fit the histogram after TH1::Multiply; 6048///; 6049/// The function return kFALSE if the Multiply operation failed; 6050 ; 6051Bool_t TH1::Multiply(TF1 *f1, Double_t c1); 6052{; 6053 if (!f1) {; 6054 Error(""Multiply"",""Attempt to multiply by a non-existing function"");; 6055 return kFALSE;; 6056 }; 6057 ; 6058 // delete",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:238885,Availability,error,errors,238885,"ifferent number; 5996/// of bins and different limits, BUT the largest bin width must be; 5997/// a multiple of the smallest bin width and the upper limit must also; 5998/// be a multiple of the bin width.; 5999/// Example:; 6000///; 6001/// ~~~ {.cpp}; 6002/// void atest() {; 6003/// TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; 6004/// TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; 6005/// TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; 6006/// TRandom r;; 6007/// for (Int_t i=0;i<10000;i++) {; 6008/// h1->Fill(r.Gaus(-55,10));; 6009/// h2->Fill(r.Gaus(55,10));; 6010/// h3->Fill(r.Gaus(0,10));; 6011/// }; 6012///; 6013/// TList *list = new TList;; 6014/// list->Add(h1);; 6015/// list->Add(h2);; 6016/// list->Add(h3);; 6017/// TH1F *h = (TH1F*)h1->Clone(""h"");; 6018/// h->Reset();; 6019/// h->Merge(list);; 6020/// h->Draw();; 6021/// }; 6022/// ~~~; 6023 ; 6024Long64_t TH1::Merge(TCollection *li,Option_t * opt); 6025{; 6026 if (!li) return 0;; 6027 if (li->IsEmpty()) return (Long64_t) GetEntries();; 6028 ; 6029 // use TH1Merger class; 6030 TH1Merger merger(*this,*li,opt);; 6031 Bool_t ret = merger();; 6032 ; 6033 return (ret) ? GetEntries() : -1;; 6034}; 6035 ; 6036 ; 6037////////////////////////////////////////////////////////////////////////////////; 6038/// Performs the operation:; 6039///; 6040/// `this = this*c1*f1`; 6041///; 6042/// If errors are defined (see TH1::Sumw2), errors are also recalculated.; 6043///; 6044/// Only bins inside the function range are recomputed.; 6045/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 6046/// you should call Sumw2 before making this operation.; 6047/// This is particularly important if you fit the histogram after TH1::Multiply; 6048///; 6049/// The function return kFALSE if the Multiply operation failed; 6050 ; 6051Bool_t TH1::Multiply(TF1 *f1, Double_t c1); 6052{; 6053 if (!f1) {; 6054 Error(""Multiply"",""Attempt to multiply by a non-existing function"");; 6055 return kFALSE;; 6056 }; 6057 ; 6058 // delete",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:239035,Availability,error,errors,239035,"6010/// h3->Fill(r.Gaus(0,10));; 6011/// }; 6012///; 6013/// TList *list = new TList;; 6014/// list->Add(h1);; 6015/// list->Add(h2);; 6016/// list->Add(h3);; 6017/// TH1F *h = (TH1F*)h1->Clone(""h"");; 6018/// h->Reset();; 6019/// h->Merge(list);; 6020/// h->Draw();; 6021/// }; 6022/// ~~~; 6023 ; 6024Long64_t TH1::Merge(TCollection *li,Option_t * opt); 6025{; 6026 if (!li) return 0;; 6027 if (li->IsEmpty()) return (Long64_t) GetEntries();; 6028 ; 6029 // use TH1Merger class; 6030 TH1Merger merger(*this,*li,opt);; 6031 Bool_t ret = merger();; 6032 ; 6033 return (ret) ? GetEntries() : -1;; 6034}; 6035 ; 6036 ; 6037////////////////////////////////////////////////////////////////////////////////; 6038/// Performs the operation:; 6039///; 6040/// `this = this*c1*f1`; 6041///; 6042/// If errors are defined (see TH1::Sumw2), errors are also recalculated.; 6043///; 6044/// Only bins inside the function range are recomputed.; 6045/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 6046/// you should call Sumw2 before making this operation.; 6047/// This is particularly important if you fit the histogram after TH1::Multiply; 6048///; 6049/// The function return kFALSE if the Multiply operation failed; 6050 ; 6051Bool_t TH1::Multiply(TF1 *f1, Double_t c1); 6052{; 6053 if (!f1) {; 6054 Error(""Multiply"",""Attempt to multiply by a non-existing function"");; 6055 return kFALSE;; 6056 }; 6057 ; 6058 // delete buffer if it is there since it will become invalid; 6059 if (fBuffer) BufferEmpty(1);; 6060 ; 6061 Int_t nx = GetNbinsX() + 2; // normal bins + uf / of (cells); 6062 Int_t ny = GetNbinsY() + 2;; 6063 Int_t nz = GetNbinsZ() + 2;; 6064 if (fDimension < 2) ny = 1;; 6065 if (fDimension < 3) nz = 1;; 6066 ; 6067 // reset min-maximum; 6068 SetMinimum();; 6069 SetMaximum();; 6070 ; 6071 // - Loop on bins (including underflows/overflows); 6072 Double_t xx[3];; 6073 Double_t *params = nullptr;; 6074 f1->InitArgs(xx,params);; 6075 ; 6076 for (Int_t binz = 0; binz ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:240908,Availability,error,errors,240908,"lows/overflows); 6072 Double_t xx[3];; 6073 Double_t *params = nullptr;; 6074 f1->InitArgs(xx,params);; 6075 ; 6076 for (Int_t binz = 0; binz < nz; ++binz) {; 6077 xx[2] = fZaxis.GetBinCenter(binz);; 6078 for (Int_t biny = 0; biny < ny; ++biny) {; 6079 xx[1] = fYaxis.GetBinCenter(biny);; 6080 for (Int_t binx = 0; binx < nx; ++binx) {; 6081 xx[0] = fXaxis.GetBinCenter(binx);; 6082 if (!f1->IsInside(xx)) continue;; 6083 TF1::RejectPoint(kFALSE);; 6084 Int_t bin = binx + nx * (biny + ny *binz);; 6085 Double_t cu = c1*f1->EvalPar(xx);; 6086 if (TF1::RejectedPoint()) continue;; 6087 UpdateBinContent(bin, RetrieveBinContent(bin) * cu);; 6088 if (fSumw2.fN) {; 6089 fSumw2.fArray[bin] = cu * cu * GetBinErrorSqUnchecked(bin);; 6090 }; 6091 }; 6092 }; 6093 }; 6094 ResetStats();; 6095 return kTRUE;; 6096}; 6097 ; 6098////////////////////////////////////////////////////////////////////////////////; 6099/// Multiply this histogram by h1.; 6100///; 6101/// `this = this*h1`; 6102///; 6103/// If errors of this are available (TH1::Sumw2), errors are recalculated.; 6104/// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; 6105/// if not already set.; 6106///; 6107/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 6108/// you should call Sumw2 before making this operation.; 6109/// This is particularly important if you fit the histogram after TH1::Multiply; 6110///; 6111/// The function return kFALSE if the Multiply operation failed; 6112 ; 6113Bool_t TH1::Multiply(const TH1 *h1); 6114{; 6115 if (!h1) {; 6116 Error(""Multiply"",""Attempt to multiply by a non-existing histogram"");; 6117 return kFALSE;; 6118 }; 6119 ; 6120 // delete buffer if it is there since it will become invalid; 6121 if (fBuffer) BufferEmpty(1);; 6122 ; 6123 if (LoggedInconsistency(""Multiply"", this, h1) >= kDifferentNumberOfBins) {; 6124 return false;; 6125 }; 6126 ; 6127 // Create Sumw2 if h1 has Sumw2 set; 6128 if (fSumw2.fN == 0 && h1->GetSumw2N() != 0) Sumw2();; 6129 ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:240927,Availability,avail,available,240927,"lows/overflows); 6072 Double_t xx[3];; 6073 Double_t *params = nullptr;; 6074 f1->InitArgs(xx,params);; 6075 ; 6076 for (Int_t binz = 0; binz < nz; ++binz) {; 6077 xx[2] = fZaxis.GetBinCenter(binz);; 6078 for (Int_t biny = 0; biny < ny; ++biny) {; 6079 xx[1] = fYaxis.GetBinCenter(biny);; 6080 for (Int_t binx = 0; binx < nx; ++binx) {; 6081 xx[0] = fXaxis.GetBinCenter(binx);; 6082 if (!f1->IsInside(xx)) continue;; 6083 TF1::RejectPoint(kFALSE);; 6084 Int_t bin = binx + nx * (biny + ny *binz);; 6085 Double_t cu = c1*f1->EvalPar(xx);; 6086 if (TF1::RejectedPoint()) continue;; 6087 UpdateBinContent(bin, RetrieveBinContent(bin) * cu);; 6088 if (fSumw2.fN) {; 6089 fSumw2.fArray[bin] = cu * cu * GetBinErrorSqUnchecked(bin);; 6090 }; 6091 }; 6092 }; 6093 }; 6094 ResetStats();; 6095 return kTRUE;; 6096}; 6097 ; 6098////////////////////////////////////////////////////////////////////////////////; 6099/// Multiply this histogram by h1.; 6100///; 6101/// `this = this*h1`; 6102///; 6103/// If errors of this are available (TH1::Sumw2), errors are recalculated.; 6104/// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; 6105/// if not already set.; 6106///; 6107/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 6108/// you should call Sumw2 before making this operation.; 6109/// This is particularly important if you fit the histogram after TH1::Multiply; 6110///; 6111/// The function return kFALSE if the Multiply operation failed; 6112 ; 6113Bool_t TH1::Multiply(const TH1 *h1); 6114{; 6115 if (!h1) {; 6116 Error(""Multiply"",""Attempt to multiply by a non-existing histogram"");; 6117 return kFALSE;; 6118 }; 6119 ; 6120 // delete buffer if it is there since it will become invalid; 6121 if (fBuffer) BufferEmpty(1);; 6122 ; 6123 if (LoggedInconsistency(""Multiply"", this, h1) >= kDifferentNumberOfBins) {; 6124 return false;; 6125 }; 6126 ; 6127 // Create Sumw2 if h1 has Sumw2 set; 6128 if (fSumw2.fN == 0 && h1->GetSumw2N() != 0) Sumw2();; 6129 ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:240951,Availability,error,errors,240951,"lows/overflows); 6072 Double_t xx[3];; 6073 Double_t *params = nullptr;; 6074 f1->InitArgs(xx,params);; 6075 ; 6076 for (Int_t binz = 0; binz < nz; ++binz) {; 6077 xx[2] = fZaxis.GetBinCenter(binz);; 6078 for (Int_t biny = 0; biny < ny; ++biny) {; 6079 xx[1] = fYaxis.GetBinCenter(biny);; 6080 for (Int_t binx = 0; binx < nx; ++binx) {; 6081 xx[0] = fXaxis.GetBinCenter(binx);; 6082 if (!f1->IsInside(xx)) continue;; 6083 TF1::RejectPoint(kFALSE);; 6084 Int_t bin = binx + nx * (biny + ny *binz);; 6085 Double_t cu = c1*f1->EvalPar(xx);; 6086 if (TF1::RejectedPoint()) continue;; 6087 UpdateBinContent(bin, RetrieveBinContent(bin) * cu);; 6088 if (fSumw2.fN) {; 6089 fSumw2.fArray[bin] = cu * cu * GetBinErrorSqUnchecked(bin);; 6090 }; 6091 }; 6092 }; 6093 }; 6094 ResetStats();; 6095 return kTRUE;; 6096}; 6097 ; 6098////////////////////////////////////////////////////////////////////////////////; 6099/// Multiply this histogram by h1.; 6100///; 6101/// `this = this*h1`; 6102///; 6103/// If errors of this are available (TH1::Sumw2), errors are recalculated.; 6104/// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; 6105/// if not already set.; 6106///; 6107/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 6108/// you should call Sumw2 before making this operation.; 6109/// This is particularly important if you fit the histogram after TH1::Multiply; 6110///; 6111/// The function return kFALSE if the Multiply operation failed; 6112 ; 6113Bool_t TH1::Multiply(const TH1 *h1); 6114{; 6115 if (!h1) {; 6116 Error(""Multiply"",""Attempt to multiply by a non-existing histogram"");; 6117 return kFALSE;; 6118 }; 6119 ; 6120 // delete buffer if it is there since it will become invalid; 6121 if (fBuffer) BufferEmpty(1);; 6122 ; 6123 if (LoggedInconsistency(""Multiply"", this, h1) >= kDifferentNumberOfBins) {; 6124 return false;; 6125 }; 6126 ; 6127 // Create Sumw2 if h1 has Sumw2 set; 6128 if (fSumw2.fN == 0 && h1->GetSumw2N() != 0) Sumw2();; 6129 ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:241143,Availability,error,errors,241143,"{; 6079 xx[1] = fYaxis.GetBinCenter(biny);; 6080 for (Int_t binx = 0; binx < nx; ++binx) {; 6081 xx[0] = fXaxis.GetBinCenter(binx);; 6082 if (!f1->IsInside(xx)) continue;; 6083 TF1::RejectPoint(kFALSE);; 6084 Int_t bin = binx + nx * (biny + ny *binz);; 6085 Double_t cu = c1*f1->EvalPar(xx);; 6086 if (TF1::RejectedPoint()) continue;; 6087 UpdateBinContent(bin, RetrieveBinContent(bin) * cu);; 6088 if (fSumw2.fN) {; 6089 fSumw2.fArray[bin] = cu * cu * GetBinErrorSqUnchecked(bin);; 6090 }; 6091 }; 6092 }; 6093 }; 6094 ResetStats();; 6095 return kTRUE;; 6096}; 6097 ; 6098////////////////////////////////////////////////////////////////////////////////; 6099/// Multiply this histogram by h1.; 6100///; 6101/// `this = this*h1`; 6102///; 6103/// If errors of this are available (TH1::Sumw2), errors are recalculated.; 6104/// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; 6105/// if not already set.; 6106///; 6107/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 6108/// you should call Sumw2 before making this operation.; 6109/// This is particularly important if you fit the histogram after TH1::Multiply; 6110///; 6111/// The function return kFALSE if the Multiply operation failed; 6112 ; 6113Bool_t TH1::Multiply(const TH1 *h1); 6114{; 6115 if (!h1) {; 6116 Error(""Multiply"",""Attempt to multiply by a non-existing histogram"");; 6117 return kFALSE;; 6118 }; 6119 ; 6120 // delete buffer if it is there since it will become invalid; 6121 if (fBuffer) BufferEmpty(1);; 6122 ; 6123 if (LoggedInconsistency(""Multiply"", this, h1) >= kDifferentNumberOfBins) {; 6124 return false;; 6125 }; 6126 ; 6127 // Create Sumw2 if h1 has Sumw2 set; 6128 if (fSumw2.fN == 0 && h1->GetSumw2N() != 0) Sumw2();; 6129 ; 6130 // - Reset min- maximum; 6131 SetMinimum();; 6132 SetMaximum();; 6133 ; 6134 // - Loop on bins (including underflows/overflows); 6135 for (Int_t i = 0; i < fNcells; ++i) {; 6136 Double_t c0 = RetrieveBinContent(i);; 6137 Double_t c1 = h1->",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:242640,Availability,error,errors,242640,"nvalid; 6121 if (fBuffer) BufferEmpty(1);; 6122 ; 6123 if (LoggedInconsistency(""Multiply"", this, h1) >= kDifferentNumberOfBins) {; 6124 return false;; 6125 }; 6126 ; 6127 // Create Sumw2 if h1 has Sumw2 set; 6128 if (fSumw2.fN == 0 && h1->GetSumw2N() != 0) Sumw2();; 6129 ; 6130 // - Reset min- maximum; 6131 SetMinimum();; 6132 SetMaximum();; 6133 ; 6134 // - Loop on bins (including underflows/overflows); 6135 for (Int_t i = 0; i < fNcells; ++i) {; 6136 Double_t c0 = RetrieveBinContent(i);; 6137 Double_t c1 = h1->RetrieveBinContent(i);; 6138 UpdateBinContent(i, c0 * c1);; 6139 if (fSumw2.fN) {; 6140 fSumw2.fArray[i] = GetBinErrorSqUnchecked(i) * c1 * c1 + h1->GetBinErrorSqUnchecked(i) * c0 * c0;; 6141 }; 6142 }; 6143 ResetStats();; 6144 return kTRUE;; 6145}; 6146 ; 6147////////////////////////////////////////////////////////////////////////////////; 6148/// Replace contents of this histogram by multiplication of h1 by h2.; 6149///; 6150/// `this = (c1*h1)*(c2*h2)`; 6151///; 6152/// If errors of this are available (TH1::Sumw2), errors are recalculated.; 6153/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 6154/// if not already set.; 6155///; 6156/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 6157/// you should call Sumw2 before making this operation.; 6158/// This is particularly important if you fit the histogram after TH1::Multiply; 6159///; 6160/// The function return kFALSE if the Multiply operation failed; 6161 ; 6162Bool_t TH1::Multiply(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 6163{; 6164 TString opt = option;; 6165 opt.ToLower();; 6166 // Bool_t binomial = kFALSE;; 6167 // if (opt.Contains(""b"")) binomial = kTRUE;; 6168 if (!h1 || !h2) {; 6169 Error(""Multiply"",""Attempt to multiply by a non-existing histogram"");; 6170 return kFALSE;; 6171 }; 6172 ; 6173 // delete buffer if it is there since it will become invalid; 6174 if (fBuffer) BufferEmpty(1);; 6175 ; 6176 if (Lo",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:242659,Availability,avail,available,242659,"nvalid; 6121 if (fBuffer) BufferEmpty(1);; 6122 ; 6123 if (LoggedInconsistency(""Multiply"", this, h1) >= kDifferentNumberOfBins) {; 6124 return false;; 6125 }; 6126 ; 6127 // Create Sumw2 if h1 has Sumw2 set; 6128 if (fSumw2.fN == 0 && h1->GetSumw2N() != 0) Sumw2();; 6129 ; 6130 // - Reset min- maximum; 6131 SetMinimum();; 6132 SetMaximum();; 6133 ; 6134 // - Loop on bins (including underflows/overflows); 6135 for (Int_t i = 0; i < fNcells; ++i) {; 6136 Double_t c0 = RetrieveBinContent(i);; 6137 Double_t c1 = h1->RetrieveBinContent(i);; 6138 UpdateBinContent(i, c0 * c1);; 6139 if (fSumw2.fN) {; 6140 fSumw2.fArray[i] = GetBinErrorSqUnchecked(i) * c1 * c1 + h1->GetBinErrorSqUnchecked(i) * c0 * c0;; 6141 }; 6142 }; 6143 ResetStats();; 6144 return kTRUE;; 6145}; 6146 ; 6147////////////////////////////////////////////////////////////////////////////////; 6148/// Replace contents of this histogram by multiplication of h1 by h2.; 6149///; 6150/// `this = (c1*h1)*(c2*h2)`; 6151///; 6152/// If errors of this are available (TH1::Sumw2), errors are recalculated.; 6153/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 6154/// if not already set.; 6155///; 6156/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 6157/// you should call Sumw2 before making this operation.; 6158/// This is particularly important if you fit the histogram after TH1::Multiply; 6159///; 6160/// The function return kFALSE if the Multiply operation failed; 6161 ; 6162Bool_t TH1::Multiply(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 6163{; 6164 TString opt = option;; 6165 opt.ToLower();; 6166 // Bool_t binomial = kFALSE;; 6167 // if (opt.Contains(""b"")) binomial = kTRUE;; 6168 if (!h1 || !h2) {; 6169 Error(""Multiply"",""Attempt to multiply by a non-existing histogram"");; 6170 return kFALSE;; 6171 }; 6172 ; 6173 // delete buffer if it is there since it will become invalid; 6174 if (fBuffer) BufferEmpty(1);; 6175 ; 6176 if (Lo",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:242683,Availability,error,errors,242683,"nvalid; 6121 if (fBuffer) BufferEmpty(1);; 6122 ; 6123 if (LoggedInconsistency(""Multiply"", this, h1) >= kDifferentNumberOfBins) {; 6124 return false;; 6125 }; 6126 ; 6127 // Create Sumw2 if h1 has Sumw2 set; 6128 if (fSumw2.fN == 0 && h1->GetSumw2N() != 0) Sumw2();; 6129 ; 6130 // - Reset min- maximum; 6131 SetMinimum();; 6132 SetMaximum();; 6133 ; 6134 // - Loop on bins (including underflows/overflows); 6135 for (Int_t i = 0; i < fNcells; ++i) {; 6136 Double_t c0 = RetrieveBinContent(i);; 6137 Double_t c1 = h1->RetrieveBinContent(i);; 6138 UpdateBinContent(i, c0 * c1);; 6139 if (fSumw2.fN) {; 6140 fSumw2.fArray[i] = GetBinErrorSqUnchecked(i) * c1 * c1 + h1->GetBinErrorSqUnchecked(i) * c0 * c0;; 6141 }; 6142 }; 6143 ResetStats();; 6144 return kTRUE;; 6145}; 6146 ; 6147////////////////////////////////////////////////////////////////////////////////; 6148/// Replace contents of this histogram by multiplication of h1 by h2.; 6149///; 6150/// `this = (c1*h1)*(c2*h2)`; 6151///; 6152/// If errors of this are available (TH1::Sumw2), errors are recalculated.; 6153/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 6154/// if not already set.; 6155///; 6156/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 6157/// you should call Sumw2 before making this operation.; 6158/// This is particularly important if you fit the histogram after TH1::Multiply; 6159///; 6160/// The function return kFALSE if the Multiply operation failed; 6161 ; 6162Bool_t TH1::Multiply(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 6163{; 6164 TString opt = option;; 6165 opt.ToLower();; 6166 // Bool_t binomial = kFALSE;; 6167 // if (opt.Contains(""b"")) binomial = kTRUE;; 6168 if (!h1 || !h2) {; 6169 Error(""Multiply"",""Attempt to multiply by a non-existing histogram"");; 6170 return kFALSE;; 6171 }; 6172 ; 6173 // delete buffer if it is there since it will become invalid; 6174 if (fBuffer) BufferEmpty(1);; 6175 ; 6176 if (Lo",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:242882,Availability,error,errors,242882," Sumw2();; 6129 ; 6130 // - Reset min- maximum; 6131 SetMinimum();; 6132 SetMaximum();; 6133 ; 6134 // - Loop on bins (including underflows/overflows); 6135 for (Int_t i = 0; i < fNcells; ++i) {; 6136 Double_t c0 = RetrieveBinContent(i);; 6137 Double_t c1 = h1->RetrieveBinContent(i);; 6138 UpdateBinContent(i, c0 * c1);; 6139 if (fSumw2.fN) {; 6140 fSumw2.fArray[i] = GetBinErrorSqUnchecked(i) * c1 * c1 + h1->GetBinErrorSqUnchecked(i) * c0 * c0;; 6141 }; 6142 }; 6143 ResetStats();; 6144 return kTRUE;; 6145}; 6146 ; 6147////////////////////////////////////////////////////////////////////////////////; 6148/// Replace contents of this histogram by multiplication of h1 by h2.; 6149///; 6150/// `this = (c1*h1)*(c2*h2)`; 6151///; 6152/// If errors of this are available (TH1::Sumw2), errors are recalculated.; 6153/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 6154/// if not already set.; 6155///; 6156/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 6157/// you should call Sumw2 before making this operation.; 6158/// This is particularly important if you fit the histogram after TH1::Multiply; 6159///; 6160/// The function return kFALSE if the Multiply operation failed; 6161 ; 6162Bool_t TH1::Multiply(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 6163{; 6164 TString opt = option;; 6165 opt.ToLower();; 6166 // Bool_t binomial = kFALSE;; 6167 // if (opt.Contains(""b"")) binomial = kTRUE;; 6168 if (!h1 || !h2) {; 6169 Error(""Multiply"",""Attempt to multiply by a non-existing histogram"");; 6170 return kFALSE;; 6171 }; 6172 ; 6173 // delete buffer if it is there since it will become invalid; 6174 if (fBuffer) BufferEmpty(1);; 6175 ; 6176 if (LoggedInconsistency(""Multiply"", this, h1) >= kDifferentNumberOfBins ||; 6177 LoggedInconsistency(""Multiply"", h1, h2) >= kDifferentNumberOfBins) {; 6178 return false;; 6179 }; 6180 ; 6181 // Create Sumw2 if h1 or h2 have Sumw2 set; 6182 if (fSumw2.fN == 0 && (",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:245730,Availability,error,errors,245730,"y TCanvas::Update.; 6206/// (see TH1::Draw for the list of options); 6207 ; 6208void TH1::Paint(Option_t *option); 6209{; 6210 GetPainter(option);; 6211 ; 6212 if (fPainter) {; 6213 if (option && strlen(option) > 0); 6214 fPainter->Paint(option);; 6215 else; 6216 fPainter->Paint(fOption.Data());; 6217 }; 6218}; 6219 ; 6220////////////////////////////////////////////////////////////////////////////////; 6221/// Rebin this histogram; 6222///; 6223/// #### case 1 xbins=0; 6224///; 6225/// If newname is blank (default), the current histogram is modified and; 6226/// a pointer to it is returned.; 6227///; 6228/// If newname is not blank, the current histogram is not modified, and a; 6229/// new histogram is returned which is a Clone of the current histogram; 6230/// with its name set to newname.; 6231///; 6232/// The parameter ngroup indicates how many bins of this have to be merged; 6233/// into one bin of the result.; 6234///; 6235/// If the original histogram has errors stored (via Sumw2), the resulting; 6236/// histograms has new errors correctly calculated.; 6237///; 6238/// examples: if h1 is an existing TH1F histogram with 100 bins; 6239///; 6240/// ~~~ {.cpp}; 6241/// h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; 6242/// h1->Rebin(5); //merges five bins in one in h1; 6243/// TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,""hnew"")); // creates a new histogram hnew; 6244/// // merging 5 bins of h1 in one bin; 6245/// ~~~; 6246///; 6247/// NOTE: If ngroup is not an exact divider of the number of bins,; 6248/// the top limit of the rebinned histogram is reduced; 6249/// to the upper edge of the last bin that can make a complete; 6250/// group. The remaining bins are added to the overflow bin.; 6251/// Statistics will be recomputed from the new bin contents.; 6252///; 6253/// #### case 2 xbins!=0; 6254///; 6255/// A new histogram is created (you should specify newname).; 6256/// The parameter ngroup is the number of variable size bins in ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:245799,Availability,error,errors,245799,"y TCanvas::Update.; 6206/// (see TH1::Draw for the list of options); 6207 ; 6208void TH1::Paint(Option_t *option); 6209{; 6210 GetPainter(option);; 6211 ; 6212 if (fPainter) {; 6213 if (option && strlen(option) > 0); 6214 fPainter->Paint(option);; 6215 else; 6216 fPainter->Paint(fOption.Data());; 6217 }; 6218}; 6219 ; 6220////////////////////////////////////////////////////////////////////////////////; 6221/// Rebin this histogram; 6222///; 6223/// #### case 1 xbins=0; 6224///; 6225/// If newname is blank (default), the current histogram is modified and; 6226/// a pointer to it is returned.; 6227///; 6228/// If newname is not blank, the current histogram is not modified, and a; 6229/// new histogram is returned which is a Clone of the current histogram; 6230/// with its name set to newname.; 6231///; 6232/// The parameter ngroup indicates how many bins of this have to be merged; 6233/// into one bin of the result.; 6234///; 6235/// If the original histogram has errors stored (via Sumw2), the resulting; 6236/// histograms has new errors correctly calculated.; 6237///; 6238/// examples: if h1 is an existing TH1F histogram with 100 bins; 6239///; 6240/// ~~~ {.cpp}; 6241/// h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; 6242/// h1->Rebin(5); //merges five bins in one in h1; 6243/// TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,""hnew"")); // creates a new histogram hnew; 6244/// // merging 5 bins of h1 in one bin; 6245/// ~~~; 6246///; 6247/// NOTE: If ngroup is not an exact divider of the number of bins,; 6248/// the top limit of the rebinned histogram is reduced; 6249/// to the upper edge of the last bin that can make a complete; 6250/// group. The remaining bins are added to the overflow bin.; 6251/// Statistics will be recomputed from the new bin contents.; 6252///; 6253/// #### case 2 xbins!=0; 6254///; 6255/// A new histogram is created (you should specify newname).; 6256/// The parameter ngroup is the number of variable size bins in ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:246923,Availability,error,errors,246923,"in(); //merges two bins in one in h1: previous contents of h1 are lost; 6242/// h1->Rebin(5); //merges five bins in one in h1; 6243/// TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,""hnew"")); // creates a new histogram hnew; 6244/// // merging 5 bins of h1 in one bin; 6245/// ~~~; 6246///; 6247/// NOTE: If ngroup is not an exact divider of the number of bins,; 6248/// the top limit of the rebinned histogram is reduced; 6249/// to the upper edge of the last bin that can make a complete; 6250/// group. The remaining bins are added to the overflow bin.; 6251/// Statistics will be recomputed from the new bin contents.; 6252///; 6253/// #### case 2 xbins!=0; 6254///; 6255/// A new histogram is created (you should specify newname).; 6256/// The parameter ngroup is the number of variable size bins in the created histogram.; 6257/// The array xbins must contain ngroup+1 elements that represent the low-edges; 6258/// of the bins.; 6259/// If the original histogram has errors stored (via Sumw2), the resulting; 6260/// histograms has new errors correctly calculated.; 6261///; 6262/// NOTE: The bin edges specified in xbins should correspond to bin edges; 6263/// in the original histogram. If a bin edge in the new histogram is; 6264/// in the middle of a bin in the original histogram, all entries in; 6265/// the split bin in the original histogram will be transfered to the; 6266/// lower of the two possible bins in the new histogram. This is; 6267/// probably not what you want. A warning message is emitted in this; 6268/// case; 6269///; 6270/// examples: if h1 is an existing TH1F histogram with 100 bins; 6271///; 6272/// ~~~ {.cpp}; 6273/// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; 6274/// h1->Rebin(24,""hnew"",xbins); //creates a new variable bin size histogram hnew; 6275/// ~~~; 6276 ; 6277TH1 *TH1::Rebin(Int_t ngroup, const char*newname, const Double_t *xbins); 6278{; 6279 Int_t nbins = fXaxis.GetNbins();; 6280 Double_t xmin = fXaxis.",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:246992,Availability,error,errors,246992,"in(); //merges two bins in one in h1: previous contents of h1 are lost; 6242/// h1->Rebin(5); //merges five bins in one in h1; 6243/// TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,""hnew"")); // creates a new histogram hnew; 6244/// // merging 5 bins of h1 in one bin; 6245/// ~~~; 6246///; 6247/// NOTE: If ngroup is not an exact divider of the number of bins,; 6248/// the top limit of the rebinned histogram is reduced; 6249/// to the upper edge of the last bin that can make a complete; 6250/// group. The remaining bins are added to the overflow bin.; 6251/// Statistics will be recomputed from the new bin contents.; 6252///; 6253/// #### case 2 xbins!=0; 6254///; 6255/// A new histogram is created (you should specify newname).; 6256/// The parameter ngroup is the number of variable size bins in the created histogram.; 6257/// The array xbins must contain ngroup+1 elements that represent the low-edges; 6258/// of the bins.; 6259/// If the original histogram has errors stored (via Sumw2), the resulting; 6260/// histograms has new errors correctly calculated.; 6261///; 6262/// NOTE: The bin edges specified in xbins should correspond to bin edges; 6263/// in the original histogram. If a bin edge in the new histogram is; 6264/// in the middle of a bin in the original histogram, all entries in; 6265/// the split bin in the original histogram will be transfered to the; 6266/// lower of the two possible bins in the new histogram. This is; 6267/// probably not what you want. A warning message is emitted in this; 6268/// case; 6269///; 6270/// examples: if h1 is an existing TH1F histogram with 100 bins; 6271///; 6272/// ~~~ {.cpp}; 6273/// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; 6274/// h1->Rebin(24,""hnew"",xbins); //creates a new variable bin size histogram hnew; 6275/// ~~~; 6276 ; 6277TH1 *TH1::Rebin(Int_t ngroup, const char*newname, const Double_t *xbins); 6278{; 6279 Int_t nbins = fXaxis.GetNbins();; 6280 Double_t xmin = fXaxis.",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:251475,Availability,error,errors,251475,"because top bins will be moved to overflow bin; 6348 }; 6349 // save the TAttAxis members (reset by SetBins); 6350 Int_t nDivisions = fXaxis.GetNdivisions();; 6351 Color_t axisColor = fXaxis.GetAxisColor();; 6352 Color_t labelColor = fXaxis.GetLabelColor();; 6353 Style_t labelFont = fXaxis.GetLabelFont();; 6354 Float_t labelOffset = fXaxis.GetLabelOffset();; 6355 Float_t labelSize = fXaxis.GetLabelSize();; 6356 Float_t tickLength = fXaxis.GetTickLength();; 6357 Float_t titleOffset = fXaxis.GetTitleOffset();; 6358 Float_t titleSize = fXaxis.GetTitleSize();; 6359 Color_t titleColor = fXaxis.GetTitleColor();; 6360 Style_t titleFont = fXaxis.GetTitleFont();; 6361 ; 6362 if(!xbins && (fXaxis.GetXbins()->GetSize() > 0)){ // variable bin sizes; 6363 Double_t *bins = new Double_t[newbins+1];; 6364 for(i = 0; i <= newbins; ++i) bins[i] = fXaxis.GetBinLowEdge(1+i*ngroup);; 6365 hnew->SetBins(newbins,bins); //this also changes errors array (if any); 6366 delete [] bins;; 6367 } else if (xbins) {; 6368 hnew->SetBins(newbins,xbins);; 6369 } else {; 6370 hnew->SetBins(newbins,xmin,xmax);; 6371 }; 6372 ; 6373 // Restore axis attributes; 6374 fXaxis.SetNdivisions(nDivisions);; 6375 fXaxis.SetAxisColor(axisColor);; 6376 fXaxis.SetLabelColor(labelColor);; 6377 fXaxis.SetLabelFont(labelFont);; 6378 fXaxis.SetLabelOffset(labelOffset);; 6379 fXaxis.SetLabelSize(labelSize);; 6380 fXaxis.SetTickLength(tickLength);; 6381 fXaxis.SetTitleOffset(titleOffset);; 6382 fXaxis.SetTitleSize(titleSize);; 6383 fXaxis.SetTitleColor(titleColor);; 6384 fXaxis.SetTitleFont(titleFont);; 6385 ; 6386 // copy merged bin contents (ignore under/overflows); 6387 // Start merging only once the new lowest edge is reached; 6388 Int_t startbin = 1;; 6389 const Double_t newxmin = hnew->GetXaxis()->GetBinLowEdge(1);; 6390 while( fXaxis.GetBinCenter(startbin) < newxmin && startbin <= nbins ) {; 6391 startbin++;; 6392 }; 6393 Int_t oldbin = startbin;; 6394 Double_t binContent, binError;; 6395 for (bin = 1;bin<=newbins;",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:256600,Availability,error,errors,256600,"rrent range; 6470 Int_t ntimes = 0;; 6471 while (point < xmin) {; 6472 if (ntimes++ > 64); 6473 return kFALSE;; 6474 xmin = xmin - range;; 6475 range *= 2;; 6476 }; 6477 while (point >= xmax) {; 6478 if (ntimes++ > 64); 6479 return kFALSE;; 6480 xmax = xmax + range;; 6481 range *= 2;; 6482 }; 6483 newMin = xmin;; 6484 newMax = xmax;; 6485 // Info(""FindNewAxisLimits"", ""OldAxis: (%lf, %lf), new: (%lf, %lf), point: %lf"",; 6486 // axis->GetXmin(), axis->GetXmax(), xmin, xmax, point);; 6487 ; 6488 return kTRUE;; 6489}; 6490 ; 6491////////////////////////////////////////////////////////////////////////////////; 6492/// Histogram is resized along axis such that x is in the axis range.; 6493/// The new axis limits are recomputed by doubling iteratively; 6494/// the current axis range until the specified value x is within the limits.; 6495/// The algorithm makes a copy of the histogram, then loops on all bins; 6496/// of the old histogram to fill the extended histogram.; 6497/// Takes into account errors (Sumw2) if any.; 6498/// The algorithm works for 1-d, 2-D and 3-D histograms.; 6499/// The axis must be extendable before invoking this function.; 6500/// Ex:; 6501///; 6502/// ~~~ {.cpp}; 6503/// h->GetXaxis()->SetCanExtend(kTRUE);; 6504/// ~~~; 6505 ; 6506void TH1::ExtendAxis(Double_t x, TAxis *axis); 6507{; 6508 if (!axis->CanExtend()) return;; 6509 if (TMath::IsNaN(x)) { // x may be a NaN; 6510 SetCanExtend(kNoAxis);; 6511 return;; 6512 }; 6513 ; 6514 if (axis->GetXmin() >= axis->GetXmax()) return;; 6515 if (axis->GetNbins() <= 0) return;; 6516 ; 6517 Double_t xmin, xmax;; 6518 if (!FindNewAxisLimits(axis, x, xmin, xmax)); 6519 return;; 6520 ; 6521 //save a copy of this histogram; 6522 TH1 *hold = (TH1*)IsA()->New();; 6523 hold->SetDirectory(nullptr);; 6524 Copy(*hold);; 6525 //set new axis limits; 6526 axis->SetLimits(xmin,xmax);; 6527 ; 6528 ; 6529 //now loop on all bins and refill; 6530 Int_t errors = GetSumw2N();; 6531 ; 6532 Reset(""ICE""); //reset only Integral, conte",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:257520,Availability,error,errors,257520,".; 6495/// The algorithm makes a copy of the histogram, then loops on all bins; 6496/// of the old histogram to fill the extended histogram.; 6497/// Takes into account errors (Sumw2) if any.; 6498/// The algorithm works for 1-d, 2-D and 3-D histograms.; 6499/// The axis must be extendable before invoking this function.; 6500/// Ex:; 6501///; 6502/// ~~~ {.cpp}; 6503/// h->GetXaxis()->SetCanExtend(kTRUE);; 6504/// ~~~; 6505 ; 6506void TH1::ExtendAxis(Double_t x, TAxis *axis); 6507{; 6508 if (!axis->CanExtend()) return;; 6509 if (TMath::IsNaN(x)) { // x may be a NaN; 6510 SetCanExtend(kNoAxis);; 6511 return;; 6512 }; 6513 ; 6514 if (axis->GetXmin() >= axis->GetXmax()) return;; 6515 if (axis->GetNbins() <= 0) return;; 6516 ; 6517 Double_t xmin, xmax;; 6518 if (!FindNewAxisLimits(axis, x, xmin, xmax)); 6519 return;; 6520 ; 6521 //save a copy of this histogram; 6522 TH1 *hold = (TH1*)IsA()->New();; 6523 hold->SetDirectory(nullptr);; 6524 Copy(*hold);; 6525 //set new axis limits; 6526 axis->SetLimits(xmin,xmax);; 6527 ; 6528 ; 6529 //now loop on all bins and refill; 6530 Int_t errors = GetSumw2N();; 6531 ; 6532 Reset(""ICE""); //reset only Integral, contents and Errors; 6533 ; 6534 int iaxis = 0;; 6535 if (axis == &fXaxis) iaxis = 1;; 6536 if (axis == &fYaxis) iaxis = 2;; 6537 if (axis == &fZaxis) iaxis = 3;; 6538 bool firstw = kTRUE;; 6539 Int_t binx,biny, binz = 0;; 6540 Int_t ix = 0,iy = 0,iz = 0;; 6541 Double_t bx,by,bz;; 6542 Int_t ncells = hold->GetNcells();; 6543 for (Int_t bin = 0; bin < ncells; ++bin) {; 6544 hold->GetBinXYZ(bin,binx,biny,binz);; 6545 bx = hold->GetXaxis()->GetBinCenter(binx);; 6546 ix = fXaxis.FindFixBin(bx);; 6547 if (fDimension > 1) {; 6548 by = hold->GetYaxis()->GetBinCenter(biny);; 6549 iy = fYaxis.FindFixBin(by);; 6550 if (fDimension > 2) {; 6551 bz = hold->GetZaxis()->GetBinCenter(binz);; 6552 iz = fZaxis.FindFixBin(bz);; 6553 }; 6554 }; 6555 // exclude underflow/overflow; 6556 double content = hold->RetrieveBinContent(bin);; 6557 if (conte",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:258822,Availability,error,errors,258822,"//reset only Integral, contents and Errors; 6533 ; 6534 int iaxis = 0;; 6535 if (axis == &fXaxis) iaxis = 1;; 6536 if (axis == &fYaxis) iaxis = 2;; 6537 if (axis == &fZaxis) iaxis = 3;; 6538 bool firstw = kTRUE;; 6539 Int_t binx,biny, binz = 0;; 6540 Int_t ix = 0,iy = 0,iz = 0;; 6541 Double_t bx,by,bz;; 6542 Int_t ncells = hold->GetNcells();; 6543 for (Int_t bin = 0; bin < ncells; ++bin) {; 6544 hold->GetBinXYZ(bin,binx,biny,binz);; 6545 bx = hold->GetXaxis()->GetBinCenter(binx);; 6546 ix = fXaxis.FindFixBin(bx);; 6547 if (fDimension > 1) {; 6548 by = hold->GetYaxis()->GetBinCenter(biny);; 6549 iy = fYaxis.FindFixBin(by);; 6550 if (fDimension > 2) {; 6551 bz = hold->GetZaxis()->GetBinCenter(binz);; 6552 iz = fZaxis.FindFixBin(bz);; 6553 }; 6554 }; 6555 // exclude underflow/overflow; 6556 double content = hold->RetrieveBinContent(bin);; 6557 if (content == 0) continue;; 6558 if (IsBinUnderflow(bin,iaxis) || IsBinOverflow(bin,iaxis) ) {; 6559 if (firstw) {; 6560 Warning(""ExtendAxis"",""Histogram %s has underflow or overflow in the axis that is extendable""; 6561 "" their content will be lost"",GetName() );; 6562 firstw= kFALSE;; 6563 }; 6564 continue;; 6565 }; 6566 Int_t ibin= GetBin(ix,iy,iz);; 6567 AddBinContent(ibin, content);; 6568 if (errors) {; 6569 fSumw2.fArray[ibin] += hold->GetBinErrorSqUnchecked(bin);; 6570 }; 6571 }; 6572 delete hold;; 6573}; 6574 ; 6575////////////////////////////////////////////////////////////////////////////////; 6576/// Recursively remove object from the list of functions; 6577 ; 6578void TH1::RecursiveRemove(TObject *obj); 6579{; 6580 // Rely on TROOT::RecursiveRemove to take the readlock.; 6581 ; 6582 if (fFunctions) {; 6583 if (!fFunctions->TestBit(kInvalidObject)) fFunctions->RecursiveRemove(obj);; 6584 }; 6585}; 6586 ; 6587////////////////////////////////////////////////////////////////////////////////; 6588/// Multiply this histogram by a constant c1.; 6589///; 6590/// `this = c1*this`; 6591///; 6592/// Note that both contents and err",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:259567,Availability,error,errors,259567,"6560 Warning(""ExtendAxis"",""Histogram %s has underflow or overflow in the axis that is extendable""; 6561 "" their content will be lost"",GetName() );; 6562 firstw= kFALSE;; 6563 }; 6564 continue;; 6565 }; 6566 Int_t ibin= GetBin(ix,iy,iz);; 6567 AddBinContent(ibin, content);; 6568 if (errors) {; 6569 fSumw2.fArray[ibin] += hold->GetBinErrorSqUnchecked(bin);; 6570 }; 6571 }; 6572 delete hold;; 6573}; 6574 ; 6575////////////////////////////////////////////////////////////////////////////////; 6576/// Recursively remove object from the list of functions; 6577 ; 6578void TH1::RecursiveRemove(TObject *obj); 6579{; 6580 // Rely on TROOT::RecursiveRemove to take the readlock.; 6581 ; 6582 if (fFunctions) {; 6583 if (!fFunctions->TestBit(kInvalidObject)) fFunctions->RecursiveRemove(obj);; 6584 }; 6585}; 6586 ; 6587////////////////////////////////////////////////////////////////////////////////; 6588/// Multiply this histogram by a constant c1.; 6589///; 6590/// `this = c1*this`; 6591///; 6592/// Note that both contents and errors (if any) are scaled.; 6593/// This function uses the services of TH1::Add; 6594///; 6595/// IMPORTANT NOTE: Sumw2() is called automatically when scaling.; 6596/// If you are not interested in the histogram statistics you can call; 6597/// Sumw2(kFALSE) or use the option ""nosw2""; 6598///; 6599/// One can scale a histogram such that the bins integral is equal to; 6600/// the normalization parameter via TH1::Scale(Double_t norm), where norm; 6601/// is the desired normalization divided by the integral of the histogram.; 6602///; 6603/// If option contains ""width"" the bin contents and errors are divided; 6604/// by the bin width.; 6605 ; 6606void TH1::Scale(Double_t c1, Option_t *option); 6607{; 6608 ; 6609 TString opt = option; opt.ToLower();; 6610 // store bin errors when scaling since cannot anymore be computed as sqrt(N); 6611 if (!opt.Contains(""nosw2"") && GetSumw2N() == 0) Sumw2();; 6612 if (opt.Contains(""width"")) Add(this, this, c1, -1);; 6613 else {",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:260162,Availability,error,errors,260162,"; 6580 // Rely on TROOT::RecursiveRemove to take the readlock.; 6581 ; 6582 if (fFunctions) {; 6583 if (!fFunctions->TestBit(kInvalidObject)) fFunctions->RecursiveRemove(obj);; 6584 }; 6585}; 6586 ; 6587////////////////////////////////////////////////////////////////////////////////; 6588/// Multiply this histogram by a constant c1.; 6589///; 6590/// `this = c1*this`; 6591///; 6592/// Note that both contents and errors (if any) are scaled.; 6593/// This function uses the services of TH1::Add; 6594///; 6595/// IMPORTANT NOTE: Sumw2() is called automatically when scaling.; 6596/// If you are not interested in the histogram statistics you can call; 6597/// Sumw2(kFALSE) or use the option ""nosw2""; 6598///; 6599/// One can scale a histogram such that the bins integral is equal to; 6600/// the normalization parameter via TH1::Scale(Double_t norm), where norm; 6601/// is the desired normalization divided by the integral of the histogram.; 6602///; 6603/// If option contains ""width"" the bin contents and errors are divided; 6604/// by the bin width.; 6605 ; 6606void TH1::Scale(Double_t c1, Option_t *option); 6607{; 6608 ; 6609 TString opt = option; opt.ToLower();; 6610 // store bin errors when scaling since cannot anymore be computed as sqrt(N); 6611 if (!opt.Contains(""nosw2"") && GetSumw2N() == 0) Sumw2();; 6612 if (opt.Contains(""width"")) Add(this, this, c1, -1);; 6613 else {; 6614 if (fBuffer) BufferEmpty(1);; 6615 for(Int_t i = 0; i < fNcells; ++i) UpdateBinContent(i, c1 * RetrieveBinContent(i));; 6616 if (fSumw2.fN) for(Int_t i = 0; i < fNcells; ++i) fSumw2.fArray[i] *= (c1 * c1); // update errors; 6617 // update global histograms statistics; 6618 Double_t s[kNstat] = {0};; 6619 GetStats(s);; 6620 for (Int_t i=0 ; i < kNstat; i++) {; 6621 if (i == 1) s[i] = c1*c1*s[i];; 6622 else s[i] = c1*s[i];; 6623 }; 6624 PutStats(s);; 6625 SetMinimum(); SetMaximum(); // minimum and maximum value will be recalculated the next time; 6626 }; 6627 ; 6628 // if contours set, must also sca",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:260343,Availability,error,errors,260343,"///////////////////////////////////////////////////////////////////; 6588/// Multiply this histogram by a constant c1.; 6589///; 6590/// `this = c1*this`; 6591///; 6592/// Note that both contents and errors (if any) are scaled.; 6593/// This function uses the services of TH1::Add; 6594///; 6595/// IMPORTANT NOTE: Sumw2() is called automatically when scaling.; 6596/// If you are not interested in the histogram statistics you can call; 6597/// Sumw2(kFALSE) or use the option ""nosw2""; 6598///; 6599/// One can scale a histogram such that the bins integral is equal to; 6600/// the normalization parameter via TH1::Scale(Double_t norm), where norm; 6601/// is the desired normalization divided by the integral of the histogram.; 6602///; 6603/// If option contains ""width"" the bin contents and errors are divided; 6604/// by the bin width.; 6605 ; 6606void TH1::Scale(Double_t c1, Option_t *option); 6607{; 6608 ; 6609 TString opt = option; opt.ToLower();; 6610 // store bin errors when scaling since cannot anymore be computed as sqrt(N); 6611 if (!opt.Contains(""nosw2"") && GetSumw2N() == 0) Sumw2();; 6612 if (opt.Contains(""width"")) Add(this, this, c1, -1);; 6613 else {; 6614 if (fBuffer) BufferEmpty(1);; 6615 for(Int_t i = 0; i < fNcells; ++i) UpdateBinContent(i, c1 * RetrieveBinContent(i));; 6616 if (fSumw2.fN) for(Int_t i = 0; i < fNcells; ++i) fSumw2.fArray[i] *= (c1 * c1); // update errors; 6617 // update global histograms statistics; 6618 Double_t s[kNstat] = {0};; 6619 GetStats(s);; 6620 for (Int_t i=0 ; i < kNstat; i++) {; 6621 if (i == 1) s[i] = c1*c1*s[i];; 6622 else s[i] = c1*s[i];; 6623 }; 6624 PutStats(s);; 6625 SetMinimum(); SetMaximum(); // minimum and maximum value will be recalculated the next time; 6626 }; 6627 ; 6628 // if contours set, must also scale contours; 6629 Int_t ncontours = GetContour();; 6630 if (ncontours == 0) return;; 6631 Double_t* levels = fContour.GetArray();; 6632 for (Int_t i = 0; i < ncontours; ++i) levels[i] *= c1;; 6633}; 6634 ; 6635///////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:260763,Availability,error,errors,260763,"orm), where norm; 6601/// is the desired normalization divided by the integral of the histogram.; 6602///; 6603/// If option contains ""width"" the bin contents and errors are divided; 6604/// by the bin width.; 6605 ; 6606void TH1::Scale(Double_t c1, Option_t *option); 6607{; 6608 ; 6609 TString opt = option; opt.ToLower();; 6610 // store bin errors when scaling since cannot anymore be computed as sqrt(N); 6611 if (!opt.Contains(""nosw2"") && GetSumw2N() == 0) Sumw2();; 6612 if (opt.Contains(""width"")) Add(this, this, c1, -1);; 6613 else {; 6614 if (fBuffer) BufferEmpty(1);; 6615 for(Int_t i = 0; i < fNcells; ++i) UpdateBinContent(i, c1 * RetrieveBinContent(i));; 6616 if (fSumw2.fN) for(Int_t i = 0; i < fNcells; ++i) fSumw2.fArray[i] *= (c1 * c1); // update errors; 6617 // update global histograms statistics; 6618 Double_t s[kNstat] = {0};; 6619 GetStats(s);; 6620 for (Int_t i=0 ; i < kNstat; i++) {; 6621 if (i == 1) s[i] = c1*c1*s[i];; 6622 else s[i] = c1*s[i];; 6623 }; 6624 PutStats(s);; 6625 SetMinimum(); SetMaximum(); // minimum and maximum value will be recalculated the next time; 6626 }; 6627 ; 6628 // if contours set, must also scale contours; 6629 Int_t ncontours = GetContour();; 6630 if (ncontours == 0) return;; 6631 Double_t* levels = fContour.GetArray();; 6632 for (Int_t i = 0; i < ncontours; ++i) levels[i] *= c1;; 6633}; 6634 ; 6635////////////////////////////////////////////////////////////////////////////////; 6636/// Returns true if all axes are extendable.; 6637 ; 6638Bool_t TH1::CanExtendAllAxes() const; 6639{; 6640 Bool_t canExtend = fXaxis.CanExtend();; 6641 if (GetDimension() > 1) canExtend &= fYaxis.CanExtend();; 6642 if (GetDimension() > 2) canExtend &= fZaxis.CanExtend();; 6643 ; 6644 return canExtend;; 6645}; 6646 ; 6647////////////////////////////////////////////////////////////////////////////////; 6648/// Make the histogram axes extendable / not extendable according to the bit mask; 6649/// returns the previous bit mask specifying which axes a",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:261932,Availability,mask,mask,261932," s[i] = c1*c1*s[i];; 6622 else s[i] = c1*s[i];; 6623 }; 6624 PutStats(s);; 6625 SetMinimum(); SetMaximum(); // minimum and maximum value will be recalculated the next time; 6626 }; 6627 ; 6628 // if contours set, must also scale contours; 6629 Int_t ncontours = GetContour();; 6630 if (ncontours == 0) return;; 6631 Double_t* levels = fContour.GetArray();; 6632 for (Int_t i = 0; i < ncontours; ++i) levels[i] *= c1;; 6633}; 6634 ; 6635////////////////////////////////////////////////////////////////////////////////; 6636/// Returns true if all axes are extendable.; 6637 ; 6638Bool_t TH1::CanExtendAllAxes() const; 6639{; 6640 Bool_t canExtend = fXaxis.CanExtend();; 6641 if (GetDimension() > 1) canExtend &= fYaxis.CanExtend();; 6642 if (GetDimension() > 2) canExtend &= fZaxis.CanExtend();; 6643 ; 6644 return canExtend;; 6645}; 6646 ; 6647////////////////////////////////////////////////////////////////////////////////; 6648/// Make the histogram axes extendable / not extendable according to the bit mask; 6649/// returns the previous bit mask specifying which axes are extendable; 6650 ; 6651UInt_t TH1::SetCanExtend(UInt_t extendBitMask); 6652{; 6653 UInt_t oldExtendBitMask = kNoAxis;; 6654 ; 6655 if (fXaxis.CanExtend()) oldExtendBitMask |= kXaxis;; 6656 if (extendBitMask & kXaxis) fXaxis.SetCanExtend(kTRUE);; 6657 else fXaxis.SetCanExtend(kFALSE);; 6658 ; 6659 if (GetDimension() > 1) {; 6660 if (fYaxis.CanExtend()) oldExtendBitMask |= kYaxis;; 6661 if (extendBitMask & kYaxis) fYaxis.SetCanExtend(kTRUE);; 6662 else fYaxis.SetCanExtend(kFALSE);; 6663 }; 6664 ; 6665 if (GetDimension() > 2) {; 6666 if (fZaxis.CanExtend()) oldExtendBitMask |= kZaxis;; 6667 if (extendBitMask & kZaxis) fZaxis.SetCanExtend(kTRUE);; 6668 else fZaxis.SetCanExtend(kFALSE);; 6669 }; 6670 ; 6671 return oldExtendBitMask;; 6672}; 6673 ; 6674///////////////////////////////////////////////////////////////////////////////; 6675/// Internal function used in TH1::Fill to see which axis is full alphanumeric,; 6",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:261971,Availability,mask,mask,261971," s[i] = c1*c1*s[i];; 6622 else s[i] = c1*s[i];; 6623 }; 6624 PutStats(s);; 6625 SetMinimum(); SetMaximum(); // minimum and maximum value will be recalculated the next time; 6626 }; 6627 ; 6628 // if contours set, must also scale contours; 6629 Int_t ncontours = GetContour();; 6630 if (ncontours == 0) return;; 6631 Double_t* levels = fContour.GetArray();; 6632 for (Int_t i = 0; i < ncontours; ++i) levels[i] *= c1;; 6633}; 6634 ; 6635////////////////////////////////////////////////////////////////////////////////; 6636/// Returns true if all axes are extendable.; 6637 ; 6638Bool_t TH1::CanExtendAllAxes() const; 6639{; 6640 Bool_t canExtend = fXaxis.CanExtend();; 6641 if (GetDimension() > 1) canExtend &= fYaxis.CanExtend();; 6642 if (GetDimension() > 2) canExtend &= fZaxis.CanExtend();; 6643 ; 6644 return canExtend;; 6645}; 6646 ; 6647////////////////////////////////////////////////////////////////////////////////; 6648/// Make the histogram axes extendable / not extendable according to the bit mask; 6649/// returns the previous bit mask specifying which axes are extendable; 6650 ; 6651UInt_t TH1::SetCanExtend(UInt_t extendBitMask); 6652{; 6653 UInt_t oldExtendBitMask = kNoAxis;; 6654 ; 6655 if (fXaxis.CanExtend()) oldExtendBitMask |= kXaxis;; 6656 if (extendBitMask & kXaxis) fXaxis.SetCanExtend(kTRUE);; 6657 else fXaxis.SetCanExtend(kFALSE);; 6658 ; 6659 if (GetDimension() > 1) {; 6660 if (fYaxis.CanExtend()) oldExtendBitMask |= kYaxis;; 6661 if (extendBitMask & kYaxis) fYaxis.SetCanExtend(kTRUE);; 6662 else fYaxis.SetCanExtend(kFALSE);; 6663 }; 6664 ; 6665 if (GetDimension() > 2) {; 6666 if (fZaxis.CanExtend()) oldExtendBitMask |= kZaxis;; 6667 if (extendBitMask & kZaxis) fZaxis.SetCanExtend(kTRUE);; 6668 else fZaxis.SetCanExtend(kFALSE);; 6669 }; 6670 ; 6671 return oldExtendBitMask;; 6672}; 6673 ; 6674///////////////////////////////////////////////////////////////////////////////; 6675/// Internal function used in TH1::Fill to see which axis is full alphanumeric,; 6",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:264143,Availability,error,errors,264143,"c; 6677UInt_t TH1::GetAxisLabelStatus() const; 6678{; 6679 UInt_t bitMask = kNoAxis;; 6680 if (fXaxis.CanExtend() && fXaxis.IsAlphanumeric() ) bitMask |= kXaxis;; 6681 if (GetDimension() > 1 && fYaxis.CanExtend() && fYaxis.IsAlphanumeric()); 6682 bitMask |= kYaxis;; 6683 if (GetDimension() > 2 && fZaxis.CanExtend() && fZaxis.IsAlphanumeric()); 6684 bitMask |= kZaxis;; 6685 ; 6686 return bitMask;; 6687}; 6688 ; 6689////////////////////////////////////////////////////////////////////////////////; 6690/// Static function to set the default buffer size for automatic histograms.; 6691/// When a histogram is created with one of its axis lower limit greater; 6692/// or equal to its upper limit, the function SetBuffer is automatically; 6693/// called with the default buffer size.; 6694 ; 6695void TH1::SetDefaultBufferSize(Int_t buffersize); 6696{; 6697 fgBufferSize = buffersize > 0 ? buffersize : 0;; 6698}; 6699 ; 6700////////////////////////////////////////////////////////////////////////////////; 6701/// When this static function is called with `sumw2=kTRUE`, all new; 6702/// histograms will automatically activate the storage; 6703/// of the sum of squares of errors, ie TH1::Sumw2 is automatically called.; 6704 ; 6705void TH1::SetDefaultSumw2(Bool_t sumw2); 6706{; 6707 fgDefaultSumw2 = sumw2;; 6708}; 6709 ; 6710////////////////////////////////////////////////////////////////////////////////; 6711/// Change/set the title.; 6712///; 6713/// If title is in the form `stringt;stringx;stringy;stringz`; 6714/// the histogram title is set to `stringt`, the x axis title to `stringx`,; 6715/// the y axis title to `stringy`, and the z axis title to `stringz`.; 6716///; 6717/// To insert the character `;` in one of the titles, one should use `#;`; 6718/// or `#semicolon`.; 6719 ; 6720void TH1::SetTitle(const char *title); 6721{; 6722 fTitle = title;; 6723 fTitle.ReplaceAll(""#;"",2,""#semicolon"",10);; 6724 ; 6725 // Decode fTitle. It may contain X, Y and Z titles; 6726 TString str1 = fT",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:274029,Availability,error,errors,274029,", minimum, norm;; 6977 Float_t *contour=nullptr;; 6978 b >> maximum; fMaximum = maximum;; 6979 b >> minimum; fMinimum = minimum;; 6980 b >> norm; fNormFactor = norm;; 6981 Int_t n = b.ReadArray(contour);; 6982 fContour.Set(n);; 6983 for (Int_t i=0;i<n;i++) fContour.fArray[i] = contour[i];; 6984 delete [] contour;; 6985 } else {; 6986 b >> fMaximum;; 6987 b >> fMinimum;; 6988 b >> fNormFactor;; 6989 fContour.Streamer(b);; 6990 }; 6991 fSumw2.Streamer(b);; 6992 fOption.Streamer(b);; 6993 fFunctions->Delete();; 6994 fFunctions->Streamer(b);; 6995 b.CheckByteCount(R__s, R__c, TH1::IsA());; 6996 ; 6997 } else {; 6998 b.WriteClassBuffer(TH1::Class(),this);; 6999 }; 7000}; 7001 ; 7002////////////////////////////////////////////////////////////////////////////////; 7003/// Print some global quantities for this histogram.; 7004/// \param[in] option; 7005/// - ""base"" is given, number of bins and ranges are also printed; 7006/// - ""range"" is given, bin contents and errors are also printed; 7007/// for all bins in the current range (default 1-->nbins); 7008/// - ""all"" is given, bin contents and errors are also printed; 7009/// for all bins including under and overflows.; 7010 ; 7011void TH1::Print(Option_t *option) const; 7012{; 7013 if (fBuffer) const_cast<TH1*>(this)->BufferEmpty();; 7014 printf( ""TH1.Print Name = %s, Entries= %d, Total sum= %g\n"",GetName(),Int_t(fEntries),GetSumOfWeights());; 7015 TString opt = option;; 7016 opt.ToLower();; 7017 Int_t all;; 7018 if (opt.Contains(""all"")) all = 0;; 7019 else if (opt.Contains(""range"")) all = 1;; 7020 else if (opt.Contains(""base"")) all = 2;; 7021 else return;; 7022 ; 7023 Int_t bin, binx, biny, binz;; 7024 Int_t firstx=0,lastx=0,firsty=0,lasty=0,firstz=0,lastz=0;; 7025 if (all == 0) {; 7026 lastx = fXaxis.GetNbins()+1;; 7027 if (fDimension > 1) lasty = fYaxis.GetNbins()+1;; 7028 if (fDimension > 2) lastz = fZaxis.GetNbins()+1;; 7029 } else {; 7030 firstx = fXaxis.GetFirst(); lastx = fXaxis.GetLast();; 7031 if (fDimension > 1) {f",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:274160,Availability,error,errors,274160,", minimum, norm;; 6977 Float_t *contour=nullptr;; 6978 b >> maximum; fMaximum = maximum;; 6979 b >> minimum; fMinimum = minimum;; 6980 b >> norm; fNormFactor = norm;; 6981 Int_t n = b.ReadArray(contour);; 6982 fContour.Set(n);; 6983 for (Int_t i=0;i<n;i++) fContour.fArray[i] = contour[i];; 6984 delete [] contour;; 6985 } else {; 6986 b >> fMaximum;; 6987 b >> fMinimum;; 6988 b >> fNormFactor;; 6989 fContour.Streamer(b);; 6990 }; 6991 fSumw2.Streamer(b);; 6992 fOption.Streamer(b);; 6993 fFunctions->Delete();; 6994 fFunctions->Streamer(b);; 6995 b.CheckByteCount(R__s, R__c, TH1::IsA());; 6996 ; 6997 } else {; 6998 b.WriteClassBuffer(TH1::Class(),this);; 6999 }; 7000}; 7001 ; 7002////////////////////////////////////////////////////////////////////////////////; 7003/// Print some global quantities for this histogram.; 7004/// \param[in] option; 7005/// - ""base"" is given, number of bins and ranges are also printed; 7006/// - ""range"" is given, bin contents and errors are also printed; 7007/// for all bins in the current range (default 1-->nbins); 7008/// - ""all"" is given, bin contents and errors are also printed; 7009/// for all bins including under and overflows.; 7010 ; 7011void TH1::Print(Option_t *option) const; 7012{; 7013 if (fBuffer) const_cast<TH1*>(this)->BufferEmpty();; 7014 printf( ""TH1.Print Name = %s, Entries= %d, Total sum= %g\n"",GetName(),Int_t(fEntries),GetSumOfWeights());; 7015 TString opt = option;; 7016 opt.ToLower();; 7017 Int_t all;; 7018 if (opt.Contains(""all"")) all = 0;; 7019 else if (opt.Contains(""range"")) all = 1;; 7020 else if (opt.Contains(""base"")) all = 2;; 7021 else return;; 7022 ; 7023 Int_t bin, binx, biny, binz;; 7024 Int_t firstx=0,lastx=0,firsty=0,lasty=0,firstz=0,lastz=0;; 7025 if (all == 0) {; 7026 lastx = fXaxis.GetNbins()+1;; 7027 if (fDimension > 1) lasty = fYaxis.GetNbins()+1;; 7028 if (fDimension > 2) lastz = fZaxis.GetNbins()+1;; 7029 } else {; 7030 firstx = fXaxis.GetFirst(); lastx = fXaxis.GetLast();; 7031 if (fDimension > 1) {f",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:275942,Availability,error,error,275942,"is.GetLast();; 7031 if (fDimension > 1) {firsty = fYaxis.GetFirst(); lasty = fYaxis.GetLast();}; 7032 if (fDimension > 2) {firstz = fZaxis.GetFirst(); lastz = fZaxis.GetLast();}; 7033 }; 7034 ; 7035 if (all== 2) {; 7036 printf("" Title = %s\n"", GetTitle());; 7037 printf("" NbinsX= %d, xmin= %g, xmax=%g"", fXaxis.GetNbins(), fXaxis.GetXmin(), fXaxis.GetXmax());; 7038 if( fDimension > 1) printf("", NbinsY= %d, ymin= %g, ymax=%g"", fYaxis.GetNbins(), fYaxis.GetXmin(), fYaxis.GetXmax());; 7039 if( fDimension > 2) printf("", NbinsZ= %d, zmin= %g, zmax=%g"", fZaxis.GetNbins(), fZaxis.GetXmin(), fZaxis.GetXmax());; 7040 printf(""\n"");; 7041 return;; 7042 }; 7043 ; 7044 Double_t w,e;; 7045 Double_t x,y,z;; 7046 if (fDimension == 1) {; 7047 for (binx=firstx;binx<=lastx;binx++) {; 7048 x = fXaxis.GetBinCenter(binx);; 7049 w = RetrieveBinContent(binx);; 7050 e = GetBinError(binx);; 7051 if(fSumw2.fN) printf("" fSumw[%d]=%g, x=%g, error=%g\n"",binx,w,x,e);; 7052 else printf("" fSumw[%d]=%g, x=%g\n"",binx,w,x);; 7053 }; 7054 }; 7055 if (fDimension == 2) {; 7056 for (biny=firsty;biny<=lasty;biny++) {; 7057 y = fYaxis.GetBinCenter(biny);; 7058 for (binx=firstx;binx<=lastx;binx++) {; 7059 bin = GetBin(binx,biny);; 7060 x = fXaxis.GetBinCenter(binx);; 7061 w = RetrieveBinContent(bin);; 7062 e = GetBinError(bin);; 7063 if(fSumw2.fN) printf("" fSumw[%d][%d]=%g, x=%g, y=%g, error=%g\n"",binx,biny,w,x,y,e);; 7064 else printf("" fSumw[%d][%d]=%g, x=%g, y=%g\n"",binx,biny,w,x,y);; 7065 }; 7066 }; 7067 }; 7068 if (fDimension == 3) {; 7069 for (binz=firstz;binz<=lastz;binz++) {; 7070 z = fZaxis.GetBinCenter(binz);; 7071 for (biny=firsty;biny<=lasty;biny++) {; 7072 y = fYaxis.GetBinCenter(biny);; 7073 for (binx=firstx;binx<=lastx;binx++) {; 7074 bin = GetBin(binx,biny,binz);; 7075 x = fXaxis.GetBinCenter(binx);; 7076 w = RetrieveBinContent(bin);; 7077 e = GetBinError(bin);; 7078 if(fSumw2.fN) printf("" fSumw[%d][%d][%d]=%g, x=%g, y=%g, z=%g, error=%g\n"",binx,biny,binz,w,x,y,z,e);; 7079 else printf("" fSumw[%d",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:276382,Availability,error,error,276382,"is.GetXmin(), fYaxis.GetXmax());; 7039 if( fDimension > 2) printf("", NbinsZ= %d, zmin= %g, zmax=%g"", fZaxis.GetNbins(), fZaxis.GetXmin(), fZaxis.GetXmax());; 7040 printf(""\n"");; 7041 return;; 7042 }; 7043 ; 7044 Double_t w,e;; 7045 Double_t x,y,z;; 7046 if (fDimension == 1) {; 7047 for (binx=firstx;binx<=lastx;binx++) {; 7048 x = fXaxis.GetBinCenter(binx);; 7049 w = RetrieveBinContent(binx);; 7050 e = GetBinError(binx);; 7051 if(fSumw2.fN) printf("" fSumw[%d]=%g, x=%g, error=%g\n"",binx,w,x,e);; 7052 else printf("" fSumw[%d]=%g, x=%g\n"",binx,w,x);; 7053 }; 7054 }; 7055 if (fDimension == 2) {; 7056 for (biny=firsty;biny<=lasty;biny++) {; 7057 y = fYaxis.GetBinCenter(biny);; 7058 for (binx=firstx;binx<=lastx;binx++) {; 7059 bin = GetBin(binx,biny);; 7060 x = fXaxis.GetBinCenter(binx);; 7061 w = RetrieveBinContent(bin);; 7062 e = GetBinError(bin);; 7063 if(fSumw2.fN) printf("" fSumw[%d][%d]=%g, x=%g, y=%g, error=%g\n"",binx,biny,w,x,y,e);; 7064 else printf("" fSumw[%d][%d]=%g, x=%g, y=%g\n"",binx,biny,w,x,y);; 7065 }; 7066 }; 7067 }; 7068 if (fDimension == 3) {; 7069 for (binz=firstz;binz<=lastz;binz++) {; 7070 z = fZaxis.GetBinCenter(binz);; 7071 for (biny=firsty;biny<=lasty;biny++) {; 7072 y = fYaxis.GetBinCenter(biny);; 7073 for (binx=firstx;binx<=lastx;binx++) {; 7074 bin = GetBin(binx,biny,binz);; 7075 x = fXaxis.GetBinCenter(binx);; 7076 w = RetrieveBinContent(bin);; 7077 e = GetBinError(bin);; 7078 if(fSumw2.fN) printf("" fSumw[%d][%d][%d]=%g, x=%g, y=%g, z=%g, error=%g\n"",binx,biny,binz,w,x,y,z,e);; 7079 else printf("" fSumw[%d][%d][%d]=%g, x=%g, y=%g, z=%g\n"",binx,biny,binz,w,x,y,z);; 7080 }; 7081 }; 7082 }; 7083 }; 7084}; 7085 ; 7086////////////////////////////////////////////////////////////////////////////////; 7087/// Using the current bin info, recompute the arrays for contents and errors; 7088 ; 7089void TH1::Rebuild(Option_t *); 7090{; 7091 SetBinsLength();; 7092 if (fSumw2.fN) {; 7093 fSumw2.Set(fNcells);; 7094 }; 7095}; 7096 ; 7097/////////////////////////////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:276951,Availability,error,error,276951,"(biny);; 7058 for (binx=firstx;binx<=lastx;binx++) {; 7059 bin = GetBin(binx,biny);; 7060 x = fXaxis.GetBinCenter(binx);; 7061 w = RetrieveBinContent(bin);; 7062 e = GetBinError(bin);; 7063 if(fSumw2.fN) printf("" fSumw[%d][%d]=%g, x=%g, y=%g, error=%g\n"",binx,biny,w,x,y,e);; 7064 else printf("" fSumw[%d][%d]=%g, x=%g, y=%g\n"",binx,biny,w,x,y);; 7065 }; 7066 }; 7067 }; 7068 if (fDimension == 3) {; 7069 for (binz=firstz;binz<=lastz;binz++) {; 7070 z = fZaxis.GetBinCenter(binz);; 7071 for (biny=firsty;biny<=lasty;biny++) {; 7072 y = fYaxis.GetBinCenter(biny);; 7073 for (binx=firstx;binx<=lastx;binx++) {; 7074 bin = GetBin(binx,biny,binz);; 7075 x = fXaxis.GetBinCenter(binx);; 7076 w = RetrieveBinContent(bin);; 7077 e = GetBinError(bin);; 7078 if(fSumw2.fN) printf("" fSumw[%d][%d][%d]=%g, x=%g, y=%g, z=%g, error=%g\n"",binx,biny,binz,w,x,y,z,e);; 7079 else printf("" fSumw[%d][%d][%d]=%g, x=%g, y=%g, z=%g\n"",binx,biny,binz,w,x,y,z);; 7080 }; 7081 }; 7082 }; 7083 }; 7084}; 7085 ; 7086////////////////////////////////////////////////////////////////////////////////; 7087/// Using the current bin info, recompute the arrays for contents and errors; 7088 ; 7089void TH1::Rebuild(Option_t *); 7090{; 7091 SetBinsLength();; 7092 if (fSumw2.fN) {; 7093 fSumw2.Set(fNcells);; 7094 }; 7095}; 7096 ; 7097////////////////////////////////////////////////////////////////////////////////; 7098/// Reset this histogram: contents, errors, etc.; 7099/// \param[in] option; 7100/// - if ""ICE"" is specified, resets only Integral, Contents and Errors.; 7101/// - if ""ICES"" is specified, resets only Integral, Contents, Errors and Statistics; 7102/// This option is used; 7103/// - if ""M"" is specified, resets also Minimum and Maximum; 7104 ; 7105void TH1::Reset(Option_t *option); 7106{; 7107 // The option ""ICE"" is used when extending the histogram (in ExtendAxis, LabelInflate, etc..); 7108 // The option ""ICES is used in combination with the buffer (see BufferEmpty and BufferFill); 7109 ; 7110 TString opt = ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:277284,Availability,error,errors,277284,"(biny);; 7058 for (binx=firstx;binx<=lastx;binx++) {; 7059 bin = GetBin(binx,biny);; 7060 x = fXaxis.GetBinCenter(binx);; 7061 w = RetrieveBinContent(bin);; 7062 e = GetBinError(bin);; 7063 if(fSumw2.fN) printf("" fSumw[%d][%d]=%g, x=%g, y=%g, error=%g\n"",binx,biny,w,x,y,e);; 7064 else printf("" fSumw[%d][%d]=%g, x=%g, y=%g\n"",binx,biny,w,x,y);; 7065 }; 7066 }; 7067 }; 7068 if (fDimension == 3) {; 7069 for (binz=firstz;binz<=lastz;binz++) {; 7070 z = fZaxis.GetBinCenter(binz);; 7071 for (biny=firsty;biny<=lasty;biny++) {; 7072 y = fYaxis.GetBinCenter(biny);; 7073 for (binx=firstx;binx<=lastx;binx++) {; 7074 bin = GetBin(binx,biny,binz);; 7075 x = fXaxis.GetBinCenter(binx);; 7076 w = RetrieveBinContent(bin);; 7077 e = GetBinError(bin);; 7078 if(fSumw2.fN) printf("" fSumw[%d][%d][%d]=%g, x=%g, y=%g, z=%g, error=%g\n"",binx,biny,binz,w,x,y,z,e);; 7079 else printf("" fSumw[%d][%d][%d]=%g, x=%g, y=%g, z=%g\n"",binx,biny,binz,w,x,y,z);; 7080 }; 7081 }; 7082 }; 7083 }; 7084}; 7085 ; 7086////////////////////////////////////////////////////////////////////////////////; 7087/// Using the current bin info, recompute the arrays for contents and errors; 7088 ; 7089void TH1::Rebuild(Option_t *); 7090{; 7091 SetBinsLength();; 7092 if (fSumw2.fN) {; 7093 fSumw2.Set(fNcells);; 7094 }; 7095}; 7096 ; 7097////////////////////////////////////////////////////////////////////////////////; 7098/// Reset this histogram: contents, errors, etc.; 7099/// \param[in] option; 7100/// - if ""ICE"" is specified, resets only Integral, Contents and Errors.; 7101/// - if ""ICES"" is specified, resets only Integral, Contents, Errors and Statistics; 7102/// This option is used; 7103/// - if ""M"" is specified, resets also Minimum and Maximum; 7104 ; 7105void TH1::Reset(Option_t *option); 7106{; 7107 // The option ""ICE"" is used when extending the histogram (in ExtendAxis, LabelInflate, etc..); 7108 // The option ""ICES is used in combination with the buffer (see BufferEmpty and BufferFill); 7109 ; 7110 TString opt = ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:277562,Availability,error,errors,277562,"065 }; 7066 }; 7067 }; 7068 if (fDimension == 3) {; 7069 for (binz=firstz;binz<=lastz;binz++) {; 7070 z = fZaxis.GetBinCenter(binz);; 7071 for (biny=firsty;biny<=lasty;biny++) {; 7072 y = fYaxis.GetBinCenter(biny);; 7073 for (binx=firstx;binx<=lastx;binx++) {; 7074 bin = GetBin(binx,biny,binz);; 7075 x = fXaxis.GetBinCenter(binx);; 7076 w = RetrieveBinContent(bin);; 7077 e = GetBinError(bin);; 7078 if(fSumw2.fN) printf("" fSumw[%d][%d][%d]=%g, x=%g, y=%g, z=%g, error=%g\n"",binx,biny,binz,w,x,y,z,e);; 7079 else printf("" fSumw[%d][%d][%d]=%g, x=%g, y=%g, z=%g\n"",binx,biny,binz,w,x,y,z);; 7080 }; 7081 }; 7082 }; 7083 }; 7084}; 7085 ; 7086////////////////////////////////////////////////////////////////////////////////; 7087/// Using the current bin info, recompute the arrays for contents and errors; 7088 ; 7089void TH1::Rebuild(Option_t *); 7090{; 7091 SetBinsLength();; 7092 if (fSumw2.fN) {; 7093 fSumw2.Set(fNcells);; 7094 }; 7095}; 7096 ; 7097////////////////////////////////////////////////////////////////////////////////; 7098/// Reset this histogram: contents, errors, etc.; 7099/// \param[in] option; 7100/// - if ""ICE"" is specified, resets only Integral, Contents and Errors.; 7101/// - if ""ICES"" is specified, resets only Integral, Contents, Errors and Statistics; 7102/// This option is used; 7103/// - if ""M"" is specified, resets also Minimum and Maximum; 7104 ; 7105void TH1::Reset(Option_t *option); 7106{; 7107 // The option ""ICE"" is used when extending the histogram (in ExtendAxis, LabelInflate, etc..); 7108 // The option ""ICES is used in combination with the buffer (see BufferEmpty and BufferFill); 7109 ; 7110 TString opt = option;; 7111 opt.ToUpper();; 7112 fSumw2.Reset();; 7113 if (fIntegral) {; 7114 delete [] fIntegral;; 7115 fIntegral = nullptr;; 7116 }; 7117 ; 7118 if (opt.Contains(""M"")) {; 7119 SetMinimum();; 7120 SetMaximum();; 7121 }; 7122 ; 7123 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 7124 ; 7125 // Setting fBuffer[0] = 0 is like resetting t",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:280152,Availability,error,error,280152,"7136 fTsumwx = 0;; 7137 fTsumwx2 = 0;; 7138 fEntries = 0;; 7139 ; 7140 if (opt == ""ICES"") return;; 7141 ; 7142 ; 7143 TObject *stats = fFunctions->FindObject(""stats"");; 7144 fFunctions->Remove(stats);; 7145 //special logic to support the case where the same object is; 7146 //added multiple times in fFunctions.; 7147 //This case happens when the same object is added with different; 7148 //drawing modes; 7149 TObject *obj;; 7150 while ((obj = fFunctions->First())) {; 7151 while(fFunctions->Remove(obj)) { }; 7152 delete obj;; 7153 }; 7154 if(stats) fFunctions->Add(stats);; 7155 fContour.Set(0);; 7156}; 7157 ; 7158////////////////////////////////////////////////////////////////////////////////; 7159/// Save the histogram as .csv, .tsv or .txt. In case of any other extension, fall; 7160/// back to TObject::SaveAs, which saves as a .C macro (but with the file name; 7161/// extension specified by the user); 7162///; 7163/// The Under/Overflow bins are also exported (as first and last lines); 7164/// The fist 2 columns are the lower and upper edges of the bins; 7165/// Column 3 contains the bin contents; 7166/// The last column contains the error in y. If errors are not present, the column; 7167/// is left empty; 7168///; 7169/// The result can be immediately imported into Excel, gnuplot, Python or whatever,; 7170/// without the needing to install pyroot, etc.; 7171///; 7172/// \param filename the name of the file where to store the histogram; 7173/// \param option some tuning options; 7174///; 7175/// The file extension defines the delimiter used:; 7176/// - `.csv` : comma; 7177/// - `.tsv` : tab; 7178/// - `.txt` : space; 7179///; 7180/// If option = ""title"" a title line is generated. If the y-axis has a title,; 7181/// this title is displayed as column 3 name, otherwise, it shows ""BinContent""; 7182 ; 7183void TH1::SaveAs(const char *filename, Option_t *option) const; 7184{; 7185 char del = '\0';; 7186 TString ext = """";; 7187 TString fname = filename;; 7188 TString opt = o",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:280167,Availability,error,errors,280167," 7146 //added multiple times in fFunctions.; 7147 //This case happens when the same object is added with different; 7148 //drawing modes; 7149 TObject *obj;; 7150 while ((obj = fFunctions->First())) {; 7151 while(fFunctions->Remove(obj)) { }; 7152 delete obj;; 7153 }; 7154 if(stats) fFunctions->Add(stats);; 7155 fContour.Set(0);; 7156}; 7157 ; 7158////////////////////////////////////////////////////////////////////////////////; 7159/// Save the histogram as .csv, .tsv or .txt. In case of any other extension, fall; 7160/// back to TObject::SaveAs, which saves as a .C macro (but with the file name; 7161/// extension specified by the user); 7162///; 7163/// The Under/Overflow bins are also exported (as first and last lines); 7164/// The fist 2 columns are the lower and upper edges of the bins; 7165/// Column 3 contains the bin contents; 7166/// The last column contains the error in y. If errors are not present, the column; 7167/// is left empty; 7168///; 7169/// The result can be immediately imported into Excel, gnuplot, Python or whatever,; 7170/// without the needing to install pyroot, etc.; 7171///; 7172/// \param filename the name of the file where to store the histogram; 7173/// \param option some tuning options; 7174///; 7175/// The file extension defines the delimiter used:; 7176/// - `.csv` : comma; 7177/// - `.tsv` : tab; 7178/// - `.txt` : space; 7179///; 7180/// If option = ""title"" a title line is generated. If the y-axis has a title,; 7181/// this title is displayed as column 3 name, otherwise, it shows ""BinContent""; 7182 ; 7183void TH1::SaveAs(const char *filename, Option_t *option) const; 7184{; 7185 char del = '\0';; 7186 TString ext = """";; 7187 TString fname = filename;; 7188 TString opt = option;; 7189 ; 7190 if (filename) {; 7191 if (fname.EndsWith("".csv"")) {; 7192 del = ',';; 7193 ext = ""csv"";; 7194 } else if (fname.EndsWith("".tsv"")) {; 7195 del = '\t';; 7196 ext = ""tsv"";; 7197 } else if (fname.EndsWith("".txt"")) {; 7198 del = ' ';; 7199 ext = ""txt"";;",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:287038,Availability,error,errors,287038,"_""); 7315 && !opt.Contains(""colz"")) {; 7316 hcounter++;; 7317 histName += ""__"";; 7318 histName += hcounter;; 7319 }; 7320 histName = gInterpreter-> MapCppName(histName);; 7321 const char *hname = histName.Data();; 7322 if (!strlen(hname)) hname = ""unnamed"";; 7323 TString savedName = GetName();; 7324 this->SetName(hname);; 7325 TString t(GetTitle());; 7326 t.ReplaceAll(""\\"",""\\\\"");; 7327 t.ReplaceAll(""\"""",""\\\"""");; 7328 out << hname << "" = new "" << ClassName() << ""("" << quote; 7329 << hname << quote << "","" << quote<< t.Data() << quote; 7330 << "","" << GetXaxis()->GetNbins();; 7331 if (nonEqiX); 7332 out << "", ""<<sxaxis;; 7333 else; 7334 out << "","" << GetXaxis()->GetXmin(); 7335 << "","" << GetXaxis()->GetXmax();; 7336 if (fDimension > 1) {; 7337 out << "","" << GetYaxis()->GetNbins();; 7338 if (nonEqiY); 7339 out << "", ""<<syaxis;; 7340 else; 7341 out << "","" << GetYaxis()->GetXmin(); 7342 << "","" << GetYaxis()->GetXmax();; 7343 }; 7344 if (fDimension > 2) {; 7345 out << "","" << GetZaxis()->GetNbins();; 7346 if (nonEqiZ); 7347 out << "", ""<<szaxis;; 7348 else; 7349 out << "","" << GetZaxis()->GetXmin(); 7350 << "","" << GetZaxis()->GetXmax();; 7351 }; 7352 out << "");"" << std::endl;; 7353 ; 7354 // save bin contents; 7355 Int_t bin;; 7356 for (bin=0;bin<fNcells;bin++) {; 7357 Double_t bc = RetrieveBinContent(bin);; 7358 if (bc) {; 7359 out<<"" ""<<hname<<""->SetBinContent(""<<bin<<"",""<<bc<<"");""<<std::endl;; 7360 }; 7361 }; 7362 ; 7363 // save bin errors; 7364 if (fSumw2.fN) {; 7365 for (bin=0;bin<fNcells;bin++) {; 7366 Double_t be = GetBinError(bin);; 7367 if (be) {; 7368 out<<"" ""<<hname<<""->SetBinError(""<<bin<<"",""<<be<<"");""<<std::endl;; 7369 }; 7370 }; 7371 }; 7372 ; 7373 TH1::SavePrimitiveHelp(out, hname, option);; 7374 this->SetName(savedName.Data());; 7375}; 7376 ; 7377////////////////////////////////////////////////////////////////////////////////; 7378/// Helper function for the SavePrimitive functions from TH1; 7379/// or classes derived from TH1, eg TProfile, TProfile2D.; 7380 ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:292659,Availability,error,error,292659,";; 7491 } else {; 7492 gStyle->SetBarOffset(fBarOffset);; 7493 gStyle->SetBarWidth(fBarWidth);; 7494 gStyle->SetHistFillColor(GetFillColor());; 7495 gStyle->SetHistFillStyle(GetFillStyle());; 7496 gStyle->SetHistLineColor(GetLineColor());; 7497 gStyle->SetHistLineStyle(GetLineStyle());; 7498 gStyle->SetHistLineWidth(GetLineWidth());; 7499 gStyle->SetMarkerColor(GetMarkerColor());; 7500 gStyle->SetMarkerStyle(GetMarkerStyle());; 7501 gStyle->SetMarkerSize(GetMarkerSize());; 7502 gStyle->SetOptStat(TestBit(kNoStats));; 7503 }; 7504 TIter next(GetListOfFunctions());; 7505 TObject *obj;; 7506 ; 7507 while ((obj = next())) {; 7508 obj->UseCurrentStyle();; 7509 }; 7510}; 7511 ; 7512////////////////////////////////////////////////////////////////////////////////; 7513/// For axis = 1,2 or 3 returns the mean value of the histogram along; 7514/// X,Y or Z axis.; 7515///; 7516/// For axis = 11, 12, 13 returns the standard error of the mean value; 7517/// of the histogram along X, Y or Z axis; 7518///; 7519/// Note that the mean value/StdDev is computed using the bins in the currently; 7520/// defined range (see TAxis::SetRange). By default the range includes; 7521/// all bins from 1 to nbins included, excluding underflows and overflows.; 7522/// To force the underflows and overflows in the computation, one must; 7523/// call the static function TH1::StatOverflows(kTRUE) before filling; 7524/// the histogram.; 7525///; 7526/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7527/// are calculated. By default, if no range has been set, the returned mean is; 7528/// the (unbinned) one calculated at fill time. If a range has been set, however,; 7529/// the mean is calculated using the bins in range, as described above; THIS; 7530/// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; 7531/// the range. To ensure that the returned mean (and all other statistics) is; 7532/// always that of the binned data stored in the histog",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:294236,Availability,error,error,294236,"24/// the histogram.; 7525///; 7526/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7527/// are calculated. By default, if no range has been set, the returned mean is; 7528/// the (unbinned) one calculated at fill time. If a range has been set, however,; 7529/// the mean is calculated using the bins in range, as described above; THIS; 7530/// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; 7531/// the range. To ensure that the returned mean (and all other statistics) is; 7532/// always that of the binned data stored in the histogram, call TH1::ResetStats.; 7533/// See TH1::GetStats.; 7534///; 7535/// Return mean value of this histogram along the X axis.; 7536 ; 7537Double_t TH1::GetMean(Int_t axis) const; 7538{; 7539 if (axis<1 || (axis>3 && axis<11) || axis>13) return 0;; 7540 Double_t stats[kNstat];; 7541 for (Int_t i=4;i<kNstat;i++) stats[i] = 0;; 7542 GetStats(stats);; 7543 if (stats[0] == 0) return 0;; 7544 if (axis<4){; 7545 Int_t ax[3] = {2,4,7};; 7546 return stats[ax[axis-1]]/stats[0];; 7547 } else {; 7548 // mean error = StdDev / sqrt( Neff ); 7549 Double_t stddev = GetStdDev(axis-10);; 7550 Double_t neff = GetEffectiveEntries();; 7551 return ( neff > 0 ? stddev/TMath::Sqrt(neff) : 0. );; 7552 }; 7553}; 7554 ; 7555////////////////////////////////////////////////////////////////////////////////; 7556/// Return standard error of mean of this histogram along the X axis.; 7557///; 7558/// Note that the mean value/StdDev is computed using the bins in the currently; 7559/// defined range (see TAxis::SetRange). By default the range includes; 7560/// all bins from 1 to nbins included, excluding underflows and overflows.; 7561/// To force the underflows and overflows in the computation, one must; 7562/// call the static function TH1::StatOverflows(kTRUE) before filling; 7563/// the histogram.; 7564///; 7565/// Also note, that although the definition of standard error doesn't include the; 7566/// assumpti",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:294547,Availability,error,error,294547,"530/// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; 7531/// the range. To ensure that the returned mean (and all other statistics) is; 7532/// always that of the binned data stored in the histogram, call TH1::ResetStats.; 7533/// See TH1::GetStats.; 7534///; 7535/// Return mean value of this histogram along the X axis.; 7536 ; 7537Double_t TH1::GetMean(Int_t axis) const; 7538{; 7539 if (axis<1 || (axis>3 && axis<11) || axis>13) return 0;; 7540 Double_t stats[kNstat];; 7541 for (Int_t i=4;i<kNstat;i++) stats[i] = 0;; 7542 GetStats(stats);; 7543 if (stats[0] == 0) return 0;; 7544 if (axis<4){; 7545 Int_t ax[3] = {2,4,7};; 7546 return stats[ax[axis-1]]/stats[0];; 7547 } else {; 7548 // mean error = StdDev / sqrt( Neff ); 7549 Double_t stddev = GetStdDev(axis-10);; 7550 Double_t neff = GetEffectiveEntries();; 7551 return ( neff > 0 ? stddev/TMath::Sqrt(neff) : 0. );; 7552 }; 7553}; 7554 ; 7555////////////////////////////////////////////////////////////////////////////////; 7556/// Return standard error of mean of this histogram along the X axis.; 7557///; 7558/// Note that the mean value/StdDev is computed using the bins in the currently; 7559/// defined range (see TAxis::SetRange). By default the range includes; 7560/// all bins from 1 to nbins included, excluding underflows and overflows.; 7561/// To force the underflows and overflows in the computation, one must; 7562/// call the static function TH1::StatOverflows(kTRUE) before filling; 7563/// the histogram.; 7564///; 7565/// Also note, that although the definition of standard error doesn't include the; 7566/// assumption of normality, many uses of this feature implicitly assume it.; 7567///; 7568/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7569/// are calculated. By default, if no range has been set, the returned value is; 7570/// the (unbinned) one calculated at fill time. If a range has been set, however,; 7571/// the value is calculated using",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:295092,Availability,error,error,295092,"turn 0;; 7544 if (axis<4){; 7545 Int_t ax[3] = {2,4,7};; 7546 return stats[ax[axis-1]]/stats[0];; 7547 } else {; 7548 // mean error = StdDev / sqrt( Neff ); 7549 Double_t stddev = GetStdDev(axis-10);; 7550 Double_t neff = GetEffectiveEntries();; 7551 return ( neff > 0 ? stddev/TMath::Sqrt(neff) : 0. );; 7552 }; 7553}; 7554 ; 7555////////////////////////////////////////////////////////////////////////////////; 7556/// Return standard error of mean of this histogram along the X axis.; 7557///; 7558/// Note that the mean value/StdDev is computed using the bins in the currently; 7559/// defined range (see TAxis::SetRange). By default the range includes; 7560/// all bins from 1 to nbins included, excluding underflows and overflows.; 7561/// To force the underflows and overflows in the computation, one must; 7562/// call the static function TH1::StatOverflows(kTRUE) before filling; 7563/// the histogram.; 7564///; 7565/// Also note, that although the definition of standard error doesn't include the; 7566/// assumption of normality, many uses of this feature implicitly assume it.; 7567///; 7568/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7569/// are calculated. By default, if no range has been set, the returned value is; 7570/// the (unbinned) one calculated at fill time. If a range has been set, however,; 7571/// the value is calculated using the bins in range, as described above; THIS; 7572/// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; 7573/// the range. To ensure that the returned value (and all other statistics) is; 7574/// always that of the binned data stored in the histogram, call TH1::ResetStats.; 7575/// See TH1::GetStats.; 7576 ; 7577Double_t TH1::GetMeanError(Int_t axis) const; 7578{; 7579 return GetMean(axis+10);; 7580}; 7581 ; 7582////////////////////////////////////////////////////////////////////////////////; 7583/// Returns the Standard Deviation (Sigma).; 7584/// The Sigma estimate is",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:296344,Availability,error,error,296344,"default, if no range has been set, the returned value is; 7570/// the (unbinned) one calculated at fill time. If a range has been set, however,; 7571/// the value is calculated using the bins in range, as described above; THIS; 7572/// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; 7573/// the range. To ensure that the returned value (and all other statistics) is; 7574/// always that of the binned data stored in the histogram, call TH1::ResetStats.; 7575/// See TH1::GetStats.; 7576 ; 7577Double_t TH1::GetMeanError(Int_t axis) const; 7578{; 7579 return GetMean(axis+10);; 7580}; 7581 ; 7582////////////////////////////////////////////////////////////////////////////////; 7583/// Returns the Standard Deviation (Sigma).; 7584/// The Sigma estimate is computed as; 7585/// \f[; 7586/// \sqrt{\frac{1}{N}(\sum(x_i-x_{mean})^2)}; 7587/// \f]; 7588/// For axis = 1,2 or 3 returns the Sigma value of the histogram along; 7589/// X, Y or Z axis; 7590/// For axis = 11, 12 or 13 returns the error of StdDev estimation along; 7591/// X, Y or Z axis for Normal distribution; 7592///; 7593/// Note that the mean value/sigma is computed using the bins in the currently; 7594/// defined range (see TAxis::SetRange). By default the range includes; 7595/// all bins from 1 to nbins included, excluding underflows and overflows.; 7596/// To force the underflows and overflows in the computation, one must; 7597/// call the static function TH1::StatOverflows(kTRUE) before filling; 7598/// the histogram.; 7599///; 7600/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7601/// are calculated. By default, if no range has been set, the returned standard; 7602/// deviation is the (unbinned) one calculated at fill time. If a range has been; 7603/// set, however, the standard deviation is calculated using the bins in range,; 7604/// as described above; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use; 7605/// TAxis::SetRange(0, 0) to unset ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:298148,Availability,error,error,298148,"bove; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use; 7605/// TAxis::SetRange(0, 0) to unset the range. To ensure that the returned standard; 7606/// deviation (and all other statistics) is always that of the binned data stored; 7607/// in the histogram, call TH1::ResetStats. See TH1::GetStats.; 7608 ; 7609Double_t TH1::GetStdDev(Int_t axis) const; 7610{; 7611 if (axis<1 || (axis>3 && axis<11) || axis>13) return 0;; 7612 ; 7613 Double_t x, stddev2, stats[kNstat];; 7614 for (Int_t i=4;i<kNstat;i++) stats[i] = 0;; 7615 GetStats(stats);; 7616 if (stats[0] == 0) return 0;; 7617 Int_t ax[3] = {2,4,7};; 7618 Int_t axm = ax[axis%10 - 1];; 7619 x = stats[axm]/stats[0];; 7620 // for negative stddev (e.g. when having negative weights) - return stdev=0; 7621 stddev2 = TMath::Max( stats[axm+1]/stats[0] -x*x, 0.0 );; 7622 if (axis<10); 7623 return TMath::Sqrt(stddev2);; 7624 else {; 7625 // The right formula for StdDev error depends on 4th momentum (see Kendall-Stuart Vol 1 pag 243); 7626 // formula valid for only gaussian distribution ( 4-th momentum = 3 * sigma^4 ); 7627 Double_t neff = GetEffectiveEntries();; 7628 return ( neff > 0 ? TMath::Sqrt(stddev2/(2*neff) ) : 0. );; 7629 }; 7630}; 7631 ; 7632////////////////////////////////////////////////////////////////////////////////; 7633/// Return error of standard deviation estimation for Normal distribution; 7634///; 7635/// Note that the mean value/StdDev is computed using the bins in the currently; 7636/// defined range (see TAxis::SetRange). By default the range includes; 7637/// all bins from 1 to nbins included, excluding underflows and overflows.; 7638/// To force the underflows and overflows in the computation, one must; 7639/// call the static function TH1::StatOverflows(kTRUE) before filling; 7640/// the histogram.; 7641///; 7642/// Value returned is standard deviation of sample standard deviation.; 7643/// Note that it is an approximated value which is valid only in the case that the; 7644/// original data distr",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:298533,Availability,error,error,298533,") const; 7610{; 7611 if (axis<1 || (axis>3 && axis<11) || axis>13) return 0;; 7612 ; 7613 Double_t x, stddev2, stats[kNstat];; 7614 for (Int_t i=4;i<kNstat;i++) stats[i] = 0;; 7615 GetStats(stats);; 7616 if (stats[0] == 0) return 0;; 7617 Int_t ax[3] = {2,4,7};; 7618 Int_t axm = ax[axis%10 - 1];; 7619 x = stats[axm]/stats[0];; 7620 // for negative stddev (e.g. when having negative weights) - return stdev=0; 7621 stddev2 = TMath::Max( stats[axm+1]/stats[0] -x*x, 0.0 );; 7622 if (axis<10); 7623 return TMath::Sqrt(stddev2);; 7624 else {; 7625 // The right formula for StdDev error depends on 4th momentum (see Kendall-Stuart Vol 1 pag 243); 7626 // formula valid for only gaussian distribution ( 4-th momentum = 3 * sigma^4 ); 7627 Double_t neff = GetEffectiveEntries();; 7628 return ( neff > 0 ? TMath::Sqrt(stddev2/(2*neff) ) : 0. );; 7629 }; 7630}; 7631 ; 7632////////////////////////////////////////////////////////////////////////////////; 7633/// Return error of standard deviation estimation for Normal distribution; 7634///; 7635/// Note that the mean value/StdDev is computed using the bins in the currently; 7636/// defined range (see TAxis::SetRange). By default the range includes; 7637/// all bins from 1 to nbins included, excluding underflows and overflows.; 7638/// To force the underflows and overflows in the computation, one must; 7639/// call the static function TH1::StatOverflows(kTRUE) before filling; 7640/// the histogram.; 7641///; 7642/// Value returned is standard deviation of sample standard deviation.; 7643/// Note that it is an approximated value which is valid only in the case that the; 7644/// original data distribution is Normal. The correct one would require; 7645/// the 4-th momentum value, which cannot be accurately estimated from a histogram since; 7646/// the x-information for all entries is not kept.; 7647///; 7648/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7649/// are calculated. By default, if no range has bee",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:300412,Availability,error,error,300412,"t, if no range has been set, the returned value is; 7650/// the (unbinned) one calculated at fill time. If a range has been set, however,; 7651/// the value is calculated using the bins in range, as described above; THIS; 7652/// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; 7653/// the range. To ensure that the returned value (and all other statistics) is; 7654/// always that of the binned data stored in the histogram, call TH1::ResetStats.; 7655/// See TH1::GetStats.; 7656 ; 7657Double_t TH1::GetStdDevError(Int_t axis) const; 7658{; 7659 return GetStdDev(axis+10);; 7660}; 7661 ; 7662////////////////////////////////////////////////////////////////////////////////; 7663/// - For axis = 1, 2 or 3 returns skewness of the histogram along x, y or z axis.; 7664/// - For axis = 11, 12 or 13 returns the approximate standard error of skewness; 7665/// of the histogram along x, y or z axis; 7666///; 7667///Note, that since third and fourth moment are not calculated; 7668///at the fill time, skewness and its standard error are computed bin by bin; 7669///; 7670/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7671/// are calculated. See TH1::GetMean and TH1::GetStdDev.; 7672 ; 7673Double_t TH1::GetSkewness(Int_t axis) const; 7674{; 7675 ; 7676 if (axis > 0 && axis <= 3){; 7677 ; 7678 Double_t mean = GetMean(axis);; 7679 Double_t stddev = GetStdDev(axis);; 7680 Double_t stddev3 = stddev*stddev*stddev;; 7681 ; 7682 Int_t firstBinX = fXaxis.GetFirst();; 7683 Int_t lastBinX = fXaxis.GetLast();; 7684 Int_t firstBinY = fYaxis.GetFirst();; 7685 Int_t lastBinY = fYaxis.GetLast();; 7686 Int_t firstBinZ = fZaxis.GetFirst();; 7687 Int_t lastBinZ = fZaxis.GetLast();; 7688 // include underflow/overflow if TH1::StatOverflows(kTRUE) in case no range is set on the axis; 7689 if (GetStatOverflowsBehaviour()) {; 7690 if ( !fXaxis.TestBit(TAxis::kAxisRange) ) {; 7691 if (firstBinX == 1) firstBinX = 0;; 7692 if (lastBinX == fXaxis.",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:300606,Availability,error,error,300606,"t, if no range has been set, the returned value is; 7650/// the (unbinned) one calculated at fill time. If a range has been set, however,; 7651/// the value is calculated using the bins in range, as described above; THIS; 7652/// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; 7653/// the range. To ensure that the returned value (and all other statistics) is; 7654/// always that of the binned data stored in the histogram, call TH1::ResetStats.; 7655/// See TH1::GetStats.; 7656 ; 7657Double_t TH1::GetStdDevError(Int_t axis) const; 7658{; 7659 return GetStdDev(axis+10);; 7660}; 7661 ; 7662////////////////////////////////////////////////////////////////////////////////; 7663/// - For axis = 1, 2 or 3 returns skewness of the histogram along x, y or z axis.; 7664/// - For axis = 11, 12 or 13 returns the approximate standard error of skewness; 7665/// of the histogram along x, y or z axis; 7666///; 7667///Note, that since third and fourth moment are not calculated; 7668///at the fill time, skewness and its standard error are computed bin by bin; 7669///; 7670/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7671/// are calculated. See TH1::GetMean and TH1::GetStdDev.; 7672 ; 7673Double_t TH1::GetSkewness(Int_t axis) const; 7674{; 7675 ; 7676 if (axis > 0 && axis <= 3){; 7677 ; 7678 Double_t mean = GetMean(axis);; 7679 Double_t stddev = GetStdDev(axis);; 7680 Double_t stddev3 = stddev*stddev*stddev;; 7681 ; 7682 Int_t firstBinX = fXaxis.GetFirst();; 7683 Int_t lastBinX = fXaxis.GetLast();; 7684 Int_t firstBinY = fYaxis.GetFirst();; 7685 Int_t lastBinY = fYaxis.GetLast();; 7686 Int_t firstBinZ = fZaxis.GetFirst();; 7687 Int_t lastBinZ = fZaxis.GetLast();; 7688 // include underflow/overflow if TH1::StatOverflows(kTRUE) in case no range is set on the axis; 7689 if (GetStatOverflowsBehaviour()) {; 7690 if ( !fXaxis.TestBit(TAxis::kAxisRange) ) {; 7691 if (firstBinX == 1) firstBinX = 0;; 7692 if (lastBinX == fXaxis.",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:302572,Availability,error,error,302572,"xis.GetNbins() ) lastBinX += 1;; 7693 }; 7694 if ( !fYaxis.TestBit(TAxis::kAxisRange) ) {; 7695 if (firstBinY == 1) firstBinY = 0;; 7696 if (lastBinY == fYaxis.GetNbins() ) lastBinY += 1;; 7697 }; 7698 if ( !fZaxis.TestBit(TAxis::kAxisRange) ) {; 7699 if (firstBinZ == 1) firstBinZ = 0;; 7700 if (lastBinZ == fZaxis.GetNbins() ) lastBinZ += 1;; 7701 }; 7702 }; 7703 ; 7704 Double_t x = 0;; 7705 Double_t sum=0;; 7706 Double_t np=0;; 7707 for (Int_t binx = firstBinX; binx <= lastBinX; binx++) {; 7708 for (Int_t biny = firstBinY; biny <= lastBinY; biny++) {; 7709 for (Int_t binz = firstBinZ; binz <= lastBinZ; binz++) {; 7710 if (axis==1 ) x = fXaxis.GetBinCenter(binx);; 7711 else if (axis==2 ) x = fYaxis.GetBinCenter(biny);; 7712 else if (axis==3 ) x = fZaxis.GetBinCenter(binz);; 7713 Double_t w = GetBinContent(binx,biny,binz);; 7714 np+=w;; 7715 sum+=w*(x-mean)*(x-mean)*(x-mean);; 7716 }; 7717 }; 7718 }; 7719 sum/=np*stddev3;; 7720 return sum;; 7721 }; 7722 else if (axis > 10 && axis <= 13) {; 7723 //compute standard error of skewness; 7724 // assume parent normal distribution use formula from Kendall-Stuart, Vol 1 pag 243, second edition; 7725 Double_t neff = GetEffectiveEntries();; 7726 return ( neff > 0 ? TMath::Sqrt(6./neff ) : 0. );; 7727 }; 7728 else {; 7729 Error(""GetSkewness"", ""illegal value of parameter"");; 7730 return 0;; 7731 }; 7732}; 7733 ; 7734////////////////////////////////////////////////////////////////////////////////; 7735/// - For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; 7736/// Kurtosis(gaussian(0, 1)) = 0.; 7737/// - For axis =11, 12 or 13 returns the approximate standard error of kurtosis; 7738/// of the histogram along x, y or z axis; 7739////; 7740/// Note, that since third and fourth moment are not calculated; 7741/// at the fill time, kurtosis and its standard error are computed bin by bin; 7742///; 7743/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7744/// are calculated. See TH1",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:303193,Availability,error,error,303193,"13 Double_t w = GetBinContent(binx,biny,binz);; 7714 np+=w;; 7715 sum+=w*(x-mean)*(x-mean)*(x-mean);; 7716 }; 7717 }; 7718 }; 7719 sum/=np*stddev3;; 7720 return sum;; 7721 }; 7722 else if (axis > 10 && axis <= 13) {; 7723 //compute standard error of skewness; 7724 // assume parent normal distribution use formula from Kendall-Stuart, Vol 1 pag 243, second edition; 7725 Double_t neff = GetEffectiveEntries();; 7726 return ( neff > 0 ? TMath::Sqrt(6./neff ) : 0. );; 7727 }; 7728 else {; 7729 Error(""GetSkewness"", ""illegal value of parameter"");; 7730 return 0;; 7731 }; 7732}; 7733 ; 7734////////////////////////////////////////////////////////////////////////////////; 7735/// - For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; 7736/// Kurtosis(gaussian(0, 1)) = 0.; 7737/// - For axis =11, 12 or 13 returns the approximate standard error of kurtosis; 7738/// of the histogram along x, y or z axis; 7739////; 7740/// Note, that since third and fourth moment are not calculated; 7741/// at the fill time, kurtosis and its standard error are computed bin by bin; 7742///; 7743/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7744/// are calculated. See TH1::GetMean and TH1::GetStdDev.; 7745 ; 7746Double_t TH1::GetKurtosis(Int_t axis) const; 7747{; 7748 if (axis > 0 && axis <= 3){; 7749 ; 7750 Double_t mean = GetMean(axis);; 7751 Double_t stddev = GetStdDev(axis);; 7752 Double_t stddev4 = stddev*stddev*stddev*stddev;; 7753 ; 7754 Int_t firstBinX = fXaxis.GetFirst();; 7755 Int_t lastBinX = fXaxis.GetLast();; 7756 Int_t firstBinY = fYaxis.GetFirst();; 7757 Int_t lastBinY = fYaxis.GetLast();; 7758 Int_t firstBinZ = fZaxis.GetFirst();; 7759 Int_t lastBinZ = fZaxis.GetLast();; 7760 // include underflow/overflow if TH1::StatOverflows(kTRUE) in case no range is set on the axis; 7761 if (GetStatOverflowsBehaviour()) {; 7762 if ( !fXaxis.TestBit(TAxis::kAxisRange) ) {; 7763 if (firstBinX == 1) firstBinX = 0;; 7764 if (lastBinX == fXaxis",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:303390,Availability,error,error,303390,"13 Double_t w = GetBinContent(binx,biny,binz);; 7714 np+=w;; 7715 sum+=w*(x-mean)*(x-mean)*(x-mean);; 7716 }; 7717 }; 7718 }; 7719 sum/=np*stddev3;; 7720 return sum;; 7721 }; 7722 else if (axis > 10 && axis <= 13) {; 7723 //compute standard error of skewness; 7724 // assume parent normal distribution use formula from Kendall-Stuart, Vol 1 pag 243, second edition; 7725 Double_t neff = GetEffectiveEntries();; 7726 return ( neff > 0 ? TMath::Sqrt(6./neff ) : 0. );; 7727 }; 7728 else {; 7729 Error(""GetSkewness"", ""illegal value of parameter"");; 7730 return 0;; 7731 }; 7732}; 7733 ; 7734////////////////////////////////////////////////////////////////////////////////; 7735/// - For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; 7736/// Kurtosis(gaussian(0, 1)) = 0.; 7737/// - For axis =11, 12 or 13 returns the approximate standard error of kurtosis; 7738/// of the histogram along x, y or z axis; 7739////; 7740/// Note, that since third and fourth moment are not calculated; 7741/// at the fill time, kurtosis and its standard error are computed bin by bin; 7742///; 7743/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7744/// are calculated. See TH1::GetMean and TH1::GetStdDev.; 7745 ; 7746Double_t TH1::GetKurtosis(Int_t axis) const; 7747{; 7748 if (axis > 0 && axis <= 3){; 7749 ; 7750 Double_t mean = GetMean(axis);; 7751 Double_t stddev = GetStdDev(axis);; 7752 Double_t stddev4 = stddev*stddev*stddev*stddev;; 7753 ; 7754 Int_t firstBinX = fXaxis.GetFirst();; 7755 Int_t lastBinX = fXaxis.GetLast();; 7756 Int_t firstBinY = fYaxis.GetFirst();; 7757 Int_t lastBinY = fYaxis.GetLast();; 7758 Int_t firstBinZ = fZaxis.GetFirst();; 7759 Int_t lastBinZ = fZaxis.GetLast();; 7760 // include underflow/overflow if TH1::StatOverflows(kTRUE) in case no range is set on the axis; 7761 if (GetStatOverflowsBehaviour()) {; 7762 if ( !fXaxis.TestBit(TAxis::kAxisRange) ) {; 7763 if (firstBinX == 1) firstBinX = 0;; 7764 if (lastBinX == fXaxis",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:305370,Availability,error,error,305370,"bins() ) lastBinX += 1;; 7765 }; 7766 if ( !fYaxis.TestBit(TAxis::kAxisRange) ) {; 7767 if (firstBinY == 1) firstBinY = 0;; 7768 if (lastBinY == fYaxis.GetNbins() ) lastBinY += 1;; 7769 }; 7770 if ( !fZaxis.TestBit(TAxis::kAxisRange) ) {; 7771 if (firstBinZ == 1) firstBinZ = 0;; 7772 if (lastBinZ == fZaxis.GetNbins() ) lastBinZ += 1;; 7773 }; 7774 }; 7775 ; 7776 Double_t x = 0;; 7777 Double_t sum=0;; 7778 Double_t np=0;; 7779 for (Int_t binx = firstBinX; binx <= lastBinX; binx++) {; 7780 for (Int_t biny = firstBinY; biny <= lastBinY; biny++) {; 7781 for (Int_t binz = firstBinZ; binz <= lastBinZ; binz++) {; 7782 if (axis==1 ) x = fXaxis.GetBinCenter(binx);; 7783 else if (axis==2 ) x = fYaxis.GetBinCenter(biny);; 7784 else if (axis==3 ) x = fZaxis.GetBinCenter(binz);; 7785 Double_t w = GetBinContent(binx,biny,binz);; 7786 np+=w;; 7787 sum+=w*(x-mean)*(x-mean)*(x-mean)*(x-mean);; 7788 }; 7789 }; 7790 }; 7791 sum/=(np*stddev4);; 7792 return sum-3;; 7793 ; 7794 } else if (axis > 10 && axis <= 13) {; 7795 //compute standard error of skewness; 7796 // assume parent normal distribution use formula from Kendall-Stuart, Vol 1 pag 243, second edition; 7797 Double_t neff = GetEffectiveEntries();; 7798 return ( neff > 0 ? TMath::Sqrt(24./neff ) : 0. );; 7799 }; 7800 else {; 7801 Error(""GetKurtosis"", ""illegal value of parameter"");; 7802 return 0;; 7803 }; 7804}; 7805 ; 7806////////////////////////////////////////////////////////////////////////////////; 7807/// fill the array stats from the contents of this histogram; 7808/// The array stats must be correctly dimensioned in the calling program.; 7809///; 7810/// ~~~ {.cpp}; 7811/// stats[0] = sumw; 7812/// stats[1] = sumw2; 7813/// stats[2] = sumwx; 7814/// stats[3] = sumwx2; 7815/// ~~~; 7816///; 7817/// If no axis-subrange is specified (via TAxis::SetRange), the array stats; 7818/// is simply a copy of the statistics quantities computed at filling time.; 7819/// If a sub-range is specified, the function recomputes these quantit",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:312236,Availability,error,error,312236,"37///Return integral of bin contents. Only bins in the bins range are considered.; 7938///; 7939/// By default the integral is computed as the sum of bin contents in the range.; 7940/// if option ""width"" is specified, the integral is the sum of; 7941/// the bin contents multiplied by the bin width in x.; 7942 ; 7943Double_t TH1::Integral(Option_t *option) const; 7944{; 7945 return Integral(fXaxis.GetFirst(),fXaxis.GetLast(),option);; 7946}; 7947 ; 7948////////////////////////////////////////////////////////////////////////////////; 7949/// Return integral of bin contents in range [binx1,binx2].; 7950///; 7951/// By default the integral is computed as the sum of bin contents in the range.; 7952/// if option ""width"" is specified, the integral is the sum of; 7953/// the bin contents multiplied by the bin width in x.; 7954 ; 7955Double_t TH1::Integral(Int_t binx1, Int_t binx2, Option_t *option) const; 7956{; 7957 double err = 0;; 7958 return DoIntegral(binx1,binx2,0,-1,0,-1,err,option);; 7959}; 7960 ; 7961////////////////////////////////////////////////////////////////////////////////; 7962/// Return integral of bin contents in range [binx1,binx2] and its error.; 7963///; 7964/// By default the integral is computed as the sum of bin contents in the range.; 7965/// if option ""width"" is specified, the integral is the sum of; 7966/// the bin contents multiplied by the bin width in x.; 7967/// the error is computed using error propagation from the bin errors assuming that; 7968/// all the bins are uncorrelated; 7969 ; 7970Double_t TH1::IntegralAndError(Int_t binx1, Int_t binx2, Double_t & error, Option_t *option) const; 7971{; 7972 return DoIntegral(binx1,binx2,0,-1,0,-1,error,option,kTRUE);; 7973}; 7974 ; 7975////////////////////////////////////////////////////////////////////////////////; 7976/// Internal function compute integral and optionally the error between the limits; 7977/// specified by the bin number values working for all histograms (1D, 2D and 3D); 7978 ; 7979",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:312479,Availability,error,error,312479,"ontents in range [binx1,binx2] and its error.; 7963///; 7964/// By default the integral is computed as the sum of bin contents in the range.; 7965/// if option ""width"" is specified, the integral is the sum of; 7966/// the bin contents multiplied by the bin width in x.; 7967/// the error is computed using error propagation from the bin errors assuming that; 7968/// all the bins are uncorrelated; 7969 ; 7970Double_t TH1::IntegralAndError(Int_t binx1, Int_t binx2, Double_t & error, Option_t *option) const; 7971{; 7972 return DoIntegral(binx1,binx2,0,-1,0,-1,error,option,kTRUE);; 7973}; 7974 ; 7975////////////////////////////////////////////////////////////////////////////////; 7976/// Internal function compute integral and optionally the error between the limits; 7977/// specified by the bin number values working for all histograms (1D, 2D and 3D); 7978 ; 7979Double_t TH1::DoIntegral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t & error ,; 7980 Option_t *option, Bool_t doError) const; 7981{; 7982 if (fBuffer) ((TH1*)this)->BufferEmpty();; 7983 ; 7984 Int_t nx = GetNbinsX() + 2;; 7985 if (binx1 < 0) binx1 = 0;; 7986 if (binx2 >= nx || binx2 < binx1) binx2 = nx - 1;; 7987 ; 7988 if (GetDimension() > 1) {; 7989 Int_t ny = GetNbinsY() + 2;; 7990 if (biny1 < 0) biny1 = 0;; 7991 if (biny2 >= ny || biny2 < biny1) biny2 = ny - 1;; 7992 } else {; 7993 biny1 = 0; biny2 = 0;; 7994 }; 7995 ; 7996 if (GetDimension() > 2) {; 7997 Int_t nz = GetNbinsZ() + 2;; 7998 if (binz1 < 0) binz1 = 0;; 7999 if (binz2 >= nz || binz2 < binz1) binz2 = nz - 1;; 8000 } else {; 8001 binz1 = 0; binz2 = 0;; 8002 }; 8003 ; 8004 // - Loop on bins in specified range; 8005 TString opt = option;; 8006 opt.ToLower();; 8007 Bool_t width = kFALSE;; 8008 if (opt.Contains(""width"")) width = kTRUE;; 8009 ; 8010 ; 8011 Double_t dx = 1., dy = .1, dz =.1;; 8012 Double_t integral = 0;; 8013 Double_t igerr2 = 0;; 8014 for (Int_t binx = binx1; binx <= binx2; ++binx) {; 8015 if (wid",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:312503,Availability,error,error,312503,"ontents in range [binx1,binx2] and its error.; 7963///; 7964/// By default the integral is computed as the sum of bin contents in the range.; 7965/// if option ""width"" is specified, the integral is the sum of; 7966/// the bin contents multiplied by the bin width in x.; 7967/// the error is computed using error propagation from the bin errors assuming that; 7968/// all the bins are uncorrelated; 7969 ; 7970Double_t TH1::IntegralAndError(Int_t binx1, Int_t binx2, Double_t & error, Option_t *option) const; 7971{; 7972 return DoIntegral(binx1,binx2,0,-1,0,-1,error,option,kTRUE);; 7973}; 7974 ; 7975////////////////////////////////////////////////////////////////////////////////; 7976/// Internal function compute integral and optionally the error between the limits; 7977/// specified by the bin number values working for all histograms (1D, 2D and 3D); 7978 ; 7979Double_t TH1::DoIntegral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t & error ,; 7980 Option_t *option, Bool_t doError) const; 7981{; 7982 if (fBuffer) ((TH1*)this)->BufferEmpty();; 7983 ; 7984 Int_t nx = GetNbinsX() + 2;; 7985 if (binx1 < 0) binx1 = 0;; 7986 if (binx2 >= nx || binx2 < binx1) binx2 = nx - 1;; 7987 ; 7988 if (GetDimension() > 1) {; 7989 Int_t ny = GetNbinsY() + 2;; 7990 if (biny1 < 0) biny1 = 0;; 7991 if (biny2 >= ny || biny2 < biny1) biny2 = ny - 1;; 7992 } else {; 7993 biny1 = 0; biny2 = 0;; 7994 }; 7995 ; 7996 if (GetDimension() > 2) {; 7997 Int_t nz = GetNbinsZ() + 2;; 7998 if (binz1 < 0) binz1 = 0;; 7999 if (binz2 >= nz || binz2 < binz1) binz2 = nz - 1;; 8000 } else {; 8001 binz1 = 0; binz2 = 0;; 8002 }; 8003 ; 8004 // - Loop on bins in specified range; 8005 TString opt = option;; 8006 opt.ToLower();; 8007 Bool_t width = kFALSE;; 8008 if (opt.Contains(""width"")) width = kTRUE;; 8009 ; 8010 ; 8011 Double_t dx = 1., dy = .1, dz =.1;; 8012 Double_t integral = 0;; 8013 Double_t igerr2 = 0;; 8014 for (Int_t binx = binx1; binx <= binx2; ++binx) {; 8015 if (wid",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:312534,Availability,error,errors,312534,"ontents in range [binx1,binx2] and its error.; 7963///; 7964/// By default the integral is computed as the sum of bin contents in the range.; 7965/// if option ""width"" is specified, the integral is the sum of; 7966/// the bin contents multiplied by the bin width in x.; 7967/// the error is computed using error propagation from the bin errors assuming that; 7968/// all the bins are uncorrelated; 7969 ; 7970Double_t TH1::IntegralAndError(Int_t binx1, Int_t binx2, Double_t & error, Option_t *option) const; 7971{; 7972 return DoIntegral(binx1,binx2,0,-1,0,-1,error,option,kTRUE);; 7973}; 7974 ; 7975////////////////////////////////////////////////////////////////////////////////; 7976/// Internal function compute integral and optionally the error between the limits; 7977/// specified by the bin number values working for all histograms (1D, 2D and 3D); 7978 ; 7979Double_t TH1::DoIntegral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t & error ,; 7980 Option_t *option, Bool_t doError) const; 7981{; 7982 if (fBuffer) ((TH1*)this)->BufferEmpty();; 7983 ; 7984 Int_t nx = GetNbinsX() + 2;; 7985 if (binx1 < 0) binx1 = 0;; 7986 if (binx2 >= nx || binx2 < binx1) binx2 = nx - 1;; 7987 ; 7988 if (GetDimension() > 1) {; 7989 Int_t ny = GetNbinsY() + 2;; 7990 if (biny1 < 0) biny1 = 0;; 7991 if (biny2 >= ny || biny2 < biny1) biny2 = ny - 1;; 7992 } else {; 7993 biny1 = 0; biny2 = 0;; 7994 }; 7995 ; 7996 if (GetDimension() > 2) {; 7997 Int_t nz = GetNbinsZ() + 2;; 7998 if (binz1 < 0) binz1 = 0;; 7999 if (binz2 >= nz || binz2 < binz1) binz2 = nz - 1;; 8000 } else {; 8001 binz1 = 0; binz2 = 0;; 8002 }; 8003 ; 8004 // - Loop on bins in specified range; 8005 TString opt = option;; 8006 opt.ToLower();; 8007 Bool_t width = kFALSE;; 8008 if (opt.Contains(""width"")) width = kTRUE;; 8009 ; 8010 ; 8011 Double_t dx = 1., dy = .1, dz =.1;; 8012 Double_t integral = 0;; 8013 Double_t igerr2 = 0;; 8014 for (Int_t binx = binx1; binx <= binx2; ++binx) {; 8015 if (wid",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:312674,Availability,error,error,312674,"ontents in range [binx1,binx2] and its error.; 7963///; 7964/// By default the integral is computed as the sum of bin contents in the range.; 7965/// if option ""width"" is specified, the integral is the sum of; 7966/// the bin contents multiplied by the bin width in x.; 7967/// the error is computed using error propagation from the bin errors assuming that; 7968/// all the bins are uncorrelated; 7969 ; 7970Double_t TH1::IntegralAndError(Int_t binx1, Int_t binx2, Double_t & error, Option_t *option) const; 7971{; 7972 return DoIntegral(binx1,binx2,0,-1,0,-1,error,option,kTRUE);; 7973}; 7974 ; 7975////////////////////////////////////////////////////////////////////////////////; 7976/// Internal function compute integral and optionally the error between the limits; 7977/// specified by the bin number values working for all histograms (1D, 2D and 3D); 7978 ; 7979Double_t TH1::DoIntegral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t & error ,; 7980 Option_t *option, Bool_t doError) const; 7981{; 7982 if (fBuffer) ((TH1*)this)->BufferEmpty();; 7983 ; 7984 Int_t nx = GetNbinsX() + 2;; 7985 if (binx1 < 0) binx1 = 0;; 7986 if (binx2 >= nx || binx2 < binx1) binx2 = nx - 1;; 7987 ; 7988 if (GetDimension() > 1) {; 7989 Int_t ny = GetNbinsY() + 2;; 7990 if (biny1 < 0) biny1 = 0;; 7991 if (biny2 >= ny || biny2 < biny1) biny2 = ny - 1;; 7992 } else {; 7993 biny1 = 0; biny2 = 0;; 7994 }; 7995 ; 7996 if (GetDimension() > 2) {; 7997 Int_t nz = GetNbinsZ() + 2;; 7998 if (binz1 < 0) binz1 = 0;; 7999 if (binz2 >= nz || binz2 < binz1) binz2 = nz - 1;; 8000 } else {; 8001 binz1 = 0; binz2 = 0;; 8002 }; 8003 ; 8004 // - Loop on bins in specified range; 8005 TString opt = option;; 8006 opt.ToLower();; 8007 Bool_t width = kFALSE;; 8008 if (opt.Contains(""width"")) width = kTRUE;; 8009 ; 8010 ; 8011 Double_t dx = 1., dy = .1, dz =.1;; 8012 Double_t integral = 0;; 8013 Double_t igerr2 = 0;; 8014 for (Int_t binx = binx1; binx <= binx2; ++binx) {; 8015 if (wid",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:312758,Availability,error,error,312758,"ontents in range [binx1,binx2] and its error.; 7963///; 7964/// By default the integral is computed as the sum of bin contents in the range.; 7965/// if option ""width"" is specified, the integral is the sum of; 7966/// the bin contents multiplied by the bin width in x.; 7967/// the error is computed using error propagation from the bin errors assuming that; 7968/// all the bins are uncorrelated; 7969 ; 7970Double_t TH1::IntegralAndError(Int_t binx1, Int_t binx2, Double_t & error, Option_t *option) const; 7971{; 7972 return DoIntegral(binx1,binx2,0,-1,0,-1,error,option,kTRUE);; 7973}; 7974 ; 7975////////////////////////////////////////////////////////////////////////////////; 7976/// Internal function compute integral and optionally the error between the limits; 7977/// specified by the bin number values working for all histograms (1D, 2D and 3D); 7978 ; 7979Double_t TH1::DoIntegral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t & error ,; 7980 Option_t *option, Bool_t doError) const; 7981{; 7982 if (fBuffer) ((TH1*)this)->BufferEmpty();; 7983 ; 7984 Int_t nx = GetNbinsX() + 2;; 7985 if (binx1 < 0) binx1 = 0;; 7986 if (binx2 >= nx || binx2 < binx1) binx2 = nx - 1;; 7987 ; 7988 if (GetDimension() > 1) {; 7989 Int_t ny = GetNbinsY() + 2;; 7990 if (biny1 < 0) biny1 = 0;; 7991 if (biny2 >= ny || biny2 < biny1) biny2 = ny - 1;; 7992 } else {; 7993 biny1 = 0; biny2 = 0;; 7994 }; 7995 ; 7996 if (GetDimension() > 2) {; 7997 Int_t nz = GetNbinsZ() + 2;; 7998 if (binz1 < 0) binz1 = 0;; 7999 if (binz2 >= nz || binz2 < binz1) binz2 = nz - 1;; 8000 } else {; 8001 binz1 = 0; binz2 = 0;; 8002 }; 8003 ; 8004 // - Loop on bins in specified range; 8005 TString opt = option;; 8006 opt.ToLower();; 8007 Bool_t width = kFALSE;; 8008 if (opt.Contains(""width"")) width = kTRUE;; 8009 ; 8010 ; 8011 Double_t dx = 1., dy = .1, dz =.1;; 8012 Double_t integral = 0;; 8013 Double_t igerr2 = 0;; 8014 for (Int_t binx = binx1; binx <= binx2; ++binx) {; 8015 if (wid",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:312942,Availability,error,error,312942,"ontents in range [binx1,binx2] and its error.; 7963///; 7964/// By default the integral is computed as the sum of bin contents in the range.; 7965/// if option ""width"" is specified, the integral is the sum of; 7966/// the bin contents multiplied by the bin width in x.; 7967/// the error is computed using error propagation from the bin errors assuming that; 7968/// all the bins are uncorrelated; 7969 ; 7970Double_t TH1::IntegralAndError(Int_t binx1, Int_t binx2, Double_t & error, Option_t *option) const; 7971{; 7972 return DoIntegral(binx1,binx2,0,-1,0,-1,error,option,kTRUE);; 7973}; 7974 ; 7975////////////////////////////////////////////////////////////////////////////////; 7976/// Internal function compute integral and optionally the error between the limits; 7977/// specified by the bin number values working for all histograms (1D, 2D and 3D); 7978 ; 7979Double_t TH1::DoIntegral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t & error ,; 7980 Option_t *option, Bool_t doError) const; 7981{; 7982 if (fBuffer) ((TH1*)this)->BufferEmpty();; 7983 ; 7984 Int_t nx = GetNbinsX() + 2;; 7985 if (binx1 < 0) binx1 = 0;; 7986 if (binx2 >= nx || binx2 < binx1) binx2 = nx - 1;; 7987 ; 7988 if (GetDimension() > 1) {; 7989 Int_t ny = GetNbinsY() + 2;; 7990 if (biny1 < 0) biny1 = 0;; 7991 if (biny2 >= ny || biny2 < biny1) biny2 = ny - 1;; 7992 } else {; 7993 biny1 = 0; biny2 = 0;; 7994 }; 7995 ; 7996 if (GetDimension() > 2) {; 7997 Int_t nz = GetNbinsZ() + 2;; 7998 if (binz1 < 0) binz1 = 0;; 7999 if (binz2 >= nz || binz2 < binz1) binz2 = nz - 1;; 8000 } else {; 8001 binz1 = 0; binz2 = 0;; 8002 }; 8003 ; 8004 // - Loop on bins in specified range; 8005 TString opt = option;; 8006 opt.ToLower();; 8007 Bool_t width = kFALSE;; 8008 if (opt.Contains(""width"")) width = kTRUE;; 8009 ; 8010 ; 8011 Double_t dx = 1., dy = .1, dz =.1;; 8012 Double_t integral = 0;; 8013 Double_t igerr2 = 0;; 8014 for (Int_t binx = binx1; binx <= binx2; ++binx) {; 8015 if (wid",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:313180,Availability,error,error,313180,"ontents in range [binx1,binx2] and its error.; 7963///; 7964/// By default the integral is computed as the sum of bin contents in the range.; 7965/// if option ""width"" is specified, the integral is the sum of; 7966/// the bin contents multiplied by the bin width in x.; 7967/// the error is computed using error propagation from the bin errors assuming that; 7968/// all the bins are uncorrelated; 7969 ; 7970Double_t TH1::IntegralAndError(Int_t binx1, Int_t binx2, Double_t & error, Option_t *option) const; 7971{; 7972 return DoIntegral(binx1,binx2,0,-1,0,-1,error,option,kTRUE);; 7973}; 7974 ; 7975////////////////////////////////////////////////////////////////////////////////; 7976/// Internal function compute integral and optionally the error between the limits; 7977/// specified by the bin number values working for all histograms (1D, 2D and 3D); 7978 ; 7979Double_t TH1::DoIntegral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t & error ,; 7980 Option_t *option, Bool_t doError) const; 7981{; 7982 if (fBuffer) ((TH1*)this)->BufferEmpty();; 7983 ; 7984 Int_t nx = GetNbinsX() + 2;; 7985 if (binx1 < 0) binx1 = 0;; 7986 if (binx2 >= nx || binx2 < binx1) binx2 = nx - 1;; 7987 ; 7988 if (GetDimension() > 1) {; 7989 Int_t ny = GetNbinsY() + 2;; 7990 if (biny1 < 0) biny1 = 0;; 7991 if (biny2 >= ny || biny2 < biny1) biny2 = ny - 1;; 7992 } else {; 7993 biny1 = 0; biny2 = 0;; 7994 }; 7995 ; 7996 if (GetDimension() > 2) {; 7997 Int_t nz = GetNbinsZ() + 2;; 7998 if (binz1 < 0) binz1 = 0;; 7999 if (binz2 >= nz || binz2 < binz1) binz2 = nz - 1;; 8000 } else {; 8001 binz1 = 0; binz2 = 0;; 8002 }; 8003 ; 8004 // - Loop on bins in specified range; 8005 TString opt = option;; 8006 opt.ToLower();; 8007 Bool_t width = kFALSE;; 8008 if (opt.Contains(""width"")) width = kTRUE;; 8009 ; 8010 ; 8011 Double_t dx = 1., dy = .1, dz =.1;; 8012 Double_t integral = 0;; 8013 Double_t igerr2 = 0;; 8014 for (Int_t binx = binx1; binx <= binx2; ++binx) {; 8015 if (wid",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:314852,Availability,error,error,314852,"= 0; binz2 = 0;; 8002 }; 8003 ; 8004 // - Loop on bins in specified range; 8005 TString opt = option;; 8006 opt.ToLower();; 8007 Bool_t width = kFALSE;; 8008 if (opt.Contains(""width"")) width = kTRUE;; 8009 ; 8010 ; 8011 Double_t dx = 1., dy = .1, dz =.1;; 8012 Double_t integral = 0;; 8013 Double_t igerr2 = 0;; 8014 for (Int_t binx = binx1; binx <= binx2; ++binx) {; 8015 if (width) dx = fXaxis.GetBinWidth(binx);; 8016 for (Int_t biny = biny1; biny <= biny2; ++biny) {; 8017 if (width) dy = fYaxis.GetBinWidth(biny);; 8018 for (Int_t binz = binz1; binz <= binz2; ++binz) {; 8019 Int_t bin = GetBin(binx, biny, binz);; 8020 Double_t dv = 0.0;; 8021 if (width) {; 8022 dz = fZaxis.GetBinWidth(binz);; 8023 dv = dx * dy * dz;; 8024 integral += RetrieveBinContent(bin) * dv;; 8025 } else {; 8026 integral += RetrieveBinContent(bin);; 8027 }; 8028 if (doError) {; 8029 if (width) igerr2 += GetBinErrorSqUnchecked(bin) * dv * dv;; 8030 else igerr2 += GetBinErrorSqUnchecked(bin);; 8031 }; 8032 }; 8033 }; 8034 }; 8035 ; 8036 if (doError) error = TMath::Sqrt(igerr2);; 8037 return integral;; 8038}; 8039 ; 8040////////////////////////////////////////////////////////////////////////////////; 8041/// Statistical test of compatibility in shape between; 8042/// this histogram and h2, using the Anderson-Darling 2 sample test.; 8043///; 8044/// The AD 2 sample test formula are derived from the paper; 8045/// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; 8046///; 8047/// The test is implemented in root in the ROOT::Math::GoFTest class; 8048/// It is the same formula ( (6) in the paper), and also shown in; 8049/// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); 8050///; 8051/// Binned data are considered as un-binned data; 8052/// with identical observation happening in the bin center.; 8053///; 8054/// \param[in] h2 Pointer to 1D histogram; 8055/// \param[in] option is a character string to specify options; 8056/// - ""D"" Put out a line of ""Debug"" printout; 8057/// - ""T"" Ret",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:324096,Availability,error,errors,324096,"212 return 0;; 8213 }; 8214 }; 8215 ; 8216 Bool_t afunc1 = kFALSE;; 8217 Bool_t afunc2 = kFALSE;; 8218 Double_t sum1 = 0, sum2 = 0;; 8219 Double_t ew1, ew2, w1 = 0, w2 = 0;; 8220 Int_t bin;; 8221 Int_t ifirst = 1;; 8222 Int_t ilast = ncx1;; 8223 // integral of all bins (use underflow/overflow if option); 8224 if (opt.Contains(""U"")) ifirst = 0;; 8225 if (opt.Contains(""O"")) ilast = ncx1 +1;; 8226 for (bin = ifirst; bin <= ilast; bin++) {; 8227 sum1 += h1->RetrieveBinContent(bin);; 8228 sum2 += h2->RetrieveBinContent(bin);; 8229 ew1 = h1->GetBinError(bin);; 8230 ew2 = h2->GetBinError(bin);; 8231 w1 += ew1*ew1;; 8232 w2 += ew2*ew2;; 8233 }; 8234 if (sum1 == 0) {; 8235 Error(""KolmogorovTest"",""Histogram1 %s integral is zero\n"",h1->GetName());; 8236 return 0;; 8237 }; 8238 if (sum2 == 0) {; 8239 Error(""KolmogorovTest"",""Histogram2 %s integral is zero\n"",h2->GetName());; 8240 return 0;; 8241 }; 8242 ; 8243 // calculate the effective entries.; 8244 // the case when errors are zero (w1 == 0 or w2 ==0) are equivalent to; 8245 // compare to a function. In that case the rescaling is done only on sqrt(esum2) or sqrt(esum1); 8246 Double_t esum1 = 0, esum2 = 0;; 8247 if (w1 > 0); 8248 esum1 = sum1 * sum1 / w1;; 8249 else; 8250 afunc1 = kTRUE; // use later for calculating z; 8251 ; 8252 if (w2 > 0); 8253 esum2 = sum2 * sum2 / w2;; 8254 else; 8255 afunc2 = kTRUE; // use later for calculating z; 8256 ; 8257 if (afunc2 && afunc1) {; 8258 Error(""KolmogorovTest"",""Errors are zero for both histograms\n"");; 8259 return 0;; 8260 }; 8261 ; 8262 ; 8263 Double_t s1 = 1/sum1;; 8264 Double_t s2 = 1/sum2;; 8265 ; 8266 // Find largest difference for Kolmogorov Test; 8267 Double_t dfmax =0, rsum1 = 0, rsum2 = 0;; 8268 ; 8269 for (bin=ifirst;bin<=ilast;bin++) {; 8270 rsum1 += s1*h1->RetrieveBinContent(bin);; 8271 rsum2 += s2*h2->RetrieveBinContent(bin);; 8272 dfmax = TMath::Max(dfmax,TMath::Abs(rsum1-rsum2));; 8273 }; 8274 ; 8275 // Get Kolmogorov probability; 8276 Double_t z, prb1=0, prb2=0, prb3=0;; ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:325169,Availability,error,errors,325169,";; 8237 }; 8238 if (sum2 == 0) {; 8239 Error(""KolmogorovTest"",""Histogram2 %s integral is zero\n"",h2->GetName());; 8240 return 0;; 8241 }; 8242 ; 8243 // calculate the effective entries.; 8244 // the case when errors are zero (w1 == 0 or w2 ==0) are equivalent to; 8245 // compare to a function. In that case the rescaling is done only on sqrt(esum2) or sqrt(esum1); 8246 Double_t esum1 = 0, esum2 = 0;; 8247 if (w1 > 0); 8248 esum1 = sum1 * sum1 / w1;; 8249 else; 8250 afunc1 = kTRUE; // use later for calculating z; 8251 ; 8252 if (w2 > 0); 8253 esum2 = sum2 * sum2 / w2;; 8254 else; 8255 afunc2 = kTRUE; // use later for calculating z; 8256 ; 8257 if (afunc2 && afunc1) {; 8258 Error(""KolmogorovTest"",""Errors are zero for both histograms\n"");; 8259 return 0;; 8260 }; 8261 ; 8262 ; 8263 Double_t s1 = 1/sum1;; 8264 Double_t s2 = 1/sum2;; 8265 ; 8266 // Find largest difference for Kolmogorov Test; 8267 Double_t dfmax =0, rsum1 = 0, rsum2 = 0;; 8268 ; 8269 for (bin=ifirst;bin<=ilast;bin++) {; 8270 rsum1 += s1*h1->RetrieveBinContent(bin);; 8271 rsum2 += s2*h2->RetrieveBinContent(bin);; 8272 dfmax = TMath::Max(dfmax,TMath::Abs(rsum1-rsum2));; 8273 }; 8274 ; 8275 // Get Kolmogorov probability; 8276 Double_t z, prb1=0, prb2=0, prb3=0;; 8277 ; 8278 // case h1 is exact (has zero errors); 8279 if (afunc1); 8280 z = dfmax*TMath::Sqrt(esum2);; 8281 // case h2 has zero errors; 8282 else if (afunc2); 8283 z = dfmax*TMath::Sqrt(esum1);; 8284 else; 8285 // for comparison between two data sets; 8286 z = dfmax*TMath::Sqrt(esum1*esum2/(esum1+esum2));; 8287 ; 8288 prob = TMath::KolmogorovProb(z);; 8289 ; 8290 // option N to combine normalization makes sense if both afunc1 and afunc2 are false; 8291 if (opt.Contains(""N"") && !(afunc1 || afunc2 ) ) {; 8292 // Combine probabilities for shape and normalization,; 8293 prb1 = prob;; 8294 Double_t d12 = esum1-esum2;; 8295 Double_t chi2 = d12*d12/(esum1+esum2);; 8296 prb2 = TMath::Prob(chi2,1);; 8297 // see Eadie et al., section 11.6.2; 8298 if (prob > 0",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:325257,Availability,error,errors,325257,";; 8237 }; 8238 if (sum2 == 0) {; 8239 Error(""KolmogorovTest"",""Histogram2 %s integral is zero\n"",h2->GetName());; 8240 return 0;; 8241 }; 8242 ; 8243 // calculate the effective entries.; 8244 // the case when errors are zero (w1 == 0 or w2 ==0) are equivalent to; 8245 // compare to a function. In that case the rescaling is done only on sqrt(esum2) or sqrt(esum1); 8246 Double_t esum1 = 0, esum2 = 0;; 8247 if (w1 > 0); 8248 esum1 = sum1 * sum1 / w1;; 8249 else; 8250 afunc1 = kTRUE; // use later for calculating z; 8251 ; 8252 if (w2 > 0); 8253 esum2 = sum2 * sum2 / w2;; 8254 else; 8255 afunc2 = kTRUE; // use later for calculating z; 8256 ; 8257 if (afunc2 && afunc1) {; 8258 Error(""KolmogorovTest"",""Errors are zero for both histograms\n"");; 8259 return 0;; 8260 }; 8261 ; 8262 ; 8263 Double_t s1 = 1/sum1;; 8264 Double_t s2 = 1/sum2;; 8265 ; 8266 // Find largest difference for Kolmogorov Test; 8267 Double_t dfmax =0, rsum1 = 0, rsum2 = 0;; 8268 ; 8269 for (bin=ifirst;bin<=ilast;bin++) {; 8270 rsum1 += s1*h1->RetrieveBinContent(bin);; 8271 rsum2 += s2*h2->RetrieveBinContent(bin);; 8272 dfmax = TMath::Max(dfmax,TMath::Abs(rsum1-rsum2));; 8273 }; 8274 ; 8275 // Get Kolmogorov probability; 8276 Double_t z, prb1=0, prb2=0, prb3=0;; 8277 ; 8278 // case h1 is exact (has zero errors); 8279 if (afunc1); 8280 z = dfmax*TMath::Sqrt(esum2);; 8281 // case h2 has zero errors; 8282 else if (afunc2); 8283 z = dfmax*TMath::Sqrt(esum1);; 8284 else; 8285 // for comparison between two data sets; 8286 z = dfmax*TMath::Sqrt(esum1*esum2/(esum1+esum2));; 8287 ; 8288 prob = TMath::KolmogorovProb(z);; 8289 ; 8290 // option N to combine normalization makes sense if both afunc1 and afunc2 are false; 8291 if (opt.Contains(""N"") && !(afunc1 || afunc2 ) ) {; 8292 // Combine probabilities for shape and normalization,; 8293 prb1 = prob;; 8294 Double_t d12 = esum1-esum2;; 8295 Double_t chi2 = d12*d12/(esum1+esum2);; 8296 prb2 = TMath::Prob(chi2,1);; 8297 // see Eadie et al., section 11.6.2; 8298 if (prob > 0",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:326351,Availability,error,errors,326351,"omparison between two data sets; 8286 z = dfmax*TMath::Sqrt(esum1*esum2/(esum1+esum2));; 8287 ; 8288 prob = TMath::KolmogorovProb(z);; 8289 ; 8290 // option N to combine normalization makes sense if both afunc1 and afunc2 are false; 8291 if (opt.Contains(""N"") && !(afunc1 || afunc2 ) ) {; 8292 // Combine probabilities for shape and normalization,; 8293 prb1 = prob;; 8294 Double_t d12 = esum1-esum2;; 8295 Double_t chi2 = d12*d12/(esum1+esum2);; 8296 prb2 = TMath::Prob(chi2,1);; 8297 // see Eadie et al., section 11.6.2; 8298 if (prob > 0 && prb2 > 0) prob *= prb2*(1-TMath::Log(prob*prb2));; 8299 else prob = 0;; 8300 }; 8301 // X option. Run Pseudo-experiments to determine NULL distribution of the; 8302 // KS distance. We can find the probability from the number of pseudo-experiment that have a; 8303 // KS distance larger than the one opbserved in the data.; 8304 // We use the histogram with the largest statistics as a parent distribution for the NULL.; 8305 // Note if one histogram has zero errors is considered as a function. In that case we use it; 8306 // as parent distribution for the toys.; 8307 //; 8308 Int_t nEXPT = 1000;; 8309 if (opt.Contains(""X"")) {; 8310 // get number of pseudo-experiment of specified; 8311 if (opt.Contains(""X="")) {; 8312 int numpos = opt.Index(""X="") + 2; // 2 is length of X=; 8313 int numlen = 0;; 8314 int len = opt.Length();; 8315 while( (numpos+numlen<len) && isdigit(opt[numpos+numlen]) ); 8316 numlen++;; 8317 TString snum = opt(numpos,numlen);; 8318 int num = atoi(snum.Data());; 8319 if (num <= 0); 8320 Warning(""KolmogorovTest"",""invalid number of toys given: %d - use 1000"",num);; 8321 else; 8322 nEXPT = num;; 8323 }; 8324 ; 8325 Double_t dSEXPT;; 8326 TH1D hparent;; 8327 // we cannot have afunc1 and func2 both True; 8328 if (afunc1 || esum1 > esum2 ) h1->Copy(hparent);; 8329 else h2->Copy(hparent);; 8330 ; 8331 // copy h1Expt from h1 and h2. It is just needed to get the correct binning; 8332 ; 8333 ; 8334 if (hparent.GetMinimum() < 0.0) {",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:329486,Availability,error,error,329486,"h afunc1 and afunc2 to be true; 8364 if (afunc1); 8365 dSEXPT = hparent.KolmogorovTest(&h2Expt,""M"");; 8366 else if (afunc2); 8367 dSEXPT = hparent.KolmogorovTest(&h1Expt,""M"");; 8368 else; 8369 dSEXPT = h1Expt.KolmogorovTest(&h2Expt,""M"");; 8370 // count number of cases toy KS distance (TS) is larger than oberved one; 8371 if (dSEXPT>dfmax) prb3 += 1.0;; 8372 }; 8373 // compute p-value; 8374 prb3 /= (Double_t)nEXPT;; 8375 }; 8376 ; 8377 ; 8378 // debug printout; 8379 if (opt.Contains(""D"")) {; 8380 printf("" Kolmo Prob h1 = %s, sum bin content =%g effective entries =%g\n"",h1->GetName(),sum1,esum1);; 8381 printf("" Kolmo Prob h2 = %s, sum bin content =%g effective entries =%g\n"",h2->GetName(),sum2,esum2);; 8382 printf("" Kolmo Prob = %g, Max Dist = %g\n"",prob,dfmax);; 8383 if (opt.Contains(""N"")); 8384 printf("" Kolmo Prob = %f for shape alone, =%f for normalisation alone\n"",prb1,prb2);; 8385 if (opt.Contains(""X"")); 8386 printf("" Kolmo Prob = %f with %d pseudo-experiments\n"",prb3,nEXPT);; 8387 }; 8388 // This numerical error condition should never occur:; 8389 if (TMath::Abs(rsum1-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h1=%s\n"",h1->GetName());; 8390 if (TMath::Abs(rsum2-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h2=%s\n"",h2->GetName());; 8391 ; 8392 if(opt.Contains(""M"")) return dfmax;; 8393 else if(opt.Contains(""X"")) return prb3;; 8394 else return prob;; 8395}; 8396 ; 8397////////////////////////////////////////////////////////////////////////////////; 8398/// Replace bin contents by the contents of array content; 8399 ; 8400void TH1::SetContent(const Double_t *content); 8401{; 8402 fEntries = fNcells;; 8403 fTsumw = 0;; 8404 for (Int_t i = 0; i < fNcells; ++i) UpdateBinContent(i, content[i]);; 8405}; 8406 ; 8407////////////////////////////////////////////////////////////////////////////////; 8408/// Return contour values into array levels if pointer levels is non zero.; 8409///; 8410/// The function returns the number of contour leve",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:342915,Availability,error,errors,342915," = fXaxis.GetFirst();; 8740 Int_t xlast = fXaxis.GetLast();; 8741 Int_t yfirst = fYaxis.GetFirst();; 8742 Int_t ylast = fYaxis.GetLast();; 8743 Int_t zfirst = fZaxis.GetFirst();; 8744 Int_t zlast = fZaxis.GetLast();; 8745 min=TMath::Infinity();; 8746 max=-TMath::Infinity();; 8747 Double_t value;; 8748 for (binz=zfirst;binz<=zlast;binz++) {; 8749 for (biny=yfirst;biny<=ylast;biny++) {; 8750 for (binx=xfirst;binx<=xlast;binx++) {; 8751 bin = GetBin(binx,biny,binz);; 8752 value = RetrieveBinContent(bin);; 8753 if (value < min) min = value;; 8754 if (value > max) max = value;; 8755 }; 8756 }; 8757 }; 8758}; 8759 ; 8760////////////////////////////////////////////////////////////////////////////////; 8761/// Redefine x axis parameters.; 8762///; 8763/// The X axis parameters are modified.; 8764/// The bins content array is resized; 8765/// if errors (Sumw2) the errors array is resized; 8766/// The previous bin contents are lost; 8767/// To change only the axis limits, see TAxis::SetRange; 8768 ; 8769void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); 8770{; 8771 if (GetDimension() != 1) {; 8772 Error(""SetBins"",""Operation only valid for 1-d histograms"");; 8773 return;; 8774 }; 8775 fXaxis.SetRange(0,0);; 8776 fXaxis.Set(nx,xmin,xmax);; 8777 fYaxis.Set(1,0,1);; 8778 fZaxis.Set(1,0,1);; 8779 fNcells = nx+2;; 8780 SetBinsLength(fNcells);; 8781 if (fSumw2.fN) {; 8782 fSumw2.Set(fNcells);; 8783 }; 8784}; 8785 ; 8786////////////////////////////////////////////////////////////////////////////////; 8787/// Redefine x axis parameters with variable bin sizes.; 8788///; 8789/// The X axis parameters are modified.; 8790/// The bins content array is resized; 8791/// if errors (Sumw2) the errors array is resized; 8792/// The previous bin contents are lost; 8793/// To change only the axis limits, see TAxis::SetRange; 8794/// xBins is supposed to be of length nx+1; 8795 ; 8796void TH1::SetBins(Int_t nx, const Double_t *xBins); 8797{; 8798 if (GetDimension() != 1) {; 8799 Error(""SetB",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:342934,Availability,error,errors,342934," = fXaxis.GetFirst();; 8740 Int_t xlast = fXaxis.GetLast();; 8741 Int_t yfirst = fYaxis.GetFirst();; 8742 Int_t ylast = fYaxis.GetLast();; 8743 Int_t zfirst = fZaxis.GetFirst();; 8744 Int_t zlast = fZaxis.GetLast();; 8745 min=TMath::Infinity();; 8746 max=-TMath::Infinity();; 8747 Double_t value;; 8748 for (binz=zfirst;binz<=zlast;binz++) {; 8749 for (biny=yfirst;biny<=ylast;biny++) {; 8750 for (binx=xfirst;binx<=xlast;binx++) {; 8751 bin = GetBin(binx,biny,binz);; 8752 value = RetrieveBinContent(bin);; 8753 if (value < min) min = value;; 8754 if (value > max) max = value;; 8755 }; 8756 }; 8757 }; 8758}; 8759 ; 8760////////////////////////////////////////////////////////////////////////////////; 8761/// Redefine x axis parameters.; 8762///; 8763/// The X axis parameters are modified.; 8764/// The bins content array is resized; 8765/// if errors (Sumw2) the errors array is resized; 8766/// The previous bin contents are lost; 8767/// To change only the axis limits, see TAxis::SetRange; 8768 ; 8769void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); 8770{; 8771 if (GetDimension() != 1) {; 8772 Error(""SetBins"",""Operation only valid for 1-d histograms"");; 8773 return;; 8774 }; 8775 fXaxis.SetRange(0,0);; 8776 fXaxis.Set(nx,xmin,xmax);; 8777 fYaxis.Set(1,0,1);; 8778 fZaxis.Set(1,0,1);; 8779 fNcells = nx+2;; 8780 SetBinsLength(fNcells);; 8781 if (fSumw2.fN) {; 8782 fSumw2.Set(fNcells);; 8783 }; 8784}; 8785 ; 8786////////////////////////////////////////////////////////////////////////////////; 8787/// Redefine x axis parameters with variable bin sizes.; 8788///; 8789/// The X axis parameters are modified.; 8790/// The bins content array is resized; 8791/// if errors (Sumw2) the errors array is resized; 8792/// The previous bin contents are lost; 8793/// To change only the axis limits, see TAxis::SetRange; 8794/// xBins is supposed to be of length nx+1; 8795 ; 8796void TH1::SetBins(Int_t nx, const Double_t *xBins); 8797{; 8798 if (GetDimension() != 1) {; 8799 Error(""SetB",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:343751,Availability,error,errors,343751,"Sumw2) the errors array is resized; 8766/// The previous bin contents are lost; 8767/// To change only the axis limits, see TAxis::SetRange; 8768 ; 8769void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); 8770{; 8771 if (GetDimension() != 1) {; 8772 Error(""SetBins"",""Operation only valid for 1-d histograms"");; 8773 return;; 8774 }; 8775 fXaxis.SetRange(0,0);; 8776 fXaxis.Set(nx,xmin,xmax);; 8777 fYaxis.Set(1,0,1);; 8778 fZaxis.Set(1,0,1);; 8779 fNcells = nx+2;; 8780 SetBinsLength(fNcells);; 8781 if (fSumw2.fN) {; 8782 fSumw2.Set(fNcells);; 8783 }; 8784}; 8785 ; 8786////////////////////////////////////////////////////////////////////////////////; 8787/// Redefine x axis parameters with variable bin sizes.; 8788///; 8789/// The X axis parameters are modified.; 8790/// The bins content array is resized; 8791/// if errors (Sumw2) the errors array is resized; 8792/// The previous bin contents are lost; 8793/// To change only the axis limits, see TAxis::SetRange; 8794/// xBins is supposed to be of length nx+1; 8795 ; 8796void TH1::SetBins(Int_t nx, const Double_t *xBins); 8797{; 8798 if (GetDimension() != 1) {; 8799 Error(""SetBins"",""Operation only valid for 1-d histograms"");; 8800 return;; 8801 }; 8802 fXaxis.SetRange(0,0);; 8803 fXaxis.Set(nx,xBins);; 8804 fYaxis.Set(1,0,1);; 8805 fZaxis.Set(1,0,1);; 8806 fNcells = nx+2;; 8807 SetBinsLength(fNcells);; 8808 if (fSumw2.fN) {; 8809 fSumw2.Set(fNcells);; 8810 }; 8811}; 8812 ; 8813////////////////////////////////////////////////////////////////////////////////; 8814/// Redefine x and y axis parameters.; 8815///; 8816/// The X and Y axis parameters are modified.; 8817/// The bins content array is resized; 8818/// if errors (Sumw2) the errors array is resized; 8819/// The previous bin contents are lost; 8820/// To change only the axis limits, see TAxis::SetRange; 8821 ; 8822void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); 8823{; 8824 if (GetDimension() != 2) {; 8825 Error(""",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:343770,Availability,error,errors,343770,"Sumw2) the errors array is resized; 8766/// The previous bin contents are lost; 8767/// To change only the axis limits, see TAxis::SetRange; 8768 ; 8769void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); 8770{; 8771 if (GetDimension() != 1) {; 8772 Error(""SetBins"",""Operation only valid for 1-d histograms"");; 8773 return;; 8774 }; 8775 fXaxis.SetRange(0,0);; 8776 fXaxis.Set(nx,xmin,xmax);; 8777 fYaxis.Set(1,0,1);; 8778 fZaxis.Set(1,0,1);; 8779 fNcells = nx+2;; 8780 SetBinsLength(fNcells);; 8781 if (fSumw2.fN) {; 8782 fSumw2.Set(fNcells);; 8783 }; 8784}; 8785 ; 8786////////////////////////////////////////////////////////////////////////////////; 8787/// Redefine x axis parameters with variable bin sizes.; 8788///; 8789/// The X axis parameters are modified.; 8790/// The bins content array is resized; 8791/// if errors (Sumw2) the errors array is resized; 8792/// The previous bin contents are lost; 8793/// To change only the axis limits, see TAxis::SetRange; 8794/// xBins is supposed to be of length nx+1; 8795 ; 8796void TH1::SetBins(Int_t nx, const Double_t *xBins); 8797{; 8798 if (GetDimension() != 1) {; 8799 Error(""SetBins"",""Operation only valid for 1-d histograms"");; 8800 return;; 8801 }; 8802 fXaxis.SetRange(0,0);; 8803 fXaxis.Set(nx,xBins);; 8804 fYaxis.Set(1,0,1);; 8805 fZaxis.Set(1,0,1);; 8806 fNcells = nx+2;; 8807 SetBinsLength(fNcells);; 8808 if (fSumw2.fN) {; 8809 fSumw2.Set(fNcells);; 8810 }; 8811}; 8812 ; 8813////////////////////////////////////////////////////////////////////////////////; 8814/// Redefine x and y axis parameters.; 8815///; 8816/// The X and Y axis parameters are modified.; 8817/// The bins content array is resized; 8818/// if errors (Sumw2) the errors array is resized; 8819/// The previous bin contents are lost; 8820/// To change only the axis limits, see TAxis::SetRange; 8821 ; 8822void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); 8823{; 8824 if (GetDimension() != 2) {; 8825 Error(""",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:344612,Availability,error,errors,344612,"is resized; 8792/// The previous bin contents are lost; 8793/// To change only the axis limits, see TAxis::SetRange; 8794/// xBins is supposed to be of length nx+1; 8795 ; 8796void TH1::SetBins(Int_t nx, const Double_t *xBins); 8797{; 8798 if (GetDimension() != 1) {; 8799 Error(""SetBins"",""Operation only valid for 1-d histograms"");; 8800 return;; 8801 }; 8802 fXaxis.SetRange(0,0);; 8803 fXaxis.Set(nx,xBins);; 8804 fYaxis.Set(1,0,1);; 8805 fZaxis.Set(1,0,1);; 8806 fNcells = nx+2;; 8807 SetBinsLength(fNcells);; 8808 if (fSumw2.fN) {; 8809 fSumw2.Set(fNcells);; 8810 }; 8811}; 8812 ; 8813////////////////////////////////////////////////////////////////////////////////; 8814/// Redefine x and y axis parameters.; 8815///; 8816/// The X and Y axis parameters are modified.; 8817/// The bins content array is resized; 8818/// if errors (Sumw2) the errors array is resized; 8819/// The previous bin contents are lost; 8820/// To change only the axis limits, see TAxis::SetRange; 8821 ; 8822void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); 8823{; 8824 if (GetDimension() != 2) {; 8825 Error(""SetBins"",""Operation only valid for 2-D histograms"");; 8826 return;; 8827 }; 8828 fXaxis.SetRange(0,0);; 8829 fYaxis.SetRange(0,0);; 8830 fXaxis.Set(nx,xmin,xmax);; 8831 fYaxis.Set(ny,ymin,ymax);; 8832 fZaxis.Set(1,0,1);; 8833 fNcells = (nx+2)*(ny+2);; 8834 SetBinsLength(fNcells);; 8835 if (fSumw2.fN) {; 8836 fSumw2.Set(fNcells);; 8837 }; 8838}; 8839 ; 8840////////////////////////////////////////////////////////////////////////////////; 8841/// Redefine x and y axis parameters with variable bin sizes.; 8842///; 8843/// The X and Y axis parameters are modified.; 8844/// The bins content array is resized; 8845/// if errors (Sumw2) the errors array is resized; 8846/// The previous bin contents are lost; 8847/// To change only the axis limits, see TAxis::SetRange; 8848/// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1; 884",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:344631,Availability,error,errors,344631,"is resized; 8792/// The previous bin contents are lost; 8793/// To change only the axis limits, see TAxis::SetRange; 8794/// xBins is supposed to be of length nx+1; 8795 ; 8796void TH1::SetBins(Int_t nx, const Double_t *xBins); 8797{; 8798 if (GetDimension() != 1) {; 8799 Error(""SetBins"",""Operation only valid for 1-d histograms"");; 8800 return;; 8801 }; 8802 fXaxis.SetRange(0,0);; 8803 fXaxis.Set(nx,xBins);; 8804 fYaxis.Set(1,0,1);; 8805 fZaxis.Set(1,0,1);; 8806 fNcells = nx+2;; 8807 SetBinsLength(fNcells);; 8808 if (fSumw2.fN) {; 8809 fSumw2.Set(fNcells);; 8810 }; 8811}; 8812 ; 8813////////////////////////////////////////////////////////////////////////////////; 8814/// Redefine x and y axis parameters.; 8815///; 8816/// The X and Y axis parameters are modified.; 8817/// The bins content array is resized; 8818/// if errors (Sumw2) the errors array is resized; 8819/// The previous bin contents are lost; 8820/// To change only the axis limits, see TAxis::SetRange; 8821 ; 8822void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); 8823{; 8824 if (GetDimension() != 2) {; 8825 Error(""SetBins"",""Operation only valid for 2-D histograms"");; 8826 return;; 8827 }; 8828 fXaxis.SetRange(0,0);; 8829 fYaxis.SetRange(0,0);; 8830 fXaxis.Set(nx,xmin,xmax);; 8831 fYaxis.Set(ny,ymin,ymax);; 8832 fZaxis.Set(1,0,1);; 8833 fNcells = (nx+2)*(ny+2);; 8834 SetBinsLength(fNcells);; 8835 if (fSumw2.fN) {; 8836 fSumw2.Set(fNcells);; 8837 }; 8838}; 8839 ; 8840////////////////////////////////////////////////////////////////////////////////; 8841/// Redefine x and y axis parameters with variable bin sizes.; 8842///; 8843/// The X and Y axis parameters are modified.; 8844/// The bins content array is resized; 8845/// if errors (Sumw2) the errors array is resized; 8846/// The previous bin contents are lost; 8847/// To change only the axis limits, see TAxis::SetRange; 8848/// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1; 884",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:345544,Availability,error,errors,345544,"etRange; 8821 ; 8822void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); 8823{; 8824 if (GetDimension() != 2) {; 8825 Error(""SetBins"",""Operation only valid for 2-D histograms"");; 8826 return;; 8827 }; 8828 fXaxis.SetRange(0,0);; 8829 fYaxis.SetRange(0,0);; 8830 fXaxis.Set(nx,xmin,xmax);; 8831 fYaxis.Set(ny,ymin,ymax);; 8832 fZaxis.Set(1,0,1);; 8833 fNcells = (nx+2)*(ny+2);; 8834 SetBinsLength(fNcells);; 8835 if (fSumw2.fN) {; 8836 fSumw2.Set(fNcells);; 8837 }; 8838}; 8839 ; 8840////////////////////////////////////////////////////////////////////////////////; 8841/// Redefine x and y axis parameters with variable bin sizes.; 8842///; 8843/// The X and Y axis parameters are modified.; 8844/// The bins content array is resized; 8845/// if errors (Sumw2) the errors array is resized; 8846/// The previous bin contents are lost; 8847/// To change only the axis limits, see TAxis::SetRange; 8848/// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1; 8849 ; 8850void TH1::SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins); 8851{; 8852 if (GetDimension() != 2) {; 8853 Error(""SetBins"",""Operation only valid for 2-D histograms"");; 8854 return;; 8855 }; 8856 fXaxis.SetRange(0,0);; 8857 fYaxis.SetRange(0,0);; 8858 fXaxis.Set(nx,xBins);; 8859 fYaxis.Set(ny,yBins);; 8860 fZaxis.Set(1,0,1);; 8861 fNcells = (nx+2)*(ny+2);; 8862 SetBinsLength(fNcells);; 8863 if (fSumw2.fN) {; 8864 fSumw2.Set(fNcells);; 8865 }; 8866}; 8867 ; 8868////////////////////////////////////////////////////////////////////////////////; 8869/// Redefine x, y and z axis parameters.; 8870///; 8871/// The X, Y and Z axis parameters are modified.; 8872/// The bins content array is resized; 8873/// if errors (Sumw2) the errors array is resized; 8874/// The previous bin contents are lost; 8875/// To change only the axis limits, see TAxis::SetRange; 8876 ; 8877void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, D",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:345563,Availability,error,errors,345563,"etRange; 8821 ; 8822void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); 8823{; 8824 if (GetDimension() != 2) {; 8825 Error(""SetBins"",""Operation only valid for 2-D histograms"");; 8826 return;; 8827 }; 8828 fXaxis.SetRange(0,0);; 8829 fYaxis.SetRange(0,0);; 8830 fXaxis.Set(nx,xmin,xmax);; 8831 fYaxis.Set(ny,ymin,ymax);; 8832 fZaxis.Set(1,0,1);; 8833 fNcells = (nx+2)*(ny+2);; 8834 SetBinsLength(fNcells);; 8835 if (fSumw2.fN) {; 8836 fSumw2.Set(fNcells);; 8837 }; 8838}; 8839 ; 8840////////////////////////////////////////////////////////////////////////////////; 8841/// Redefine x and y axis parameters with variable bin sizes.; 8842///; 8843/// The X and Y axis parameters are modified.; 8844/// The bins content array is resized; 8845/// if errors (Sumw2) the errors array is resized; 8846/// The previous bin contents are lost; 8847/// To change only the axis limits, see TAxis::SetRange; 8848/// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1; 8849 ; 8850void TH1::SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins); 8851{; 8852 if (GetDimension() != 2) {; 8853 Error(""SetBins"",""Operation only valid for 2-D histograms"");; 8854 return;; 8855 }; 8856 fXaxis.SetRange(0,0);; 8857 fYaxis.SetRange(0,0);; 8858 fXaxis.Set(nx,xBins);; 8859 fYaxis.Set(ny,yBins);; 8860 fZaxis.Set(1,0,1);; 8861 fNcells = (nx+2)*(ny+2);; 8862 SetBinsLength(fNcells);; 8863 if (fSumw2.fN) {; 8864 fSumw2.Set(fNcells);; 8865 }; 8866}; 8867 ; 8868////////////////////////////////////////////////////////////////////////////////; 8869/// Redefine x, y and z axis parameters.; 8870///; 8871/// The X, Y and Z axis parameters are modified.; 8872/// The bins content array is resized; 8873/// if errors (Sumw2) the errors array is resized; 8874/// The previous bin contents are lost; 8875/// To change only the axis limits, see TAxis::SetRange; 8876 ; 8877void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, D",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:346524,Availability,error,errors,346524,"sed to be of length nx+1, yBins is supposed to be of length ny+1; 8849 ; 8850void TH1::SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins); 8851{; 8852 if (GetDimension() != 2) {; 8853 Error(""SetBins"",""Operation only valid for 2-D histograms"");; 8854 return;; 8855 }; 8856 fXaxis.SetRange(0,0);; 8857 fYaxis.SetRange(0,0);; 8858 fXaxis.Set(nx,xBins);; 8859 fYaxis.Set(ny,yBins);; 8860 fZaxis.Set(1,0,1);; 8861 fNcells = (nx+2)*(ny+2);; 8862 SetBinsLength(fNcells);; 8863 if (fSumw2.fN) {; 8864 fSumw2.Set(fNcells);; 8865 }; 8866}; 8867 ; 8868////////////////////////////////////////////////////////////////////////////////; 8869/// Redefine x, y and z axis parameters.; 8870///; 8871/// The X, Y and Z axis parameters are modified.; 8872/// The bins content array is resized; 8873/// if errors (Sumw2) the errors array is resized; 8874/// The previous bin contents are lost; 8875/// To change only the axis limits, see TAxis::SetRange; 8876 ; 8877void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); 8878{; 8879 if (GetDimension() != 3) {; 8880 Error(""SetBins"",""Operation only valid for 3-D histograms"");; 8881 return;; 8882 }; 8883 fXaxis.SetRange(0,0);; 8884 fYaxis.SetRange(0,0);; 8885 fZaxis.SetRange(0,0);; 8886 fXaxis.Set(nx,xmin,xmax);; 8887 fYaxis.Set(ny,ymin,ymax);; 8888 fZaxis.Set(nz,zmin,zmax);; 8889 fNcells = (nx+2)*(ny+2)*(nz+2);; 8890 SetBinsLength(fNcells);; 8891 if (fSumw2.fN) {; 8892 fSumw2.Set(fNcells);; 8893 }; 8894}; 8895 ; 8896////////////////////////////////////////////////////////////////////////////////; 8897/// Redefine x, y and z axis parameters with variable bin sizes.; 8898///; 8899/// The X, Y and Z axis parameters are modified.; 8900/// The bins content array is resized; 8901/// if errors (Sumw2) the errors array is resized; 8902/// The previous bin contents are lost; 8903/// To change only the axis limits, see TAxis::SetRange; 8904/// xBins is suppos",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:346543,Availability,error,errors,346543,"sed to be of length nx+1, yBins is supposed to be of length ny+1; 8849 ; 8850void TH1::SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins); 8851{; 8852 if (GetDimension() != 2) {; 8853 Error(""SetBins"",""Operation only valid for 2-D histograms"");; 8854 return;; 8855 }; 8856 fXaxis.SetRange(0,0);; 8857 fYaxis.SetRange(0,0);; 8858 fXaxis.Set(nx,xBins);; 8859 fYaxis.Set(ny,yBins);; 8860 fZaxis.Set(1,0,1);; 8861 fNcells = (nx+2)*(ny+2);; 8862 SetBinsLength(fNcells);; 8863 if (fSumw2.fN) {; 8864 fSumw2.Set(fNcells);; 8865 }; 8866}; 8867 ; 8868////////////////////////////////////////////////////////////////////////////////; 8869/// Redefine x, y and z axis parameters.; 8870///; 8871/// The X, Y and Z axis parameters are modified.; 8872/// The bins content array is resized; 8873/// if errors (Sumw2) the errors array is resized; 8874/// The previous bin contents are lost; 8875/// To change only the axis limits, see TAxis::SetRange; 8876 ; 8877void TH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); 8878{; 8879 if (GetDimension() != 3) {; 8880 Error(""SetBins"",""Operation only valid for 3-D histograms"");; 8881 return;; 8882 }; 8883 fXaxis.SetRange(0,0);; 8884 fYaxis.SetRange(0,0);; 8885 fZaxis.SetRange(0,0);; 8886 fXaxis.Set(nx,xmin,xmax);; 8887 fYaxis.Set(ny,ymin,ymax);; 8888 fZaxis.Set(nz,zmin,zmax);; 8889 fNcells = (nx+2)*(ny+2)*(nz+2);; 8890 SetBinsLength(fNcells);; 8891 if (fSumw2.fN) {; 8892 fSumw2.Set(fNcells);; 8893 }; 8894}; 8895 ; 8896////////////////////////////////////////////////////////////////////////////////; 8897/// Redefine x, y and z axis parameters with variable bin sizes.; 8898///; 8899/// The X, Y and Z axis parameters are modified.; 8900/// The bins content array is resized; 8901/// if errors (Sumw2) the errors array is resized; 8902/// The previous bin contents are lost; 8903/// To change only the axis limits, see TAxis::SetRange; 8904/// xBins is suppos",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:347544,Availability,error,errors,347544,"ouble_t zmin, Double_t zmax); 8878{; 8879 if (GetDimension() != 3) {; 8880 Error(""SetBins"",""Operation only valid for 3-D histograms"");; 8881 return;; 8882 }; 8883 fXaxis.SetRange(0,0);; 8884 fYaxis.SetRange(0,0);; 8885 fZaxis.SetRange(0,0);; 8886 fXaxis.Set(nx,xmin,xmax);; 8887 fYaxis.Set(ny,ymin,ymax);; 8888 fZaxis.Set(nz,zmin,zmax);; 8889 fNcells = (nx+2)*(ny+2)*(nz+2);; 8890 SetBinsLength(fNcells);; 8891 if (fSumw2.fN) {; 8892 fSumw2.Set(fNcells);; 8893 }; 8894}; 8895 ; 8896////////////////////////////////////////////////////////////////////////////////; 8897/// Redefine x, y and z axis parameters with variable bin sizes.; 8898///; 8899/// The X, Y and Z axis parameters are modified.; 8900/// The bins content array is resized; 8901/// if errors (Sumw2) the errors array is resized; 8902/// The previous bin contents are lost; 8903/// To change only the axis limits, see TAxis::SetRange; 8904/// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,; 8905/// zBins is supposed to be of length nz+1; 8906 ; 8907void TH1::SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins, Int_t nz, const Double_t *zBins); 8908{; 8909 if (GetDimension() != 3) {; 8910 Error(""SetBins"",""Operation only valid for 3-D histograms"");; 8911 return;; 8912 }; 8913 fXaxis.SetRange(0,0);; 8914 fYaxis.SetRange(0,0);; 8915 fZaxis.SetRange(0,0);; 8916 fXaxis.Set(nx,xBins);; 8917 fYaxis.Set(ny,yBins);; 8918 fZaxis.Set(nz,zBins);; 8919 fNcells = (nx+2)*(ny+2)*(nz+2);; 8920 SetBinsLength(fNcells);; 8921 if (fSumw2.fN) {; 8922 fSumw2.Set(fNcells);; 8923 }; 8924}; 8925 ; 8926////////////////////////////////////////////////////////////////////////////////; 8927/// By default, when a histogram is created, it is added to the list; 8928/// of histogram objects in the current directory in memory.; 8929/// Remove reference to this histogram from current directory and add; 8930/// reference to new directory dir. dir can be 0 in which case the; 8931/// histogram does not",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:347563,Availability,error,errors,347563,"ouble_t zmin, Double_t zmax); 8878{; 8879 if (GetDimension() != 3) {; 8880 Error(""SetBins"",""Operation only valid for 3-D histograms"");; 8881 return;; 8882 }; 8883 fXaxis.SetRange(0,0);; 8884 fYaxis.SetRange(0,0);; 8885 fZaxis.SetRange(0,0);; 8886 fXaxis.Set(nx,xmin,xmax);; 8887 fYaxis.Set(ny,ymin,ymax);; 8888 fZaxis.Set(nz,zmin,zmax);; 8889 fNcells = (nx+2)*(ny+2)*(nz+2);; 8890 SetBinsLength(fNcells);; 8891 if (fSumw2.fN) {; 8892 fSumw2.Set(fNcells);; 8893 }; 8894}; 8895 ; 8896////////////////////////////////////////////////////////////////////////////////; 8897/// Redefine x, y and z axis parameters with variable bin sizes.; 8898///; 8899/// The X, Y and Z axis parameters are modified.; 8900/// The bins content array is resized; 8901/// if errors (Sumw2) the errors array is resized; 8902/// The previous bin contents are lost; 8903/// To change only the axis limits, see TAxis::SetRange; 8904/// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,; 8905/// zBins is supposed to be of length nz+1; 8906 ; 8907void TH1::SetBins(Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins, Int_t nz, const Double_t *zBins); 8908{; 8909 if (GetDimension() != 3) {; 8910 Error(""SetBins"",""Operation only valid for 3-D histograms"");; 8911 return;; 8912 }; 8913 fXaxis.SetRange(0,0);; 8914 fYaxis.SetRange(0,0);; 8915 fZaxis.SetRange(0,0);; 8916 fXaxis.Set(nx,xBins);; 8917 fYaxis.Set(ny,yBins);; 8918 fZaxis.Set(nz,zBins);; 8919 fNcells = (nx+2)*(ny+2)*(nz+2);; 8920 SetBinsLength(fNcells);; 8921 if (fSumw2.fN) {; 8922 fSumw2.Set(fNcells);; 8923 }; 8924}; 8925 ; 8926////////////////////////////////////////////////////////////////////////////////; 8927/// By default, when a histogram is created, it is added to the list; 8928/// of histogram objects in the current directory in memory.; 8929/// Remove reference to this histogram from current directory and add; 8930/// reference to new directory dir. dir can be 0 in which case the; 8931/// histogram does not",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:349547,Availability,error,errors,349547,"(ny+2)*(nz+2);; 8920 SetBinsLength(fNcells);; 8921 if (fSumw2.fN) {; 8922 fSumw2.Set(fNcells);; 8923 }; 8924}; 8925 ; 8926////////////////////////////////////////////////////////////////////////////////; 8927/// By default, when a histogram is created, it is added to the list; 8928/// of histogram objects in the current directory in memory.; 8929/// Remove reference to this histogram from current directory and add; 8930/// reference to new directory dir. dir can be 0 in which case the; 8931/// histogram does not belong to any directory.; 8932///; 8933/// Note that the directory is not a real property of the histogram and; 8934/// it will not be copied when the histogram is copied or cloned.; 8935/// If the user wants to have the copied (cloned) histogram in the same; 8936/// directory, he needs to set again the directory using SetDirectory to the; 8937/// copied histograms; 8938 ; 8939void TH1::SetDirectory(TDirectory *dir); 8940{; 8941 if (fDirectory == dir) return;; 8942 if (fDirectory) fDirectory->Remove(this);; 8943 fDirectory = dir;; 8944 if (fDirectory) {; 8945 fFunctions->UseRWLock();; 8946 fDirectory->Append(this);; 8947 }; 8948}; 8949 ; 8950////////////////////////////////////////////////////////////////////////////////; 8951/// Replace bin errors by values in array error.; 8952 ; 8953void TH1::SetError(const Double_t *error); 8954{; 8955 for (Int_t i = 0; i < fNcells; ++i) SetBinError(i, error[i]);; 8956}; 8957 ; 8958////////////////////////////////////////////////////////////////////////////////; 8959/// Change the name of this histogram; 8960///; 8961 ; 8962void TH1::SetName(const char *name); 8963{; 8964 // Histograms are named objects in a THashList.; 8965 // We must update the hashlist if we change the name; 8966 // We protect this operation; 8967 R__LOCKGUARD(gROOTMutex);; 8968 if (fDirectory) fDirectory->Remove(this);; 8969 fName = name;; 8970 if (fDirectory) fDirectory->Append(this);; 8971}; 8972 ; 8973///////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:349573,Availability,error,error,349573,"(ny+2)*(nz+2);; 8920 SetBinsLength(fNcells);; 8921 if (fSumw2.fN) {; 8922 fSumw2.Set(fNcells);; 8923 }; 8924}; 8925 ; 8926////////////////////////////////////////////////////////////////////////////////; 8927/// By default, when a histogram is created, it is added to the list; 8928/// of histogram objects in the current directory in memory.; 8929/// Remove reference to this histogram from current directory and add; 8930/// reference to new directory dir. dir can be 0 in which case the; 8931/// histogram does not belong to any directory.; 8932///; 8933/// Note that the directory is not a real property of the histogram and; 8934/// it will not be copied when the histogram is copied or cloned.; 8935/// If the user wants to have the copied (cloned) histogram in the same; 8936/// directory, he needs to set again the directory using SetDirectory to the; 8937/// copied histograms; 8938 ; 8939void TH1::SetDirectory(TDirectory *dir); 8940{; 8941 if (fDirectory == dir) return;; 8942 if (fDirectory) fDirectory->Remove(this);; 8943 fDirectory = dir;; 8944 if (fDirectory) {; 8945 fFunctions->UseRWLock();; 8946 fDirectory->Append(this);; 8947 }; 8948}; 8949 ; 8950////////////////////////////////////////////////////////////////////////////////; 8951/// Replace bin errors by values in array error.; 8952 ; 8953void TH1::SetError(const Double_t *error); 8954{; 8955 for (Int_t i = 0; i < fNcells; ++i) SetBinError(i, error[i]);; 8956}; 8957 ; 8958////////////////////////////////////////////////////////////////////////////////; 8959/// Change the name of this histogram; 8960///; 8961 ; 8962void TH1::SetName(const char *name); 8963{; 8964 // Histograms are named objects in a THashList.; 8965 // We must update the hashlist if we change the name; 8966 // We protect this operation; 8967 R__LOCKGUARD(gROOTMutex);; 8968 if (fDirectory) fDirectory->Remove(this);; 8969 fName = name;; 8970 if (fDirectory) fDirectory->Append(this);; 8971}; 8972 ; 8973///////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:349627,Availability,error,error,349627,"/ histogram does not belong to any directory.; 8932///; 8933/// Note that the directory is not a real property of the histogram and; 8934/// it will not be copied when the histogram is copied or cloned.; 8935/// If the user wants to have the copied (cloned) histogram in the same; 8936/// directory, he needs to set again the directory using SetDirectory to the; 8937/// copied histograms; 8938 ; 8939void TH1::SetDirectory(TDirectory *dir); 8940{; 8941 if (fDirectory == dir) return;; 8942 if (fDirectory) fDirectory->Remove(this);; 8943 fDirectory = dir;; 8944 if (fDirectory) {; 8945 fFunctions->UseRWLock();; 8946 fDirectory->Append(this);; 8947 }; 8948}; 8949 ; 8950////////////////////////////////////////////////////////////////////////////////; 8951/// Replace bin errors by values in array error.; 8952 ; 8953void TH1::SetError(const Double_t *error); 8954{; 8955 for (Int_t i = 0; i < fNcells; ++i) SetBinError(i, error[i]);; 8956}; 8957 ; 8958////////////////////////////////////////////////////////////////////////////////; 8959/// Change the name of this histogram; 8960///; 8961 ; 8962void TH1::SetName(const char *name); 8963{; 8964 // Histograms are named objects in a THashList.; 8965 // We must update the hashlist if we change the name; 8966 // We protect this operation; 8967 R__LOCKGUARD(gROOTMutex);; 8968 if (fDirectory) fDirectory->Remove(this);; 8969 fName = name;; 8970 if (fDirectory) fDirectory->Append(this);; 8971}; 8972 ; 8973////////////////////////////////////////////////////////////////////////////////; 8974/// Change the name and title of this histogram; 8975 ; 8976void TH1::SetNameTitle(const char *name, const char *title); 8977{; 8978 // Histograms are named objects in a THashList.; 8979 // We must update the hashlist if we change the name; 8980 SetName(name);; 8981 SetTitle(title);; 8982}; 8983 ; 8984////////////////////////////////////////////////////////////////////////////////; 8985/// Set statistics option on/off.; 8986///; 8987/// By default, the ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:349698,Availability,error,error,349698,"/ histogram does not belong to any directory.; 8932///; 8933/// Note that the directory is not a real property of the histogram and; 8934/// it will not be copied when the histogram is copied or cloned.; 8935/// If the user wants to have the copied (cloned) histogram in the same; 8936/// directory, he needs to set again the directory using SetDirectory to the; 8937/// copied histograms; 8938 ; 8939void TH1::SetDirectory(TDirectory *dir); 8940{; 8941 if (fDirectory == dir) return;; 8942 if (fDirectory) fDirectory->Remove(this);; 8943 fDirectory = dir;; 8944 if (fDirectory) {; 8945 fFunctions->UseRWLock();; 8946 fDirectory->Append(this);; 8947 }; 8948}; 8949 ; 8950////////////////////////////////////////////////////////////////////////////////; 8951/// Replace bin errors by values in array error.; 8952 ; 8953void TH1::SetError(const Double_t *error); 8954{; 8955 for (Int_t i = 0; i < fNcells; ++i) SetBinError(i, error[i]);; 8956}; 8957 ; 8958////////////////////////////////////////////////////////////////////////////////; 8959/// Change the name of this histogram; 8960///; 8961 ; 8962void TH1::SetName(const char *name); 8963{; 8964 // Histograms are named objects in a THashList.; 8965 // We must update the hashlist if we change the name; 8966 // We protect this operation; 8967 R__LOCKGUARD(gROOTMutex);; 8968 if (fDirectory) fDirectory->Remove(this);; 8969 fName = name;; 8970 if (fDirectory) fDirectory->Append(this);; 8971}; 8972 ; 8973////////////////////////////////////////////////////////////////////////////////; 8974/// Change the name and title of this histogram; 8975 ; 8976void TH1::SetNameTitle(const char *name, const char *title); 8977{; 8978 // Histograms are named objects in a THashList.; 8979 // We must update the hashlist if we change the name; 8980 SetName(name);; 8981 SetTitle(title);; 8982}; 8983 ; 8984////////////////////////////////////////////////////////////////////////////////; 8985/// Set statistics option on/off.; 8986///; 8987/// By default, the ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:351656,Availability,error,error,351656,"/////////////////////////////////////////////////////////////////////////////; 8985/// Set statistics option on/off.; 8986///; 8987/// By default, the statistics box is drawn.; 8988/// The paint options can be selected via gStyle->SetOptStat.; 8989/// This function sets/resets the kNoStats bit in the histogram object.; 8990/// It has priority over the Style option.; 8991 ; 8992void TH1::SetStats(Bool_t stats); 8993{; 8994 ResetBit(kNoStats);; 8995 if (!stats) {; 8996 SetBit(kNoStats);; 8997 //remove the ""stats"" object from the list of functions; 8998 if (fFunctions) {; 8999 TObject *obj = fFunctions->FindObject(""stats"");; 9000 if (obj) {; 9001 fFunctions->Remove(obj);; 9002 delete obj;; 9003 }; 9004 }; 9005 }; 9006}; 9007 ; 9008////////////////////////////////////////////////////////////////////////////////; 9009/// Create structure to store sum of squares of weights.; 9010///; 9011/// if histogram is already filled, the sum of squares of weights; 9012/// is filled with the existing bin contents; 9013///; 9014/// The error per bin will be computed as sqrt(sum of squares of weight); 9015/// for each bin.; 9016///; 9017/// This function is automatically called when the histogram is created; 9018/// if the static function TH1::SetDefaultSumw2 has been called before.; 9019/// If flag = false the structure containing the sum of the square of weights; 9020/// is rest and it will be empty, but it is not deleted (i.e. GetSumw2()->fN = 0); 9021 ; 9022void TH1::Sumw2(Bool_t flag); 9023{; 9024 if (!flag) {; 9025 // clear the array if existing - do nothing otherwise; 9026 if (fSumw2.fN > 0 ) fSumw2.Set(0);; 9027 return;; 9028 }; 9029 ; 9030 if (fSumw2.fN == fNcells) {; 9031 if (!fgDefaultSumw2 ); 9032 Warning(""Sumw2"",""Sum of squares of weights structure already created"");; 9033 return;; 9034 }; 9035 ; 9036 fSumw2.Set(fNcells);; 9037 ; 9038 // empty the buffer; 9039 if (fBuffer) BufferEmpty();; 9040 ; 9041 if (fEntries > 0); 9042 for (Int_t i = 0; i < fNcells; ++i); 9043 fSumw2.",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:353189,Availability,error,error,353189,"022void TH1::Sumw2(Bool_t flag); 9023{; 9024 if (!flag) {; 9025 // clear the array if existing - do nothing otherwise; 9026 if (fSumw2.fN > 0 ) fSumw2.Set(0);; 9027 return;; 9028 }; 9029 ; 9030 if (fSumw2.fN == fNcells) {; 9031 if (!fgDefaultSumw2 ); 9032 Warning(""Sumw2"",""Sum of squares of weights structure already created"");; 9033 return;; 9034 }; 9035 ; 9036 fSumw2.Set(fNcells);; 9037 ; 9038 // empty the buffer; 9039 if (fBuffer) BufferEmpty();; 9040 ; 9041 if (fEntries > 0); 9042 for (Int_t i = 0; i < fNcells; ++i); 9043 fSumw2.fArray[i] = TMath::Abs(RetrieveBinContent(i));; 9044}; 9045 ; 9046////////////////////////////////////////////////////////////////////////////////; 9047/// Return pointer to function with name.; 9048///; 9049///; 9050/// Functions such as TH1::Fit store the fitted function in the list of; 9051/// functions of this histogram.; 9052 ; 9053TF1 *TH1::GetFunction(const char *name) const; 9054{; 9055 return (TF1*)fFunctions->FindObject(name);; 9056}; 9057 ; 9058////////////////////////////////////////////////////////////////////////////////; 9059/// Return value of error associated to bin number bin.; 9060///; 9061/// if the sum of squares of weights has been defined (via Sumw2),; 9062/// this function returns the sqrt(sum of w2).; 9063/// otherwise it returns the sqrt(contents) for this bin.; 9064 ; 9065Double_t TH1::GetBinError(Int_t bin) const; 9066{; 9067 if (bin < 0) bin = 0;; 9068 if (bin >= fNcells) bin = fNcells-1;; 9069 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9070 if (fSumw2.fN) return TMath::Sqrt(fSumw2.fArray[bin]);; 9071 ; 9072 return TMath::Sqrt(TMath::Abs(RetrieveBinContent(bin)));; 9073}; 9074 ; 9075////////////////////////////////////////////////////////////////////////////////; 9076/// Return lower error associated to bin number bin.; 9077///; 9078/// The error will depend on the statistic option used will return; 9079/// the binContent - lower interval value; 9080 ; 9081Double_t TH1::GetBinErrorLow(Int_t bin) const; 9082{; 90",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:353855,Availability,error,error,353855,"; 9047/// Return pointer to function with name.; 9048///; 9049///; 9050/// Functions such as TH1::Fit store the fitted function in the list of; 9051/// functions of this histogram.; 9052 ; 9053TF1 *TH1::GetFunction(const char *name) const; 9054{; 9055 return (TF1*)fFunctions->FindObject(name);; 9056}; 9057 ; 9058////////////////////////////////////////////////////////////////////////////////; 9059/// Return value of error associated to bin number bin.; 9060///; 9061/// if the sum of squares of weights has been defined (via Sumw2),; 9062/// this function returns the sqrt(sum of w2).; 9063/// otherwise it returns the sqrt(contents) for this bin.; 9064 ; 9065Double_t TH1::GetBinError(Int_t bin) const; 9066{; 9067 if (bin < 0) bin = 0;; 9068 if (bin >= fNcells) bin = fNcells-1;; 9069 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9070 if (fSumw2.fN) return TMath::Sqrt(fSumw2.fArray[bin]);; 9071 ; 9072 return TMath::Sqrt(TMath::Abs(RetrieveBinContent(bin)));; 9073}; 9074 ; 9075////////////////////////////////////////////////////////////////////////////////; 9076/// Return lower error associated to bin number bin.; 9077///; 9078/// The error will depend on the statistic option used will return; 9079/// the binContent - lower interval value; 9080 ; 9081Double_t TH1::GetBinErrorLow(Int_t bin) const; 9082{; 9083 if (fBinStatErrOpt == kNormal) return GetBinError(bin);; 9084 // in case of weighted histogram check if it is really weighted; 9085 if (fSumw2.fN && fTsumw != fTsumw2) return GetBinError(bin);; 9086 ; 9087 if (bin < 0) bin = 0;; 9088 if (bin >= fNcells) bin = fNcells-1;; 9089 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9090 ; 9091 Double_t alpha = 1.- 0.682689492;; 9092 if (fBinStatErrOpt == kPoisson2) alpha = 0.05;; 9093 ; 9094 Double_t c = RetrieveBinContent(bin);; 9095 Int_t n = int(c);; 9096 if (n < 0) {; 9097 Warning(""GetBinErrorLow"",""Histogram has negative bin content-force usage to normal errors"");; 9098 ((TH1*)this)->fBinStatErrOpt = kNormal;; 9099 return GetBinErr",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:353913,Availability,error,error,353913,");; 9056}; 9057 ; 9058////////////////////////////////////////////////////////////////////////////////; 9059/// Return value of error associated to bin number bin.; 9060///; 9061/// if the sum of squares of weights has been defined (via Sumw2),; 9062/// this function returns the sqrt(sum of w2).; 9063/// otherwise it returns the sqrt(contents) for this bin.; 9064 ; 9065Double_t TH1::GetBinError(Int_t bin) const; 9066{; 9067 if (bin < 0) bin = 0;; 9068 if (bin >= fNcells) bin = fNcells-1;; 9069 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9070 if (fSumw2.fN) return TMath::Sqrt(fSumw2.fArray[bin]);; 9071 ; 9072 return TMath::Sqrt(TMath::Abs(RetrieveBinContent(bin)));; 9073}; 9074 ; 9075////////////////////////////////////////////////////////////////////////////////; 9076/// Return lower error associated to bin number bin.; 9077///; 9078/// The error will depend on the statistic option used will return; 9079/// the binContent - lower interval value; 9080 ; 9081Double_t TH1::GetBinErrorLow(Int_t bin) const; 9082{; 9083 if (fBinStatErrOpt == kNormal) return GetBinError(bin);; 9084 // in case of weighted histogram check if it is really weighted; 9085 if (fSumw2.fN && fTsumw != fTsumw2) return GetBinError(bin);; 9086 ; 9087 if (bin < 0) bin = 0;; 9088 if (bin >= fNcells) bin = fNcells-1;; 9089 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9090 ; 9091 Double_t alpha = 1.- 0.682689492;; 9092 if (fBinStatErrOpt == kPoisson2) alpha = 0.05;; 9093 ; 9094 Double_t c = RetrieveBinContent(bin);; 9095 Int_t n = int(c);; 9096 if (n < 0) {; 9097 Warning(""GetBinErrorLow"",""Histogram has negative bin content-force usage to normal errors"");; 9098 ((TH1*)this)->fBinStatErrOpt = kNormal;; 9099 return GetBinError(bin);; 9100 }; 9101 ; 9102 if (n == 0) return 0;; 9103 return c - ROOT::Math::gamma_quantile( alpha/2, n, 1.);; 9104}; 9105 ; 9106////////////////////////////////////////////////////////////////////////////////; 9107/// Return upper error associated to bin number bin.; 9108///; 9109/// Th",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:354692,Availability,error,errors,354692,"t(TMath::Abs(RetrieveBinContent(bin)));; 9073}; 9074 ; 9075////////////////////////////////////////////////////////////////////////////////; 9076/// Return lower error associated to bin number bin.; 9077///; 9078/// The error will depend on the statistic option used will return; 9079/// the binContent - lower interval value; 9080 ; 9081Double_t TH1::GetBinErrorLow(Int_t bin) const; 9082{; 9083 if (fBinStatErrOpt == kNormal) return GetBinError(bin);; 9084 // in case of weighted histogram check if it is really weighted; 9085 if (fSumw2.fN && fTsumw != fTsumw2) return GetBinError(bin);; 9086 ; 9087 if (bin < 0) bin = 0;; 9088 if (bin >= fNcells) bin = fNcells-1;; 9089 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9090 ; 9091 Double_t alpha = 1.- 0.682689492;; 9092 if (fBinStatErrOpt == kPoisson2) alpha = 0.05;; 9093 ; 9094 Double_t c = RetrieveBinContent(bin);; 9095 Int_t n = int(c);; 9096 if (n < 0) {; 9097 Warning(""GetBinErrorLow"",""Histogram has negative bin content-force usage to normal errors"");; 9098 ((TH1*)this)->fBinStatErrOpt = kNormal;; 9099 return GetBinError(bin);; 9100 }; 9101 ; 9102 if (n == 0) return 0;; 9103 return c - ROOT::Math::gamma_quantile( alpha/2, n, 1.);; 9104}; 9105 ; 9106////////////////////////////////////////////////////////////////////////////////; 9107/// Return upper error associated to bin number bin.; 9108///; 9109/// The error will depend on the statistic option used will return; 9110/// the binContent - upper interval value; 9111 ; 9112Double_t TH1::GetBinErrorUp(Int_t bin) const; 9113{; 9114 if (fBinStatErrOpt == kNormal) return GetBinError(bin);; 9115 // in case of weighted histogram check if it is really weighted; 9116 if (fSumw2.fN && fTsumw != fTsumw2) return GetBinError(bin);; 9117 if (bin < 0) bin = 0;; 9118 if (bin >= fNcells) bin = fNcells-1;; 9119 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9120 ; 9121 Double_t alpha = 1.- 0.682689492;; 9122 if (fBinStatErrOpt == kPoisson2) alpha = 0.05;; 9123 ; 9124 Double_t c = RetrieveBinCont",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:355006,Availability,error,error,355006,"ill return; 9079/// the binContent - lower interval value; 9080 ; 9081Double_t TH1::GetBinErrorLow(Int_t bin) const; 9082{; 9083 if (fBinStatErrOpt == kNormal) return GetBinError(bin);; 9084 // in case of weighted histogram check if it is really weighted; 9085 if (fSumw2.fN && fTsumw != fTsumw2) return GetBinError(bin);; 9086 ; 9087 if (bin < 0) bin = 0;; 9088 if (bin >= fNcells) bin = fNcells-1;; 9089 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9090 ; 9091 Double_t alpha = 1.- 0.682689492;; 9092 if (fBinStatErrOpt == kPoisson2) alpha = 0.05;; 9093 ; 9094 Double_t c = RetrieveBinContent(bin);; 9095 Int_t n = int(c);; 9096 if (n < 0) {; 9097 Warning(""GetBinErrorLow"",""Histogram has negative bin content-force usage to normal errors"");; 9098 ((TH1*)this)->fBinStatErrOpt = kNormal;; 9099 return GetBinError(bin);; 9100 }; 9101 ; 9102 if (n == 0) return 0;; 9103 return c - ROOT::Math::gamma_quantile( alpha/2, n, 1.);; 9104}; 9105 ; 9106////////////////////////////////////////////////////////////////////////////////; 9107/// Return upper error associated to bin number bin.; 9108///; 9109/// The error will depend on the statistic option used will return; 9110/// the binContent - upper interval value; 9111 ; 9112Double_t TH1::GetBinErrorUp(Int_t bin) const; 9113{; 9114 if (fBinStatErrOpt == kNormal) return GetBinError(bin);; 9115 // in case of weighted histogram check if it is really weighted; 9116 if (fSumw2.fN && fTsumw != fTsumw2) return GetBinError(bin);; 9117 if (bin < 0) bin = 0;; 9118 if (bin >= fNcells) bin = fNcells-1;; 9119 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9120 ; 9121 Double_t alpha = 1.- 0.682689492;; 9122 if (fBinStatErrOpt == kPoisson2) alpha = 0.05;; 9123 ; 9124 Double_t c = RetrieveBinContent(bin);; 9125 Int_t n = int(c);; 9126 if (n < 0) {; 9127 Warning(""GetBinErrorUp"",""Histogram has negative bin content-force usage to normal errors"");; 9128 ((TH1*)this)->fBinStatErrOpt = kNormal;; 9129 return GetBinError(bin);; 9130 }; 9131 ; 9132 // for N==0 return ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:355064,Availability,error,error,355064,"ted; 9085 if (fSumw2.fN && fTsumw != fTsumw2) return GetBinError(bin);; 9086 ; 9087 if (bin < 0) bin = 0;; 9088 if (bin >= fNcells) bin = fNcells-1;; 9089 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9090 ; 9091 Double_t alpha = 1.- 0.682689492;; 9092 if (fBinStatErrOpt == kPoisson2) alpha = 0.05;; 9093 ; 9094 Double_t c = RetrieveBinContent(bin);; 9095 Int_t n = int(c);; 9096 if (n < 0) {; 9097 Warning(""GetBinErrorLow"",""Histogram has negative bin content-force usage to normal errors"");; 9098 ((TH1*)this)->fBinStatErrOpt = kNormal;; 9099 return GetBinError(bin);; 9100 }; 9101 ; 9102 if (n == 0) return 0;; 9103 return c - ROOT::Math::gamma_quantile( alpha/2, n, 1.);; 9104}; 9105 ; 9106////////////////////////////////////////////////////////////////////////////////; 9107/// Return upper error associated to bin number bin.; 9108///; 9109/// The error will depend on the statistic option used will return; 9110/// the binContent - upper interval value; 9111 ; 9112Double_t TH1::GetBinErrorUp(Int_t bin) const; 9113{; 9114 if (fBinStatErrOpt == kNormal) return GetBinError(bin);; 9115 // in case of weighted histogram check if it is really weighted; 9116 if (fSumw2.fN && fTsumw != fTsumw2) return GetBinError(bin);; 9117 if (bin < 0) bin = 0;; 9118 if (bin >= fNcells) bin = fNcells-1;; 9119 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9120 ; 9121 Double_t alpha = 1.- 0.682689492;; 9122 if (fBinStatErrOpt == kPoisson2) alpha = 0.05;; 9123 ; 9124 Double_t c = RetrieveBinContent(bin);; 9125 Int_t n = int(c);; 9126 if (n < 0) {; 9127 Warning(""GetBinErrorUp"",""Histogram has negative bin content-force usage to normal errors"");; 9128 ((TH1*)this)->fBinStatErrOpt = kNormal;; 9129 return GetBinError(bin);; 9130 }; 9131 ; 9132 // for N==0 return an upper limit at 0.68 or (1-alpha)/2 ?; 9133 // decide to return always (1-alpha)/2 upper interval; 9134 //if (n == 0) return ROOT::Math::gamma_quantile_c(alpha,n+1,1);; 9135 return ROOT::Math::gamma_quantile_c( alpha/2, n+1, 1) - c;; 9136}; 9137 ; 9",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:355834,Availability,error,errors,355834,"turn 0;; 9103 return c - ROOT::Math::gamma_quantile( alpha/2, n, 1.);; 9104}; 9105 ; 9106////////////////////////////////////////////////////////////////////////////////; 9107/// Return upper error associated to bin number bin.; 9108///; 9109/// The error will depend on the statistic option used will return; 9110/// the binContent - upper interval value; 9111 ; 9112Double_t TH1::GetBinErrorUp(Int_t bin) const; 9113{; 9114 if (fBinStatErrOpt == kNormal) return GetBinError(bin);; 9115 // in case of weighted histogram check if it is really weighted; 9116 if (fSumw2.fN && fTsumw != fTsumw2) return GetBinError(bin);; 9117 if (bin < 0) bin = 0;; 9118 if (bin >= fNcells) bin = fNcells-1;; 9119 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9120 ; 9121 Double_t alpha = 1.- 0.682689492;; 9122 if (fBinStatErrOpt == kPoisson2) alpha = 0.05;; 9123 ; 9124 Double_t c = RetrieveBinContent(bin);; 9125 Int_t n = int(c);; 9126 if (n < 0) {; 9127 Warning(""GetBinErrorUp"",""Histogram has negative bin content-force usage to normal errors"");; 9128 ((TH1*)this)->fBinStatErrOpt = kNormal;; 9129 return GetBinError(bin);; 9130 }; 9131 ; 9132 // for N==0 return an upper limit at 0.68 or (1-alpha)/2 ?; 9133 // decide to return always (1-alpha)/2 upper interval; 9134 //if (n == 0) return ROOT::Math::gamma_quantile_c(alpha,n+1,1);; 9135 return ROOT::Math::gamma_quantile_c( alpha/2, n+1, 1) - c;; 9136}; 9137 ; 9138//L.M. These following getters are useless and should be probably deprecated; 9139////////////////////////////////////////////////////////////////////////////////; 9140/// Return bin center for 1D histogram.; 9141/// Better to use h1.GetXaxis()->GetBinCenter(bin); 9142 ; 9143Double_t TH1::GetBinCenter(Int_t bin) const; 9144{; 9145 if (fDimension == 1) return fXaxis.GetBinCenter(bin);; 9146 Error(""GetBinCenter"",""Invalid method for a %d-d histogram - return a NaN"",fDimension);; 9147 return TMath::QuietNaN();; 9148}; 9149 ; 9150/////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:358740,Availability,error,error,358740,"ion);; 9169 return TMath::QuietNaN();; 9170}; 9171 ; 9172////////////////////////////////////////////////////////////////////////////////; 9173/// Fill array with center of bins for 1D histogram; 9174/// Better to use h1.GetXaxis()->GetCenter(center); 9175 ; 9176void TH1::GetCenter(Double_t *center) const; 9177{; 9178 if (fDimension == 1) {; 9179 fXaxis.GetCenter(center);; 9180 return;; 9181 }; 9182 Error(""GetCenter"",""Invalid method for a %d-d histogram "",fDimension);; 9183}; 9184 ; 9185////////////////////////////////////////////////////////////////////////////////; 9186/// Fill array with low edge of bins for 1D histogram; 9187/// Better to use h1.GetXaxis()->GetLowEdge(edge); 9188 ; 9189void TH1::GetLowEdge(Double_t *edge) const; 9190{; 9191 if (fDimension == 1) {; 9192 fXaxis.GetLowEdge(edge);; 9193 return;; 9194 }; 9195 Error(""GetLowEdge"",""Invalid method for a %d-d histogram "",fDimension);; 9196}; 9197 ; 9198////////////////////////////////////////////////////////////////////////////////; 9199/// Set the bin Error; 9200/// Note that this resets the bin eror option to be of Normal Type and for the; 9201/// non-empty bin the bin error is set by default to the square root of their content.; 9202/// Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent); 9203/// he needs then to provide also the corresponding bin error (using SetBinError) since the bin error; 9204/// will not be recalculated after setting the content and a default error = 0 will be used for those bins.; 9205///; 9206/// See convention for numbering bins in TH1::GetBin; 9207 ; 9208void TH1::SetBinError(Int_t bin, Double_t error); 9209{; 9210 if (bin < 0 || bin>= fNcells) return;; 9211 if (!fSumw2.fN) Sumw2();; 9212 fSumw2.fArray[bin] = error * error;; 9213 // reset the bin error option; 9214 SetBinErrorOption(kNormal);; 9215}; 9216 ; 9217////////////////////////////////////////////////////////////////////////////////; 9218/// Set bin content;",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:358985,Availability,error,error,358985,"thod for a %d-d histogram "",fDimension);; 9183}; 9184 ; 9185////////////////////////////////////////////////////////////////////////////////; 9186/// Fill array with low edge of bins for 1D histogram; 9187/// Better to use h1.GetXaxis()->GetLowEdge(edge); 9188 ; 9189void TH1::GetLowEdge(Double_t *edge) const; 9190{; 9191 if (fDimension == 1) {; 9192 fXaxis.GetLowEdge(edge);; 9193 return;; 9194 }; 9195 Error(""GetLowEdge"",""Invalid method for a %d-d histogram "",fDimension);; 9196}; 9197 ; 9198////////////////////////////////////////////////////////////////////////////////; 9199/// Set the bin Error; 9200/// Note that this resets the bin eror option to be of Normal Type and for the; 9201/// non-empty bin the bin error is set by default to the square root of their content.; 9202/// Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent); 9203/// he needs then to provide also the corresponding bin error (using SetBinError) since the bin error; 9204/// will not be recalculated after setting the content and a default error = 0 will be used for those bins.; 9205///; 9206/// See convention for numbering bins in TH1::GetBin; 9207 ; 9208void TH1::SetBinError(Int_t bin, Double_t error); 9209{; 9210 if (bin < 0 || bin>= fNcells) return;; 9211 if (!fSumw2.fN) Sumw2();; 9212 fSumw2.fArray[bin] = error * error;; 9213 // reset the bin error option; 9214 SetBinErrorOption(kNormal);; 9215}; 9216 ; 9217////////////////////////////////////////////////////////////////////////////////; 9218/// Set bin content; 9219/// see convention for numbering bins in TH1::GetBin; 9220/// In case the bin number is greater than the number of bins and; 9221/// the timedisplay option is set or CanExtendAllAxes(),; 9222/// the number of bins is automatically doubled to accommodate the new bin; 9223 ; 9224void TH1::SetBinContent(Int_t bin, Double_t content); 9225{; 9226 fEntries++;; 9227 fTsumw = 0;; 9228 if (bin < 0) return;; 9229 if (bin >= fNcells-1",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:359025,Availability,error,error,359025,"thod for a %d-d histogram "",fDimension);; 9183}; 9184 ; 9185////////////////////////////////////////////////////////////////////////////////; 9186/// Fill array with low edge of bins for 1D histogram; 9187/// Better to use h1.GetXaxis()->GetLowEdge(edge); 9188 ; 9189void TH1::GetLowEdge(Double_t *edge) const; 9190{; 9191 if (fDimension == 1) {; 9192 fXaxis.GetLowEdge(edge);; 9193 return;; 9194 }; 9195 Error(""GetLowEdge"",""Invalid method for a %d-d histogram "",fDimension);; 9196}; 9197 ; 9198////////////////////////////////////////////////////////////////////////////////; 9199/// Set the bin Error; 9200/// Note that this resets the bin eror option to be of Normal Type and for the; 9201/// non-empty bin the bin error is set by default to the square root of their content.; 9202/// Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent); 9203/// he needs then to provide also the corresponding bin error (using SetBinError) since the bin error; 9204/// will not be recalculated after setting the content and a default error = 0 will be used for those bins.; 9205///; 9206/// See convention for numbering bins in TH1::GetBin; 9207 ; 9208void TH1::SetBinError(Int_t bin, Double_t error); 9209{; 9210 if (bin < 0 || bin>= fNcells) return;; 9211 if (!fSumw2.fN) Sumw2();; 9212 fSumw2.fArray[bin] = error * error;; 9213 // reset the bin error option; 9214 SetBinErrorOption(kNormal);; 9215}; 9216 ; 9217////////////////////////////////////////////////////////////////////////////////; 9218/// Set bin content; 9219/// see convention for numbering bins in TH1::GetBin; 9220/// In case the bin number is greater than the number of bins and; 9221/// the timedisplay option is set or CanExtendAllAxes(),; 9222/// the number of bins is automatically doubled to accommodate the new bin; 9223 ; 9224void TH1::SetBinContent(Int_t bin, Double_t content); 9225{; 9226 fEntries++;; 9227 fTsumw = 0;; 9228 if (bin < 0) return;; 9229 if (bin >= fNcells-1",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:359105,Availability,error,error,359105,"thod for a %d-d histogram "",fDimension);; 9183}; 9184 ; 9185////////////////////////////////////////////////////////////////////////////////; 9186/// Fill array with low edge of bins for 1D histogram; 9187/// Better to use h1.GetXaxis()->GetLowEdge(edge); 9188 ; 9189void TH1::GetLowEdge(Double_t *edge) const; 9190{; 9191 if (fDimension == 1) {; 9192 fXaxis.GetLowEdge(edge);; 9193 return;; 9194 }; 9195 Error(""GetLowEdge"",""Invalid method for a %d-d histogram "",fDimension);; 9196}; 9197 ; 9198////////////////////////////////////////////////////////////////////////////////; 9199/// Set the bin Error; 9200/// Note that this resets the bin eror option to be of Normal Type and for the; 9201/// non-empty bin the bin error is set by default to the square root of their content.; 9202/// Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent); 9203/// he needs then to provide also the corresponding bin error (using SetBinError) since the bin error; 9204/// will not be recalculated after setting the content and a default error = 0 will be used for those bins.; 9205///; 9206/// See convention for numbering bins in TH1::GetBin; 9207 ; 9208void TH1::SetBinError(Int_t bin, Double_t error); 9209{; 9210 if (bin < 0 || bin>= fNcells) return;; 9211 if (!fSumw2.fN) Sumw2();; 9212 fSumw2.fArray[bin] = error * error;; 9213 // reset the bin error option; 9214 SetBinErrorOption(kNormal);; 9215}; 9216 ; 9217////////////////////////////////////////////////////////////////////////////////; 9218/// Set bin content; 9219/// see convention for numbering bins in TH1::GetBin; 9220/// In case the bin number is greater than the number of bins and; 9221/// the timedisplay option is set or CanExtendAllAxes(),; 9222/// the number of bins is automatically doubled to accommodate the new bin; 9223 ; 9224void TH1::SetBinContent(Int_t bin, Double_t content); 9225{; 9226 fEntries++;; 9227 fTsumw = 0;; 9228 if (bin < 0) return;; 9229 if (bin >= fNcells-1",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:359265,Availability,error,error,359265,"se h1.GetXaxis()->GetLowEdge(edge); 9188 ; 9189void TH1::GetLowEdge(Double_t *edge) const; 9190{; 9191 if (fDimension == 1) {; 9192 fXaxis.GetLowEdge(edge);; 9193 return;; 9194 }; 9195 Error(""GetLowEdge"",""Invalid method for a %d-d histogram "",fDimension);; 9196}; 9197 ; 9198////////////////////////////////////////////////////////////////////////////////; 9199/// Set the bin Error; 9200/// Note that this resets the bin eror option to be of Normal Type and for the; 9201/// non-empty bin the bin error is set by default to the square root of their content.; 9202/// Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent); 9203/// he needs then to provide also the corresponding bin error (using SetBinError) since the bin error; 9204/// will not be recalculated after setting the content and a default error = 0 will be used for those bins.; 9205///; 9206/// See convention for numbering bins in TH1::GetBin; 9207 ; 9208void TH1::SetBinError(Int_t bin, Double_t error); 9209{; 9210 if (bin < 0 || bin>= fNcells) return;; 9211 if (!fSumw2.fN) Sumw2();; 9212 fSumw2.fArray[bin] = error * error;; 9213 // reset the bin error option; 9214 SetBinErrorOption(kNormal);; 9215}; 9216 ; 9217////////////////////////////////////////////////////////////////////////////////; 9218/// Set bin content; 9219/// see convention for numbering bins in TH1::GetBin; 9220/// In case the bin number is greater than the number of bins and; 9221/// the timedisplay option is set or CanExtendAllAxes(),; 9222/// the number of bins is automatically doubled to accommodate the new bin; 9223 ; 9224void TH1::SetBinContent(Int_t bin, Double_t content); 9225{; 9226 fEntries++;; 9227 fTsumw = 0;; 9228 if (bin < 0) return;; 9229 if (bin >= fNcells-1) {; 9230 if (fXaxis.GetTimeDisplay() || CanExtendAllAxes() ) {; 9231 while (bin >= fNcells-1) LabelsInflate();; 9232 } else {; 9233 if (bin == fNcells-1) UpdateBinContent(bin, content);; 9234 return;; 9235 }; 9236 }; 9",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:359381,Availability,error,error,359381,"the; 9201/// non-empty bin the bin error is set by default to the square root of their content.; 9202/// Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent); 9203/// he needs then to provide also the corresponding bin error (using SetBinError) since the bin error; 9204/// will not be recalculated after setting the content and a default error = 0 will be used for those bins.; 9205///; 9206/// See convention for numbering bins in TH1::GetBin; 9207 ; 9208void TH1::SetBinError(Int_t bin, Double_t error); 9209{; 9210 if (bin < 0 || bin>= fNcells) return;; 9211 if (!fSumw2.fN) Sumw2();; 9212 fSumw2.fArray[bin] = error * error;; 9213 // reset the bin error option; 9214 SetBinErrorOption(kNormal);; 9215}; 9216 ; 9217////////////////////////////////////////////////////////////////////////////////; 9218/// Set bin content; 9219/// see convention for numbering bins in TH1::GetBin; 9220/// In case the bin number is greater than the number of bins and; 9221/// the timedisplay option is set or CanExtendAllAxes(),; 9222/// the number of bins is automatically doubled to accommodate the new bin; 9223 ; 9224void TH1::SetBinContent(Int_t bin, Double_t content); 9225{; 9226 fEntries++;; 9227 fTsumw = 0;; 9228 if (bin < 0) return;; 9229 if (bin >= fNcells-1) {; 9230 if (fXaxis.GetTimeDisplay() || CanExtendAllAxes() ) {; 9231 while (bin >= fNcells-1) LabelsInflate();; 9232 } else {; 9233 if (bin == fNcells-1) UpdateBinContent(bin, content);; 9234 return;; 9235 }; 9236 }; 9237 UpdateBinContent(bin, content);; 9238}; 9239 ; 9240////////////////////////////////////////////////////////////////////////////////; 9241/// See convention for numbering bins in TH1::GetBin; 9242 ; 9243void TH1::SetBinError(Int_t binx, Int_t biny, Double_t error); 9244{; 9245 if (binx < 0 || binx > fXaxis.GetNbins() + 1) return;; 9246 if (biny < 0 || biny > fYaxis.GetNbins() + 1) return;; 9247 SetBinError(GetBin(binx, biny), error);; 9248}; 9249 ; 9250////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:359389,Availability,error,error,359389,"the; 9201/// non-empty bin the bin error is set by default to the square root of their content.; 9202/// Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent); 9203/// he needs then to provide also the corresponding bin error (using SetBinError) since the bin error; 9204/// will not be recalculated after setting the content and a default error = 0 will be used for those bins.; 9205///; 9206/// See convention for numbering bins in TH1::GetBin; 9207 ; 9208void TH1::SetBinError(Int_t bin, Double_t error); 9209{; 9210 if (bin < 0 || bin>= fNcells) return;; 9211 if (!fSumw2.fN) Sumw2();; 9212 fSumw2.fArray[bin] = error * error;; 9213 // reset the bin error option; 9214 SetBinErrorOption(kNormal);; 9215}; 9216 ; 9217////////////////////////////////////////////////////////////////////////////////; 9218/// Set bin content; 9219/// see convention for numbering bins in TH1::GetBin; 9220/// In case the bin number is greater than the number of bins and; 9221/// the timedisplay option is set or CanExtendAllAxes(),; 9222/// the number of bins is automatically doubled to accommodate the new bin; 9223 ; 9224void TH1::SetBinContent(Int_t bin, Double_t content); 9225{; 9226 fEntries++;; 9227 fTsumw = 0;; 9228 if (bin < 0) return;; 9229 if (bin >= fNcells-1) {; 9230 if (fXaxis.GetTimeDisplay() || CanExtendAllAxes() ) {; 9231 while (bin >= fNcells-1) LabelsInflate();; 9232 } else {; 9233 if (bin == fNcells-1) UpdateBinContent(bin, content);; 9234 return;; 9235 }; 9236 }; 9237 UpdateBinContent(bin, content);; 9238}; 9239 ; 9240////////////////////////////////////////////////////////////////////////////////; 9241/// See convention for numbering bins in TH1::GetBin; 9242 ; 9243void TH1::SetBinError(Int_t binx, Int_t biny, Double_t error); 9244{; 9245 if (binx < 0 || binx > fXaxis.GetNbins() + 1) return;; 9246 if (biny < 0 || biny > fYaxis.GetNbins() + 1) return;; 9247 SetBinError(GetBin(binx, biny), error);; 9248}; 9249 ; 9250////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:359419,Availability,error,error,359419,"the; 9201/// non-empty bin the bin error is set by default to the square root of their content.; 9202/// Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent); 9203/// he needs then to provide also the corresponding bin error (using SetBinError) since the bin error; 9204/// will not be recalculated after setting the content and a default error = 0 will be used for those bins.; 9205///; 9206/// See convention for numbering bins in TH1::GetBin; 9207 ; 9208void TH1::SetBinError(Int_t bin, Double_t error); 9209{; 9210 if (bin < 0 || bin>= fNcells) return;; 9211 if (!fSumw2.fN) Sumw2();; 9212 fSumw2.fArray[bin] = error * error;; 9213 // reset the bin error option; 9214 SetBinErrorOption(kNormal);; 9215}; 9216 ; 9217////////////////////////////////////////////////////////////////////////////////; 9218/// Set bin content; 9219/// see convention for numbering bins in TH1::GetBin; 9220/// In case the bin number is greater than the number of bins and; 9221/// the timedisplay option is set or CanExtendAllAxes(),; 9222/// the number of bins is automatically doubled to accommodate the new bin; 9223 ; 9224void TH1::SetBinContent(Int_t bin, Double_t content); 9225{; 9226 fEntries++;; 9227 fTsumw = 0;; 9228 if (bin < 0) return;; 9229 if (bin >= fNcells-1) {; 9230 if (fXaxis.GetTimeDisplay() || CanExtendAllAxes() ) {; 9231 while (bin >= fNcells-1) LabelsInflate();; 9232 } else {; 9233 if (bin == fNcells-1) UpdateBinContent(bin, content);; 9234 return;; 9235 }; 9236 }; 9237 UpdateBinContent(bin, content);; 9238}; 9239 ; 9240////////////////////////////////////////////////////////////////////////////////; 9241/// See convention for numbering bins in TH1::GetBin; 9242 ; 9243void TH1::SetBinError(Int_t binx, Int_t biny, Double_t error); 9244{; 9245 if (binx < 0 || binx > fXaxis.GetNbins() + 1) return;; 9246 if (biny < 0 || biny > fYaxis.GetNbins() + 1) return;; 9247 SetBinError(GetBin(binx, biny), error);; 9248}; 9249 ; 9250////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:360503,Availability,error,error,360503,"| bin>= fNcells) return;; 9211 if (!fSumw2.fN) Sumw2();; 9212 fSumw2.fArray[bin] = error * error;; 9213 // reset the bin error option; 9214 SetBinErrorOption(kNormal);; 9215}; 9216 ; 9217////////////////////////////////////////////////////////////////////////////////; 9218/// Set bin content; 9219/// see convention for numbering bins in TH1::GetBin; 9220/// In case the bin number is greater than the number of bins and; 9221/// the timedisplay option is set or CanExtendAllAxes(),; 9222/// the number of bins is automatically doubled to accommodate the new bin; 9223 ; 9224void TH1::SetBinContent(Int_t bin, Double_t content); 9225{; 9226 fEntries++;; 9227 fTsumw = 0;; 9228 if (bin < 0) return;; 9229 if (bin >= fNcells-1) {; 9230 if (fXaxis.GetTimeDisplay() || CanExtendAllAxes() ) {; 9231 while (bin >= fNcells-1) LabelsInflate();; 9232 } else {; 9233 if (bin == fNcells-1) UpdateBinContent(bin, content);; 9234 return;; 9235 }; 9236 }; 9237 UpdateBinContent(bin, content);; 9238}; 9239 ; 9240////////////////////////////////////////////////////////////////////////////////; 9241/// See convention for numbering bins in TH1::GetBin; 9242 ; 9243void TH1::SetBinError(Int_t binx, Int_t biny, Double_t error); 9244{; 9245 if (binx < 0 || binx > fXaxis.GetNbins() + 1) return;; 9246 if (biny < 0 || biny > fYaxis.GetNbins() + 1) return;; 9247 SetBinError(GetBin(binx, biny), error);; 9248}; 9249 ; 9250////////////////////////////////////////////////////////////////////////////////; 9251/// See convention for numbering bins in TH1::GetBin; 9252 ; 9253void TH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); 9254{; 9255 if (binx < 0 || binx > fXaxis.GetNbins() + 1) return;; 9256 if (biny < 0 || biny > fYaxis.GetNbins() + 1) return;; 9257 if (binz < 0 || binz > fZaxis.GetNbins() + 1) return;; 9258 SetBinError(GetBin(binx, biny, binz), error);; 9259}; 9260 ; 9261////////////////////////////////////////////////////////////////////////////////; 9262/// This function calculates",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:360675,Availability,error,error,360675,"the number of bins is automatically doubled to accommodate the new bin; 9223 ; 9224void TH1::SetBinContent(Int_t bin, Double_t content); 9225{; 9226 fEntries++;; 9227 fTsumw = 0;; 9228 if (bin < 0) return;; 9229 if (bin >= fNcells-1) {; 9230 if (fXaxis.GetTimeDisplay() || CanExtendAllAxes() ) {; 9231 while (bin >= fNcells-1) LabelsInflate();; 9232 } else {; 9233 if (bin == fNcells-1) UpdateBinContent(bin, content);; 9234 return;; 9235 }; 9236 }; 9237 UpdateBinContent(bin, content);; 9238}; 9239 ; 9240////////////////////////////////////////////////////////////////////////////////; 9241/// See convention for numbering bins in TH1::GetBin; 9242 ; 9243void TH1::SetBinError(Int_t binx, Int_t biny, Double_t error); 9244{; 9245 if (binx < 0 || binx > fXaxis.GetNbins() + 1) return;; 9246 if (biny < 0 || biny > fYaxis.GetNbins() + 1) return;; 9247 SetBinError(GetBin(binx, biny), error);; 9248}; 9249 ; 9250////////////////////////////////////////////////////////////////////////////////; 9251/// See convention for numbering bins in TH1::GetBin; 9252 ; 9253void TH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); 9254{; 9255 if (binx < 0 || binx > fXaxis.GetNbins() + 1) return;; 9256 if (biny < 0 || biny > fYaxis.GetNbins() + 1) return;; 9257 if (binz < 0 || binz > fZaxis.GetNbins() + 1) return;; 9258 SetBinError(GetBin(binx, biny, binz), error);; 9259}; 9260 ; 9261////////////////////////////////////////////////////////////////////////////////; 9262/// This function calculates the background spectrum in this histogram.; 9263/// The background is returned as a histogram.; 9264///; 9265/// \param[in] niter number of iterations (default value = 2); 9266/// Increasing niter make the result smoother and lower.; 9267/// \param[in] option may contain one of the following options; 9268/// - to set the direction parameter; 9269/// ""BackDecreasingWindow"". By default the direction is BackIncreasingWindow; 9270/// - filterOrder-order of clipping filter (default ""BackOrder",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:360920,Availability,error,error,360920,"the number of bins is automatically doubled to accommodate the new bin; 9223 ; 9224void TH1::SetBinContent(Int_t bin, Double_t content); 9225{; 9226 fEntries++;; 9227 fTsumw = 0;; 9228 if (bin < 0) return;; 9229 if (bin >= fNcells-1) {; 9230 if (fXaxis.GetTimeDisplay() || CanExtendAllAxes() ) {; 9231 while (bin >= fNcells-1) LabelsInflate();; 9232 } else {; 9233 if (bin == fNcells-1) UpdateBinContent(bin, content);; 9234 return;; 9235 }; 9236 }; 9237 UpdateBinContent(bin, content);; 9238}; 9239 ; 9240////////////////////////////////////////////////////////////////////////////////; 9241/// See convention for numbering bins in TH1::GetBin; 9242 ; 9243void TH1::SetBinError(Int_t binx, Int_t biny, Double_t error); 9244{; 9245 if (binx < 0 || binx > fXaxis.GetNbins() + 1) return;; 9246 if (biny < 0 || biny > fYaxis.GetNbins() + 1) return;; 9247 SetBinError(GetBin(binx, biny), error);; 9248}; 9249 ; 9250////////////////////////////////////////////////////////////////////////////////; 9251/// See convention for numbering bins in TH1::GetBin; 9252 ; 9253void TH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); 9254{; 9255 if (binx < 0 || binx > fXaxis.GetNbins() + 1) return;; 9256 if (biny < 0 || biny > fYaxis.GetNbins() + 1) return;; 9257 if (binz < 0 || binz > fZaxis.GetNbins() + 1) return;; 9258 SetBinError(GetBin(binx, biny, binz), error);; 9259}; 9260 ; 9261////////////////////////////////////////////////////////////////////////////////; 9262/// This function calculates the background spectrum in this histogram.; 9263/// The background is returned as a histogram.; 9264///; 9265/// \param[in] niter number of iterations (default value = 2); 9266/// Increasing niter make the result smoother and lower.; 9267/// \param[in] option may contain one of the following options; 9268/// - to set the direction parameter; 9269/// ""BackDecreasingWindow"". By default the direction is BackIncreasingWindow; 9270/// - filterOrder-order of clipping filter (default ""BackOrder",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:361158,Availability,error,error,361158,"return;; 9235 }; 9236 }; 9237 UpdateBinContent(bin, content);; 9238}; 9239 ; 9240////////////////////////////////////////////////////////////////////////////////; 9241/// See convention for numbering bins in TH1::GetBin; 9242 ; 9243void TH1::SetBinError(Int_t binx, Int_t biny, Double_t error); 9244{; 9245 if (binx < 0 || binx > fXaxis.GetNbins() + 1) return;; 9246 if (biny < 0 || biny > fYaxis.GetNbins() + 1) return;; 9247 SetBinError(GetBin(binx, biny), error);; 9248}; 9249 ; 9250////////////////////////////////////////////////////////////////////////////////; 9251/// See convention for numbering bins in TH1::GetBin; 9252 ; 9253void TH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); 9254{; 9255 if (binx < 0 || binx > fXaxis.GetNbins() + 1) return;; 9256 if (biny < 0 || biny > fYaxis.GetNbins() + 1) return;; 9257 if (binz < 0 || binz > fZaxis.GetNbins() + 1) return;; 9258 SetBinError(GetBin(binx, biny, binz), error);; 9259}; 9260 ; 9261////////////////////////////////////////////////////////////////////////////////; 9262/// This function calculates the background spectrum in this histogram.; 9263/// The background is returned as a histogram.; 9264///; 9265/// \param[in] niter number of iterations (default value = 2); 9266/// Increasing niter make the result smoother and lower.; 9267/// \param[in] option may contain one of the following options; 9268/// - to set the direction parameter; 9269/// ""BackDecreasingWindow"". By default the direction is BackIncreasingWindow; 9270/// - filterOrder-order of clipping filter (default ""BackOrder2""); 9271/// possible values= ""BackOrder4"" ""BackOrder6"" ""BackOrder8""; 9272/// - ""nosmoothing"" - if selected, the background is not smoothed; 9273/// By default the background is smoothed.; 9274/// - smoothWindow - width of smoothing window, (default is ""BackSmoothing3""); 9275/// possible values= ""BackSmoothing5"" ""BackSmoothing7"" ""BackSmoothing9""; 9276/// ""BackSmoothing11"" ""BackSmoothing13"" ""BackSmoothing15""; 9277/// - ""n",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:405988,Availability,error,error,405988,RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; Style_tshort Style_tDefinition RtypesCore.h:82; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Color_tshort Color_tDefinition RtypesCore.h:85; Version_tshort Version_tDefinition RtypesCore.h:65; Char_tchar Char_tDefinition RtypesCore.h:37; Float_tfloat Float_tDefinition RtypesCore.h:57; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBrowser.h; TBuffer.h; TClass.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; TF2.h; TF3.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; SetLineWidthOption_t Option_t SetLineWidthDefinition TGWin32VirtualXProxy.cxx:56; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefini,MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:413733,Availability,error,error,413733,"maxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; TMath.h; TPluginManager.h; TProfile.h; gDebugInt_t gDebugDefinition TROOT.cxx:597; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TVectorD.h; TVectorF.h; TVirtualFFT.h; TVirtualFitter.h; TVirtualHistPainter.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TVirtualPaveStats.h; R__WRITE_LOCKGUARD#define R__WRITE_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:157; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::DataRangeclass describing the range in the coordinates it supports multiple range in a coordinate.Definition DataRange.h:35; ROOT::Math::GoFTest::AndersonDarling2SamplesTestvoid AndersonDarling2SamplesTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 2-Sample Test.Definition GoFTest.cxx:646; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; TArrayCArray of chars or bytes (8 bits per element).Definition TArrayC.h:27; TArrayC::fArrayChar_t * fArrayDefinition TArrayC.h:30; TArrayC::Resetvoid Reset(Char_t val=0)Definition TArrayC.h:47; TArrayC::Setvoid Set(Int_t n) overrideSet size of this array to n chars.Definition TArrayC.cxx:105; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArrayD::GetAtDouble_t GetAt(Int_t i) const overrideDefinition TArrayD.h:45; TArrayD::fArrayDouble_t * fArrayDefinition TArrayD.h:30",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:432646,Availability,error,error,432646,"H1.cxx:10034; TH1L::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:10120; TH1MergerDefinition TH1Merger.h:20; TH1S1-D histogram with a short per channel (see TH1 documentation)Definition TH1.h:499; TH1S::operator=TH1S & operator=(const TH1S &h1)Operator =.Definition TH1.cxx:9773; TH1S::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:9745; TH1S::TH1STH1S()Constructor.Definition TH1.cxx:9659; TH1S::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:9763; TH1S::~TH1S~TH1S() overrideDestructor.Definition TH1.cxx:9707; TH1S::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9724; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::~TH1~TH1() overrideHistogram default destructor.Definition TH1.cxx:643; TH1::SetErrorvirtual void SetError(const Double_t *error)Replace bin errors by values in array error.Definition TH1.cxx:8951; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FitPanelvirtual void FitPanel()Display a panel with all histogram fit options.Definition TH1.cxx:4284; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::AutoP2FindLimitsvirtual Int_t AutoP2FindLimits(Double_t min, Double_t max)Buffer-based estimate of the histogram range using the power of 2 algorithm.Definition TH1.cxx:1343; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::GetObjectInfo.Definition TH1.cxx:4502; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this hi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:432664,Availability,error,errors,432664,"H1.cxx:10034; TH1L::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:10120; TH1MergerDefinition TH1Merger.h:20; TH1S1-D histogram with a short per channel (see TH1 documentation)Definition TH1.h:499; TH1S::operator=TH1S & operator=(const TH1S &h1)Operator =.Definition TH1.cxx:9773; TH1S::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:9745; TH1S::TH1STH1S()Constructor.Definition TH1.cxx:9659; TH1S::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:9763; TH1S::~TH1S~TH1S() overrideDestructor.Definition TH1.cxx:9707; TH1S::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9724; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::~TH1~TH1() overrideHistogram default destructor.Definition TH1.cxx:643; TH1::SetErrorvirtual void SetError(const Double_t *error)Replace bin errors by values in array error.Definition TH1.cxx:8951; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FitPanelvirtual void FitPanel()Display a panel with all histogram fit options.Definition TH1.cxx:4284; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::AutoP2FindLimitsvirtual Int_t AutoP2FindLimits(Double_t min, Double_t max)Buffer-based estimate of the histogram range using the power of 2 algorithm.Definition TH1.cxx:1343; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::GetObjectInfo.Definition TH1.cxx:4502; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this hi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:432690,Availability,error,error,432690,"H1.cxx:10034; TH1L::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:10120; TH1MergerDefinition TH1Merger.h:20; TH1S1-D histogram with a short per channel (see TH1 documentation)Definition TH1.h:499; TH1S::operator=TH1S & operator=(const TH1S &h1)Operator =.Definition TH1.cxx:9773; TH1S::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:9745; TH1S::TH1STH1S()Constructor.Definition TH1.cxx:9659; TH1S::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:9763; TH1S::~TH1S~TH1S() overrideDestructor.Definition TH1.cxx:9707; TH1S::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9724; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::~TH1~TH1() overrideHistogram default destructor.Definition TH1.cxx:643; TH1::SetErrorvirtual void SetError(const Double_t *error)Replace bin errors by values in array error.Definition TH1.cxx:8951; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FitPanelvirtual void FitPanel()Display a panel with all histogram fit options.Definition TH1.cxx:4284; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::AutoP2FindLimitsvirtual Int_t AutoP2FindLimits(Double_t min, Double_t max)Buffer-based estimate of the histogram range using the power of 2 algorithm.Definition TH1.cxx:1343; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::GetObjectInfo.Definition TH1.cxx:4502; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this hi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:433916,Availability,error,errors,433916,"am objects in the current ...Definition TH1.cxx:8937; TH1::FitPanelvirtual void FitPanel()Display a panel with all histogram fit options.Definition TH1.cxx:4284; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::AutoP2FindLimitsvirtual Int_t AutoP2FindLimits(Double_t min, Double_t max)Buffer-based estimate of the histogram range using the power of 2 algorithm.Definition TH1.cxx:1343; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::GetObjectInfo.Definition TH1.cxx:4502; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn bin center for 1D histogram.Definition TH1.cxx:9141; TH1::Rebuildvirtual void Rebuild(Option_t *option="""")Using the current bin info, recompute the arrays for contents and errors.Definition TH1.cxx:7087; TH1::SetBarOffsetvirtual void SetBarOffset(Float_t offset=0.25)Set the bar offset as fraction of the bin width for drawing mode ""B"".Definition TH1.h:364; TH1::fgStatOverflowsstatic Bool_t fgStatOverflows! Flag to use under/overflows in statisticsDefinition TH1.h:117; TH1::FindLastBinAbovevirtual Int_t FindLastBinAbove(Double_t threshold=0, Int_t axis=1, Int_t firstBin=1, Int_t lastBin=-1) constFind last bin with content > threshold for axis (1=x, 2=y, 3=z) if no bins with content > threshold i...Definition TH1.cxx:3797; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a line.Definition TH1.cxx:2823; TH1::Multiplyvirtual Bool_t Multiply(TF1 *f1, Double_t c1=1)Performs the operation:Definition TH1.cxx:6049; TH1::kXaxis@ kXaxisDefinition TH1.h:73; TH1::kNoAxis@ kNoAxisNOTE: Must a",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:436734,Availability,error,error,436734,"uares of weights.Definition TH1.h:97; TH1::StatOverflowsstatic void StatOverflows(Bool_t flag=kTRUE)if flag=kTRUE, underflows and overflows are used by the Fill functions in the computation of statisti...Definition TH1.cxx:6925; TH1::GetBarOffsetvirtual Float_t GetBarOffset() constDefinition TH1.h:256; TH1::fFunctionsTList * fFunctions->Pointer to list of functions (fits and user)Definition TH1.h:106; TH1::fgAddDirectorystatic Bool_t fgAddDirectory! Flag to add histograms to the directoryDefinition TH1.h:116; TH1::CheckConsistencystatic int CheckConsistency(const TH1 *h1, const TH1 *h2)Check histogram compatibility.Definition TH1.cxx:1677; TH1::Classstatic TClass * Class(); TH1::GetDefaultBufferSizestatic Int_t GetDefaultBufferSize()Static function return the default buffer size for automatic histograms the parameter fgBufferSize ma...Definition TH1.cxx:4406; TH1::DoIntegralvirtual Double_t DoIntegral(Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) constInternal function compute integral and optionally the error between the limits specified by the bin n...Definition TH1.cxx:7977; TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::TH1TH1()Histogram default constructor.Definition TH1.cxx:615; TH1::TransformHistostatic TH1 * TransformHisto(TVirtualFFT *fft, TH1 *h_output, Option_t *option)For a given transform (first parameter), fills the histogram (second parameter) with the transform ou...Definition TH1.cxx:9319; TH1::UseCurrentStylevoid UseCurrentStyle() overrideCopy current attributes from/to current style.Definition TH1.cxx:7469; TH1::LabelsOptionvirtual void LabelsOption(Option_t *option=""h"", Option_t *axis=""X"")Sort bins with labels or set option(s) to draw axis with labels.Definition TH1.cxx:5382; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDef",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:438279,Availability,error,error,438279,"ith the transform ou...Definition TH1.cxx:9319; TH1::UseCurrentStylevoid UseCurrentStyle() overrideCopy current attributes from/to current style.Definition TH1.cxx:7469; TH1::LabelsOptionvirtual void LabelsOption(Option_t *option=""h"", Option_t *axis=""X"")Sort bins with labels or set option(s) to draw axis with labels.Definition TH1.cxx:5382; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::fBarOffsetShort_t fBarOffset(1000*offset) for bar charts or legosDefinition TH1.h:93; TH1::Chi2TestXvirtual Double_t Chi2TestX(const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) constThe computation routine of the Chisquare test.Definition TH1.cxx:2067; TH1::CheckBinLimitsstatic bool CheckBinLimits(const TAxis *a1, const TAxis *a2)Check bin limits.Definition TH1.cxx:1541; TH1::AddBinContentvirtual void AddBinContent(Int_t bin)Increment bin content by 1.Definition TH1.cxx:1268; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::FitOptionsMakestatic Int_t FitOptionsMake(Option_t *option, Foption_t &Foption)Decode string choptin and fill fitOption structure.Definition TH1.cxx:4652; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::GetNormFactorvirtual Double_t GetNormFactor() constDefinition TH1.h:301; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::GetSkewnessvirtual Double_t GetSkewness(Int_t axis=1) constDefinition TH1.cxx:7671; TH1::ClearUnderflowAndOverflowvirtual void ClearUnderflowAndOverflow()Remove all the content from the underflow and overflow bins, without changing the number of entries A...Definition TH1.cxx:2517; TH1::GetContourLevelPadvirtual Double_t GetContourLevelPad(Int_t level) constReturn the value of contour number ""level"" in Pad coordinates.Definition TH1.cxx:84",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:440764,Availability,error,errors,440764,"rolling the automatic add of histograms in memory.Definition TH1.cxx:1294; TH1::kIsAverage@ kIsAverageBin contents are average (used by Add)Definition TH1.h:171; TH1::kUserContour@ kUserContourUser specified contour levels.Definition TH1.h:166; TH1::kNoStats@ kNoStatsDon't draw stats box.Definition TH1.h:165; TH1::kAutoBinPTwo@ kAutoBinPTwodifferent than 1.Definition TH1.h:174; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::kIsHighlight@ kIsHighlightbit set if histo is highlightDefinition TH1.h:175; TH1::SetContourLevelvirtual void SetContourLevel(Int_t level, Double_t value)Set value for one contour level.Definition TH1.cxx:8522; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::fDirectoryTDirectory * fDirectory! Pointer to directory holding this histogramDefinition TH1.h:109; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::SetNameTitlevoid SetNameTitle(const char *name, const char *title) overrideChange the name and title of this histogram.Definition TH1.cxx:8974; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetBinXYZvirtual void GetBinXYZ(Int_t binglobal, Int_t &binx, Int_t &biny, Int_t &binz) constReturn binx, biny, binz corresponding to the global bin number globalbin see TH1::GetBin function abo...Definition TH1.cxx:4974; TH1::GetCumulativeTH1 * GetCumulative(Bool_t forward=kTRUE, const char *suffix=""_cumulative"") constReturn a pointer to a histogram containing the cumulative content.Definition TH1.cxx:2616; TH1::AutoP2GetPower2static Double_t AutoP2GetPower2(Double_t x, Bool_t next=kTRUE)Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x.Definition TH1.cxx:1308; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::ShowPeaksvirtual Int_t ShowPeaks(Double_",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:444534,Availability,error,errors,444534,"Double_t GetMaximum(Double_t maxval=FLT_MAX) constReturn maximum value smaller than maxval of bins in the range, unless the value has been overridden b...Definition TH1.cxx:8545; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::FFTvirtual TH1 * FFT(TH1 *h_output, Option_t *option)This function allows to do discrete Fourier transforms of TH1 and TH2.Definition TH1.cxx:3284; TH1::LabelsInflatevirtual void LabelsInflate(Option_t *axis=""X"")Double the number of bins for axis.Definition TH1.cxx:5315; TH1::ShowBackgroundvirtual TH1 * ShowBackground(Int_t niter=20, Option_t *option=""same"")This function calculates the background spectrum in this histogram.Definition TH1.cxx:9287; TH1::SameLimitsAndNBinsstatic Bool_t SameLimitsAndNBins(const TAxis &axis1, const TAxis &axis2)Same limits and bins.Definition TH1.cxx:5898; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fMaximumDouble_t fMaximumMaximum value for plotting.Definition TH1.h:100; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fBinStatErrOptEBinErrorOpt fBinStat",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:445132,Availability,error,error,445132,"uble the number of bins for axis.Definition TH1.cxx:5315; TH1::ShowBackgroundvirtual TH1 * ShowBackground(Int_t niter=20, Option_t *option=""same"")This function calculates the background spectrum in this histogram.Definition TH1.cxx:9287; TH1::SameLimitsAndNBinsstatic Bool_t SameLimitsAndNBins(const TAxis &axis1, const TAxis &axis2)Same limits and bins.Definition TH1.cxx:5898; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fMaximumDouble_t fMaximumMaximum value for plotting.Definition TH1.h:100; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fBinStatErrOptEBinErrorOpt fBinStatErrOptOption for bin statistical errors.Definition TH1.h:113; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::SetBinsLengthvirtual void SetBinsLength(Int_t=-1)Definition TH1.h:380; TH1::fNormFactorDouble_t fNormFactorNormalization factor.Definition TH1.h:102; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::fContourTArrayD fContourArray to display contour levels.Definitio",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:445314,Availability,error,error,445314,"st TAxis &axis1, const TAxis &axis2)Same limits and bins.Definition TH1.cxx:5898; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fMaximumDouble_t fMaximumMaximum value for plotting.Definition TH1.h:100; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fBinStatErrOptEBinErrorOpt fBinStatErrOptOption for bin statistical errors.Definition TH1.h:113; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::SetBinsLengthvirtual void SetBinsLength(Int_t=-1)Definition TH1.h:380; TH1::fNormFactorDouble_t fNormFactorNormalization factor.Definition TH1.h:102; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::fContourTArrayD fContourArray to display contour levels.Definition TH1.h:103; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::Browsevoid Browse(TBrowser *b) overrideBrowse the Histogram object.Definition TH1.cxx:762; TH1::SetContentvirtual void SetContent(const Do",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:445522,Availability,error,errors,445522,""""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fMaximumDouble_t fMaximumMaximum value for plotting.Definition TH1.h:100; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fBinStatErrOptEBinErrorOpt fBinStatErrOptOption for bin statistical errors.Definition TH1.h:113; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::SetBinsLengthvirtual void SetBinsLength(Int_t=-1)Definition TH1.h:380; TH1::fNormFactorDouble_t fNormFactorNormalization factor.Definition TH1.h:102; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::fContourTArrayD fContourArray to display contour levels.Definition TH1.h:103; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::Browsevoid Browse(TBrowser *b) overrideBrowse the Histogram object.Definition TH1.cxx:762; TH1::SetContentvirtual void SetContent(const Double_t *content)Replace bin contents by the contents of array content.Definition TH1.cxx:8398; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw th",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:446131,Availability,error,error,446131,"ange [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fBinStatErrOptEBinErrorOpt fBinStatErrOptOption for bin statistical errors.Definition TH1.h:113; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::SetBinsLengthvirtual void SetBinsLength(Int_t=-1)Definition TH1.h:380; TH1::fNormFactorDouble_t fNormFactorNormalization factor.Definition TH1.h:102; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::fContourTArrayD fContourArray to display contour levels.Definition TH1.h:103; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::Browsevoid Browse(TBrowser *b) overrideBrowse the Histogram object.Definition TH1.cxx:762; TH1::SetContentvirtual void SetContent(const Double_t *content)Replace bin contents by the contents of array content.Definition TH1.cxx:8398; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SavePrimitiveHelpvirtual void SavePrimitiveHelp(std::ostream &out, const char *hname, Option_t *option="""")Helper function for the SavePrimitive functions from TH1 or classes derived from TH1,...Definition TH1.cxx:7379; TH1::fBarWidthShort_t fBarWidth(1000*width) for bar charts or legosDefinition TH1.h:94; TH1::GetBinErrorSqUncheckedvirtual Double_t GetBinErrorSqUnchecked(Int_t bin) constDefinition TH1.h:449; TH1::AxisChoiceInt_t AxisChoice(Option_t *axis) constChoose an axis according to ""axis"".Definition Haxis.cxx:14; TH1::SetMinimumvirtual void SetMinimum(D",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:450212,Availability,mask,mask,450212," bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::Buildvoid Build()Creates histogram basic data structure.Definition TH1.cxx:771; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::GetFunctionvirtual TF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TH1.cxx:9051; TH1::Rebinvirtual TH1 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr)Rebin this histogram.Definition TH1.cxx:6275; TH1::BufferFillvirtual Int_t BufferFill(Double_t x, Double_t w)accumulate arguments in buffer.Definition TH1.cxx:1506; TH1::GetBinWithContentvirtual Double_t GetBinWithContent(Double_t c, Int_t &binx, Int_t firstx=0, Int_t lastx=0, Double_t maxdiff=0) constCompute first binx in the range [firstx,lastx] for which diff = abs(bin_content-c) <= maxdiff.Definition TH1.cxx:5086; TH1::SetCanExtendvirtual UInt_t SetCanExtend(UInt_t extendBitMask)Make the histogram axes extendable / not extendable according to the bit mask returns the previous bi...Definition TH1.cxx:6649; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constSt",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:450851,Availability,error,error,450851,"thContentvirtual Double_t GetBinWithContent(Double_t c, Int_t &binx, Int_t firstx=0, Int_t lastx=0, Double_t maxdiff=0) constCompute first binx in the range [firstx,lastx] for which diff = abs(bin_content-c) <= maxdiff.Definition TH1.cxx:5086; TH1::SetCanExtendvirtual UInt_t SetCanExtend(UInt_t extendBitMask)Make the histogram axes extendable / not extendable according to the bit mask returns the previous bi...Definition TH1.cxx:6649; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling ...Definition TH1.cxx:8062; TH1::ResetStatsvirtual void ResetStats()Reset the statistics including the number of entries and replace with values calculated from bin cont...Definition TH1.cxx:7902; TH1::SetDefaultBufferSizestatic void SetDefaultBufferSize(Int_t buffersize=1000)Static function to set the default buffer size for automatic histograms.Definition TH1.cxx:6693; TH1::SetBinErrorOptionvirtual void SetBinErrorOption(EBinErrorOpt type)Definition TH1.h:381; TH1::SetBuffervirtual void SetBuffer(Int_t buffersize, Option_t *option="""")Set the maximum number of entries to ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:454820,Availability,error,errorUp,454820,"Double_t * GetIntegral()Return a pointer to the array of bins integral.Definition TH1.cxx:2586; TH1::fZaxisTAxis fZaxisZ axis descriptor.Definition TH1.h:92; TH1::fStatOverflowsEStatOverflows fStatOverflowsPer object flag to use under/overflows in statistics.Definition TH1.h:114; TH1::IsATClass * IsA() const overrideDefinition TH1.h:444; TH1::FillNvirtual void FillN(Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1)Fill this histogram with an array x and weights w.Definition TH1.cxx:3447; TH1::UpdateBinContentvirtual void UpdateBinContent(Int_t bin, Double_t content)Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.cxx:9449; TH1::CheckEqualAxesstatic bool CheckEqualAxes(const TAxis *a1, const TAxis *a2)Check that the axis are the same.Definition TH1.cxx:1611; TH1::kPoisson2@ kPoisson2Errors from Poisson interval at 95% CL (~ 2 sigma)Definition TH1.h:67; TH1::kNormal@ kNormalErrors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N)Definition TH1.h:65; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetContourvirtual Int_t GetContour(Double_t *levels=nullptr)Return contour values into array levels if pointer levels is non zero.Definition TH1.cxx:8411; TH1::fXaxisTAxis fXaxisX axis descriptor.Definition TH1.h:90; TH1::IsHighlightvirtual Bool_t IsHighlight() constDefinition TH1.h:338; TH1::ExtendAxisvirtual void ExtendAxis(Double_t x, TAxis *axis)Histogram is resized along axis such that x is in the axis range.Definition TH1.cxx:6504; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::fSumw2TArrayD fSumw2Array of sum of squares of weights.Definition TH1.h:104; TH1::GetAsymmetryTH1 * GetAsymmetry(TH1 *h2, Double_t c2=1, Double_t dc2=0)Return a histogram containing the asymmetry of this histogram with h2, where the asymmetry is",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:454828,Availability,error,errorLow,454828,"Double_t * GetIntegral()Return a pointer to the array of bins integral.Definition TH1.cxx:2586; TH1::fZaxisTAxis fZaxisZ axis descriptor.Definition TH1.h:92; TH1::fStatOverflowsEStatOverflows fStatOverflowsPer object flag to use under/overflows in statistics.Definition TH1.h:114; TH1::IsATClass * IsA() const overrideDefinition TH1.h:444; TH1::FillNvirtual void FillN(Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1)Fill this histogram with an array x and weights w.Definition TH1.cxx:3447; TH1::UpdateBinContentvirtual void UpdateBinContent(Int_t bin, Double_t content)Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.cxx:9449; TH1::CheckEqualAxesstatic bool CheckEqualAxes(const TAxis *a1, const TAxis *a2)Check that the axis are the same.Definition TH1.cxx:1611; TH1::kPoisson2@ kPoisson2Errors from Poisson interval at 95% CL (~ 2 sigma)Definition TH1.h:67; TH1::kNormal@ kNormalErrors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N)Definition TH1.h:65; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetContourvirtual Int_t GetContour(Double_t *levels=nullptr)Return contour values into array levels if pointer levels is non zero.Definition TH1.cxx:8411; TH1::fXaxisTAxis fXaxisX axis descriptor.Definition TH1.h:90; TH1::IsHighlightvirtual Bool_t IsHighlight() constDefinition TH1.h:338; TH1::ExtendAxisvirtual void ExtendAxis(Double_t x, TAxis *axis)Histogram is resized along axis such that x is in the axis range.Definition TH1.cxx:6504; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::fSumw2TArrayD fSumw2Array of sum of squares of weights.Definition TH1.h:104; TH1::GetAsymmetryTH1 * GetAsymmetry(TH1 *h2, Double_t c2=1, Double_t dc2=0)Return a histogram containing the asymmetry of this histogram with h2, where the asymmetry is",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:456383,Availability,error,error,456383,"is resized along axis such that x is in the axis range.Definition TH1.cxx:6504; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::fSumw2TArrayD fSumw2Array of sum of squares of weights.Definition TH1.h:104; TH1::GetAsymmetryTH1 * GetAsymmetry(TH1 *h2, Double_t c2=1, Double_t dc2=0)Return a histogram containing the asymmetry of this histogram with h2, where the asymmetry is defined...Definition TH1.cxx:4339; TH1::GetContourLevelvirtual Double_t GetContourLevel(Int_t level) constReturn value of contour number level.Definition TH1.cxx:8430; TH1::SetContourvirtual void SetContour(Int_t nlevels, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TH1.cxx:8483; TH1::SetHighlightvirtual void SetHighlight(Bool_t set=kTRUE)Set highlight (enable/disable) mode for the histogram by default highlight mode is disable.Definition TH1.cxx:4482; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH1::Scalevirtual void Scale(Double_t c1=1, Option_t *option="""")Multiply this histogram by a constant c1.Definition TH1.cxx:6604; TH1::GetMinimumBinvirtual Int_t GetMinimumBin() constReturn location of bin with minimum value in the range.Definition TH1.cxx:8665; TH1::GetSumw2Nvirtual Int_t GetSumw2N() constDefinition TH1.h:315; TH1::FindBinvirtual Int_t FindBin(Double_t x, Double_t y=0, Double_t z=0)Return Global bin number corresponding to x,y,z.Definition TH1.cxx:3672; TH1::GetStatOverflowsBehaviourBool_t GetStatOverflowsBehaviour() constDefinition TH1.h:152; TH1::SaveAsvoid SaveAs(const char *filename=""hist"", Option_t *option="""") const overrideSave the histogram as .csv, .tsv or .txt.Definition TH1.cxx:7181; TH1::GetQuantilesvirtual Int_t GetQuantiles(Int_t n, Double_t *xp, const Double_t *p=nullptr)Compute Quantiles for this histogram Quantile x_p := Q(p) is defined as the value x_p such that the ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:457598,Availability,error,error,457598,"umBinvirtual Int_t GetMinimumBin() constReturn location of bin with minimum value in the range.Definition TH1.cxx:8665; TH1::GetSumw2Nvirtual Int_t GetSumw2N() constDefinition TH1.h:315; TH1::FindBinvirtual Int_t FindBin(Double_t x, Double_t y=0, Double_t z=0)Return Global bin number corresponding to x,y,z.Definition TH1.cxx:3672; TH1::GetStatOverflowsBehaviourBool_t GetStatOverflowsBehaviour() constDefinition TH1.h:152; TH1::SaveAsvoid SaveAs(const char *filename=""hist"", Option_t *option="""") const overrideSave the histogram as .csv, .tsv or .txt.Definition TH1.cxx:7181; TH1::GetQuantilesvirtual Int_t GetQuantiles(Int_t n, Double_t *xp, const Double_t *p=nullptr)Compute Quantiles for this histogram Quantile x_p := Q(p) is defined as the value x_p such that the c...Definition TH1.cxx:4611; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::GetStdDevErrorvirtual Double_t GetStdDevError(Int_t axis=1) constReturn error of standard deviation estimation for Normal distribution.Definition TH1.cxx:7655; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TH1::LoggedInconsistencyint LoggedInconsistency(const char *name, const TH1 *h1, const TH1 *h2, bool useMerge=false) constDefinition TH1.cxx:883; TH1::CheckConsistentSubAxesstatic bool CheckConsistentSubAxes(const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0)Check that two sub axis are the same.Definition TH1.cxx:1640; TH1::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove object from the list of functions.Definition TH1.cxx:6576; TH1::fYaxisTAxis",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:457789,Availability,error,errors,457789,"Definition TH1.h:315; TH1::FindBinvirtual Int_t FindBin(Double_t x, Double_t y=0, Double_t z=0)Return Global bin number corresponding to x,y,z.Definition TH1.cxx:3672; TH1::GetStatOverflowsBehaviourBool_t GetStatOverflowsBehaviour() constDefinition TH1.h:152; TH1::SaveAsvoid SaveAs(const char *filename=""hist"", Option_t *option="""") const overrideSave the histogram as .csv, .tsv or .txt.Definition TH1.cxx:7181; TH1::GetQuantilesvirtual Int_t GetQuantiles(Int_t n, Double_t *xp, const Double_t *p=nullptr)Compute Quantiles for this histogram Quantile x_p := Q(p) is defined as the value x_p such that the c...Definition TH1.cxx:4611; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::GetStdDevErrorvirtual Double_t GetStdDevError(Int_t axis=1) constReturn error of standard deviation estimation for Normal distribution.Definition TH1.cxx:7655; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TH1::LoggedInconsistencyint LoggedInconsistency(const char *name, const TH1 *h1, const TH1 *h2, bool useMerge=false) constDefinition TH1.cxx:883; TH1::CheckConsistentSubAxesstatic bool CheckConsistentSubAxes(const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0)Check that two sub axis are the same.Definition TH1.cxx:1640; TH1::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove object from the list of functions.Definition TH1.cxx:6576; TH1::fYaxisTAxis fYaxisY axis descriptor.Definition TH1.h:91; TH1::KolmogorovTestvirtual Double_t KolmogorovTest(const TH1 *h2, Option_t *option="""") constStatistical test of compati",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:466101,Availability,error,error,466101,"cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TProfile::Classstatic TClass * Class(); TRandomThis is the base class for the ROOT R",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:476165,Availability,down,downward,476165,"3; ROOT::Fit::EChisquareType::kPLikeRatio@ kPLikeRatio; ROOT::Fit::EChisquareType::kNeyman@ kNeyman; ROOT::Fit::EChisquareType::kPearson@ kPearson; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::MedianDouble_t Median(Long64_t n, const T *a, const Double_t *w=nullptr, Long64_t *work=nullptr)Same as RMS.Definition TMath.h:1272; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::MinElementT MinElement(Long64_t n, const T *a)Returns minimum of array a of length n.Definition TMath.h:960; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::AreEqualRelBool_t AreEqualRel(Double_t af, Double_t bf, Doub",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:477568,Availability,down,down,477568,"x.Definition TMath.h:668; TMath::MinElementT MinElement(Long64_t n, const T *a)Returns minimum of array a of length n.Definition TMath.h:960; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::AreEqualRelBool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec)Comparing floating points.Definition TMath.h:426; TMath::AreEqualAbsBool_t AreEqualAbs(Double_t af, Double_t bf, Double_t epsilon)Comparing floating points.Definition TMath.h:418; TMath::KolmogorovProbDouble_t KolmogorovProb(Double_t z)Calculates the Kolmogorov distribution function,.Definition TMath.cxx:679; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::InfinityDouble_t Infinity()Returns an infinity as defined by the IEEE standard.Definition TMath.h:917; v@ vDefinition rootcling_impl.cxx:3699; Foption_tDefinition Foption.h:24; Drawth1 Draw(); mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. histhistsrcTH1.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:20904,Deployability,update,updated,20904,"errors and functions, e.g.:; 456~~~ {.cpp}; 457 TH1F *hnew = (TH1F*)h->Clone(""hnew"");; 458~~~; 459 ; 460\anchor normalizing; 461### Normalizing histograms; 462 ; 463 One can scale a histogram such that the bins integral is equal to; 464 the normalization parameter via TH1::Scale(Double_t norm), where norm; 465 is the desired normalization divided by the integral of the histogram.; 466 ; 467 ; 468\anchor drawing-histograms; 469## Drawing histograms; 470 ; 471 Histograms are drawn via the THistPainter class. Each histogram has; 472 a pointer to its own painter (to be usable in a multithreaded program).; 473 Many drawing options are supported.; 474 See THistPainter::Paint() for more details.; 475 ; 476 The same histogram can be drawn with different options in different pads.; 477 When a histogram drawn in a pad is deleted, the histogram is; 478 automatically removed from the pad or pads where it was drawn.; 479 If a histogram is drawn in a pad, then filled again, the new status; 480 of the histogram will be automatically shown in the pad next time; 481 the pad is updated. One does not need to redraw the histogram.; 482 To draw the current version of a histogram in a pad, one can use; 483~~~ {.cpp}; 484 h->DrawCopy();; 485~~~; 486 This makes a clone (see Clone below) of the histogram. Once the clone; 487 is drawn, the original histogram may be modified or deleted without; 488 affecting the aspect of the clone.; 489 ; 490 One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular; 491 value for the maximum or the minimum scale on the plot. (For 1-D; 492 histograms this means the y-axis, while for 2-D histograms these; 493 functions affect the z-axis).; 494 ; 495 TH1::UseCurrentStyle() can be used to change all histogram graphics; 496 attributes to correspond to the current selected style.; 497 This function must be called for each histogram.; 498 In case one reads and draws many histograms from a file, one can force; 499 the histograms to inherit automatica",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:42016,Deployability,update,update,42016,"31 else if (fSumw2.fN) {; 1032 w2 = 1.E200; // use an arbitrary huge value; 1033 if (y2 == 0) {; 1034 // use an estimated error from the global histogram scale; 1035 double sf = (s1[0] != 0) ? s1[1]/s1[0] : 1;; 1036 w2 = 1./(sf*sf);; 1037 }; 1038 }; 1039 ; 1040 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1041 UpdateBinContent(bin, y);; 1042 if (fSumw2.fN) {; 1043 double err2 = 1./(w1 + w2);; 1044 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1045 fSumw2.fArray[bin] = err2;; 1046 }; 1047 } else { // normal case of addition between histograms; 1048 AddBinContent(bin, c1 * factor * h1->RetrieveBinContent(bin));; 1049 if (fSumw2.fN) fSumw2.fArray[bin] += c1sq * factsq * h1->GetBinErrorSqUnchecked(bin);; 1050 }; 1051 }; 1052 ; 1053 // update statistics (do here to avoid changes by SetBinContent); 1054 if (resetStats) {; 1055 // statistics need to be reset in case coefficient are negative; 1056 ResetStats();; 1057 }; 1058 else {; 1059 for (Int_t i=0;i<kNstat;i++) {; 1060 if (i == 1) s1[i] += c1*c1*s2[i];; 1061 else s1[i] += c1*s2[i];; 1062 }; 1063 PutStats(s1);; 1064 SetEntries(entries);; 1065 }; 1066 return kTRUE;; 1067}; 1068 ; 1069////////////////////////////////////////////////////////////////////////////////; 1070/// Replace contents of this histogram by the addition of h1 and h2.; 1071///; 1072/// `this = c1*h1 + c2*h2`; 1073/// if errors are defined (see TH1::Sumw2), errors are also recalculated; 1074///; 1075/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 1076/// if not already set.; 1077///; 1078/// Note also that adding histogram with labels is not supported, histogram will be; 1079/// added merging them by bin number independently of the labels.; 1080/// For adding histogram ith labels one should use TH1::Merge; 1081///; 1082/// SPECIAL CASE (Average/Efficiency histograms); 1083/// For histograms representing averages or efficiencies, one should compute the average; 1084/// of the two histograms and ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:49841,Deployability,update,update,49841,"obal histogram scale; 1227 double sf = (s2[0] != 0) ? s2[1]/s2[0] : 1;; 1228 w2 = 1./(sf*sf);; 1229 }; 1230 }; 1231 ; 1232 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1233 UpdateBinContent(i, y);; 1234 if (fSumw2.fN) {; 1235 double err2 = 1./(w1 + w2);; 1236 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1237 fSumw2.fArray[i] = err2;; 1238 }; 1239 }; 1240 } else { // case of simple histogram addition; 1241 Double_t c1sq = c1 * c1;; 1242 Double_t c2sq = c2 * c2;; 1243 for (Int_t i = 0; i < fNcells; ++i) { // Loop on cells (bins including underflows/overflows); 1244 UpdateBinContent(i, c1 * h1->RetrieveBinContent(i) + c2 * h2->RetrieveBinContent(i));; 1245 if (fSumw2.fN) {; 1246 fSumw2.fArray[i] = c1sq * h1->GetBinErrorSqUnchecked(i) + c2sq * h2->GetBinErrorSqUnchecked(i);; 1247 }; 1248 }; 1249 }; 1250 ; 1251 if (resetStats) {; 1252 // statistics need to be reset in case coefficient are negative; 1253 ResetStats();; 1254 }; 1255 else {; 1256 // update statistics (do here to avoid changes by SetBinContent) FIXME remove???; 1257 PutStats(s3);; 1258 SetEntries(nEntries);; 1259 }; 1260 ; 1261 return kTRUE;; 1262}; 1263 ; 1264////////////////////////////////////////////////////////////////////////////////; 1265/// Increment bin content by 1.; 1266/// Passing an out-of-range bin leads to undefined behavior; 1267 ; 1268void TH1::AddBinContent(Int_t); 1269{; 1270 AbstractMethod(""AddBinContent"");; 1271}; 1272 ; 1273////////////////////////////////////////////////////////////////////////////////; 1274/// Increment bin content by a weight w.; 1275/// Passing an out-of-range bin leads to undefined behavior; 1276 ; 1277void TH1::AddBinContent(Int_t, Double_t); 1278{; 1279 AbstractMethod(""AddBinContent"");; 1280}; 1281 ; 1282////////////////////////////////////////////////////////////////////////////////; 1283/// Sets the flag controlling the automatic add of histograms in memory; 1284///; 1285/// By default (fAddDirectory = kTRUE), histograms are automatic",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:110256,Deployability,update,update,110256,"y stored.; 2739 // and if the AddDirectoryStatus() is false it will not be added to; 2740 // any directory (fDirectory = nullptr); 2741 if (fgAddDirectory && gDirectory) {; 2742 gDirectory->Append(&obj);; 2743 ((TH1&)obj).fFunctions->UseRWLock();; 2744 ((TH1&)obj).fDirectory = gDirectory;; 2745 } else; 2746 ((TH1&)obj).fDirectory = nullptr;; 2747 ; 2748}; 2749 ; 2750////////////////////////////////////////////////////////////////////////////////; 2751/// Make a complete copy of the underlying object. If 'newname' is set,; 2752/// the copy's name will be set to that name.; 2753 ; 2754TObject* TH1::Clone(const char* newname) const; 2755{; 2756 TH1* obj = (TH1*)IsA()->GetNew()(nullptr);; 2757 Copy(*obj);; 2758 ; 2759 // Now handle the parts that Copy doesn't do; 2760 if(fFunctions) {; 2761 // The Copy above might have published 'obj' to the ListOfCleanups.; 2762 // Clone can call RecursiveRemove, for example via TCheckHashRecursiveRemoveConsistency; 2763 // when dictionary information is initialized, so we need to; 2764 // keep obj->fFunction valid during its execution and; 2765 // protect the update with the write lock.; 2766 ; 2767 // Reset stats parent - else cloning the stats will clone this histogram, too.; 2768 auto oldstats = dynamic_cast<TVirtualPaveStats*>(fFunctions->FindObject(""stats""));; 2769 TObject *oldparent = nullptr;; 2770 if (oldstats) {; 2771 oldparent = oldstats->GetParent();; 2772 oldstats->SetParent(nullptr);; 2773 }; 2774 ; 2775 auto newlist = (TList*)fFunctions->Clone();; 2776 ; 2777 if (oldstats); 2778 oldstats->SetParent(oldparent);; 2779 auto newstats = dynamic_cast<TVirtualPaveStats*>(obj->fFunctions->FindObject(""stats""));; 2780 if (newstats); 2781 newstats->SetParent(obj);; 2782 ; 2783 auto oldlist = obj->fFunctions;; 2784 {; 2785 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2786 obj->fFunctions = newlist;; 2787 }; 2788 delete oldlist;; 2789 }; 2790 if(newname && strlen(newname) ) {; 2791 obj->SetName(newname);; 2792 }; 2793 return obj;; 2794}; 2",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:121189,Deployability,update,updated,121189,"or not equal to zero; 3023 fSumw2.fArray[i] = 0;; 3024 }; 3025 } else {; 3026 fSumw2.fArray[i] = c1sq * c2sq * (e1sq * b2sq + e2sq * b1sq) / (c2sq * c2sq * b2sq * b2sq);; 3027 }; 3028 }; 3029 }; 3030 ResetStats();; 3031 if (binomial); 3032 // in case of binomial division use denominator for number of entries; 3033 SetEntries ( h2->GetEntries() );; 3034 ; 3035 return kTRUE;; 3036}; 3037 ; 3038////////////////////////////////////////////////////////////////////////////////; 3039/// Draw this histogram with options.; 3040///; 3041/// Histograms are drawn via the THistPainter class. Each histogram has; 3042/// a pointer to its own painter (to be usable in a multithreaded program).; 3043/// The same histogram can be drawn with different options in different pads.; 3044/// When a histogram drawn in a pad is deleted, the histogram is; 3045/// automatically removed from the pad or pads where it was drawn.; 3046/// If a histogram is drawn in a pad, then filled again, the new status; 3047/// of the histogram will be automatically shown in the pad next time; 3048/// the pad is updated. One does not need to redraw the histogram.; 3049/// To draw the current version of a histogram in a pad, one can use; 3050/// `h->DrawCopy();`; 3051/// This makes a clone of the histogram. Once the clone is drawn, the original; 3052/// histogram may be modified or deleted without affecting the aspect of the; 3053/// clone.; 3054/// By default, TH1::Draw clears the current pad.; 3055///; 3056/// One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; 3057/// value for the maximum or the minimum scale on the plot.; 3058///; 3059/// TH1::UseCurrentStyle can be used to change all histogram graphics; 3060/// attributes to correspond to the current selected style.; 3061/// This function must be called for each histogram.; 3062/// In case one reads and draws many histograms from a file, one can force; 3063/// the histograms to inherit automatically the current graphics style; 3064/// by c",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:128933,Deployability,release,released,128933," nbinsx = fXaxis.GetNbins();; 3213 Int_t nbinsy = fYaxis.GetNbins();; 3214 Int_t nbinsz = fZaxis.GetNbins();; 3215 if (!add) Reset();; 3216 ; 3217 for (Int_t binz = 1; binz <= nbinsz; ++binz) {; 3218 x[2] = fZaxis.GetBinCenter(binz);; 3219 for (Int_t biny = 1; biny <= nbinsy; ++biny) {; 3220 x[1] = fYaxis.GetBinCenter(biny);; 3221 for (Int_t binx = 1; binx <= nbinsx; ++binx) {; 3222 Int_t bin = GetBin(binx,biny,binz);; 3223 x[0] = fXaxis.GetBinCenter(binx);; 3224 if (range && !f1->IsInside(x)) continue;; 3225 Double_t fu = f1->Eval(x[0], x[1], x[2]);; 3226 if (stat) fu = gRandom->PoissonD(fu);; 3227 AddBinContent(bin, fu);; 3228 if (fSumw2.fN) fSumw2.fArray[bin] += TMath::Abs(fu);; 3229 }; 3230 }; 3231 }; 3232}; 3233 ; 3234////////////////////////////////////////////////////////////////////////////////; 3235/// Execute action corresponding to one event.; 3236///; 3237/// This member function is called when a histogram is clicked with the locator; 3238///; 3239/// If Left button clicked on the bin top value, then the content of this bin; 3240/// is modified according to the new position of the mouse when it is released.; 3241 ; 3242void TH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); 3243{; 3244 if (fPainter) fPainter->ExecuteEvent(event, px, py);; 3245}; 3246 ; 3247////////////////////////////////////////////////////////////////////////////////; 3248/// This function allows to do discrete Fourier transforms of TH1 and TH2.; 3249/// Available transform types and flags are described below.; 3250///; 3251/// To extract more information about the transform, use the function; 3252/// TVirtualFFT::GetCurrentTransform() to get a pointer to the current; 3253/// transform object.; 3254///; 3255/// \param[out] h_output histogram for the output. If a null pointer is passed, a new histogram is created; 3256/// and returned, otherwise, the provided histogram is used and should be big enough; 3257/// \param[in] option option parameters consists of 3 parts:; 3258/// - option on",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:139622,Deployability,integrat,integrated,139622,"ide); 3476{; 3477 Int_t bin,i;; 3478 ; 3479 fEntries += ntimes;; 3480 Double_t ww = 1;; 3481 Int_t nbins = fXaxis.GetNbins();; 3482 ntimes *= stride;; 3483 for (i=0;i<ntimes;i+=stride) {; 3484 bin =fXaxis.FindBin(x[i]);; 3485 if (bin <0) continue;; 3486 if (w) ww = w[i];; 3487 if (!fSumw2.fN && ww != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2();; 3488 if (fSumw2.fN) fSumw2.fArray[bin] += ww*ww;; 3489 AddBinContent(bin, ww);; 3490 if (bin == 0 || bin > nbins) {; 3491 if (!GetStatOverflowsBehaviour()) continue;; 3492 }; 3493 Double_t z= ww;; 3494 fTsumw += z;; 3495 fTsumw2 += z*z;; 3496 fTsumwx += z*x[i];; 3497 fTsumwx2 += z*x[i]*x[i];; 3498 }; 3499}; 3500 ; 3501////////////////////////////////////////////////////////////////////////////////; 3502/// Fill histogram following distribution in function fname.; 3503///; 3504/// @param fname : Function name used for filling the histogram; 3505/// @param ntimes : number of times the histogram is filled; 3506/// @param rng : (optional) Random number generator used to sample; 3507///; 3508///; 3509/// The distribution contained in the function fname (TF1) is integrated; 3510/// over the channel contents for the bin range of this histogram.; 3511/// It is normalized to 1.; 3512///; 3513/// Getting one random number implies:; 3514/// - Generating a random number between 0 and 1 (say r1); 3515/// - Look in which bin in the normalized integral r1 corresponds to; 3516/// - Fill histogram channel; 3517/// ntimes random numbers are generated; 3518///; 3519/// One can also call TF1::GetRandom to get a random variate from a function.; 3520 ; 3521void TH1::FillRandom(const char *fname, Int_t ntimes, TRandom * rng); 3522{; 3523 Int_t bin, binx, ibin, loop;; 3524 Double_t r1, x;; 3525 // - Search for fname in the list of ROOT defined functions; 3526 TF1 *f1 = (TF1*)gROOT->GetFunction(fname);; 3527 if (!f1) { Error(""FillRandom"", ""Unknown function: %s"",fname); return; }; 3528 ; 3529 // - Allocate temporary space to store the integral and compute ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:142467,Deployability,integrat,integrated,142467," 3554 delete [] integral;; 3555 Error(""FillRandom"", ""Integral = zero""); return;; 3556 }; 3557 for (bin=1;bin<=nbinsx;bin++) integral[bin] /= integral[nbinsx];; 3558 ; 3559 // --------------Start main loop ntimes; 3560 for (loop=0;loop<ntimes;loop++) {; 3561 r1 = (rng) ? rng->Rndm() : gRandom->Rndm();; 3562 ibin = TMath::BinarySearch(nbinsx,&integral[0],r1);; 3563 //binx = 1 + ibin;; 3564 //x = xAxis->GetBinCenter(binx); //this is not OK when SetBuffer is used; 3565 x = xAxis->GetBinLowEdge(ibin+first); 3566 +xAxis->GetBinWidth(ibin+first)*(r1-integral[ibin])/(integral[ibin+1] - integral[ibin]);; 3567 Fill(x);; 3568 }; 3569 delete [] integral;; 3570}; 3571 ; 3572////////////////////////////////////////////////////////////////////////////////; 3573/// Fill histogram following distribution in histogram h.; 3574///; 3575/// @param h : Histogram pointer used for sampling random number; 3576/// @param ntimes : number of times the histogram is filled; 3577/// @param rng : (optional) Random number generator used for sampling; 3578///; 3579/// The distribution contained in the histogram h (TH1) is integrated; 3580/// over the channel contents for the bin range of this histogram.; 3581/// It is normalized to 1.; 3582///; 3583/// Getting one random number implies:; 3584/// - Generating a random number between 0 and 1 (say r1); 3585/// - Look in which bin in the normalized integral r1 corresponds to; 3586/// - Fill histogram channel ntimes random numbers are generated; 3587///; 3588/// SPECIAL CASE when the target histogram has the same binning as the source.; 3589/// in this case we simply use a poisson distribution where; 3590/// the mean value per bin = bincontent/integral.; 3591 ; 3592void TH1::FillRandom(TH1 *h, Int_t ntimes, TRandom * rng); 3593{; 3594 if (!h) { Error(""FillRandom"", ""Null histogram""); return; }; 3595 if (fDimension != h->GetDimension()) {; 3596 Error(""FillRandom"", ""Histograms with different dimensions""); return;; 3597 }; 3598 if (std::isnan(h->ComputeIntegr",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:159880,Deployability,configurat,configuration,159880,"eters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; 3963/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 3964/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 3965/// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); 3966/// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; 3967/// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; 3968///; 3969/// The default fitting of an histogram (when no option is given) is perfomed as following:; 3970/// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; 3971/// - the full range of the histogram is used;; 3972/// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; 3973/// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; 3974/// - only the status of the fit is returned;; 3975/// - the fit is performed in Multithread whenever is enabled in ROOT;; 3976/// - only the last fitted function is saved in the histogram;; 3977/// - the histogram is drawn after fitting overalyed with the resulting fitting function; 3978///; 3979/// \anchor HFitMinimizer; 3980/// ### Minimizer Configuration; 3981///; 3982/// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; 3983/// It is possible to change the default minimizer and its configuration parameters by calling thes",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:160654,Deployability,configurat,configuration,160654,"zero errors (empty bins);; 3971/// - the full range of the histogram is used;; 3972/// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; 3973/// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; 3974/// - only the status of the fit is returned;; 3975/// - the fit is performed in Multithread whenever is enabled in ROOT;; 3976/// - only the last fitted function is saved in the histogram;; 3977/// - the histogram is drawn after fitting overalyed with the resulting fitting function; 3978///; 3979/// \anchor HFitMinimizer; 3980/// ### Minimizer Configuration; 3981///; 3982/// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; 3983/// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; 3984/// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; 3985/// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; 3986/// The current defaults are (""Minuit"",""Migrad"").; 3987/// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; 3988/// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; 3989/// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; 3990/// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; 3991///; 3992/// Other options are possible dependi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:260756,Deployability,update,update,260756,"orm), where norm; 6601/// is the desired normalization divided by the integral of the histogram.; 6602///; 6603/// If option contains ""width"" the bin contents and errors are divided; 6604/// by the bin width.; 6605 ; 6606void TH1::Scale(Double_t c1, Option_t *option); 6607{; 6608 ; 6609 TString opt = option; opt.ToLower();; 6610 // store bin errors when scaling since cannot anymore be computed as sqrt(N); 6611 if (!opt.Contains(""nosw2"") && GetSumw2N() == 0) Sumw2();; 6612 if (opt.Contains(""width"")) Add(this, this, c1, -1);; 6613 else {; 6614 if (fBuffer) BufferEmpty(1);; 6615 for(Int_t i = 0; i < fNcells; ++i) UpdateBinContent(i, c1 * RetrieveBinContent(i));; 6616 if (fSumw2.fN) for(Int_t i = 0; i < fNcells; ++i) fSumw2.fArray[i] *= (c1 * c1); // update errors; 6617 // update global histograms statistics; 6618 Double_t s[kNstat] = {0};; 6619 GetStats(s);; 6620 for (Int_t i=0 ; i < kNstat; i++) {; 6621 if (i == 1) s[i] = c1*c1*s[i];; 6622 else s[i] = c1*s[i];; 6623 }; 6624 PutStats(s);; 6625 SetMinimum(); SetMaximum(); // minimum and maximum value will be recalculated the next time; 6626 }; 6627 ; 6628 // if contours set, must also scale contours; 6629 Int_t ncontours = GetContour();; 6630 if (ncontours == 0) return;; 6631 Double_t* levels = fContour.GetArray();; 6632 for (Int_t i = 0; i < ncontours; ++i) levels[i] *= c1;; 6633}; 6634 ; 6635////////////////////////////////////////////////////////////////////////////////; 6636/// Returns true if all axes are extendable.; 6637 ; 6638Bool_t TH1::CanExtendAllAxes() const; 6639{; 6640 Bool_t canExtend = fXaxis.CanExtend();; 6641 if (GetDimension() > 1) canExtend &= fYaxis.CanExtend();; 6642 if (GetDimension() > 2) canExtend &= fZaxis.CanExtend();; 6643 ; 6644 return canExtend;; 6645}; 6646 ; 6647////////////////////////////////////////////////////////////////////////////////; 6648/// Make the histogram axes extendable / not extendable according to the bit mask; 6649/// returns the previous bit mask specifying which axes a",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:260779,Deployability,update,update,260779,"orm), where norm; 6601/// is the desired normalization divided by the integral of the histogram.; 6602///; 6603/// If option contains ""width"" the bin contents and errors are divided; 6604/// by the bin width.; 6605 ; 6606void TH1::Scale(Double_t c1, Option_t *option); 6607{; 6608 ; 6609 TString opt = option; opt.ToLower();; 6610 // store bin errors when scaling since cannot anymore be computed as sqrt(N); 6611 if (!opt.Contains(""nosw2"") && GetSumw2N() == 0) Sumw2();; 6612 if (opt.Contains(""width"")) Add(this, this, c1, -1);; 6613 else {; 6614 if (fBuffer) BufferEmpty(1);; 6615 for(Int_t i = 0; i < fNcells; ++i) UpdateBinContent(i, c1 * RetrieveBinContent(i));; 6616 if (fSumw2.fN) for(Int_t i = 0; i < fNcells; ++i) fSumw2.fArray[i] *= (c1 * c1); // update errors; 6617 // update global histograms statistics; 6618 Double_t s[kNstat] = {0};; 6619 GetStats(s);; 6620 for (Int_t i=0 ; i < kNstat; i++) {; 6621 if (i == 1) s[i] = c1*c1*s[i];; 6622 else s[i] = c1*s[i];; 6623 }; 6624 PutStats(s);; 6625 SetMinimum(); SetMaximum(); // minimum and maximum value will be recalculated the next time; 6626 }; 6627 ; 6628 // if contours set, must also scale contours; 6629 Int_t ncontours = GetContour();; 6630 if (ncontours == 0) return;; 6631 Double_t* levels = fContour.GetArray();; 6632 for (Int_t i = 0; i < ncontours; ++i) levels[i] *= c1;; 6633}; 6634 ; 6635////////////////////////////////////////////////////////////////////////////////; 6636/// Returns true if all axes are extendable.; 6637 ; 6638Bool_t TH1::CanExtendAllAxes() const; 6639{; 6640 Bool_t canExtend = fXaxis.CanExtend();; 6641 if (GetDimension() > 1) canExtend &= fYaxis.CanExtend();; 6642 if (GetDimension() > 2) canExtend &= fZaxis.CanExtend();; 6643 ; 6644 return canExtend;; 6645}; 6646 ; 6647////////////////////////////////////////////////////////////////////////////////; 6648/// Make the histogram axes extendable / not extendable according to the bit mask; 6649/// returns the previous bit mask specifying which axes a",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:278623,Deployability,update,update,278623," contents, errors, etc.; 7099/// \param[in] option; 7100/// - if ""ICE"" is specified, resets only Integral, Contents and Errors.; 7101/// - if ""ICES"" is specified, resets only Integral, Contents, Errors and Statistics; 7102/// This option is used; 7103/// - if ""M"" is specified, resets also Minimum and Maximum; 7104 ; 7105void TH1::Reset(Option_t *option); 7106{; 7107 // The option ""ICE"" is used when extending the histogram (in ExtendAxis, LabelInflate, etc..); 7108 // The option ""ICES is used in combination with the buffer (see BufferEmpty and BufferFill); 7109 ; 7110 TString opt = option;; 7111 opt.ToUpper();; 7112 fSumw2.Reset();; 7113 if (fIntegral) {; 7114 delete [] fIntegral;; 7115 fIntegral = nullptr;; 7116 }; 7117 ; 7118 if (opt.Contains(""M"")) {; 7119 SetMinimum();; 7120 SetMaximum();; 7121 }; 7122 ; 7123 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 7124 ; 7125 // Setting fBuffer[0] = 0 is like resetting the buffer but not deleting it; 7126 // But what is the sense of calling BufferEmpty() ? For making the axes ?; 7127 // BufferEmpty will update contents that later will be; 7128 // reset in calling TH1D::Reset. For this we need to reset the stats afterwards; 7129 // It may be needed for computing the axis limits....; 7130 if (fBuffer) {BufferEmpty(); fBuffer[0] = 0;}; 7131 ; 7132 // need to reset also the statistics; 7133 // (needs to be done after calling BufferEmpty() ); 7134 fTsumw = 0;; 7135 fTsumw2 = 0;; 7136 fTsumwx = 0;; 7137 fTsumwx2 = 0;; 7138 fEntries = 0;; 7139 ; 7140 if (opt == ""ICES"") return;; 7141 ; 7142 ; 7143 TObject *stats = fFunctions->FindObject(""stats"");; 7144 fFunctions->Remove(stats);; 7145 //special logic to support the case where the same object is; 7146 //added multiple times in fFunctions.; 7147 //This case happens when the same object is added with different; 7148 //drawing modes; 7149 TObject *obj;; 7150 while ((obj = fFunctions->First())) {; 7151 while(fFunctions->Remove(obj)) { }; 7152 delete obj;; 7153 }; 7154 if(stats",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:280355,Deployability,install,install,280355," 7146 //added multiple times in fFunctions.; 7147 //This case happens when the same object is added with different; 7148 //drawing modes; 7149 TObject *obj;; 7150 while ((obj = fFunctions->First())) {; 7151 while(fFunctions->Remove(obj)) { }; 7152 delete obj;; 7153 }; 7154 if(stats) fFunctions->Add(stats);; 7155 fContour.Set(0);; 7156}; 7157 ; 7158////////////////////////////////////////////////////////////////////////////////; 7159/// Save the histogram as .csv, .tsv or .txt. In case of any other extension, fall; 7160/// back to TObject::SaveAs, which saves as a .C macro (but with the file name; 7161/// extension specified by the user); 7162///; 7163/// The Under/Overflow bins are also exported (as first and last lines); 7164/// The fist 2 columns are the lower and upper edges of the bins; 7165/// Column 3 contains the bin contents; 7166/// The last column contains the error in y. If errors are not present, the column; 7167/// is left empty; 7168///; 7169/// The result can be immediately imported into Excel, gnuplot, Python or whatever,; 7170/// without the needing to install pyroot, etc.; 7171///; 7172/// \param filename the name of the file where to store the histogram; 7173/// \param option some tuning options; 7174///; 7175/// The file extension defines the delimiter used:; 7176/// - `.csv` : comma; 7177/// - `.tsv` : tab; 7178/// - `.txt` : space; 7179///; 7180/// If option = ""title"" a title line is generated. If the y-axis has a title,; 7181/// this title is displayed as column 3 name, otherwise, it shows ""BinContent""; 7182 ; 7183void TH1::SaveAs(const char *filename, Option_t *option) const; 7184{; 7185 char del = '\0';; 7186 TString ext = """";; 7187 TString fname = filename;; 7188 TString opt = option;; 7189 ; 7190 if (filename) {; 7191 if (fname.EndsWith("".csv"")) {; 7192 del = ',';; 7193 ext = ""csv"";; 7194 } else if (fname.EndsWith("".tsv"")) {; 7195 del = '\t';; 7196 ext = ""tsv"";; 7197 } else if (fname.EndsWith("".txt"")) {; 7198 del = ' ';; 7199 ext = ""txt"";;",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:349987,Deployability,update,update,349987,"Directory == dir) return;; 8942 if (fDirectory) fDirectory->Remove(this);; 8943 fDirectory = dir;; 8944 if (fDirectory) {; 8945 fFunctions->UseRWLock();; 8946 fDirectory->Append(this);; 8947 }; 8948}; 8949 ; 8950////////////////////////////////////////////////////////////////////////////////; 8951/// Replace bin errors by values in array error.; 8952 ; 8953void TH1::SetError(const Double_t *error); 8954{; 8955 for (Int_t i = 0; i < fNcells; ++i) SetBinError(i, error[i]);; 8956}; 8957 ; 8958////////////////////////////////////////////////////////////////////////////////; 8959/// Change the name of this histogram; 8960///; 8961 ; 8962void TH1::SetName(const char *name); 8963{; 8964 // Histograms are named objects in a THashList.; 8965 // We must update the hashlist if we change the name; 8966 // We protect this operation; 8967 R__LOCKGUARD(gROOTMutex);; 8968 if (fDirectory) fDirectory->Remove(this);; 8969 fName = name;; 8970 if (fDirectory) fDirectory->Append(this);; 8971}; 8972 ; 8973////////////////////////////////////////////////////////////////////////////////; 8974/// Change the name and title of this histogram; 8975 ; 8976void TH1::SetNameTitle(const char *name, const char *title); 8977{; 8978 // Histograms are named objects in a THashList.; 8979 // We must update the hashlist if we change the name; 8980 SetName(name);; 8981 SetTitle(title);; 8982}; 8983 ; 8984////////////////////////////////////////////////////////////////////////////////; 8985/// Set statistics option on/off.; 8986///; 8987/// By default, the statistics box is drawn.; 8988/// The paint options can be selected via gStyle->SetOptStat.; 8989/// This function sets/resets the kNoStats bit in the histogram object.; 8990/// It has priority over the Style option.; 8991 ; 8992void TH1::SetStats(Bool_t stats); 8993{; 8994 ResetBit(kNoStats);; 8995 if (!stats) {; 8996 SetBit(kNoStats);; 8997 //remove the ""stats"" object from the list of functions; 8998 if (fFunctions) {; 8999 TObject *obj = fFunctions->Fi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:350515,Deployability,update,update,350515,"ouble_t *error); 8954{; 8955 for (Int_t i = 0; i < fNcells; ++i) SetBinError(i, error[i]);; 8956}; 8957 ; 8958////////////////////////////////////////////////////////////////////////////////; 8959/// Change the name of this histogram; 8960///; 8961 ; 8962void TH1::SetName(const char *name); 8963{; 8964 // Histograms are named objects in a THashList.; 8965 // We must update the hashlist if we change the name; 8966 // We protect this operation; 8967 R__LOCKGUARD(gROOTMutex);; 8968 if (fDirectory) fDirectory->Remove(this);; 8969 fName = name;; 8970 if (fDirectory) fDirectory->Append(this);; 8971}; 8972 ; 8973////////////////////////////////////////////////////////////////////////////////; 8974/// Change the name and title of this histogram; 8975 ; 8976void TH1::SetNameTitle(const char *name, const char *title); 8977{; 8978 // Histograms are named objects in a THashList.; 8979 // We must update the hashlist if we change the name; 8980 SetName(name);; 8981 SetTitle(title);; 8982}; 8983 ; 8984////////////////////////////////////////////////////////////////////////////////; 8985/// Set statistics option on/off.; 8986///; 8987/// By default, the statistics box is drawn.; 8988/// The paint options can be selected via gStyle->SetOptStat.; 8989/// This function sets/resets the kNoStats bit in the histogram object.; 8990/// It has priority over the Style option.; 8991 ; 8992void TH1::SetStats(Bool_t stats); 8993{; 8994 ResetBit(kNoStats);; 8995 if (!stats) {; 8996 SetBit(kNoStats);; 8997 //remove the ""stats"" object from the list of functions; 8998 if (fFunctions) {; 8999 TObject *obj = fFunctions->FindObject(""stats"");; 9000 if (obj) {; 9001 fFunctions->Remove(obj);; 9002 delete obj;; 9003 }; 9004 }; 9005 }; 9006}; 9007 ; 9008////////////////////////////////////////////////////////////////////////////////; 9009/// Create structure to store sum of squares of weights.; 9010///; 9011/// if histogram is already filled, the sum of squares of weights; 9012/// is filled with the existi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:368481,Deployability,update,update,368481,"1; ind[1] = biny-1;; 9409 fft->GetPointComplex(ind, re, im);; 9410 if (TMath::Abs(re) > 1e-13){; 9411 ph = TMath::ATan(im/re);; 9412 //find the correct quadrant; 9413 if (re<0 && im<0); 9414 ph -= TMath::Pi();; 9415 if (re<0 && im>=0); 9416 ph += TMath::Pi();; 9417 } else {; 9418 if (TMath::Abs(im) < 1e-13); 9419 ph = 0;; 9420 else if (im>0); 9421 ph = TMath::Pi()*0.5;; 9422 else; 9423 ph = -TMath::Pi()*0.5;; 9424 }; 9425 hout->SetBinContent(binx, biny, ph);; 9426 }; 9427 }; 9428 } else {; 9429 printf(""Pure real output, no phase"");; 9430 return nullptr;; 9431 }; 9432 }; 9433 ; 9434 return hout;; 9435}; 9436 ; 9437////////////////////////////////////////////////////////////////////////////////; 9438/// Raw retrieval of bin content on internal data structure; 9439/// see convention for numbering bins in TH1::GetBin; 9440 ; 9441Double_t TH1::RetrieveBinContent(Int_t) const; 9442{; 9443 AbstractMethod(""RetrieveBinContent"");; 9444 return 0;; 9445}; 9446 ; 9447////////////////////////////////////////////////////////////////////////////////; 9448/// Raw update of bin content on internal data structure; 9449/// see convention for numbering bins in TH1::GetBin; 9450 ; 9451void TH1::UpdateBinContent(Int_t, Double_t); 9452{; 9453 AbstractMethod(""UpdateBinContent"");; 9454}; 9455 ; 9456////////////////////////////////////////////////////////////////////////////////; 9457/// Print value overload; 9458 ; 9459std::string cling::printValue(TH1 *val) {; 9460 std::ostringstream strm;; 9461 strm << cling::printValue((TObject*)val) << "" NbinsX: "" << val->GetNbinsX();; 9462 return strm.str();; 9463}; 9464 ; 9465//______________________________________________________________________________; 9466// TH1C methods; 9467// TH1C : histograms with one byte per channel. Maximum bin content = 127; 9468//______________________________________________________________________________; 9469 ; 9470ClassImp(TH1C);; 9471 ; 9472////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:454400,Deployability,update,update,454400,"Merge(TCollection *list)Definition TH1.h:345; TH1::SetColorsvirtual void SetColors(Color_t linecolor=-1, Color_t markercolor=-1, Color_t fillcolor=-1)Shortcut to set the three histogram colors with a single call.Definition TH1.cxx:4467; TH1::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TH1.cxx:3240; TH1::GetIntegralvirtual Double_t * GetIntegral()Return a pointer to the array of bins integral.Definition TH1.cxx:2586; TH1::fZaxisTAxis fZaxisZ axis descriptor.Definition TH1.h:92; TH1::fStatOverflowsEStatOverflows fStatOverflowsPer object flag to use under/overflows in statistics.Definition TH1.h:114; TH1::IsATClass * IsA() const overrideDefinition TH1.h:444; TH1::FillNvirtual void FillN(Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1)Fill this histogram with an array x and weights w.Definition TH1.cxx:3447; TH1::UpdateBinContentvirtual void UpdateBinContent(Int_t bin, Double_t content)Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.cxx:9449; TH1::CheckEqualAxesstatic bool CheckEqualAxes(const TAxis *a1, const TAxis *a2)Check that the axis are the same.Definition TH1.cxx:1611; TH1::kPoisson2@ kPoisson2Errors from Poisson interval at 95% CL (~ 2 sigma)Definition TH1.h:67; TH1::kNormal@ kNormalErrors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N)Definition TH1.h:65; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetContourvirtual Int_t GetContour(Double_t *levels=nullptr)Return contour values into array levels if pointer levels is non zero.Definition TH1.cxx:8411; TH1::fXaxisTAxis fXaxisX axis descriptor.Definition TH1.h:90; TH1::IsHighlightvirtual Bool_t IsHighlight() constDefinition TH1.h:338; TH1::ExtendAxisvirtual void ExtendAxis(Double_t x, TAxis *axis)Histogram is resized along axis such that x is in the axi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:51440,Energy Efficiency,power,power,51440,"ehavior; 1276 ; 1277void TH1::AddBinContent(Int_t, Double_t); 1278{; 1279 AbstractMethod(""AddBinContent"");; 1280}; 1281 ; 1282////////////////////////////////////////////////////////////////////////////////; 1283/// Sets the flag controlling the automatic add of histograms in memory; 1284///; 1285/// By default (fAddDirectory = kTRUE), histograms are automatically added; 1286/// to the list of objects in memory.; 1287/// Note that one histogram can be removed from its support directory; 1288/// by calling h->SetDirectory(nullptr) or h->SetDirectory(dir) to add it; 1289/// to the list of objects in the directory dir.; 1290///; 1291/// NOTE that this is a static function. To call it, use;; 1292/// TH1::AddDirectory; 1293 ; 1294void TH1::AddDirectory(Bool_t add); 1295{; 1296 fgAddDirectory = add;; 1297}; 1298 ; 1299////////////////////////////////////////////////////////////////////////////////; 1300/// Auxiliary function to get the power of 2 next (larger) or previous (smaller); 1301/// a given x; 1302///; 1303/// next = kTRUE : next larger; 1304/// next = kFALSE : previous smaller; 1305///; 1306/// Used by the autobin power of 2 algorithm; 1307 ; 1308inline Double_t TH1::AutoP2GetPower2(Double_t x, Bool_t next); 1309{; 1310 Int_t nn;; 1311 Double_t f2 = std::frexp(x, &nn);; 1312 return ((next && x > 0.) || (!next && x <= 0.)) ? std::ldexp(std::copysign(1., f2), nn); 1313 : std::ldexp(std::copysign(1., f2), --nn);; 1314}; 1315 ; 1316////////////////////////////////////////////////////////////////////////////////; 1317/// Auxiliary function to get the next power of 2 integer value larger then n; 1318///; 1319/// Used by the autobin power of 2 algorithm; 1320 ; 1321inline Int_t TH1::AutoP2GetBins(Int_t n); 1322{; 1323 Int_t nn;; 1324 Double_t f2 = std::frexp(n, &nn);; 1325 if (TMath::Abs(f2 - .5) > 0.001); 1326 return (Int_t)std::ldexp(1., nn);; 1327 return n;; 1328}; 1329 ; 1330////////////////////////////////////////////////////////////////////////////////; 1331/// Bu",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:51631,Energy Efficiency,power,power,51631,"ehavior; 1276 ; 1277void TH1::AddBinContent(Int_t, Double_t); 1278{; 1279 AbstractMethod(""AddBinContent"");; 1280}; 1281 ; 1282////////////////////////////////////////////////////////////////////////////////; 1283/// Sets the flag controlling the automatic add of histograms in memory; 1284///; 1285/// By default (fAddDirectory = kTRUE), histograms are automatically added; 1286/// to the list of objects in memory.; 1287/// Note that one histogram can be removed from its support directory; 1288/// by calling h->SetDirectory(nullptr) or h->SetDirectory(dir) to add it; 1289/// to the list of objects in the directory dir.; 1290///; 1291/// NOTE that this is a static function. To call it, use;; 1292/// TH1::AddDirectory; 1293 ; 1294void TH1::AddDirectory(Bool_t add); 1295{; 1296 fgAddDirectory = add;; 1297}; 1298 ; 1299////////////////////////////////////////////////////////////////////////////////; 1300/// Auxiliary function to get the power of 2 next (larger) or previous (smaller); 1301/// a given x; 1302///; 1303/// next = kTRUE : next larger; 1304/// next = kFALSE : previous smaller; 1305///; 1306/// Used by the autobin power of 2 algorithm; 1307 ; 1308inline Double_t TH1::AutoP2GetPower2(Double_t x, Bool_t next); 1309{; 1310 Int_t nn;; 1311 Double_t f2 = std::frexp(x, &nn);; 1312 return ((next && x > 0.) || (!next && x <= 0.)) ? std::ldexp(std::copysign(1., f2), nn); 1313 : std::ldexp(std::copysign(1., f2), --nn);; 1314}; 1315 ; 1316////////////////////////////////////////////////////////////////////////////////; 1317/// Auxiliary function to get the next power of 2 integer value larger then n; 1318///; 1319/// Used by the autobin power of 2 algorithm; 1320 ; 1321inline Int_t TH1::AutoP2GetBins(Int_t n); 1322{; 1323 Int_t nn;; 1324 Double_t f2 = std::frexp(n, &nn);; 1325 if (TMath::Abs(f2 - .5) > 0.001); 1326 return (Int_t)std::ldexp(1., nn);; 1327 return n;; 1328}; 1329 ; 1330////////////////////////////////////////////////////////////////////////////////; 1331/// Bu",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:52076,Energy Efficiency,power,power,52076,"r.; 1290///; 1291/// NOTE that this is a static function. To call it, use;; 1292/// TH1::AddDirectory; 1293 ; 1294void TH1::AddDirectory(Bool_t add); 1295{; 1296 fgAddDirectory = add;; 1297}; 1298 ; 1299////////////////////////////////////////////////////////////////////////////////; 1300/// Auxiliary function to get the power of 2 next (larger) or previous (smaller); 1301/// a given x; 1302///; 1303/// next = kTRUE : next larger; 1304/// next = kFALSE : previous smaller; 1305///; 1306/// Used by the autobin power of 2 algorithm; 1307 ; 1308inline Double_t TH1::AutoP2GetPower2(Double_t x, Bool_t next); 1309{; 1310 Int_t nn;; 1311 Double_t f2 = std::frexp(x, &nn);; 1312 return ((next && x > 0.) || (!next && x <= 0.)) ? std::ldexp(std::copysign(1., f2), nn); 1313 : std::ldexp(std::copysign(1., f2), --nn);; 1314}; 1315 ; 1316////////////////////////////////////////////////////////////////////////////////; 1317/// Auxiliary function to get the next power of 2 integer value larger then n; 1318///; 1319/// Used by the autobin power of 2 algorithm; 1320 ; 1321inline Int_t TH1::AutoP2GetBins(Int_t n); 1322{; 1323 Int_t nn;; 1324 Double_t f2 = std::frexp(n, &nn);; 1325 if (TMath::Abs(f2 - .5) > 0.001); 1326 return (Int_t)std::ldexp(1., nn);; 1327 return n;; 1328}; 1329 ; 1330////////////////////////////////////////////////////////////////////////////////; 1331/// Buffer-based estimate of the histogram range using the power of 2 algorithm.; 1332///; 1333/// Used by the autobin power of 2 algorithm.; 1334///; 1335/// Works on arguments (min and max from fBuffer) and internal inputs: fXmin,; 1336/// fXmax, NBinsX (from fXaxis), ...; 1337/// Result save internally in fXaxis.; 1338///; 1339/// Overloaded by TH2 and TH3.; 1340///; 1341/// Return -1 if internal inputs are inconsistent, 0 otherwise.; 1342 ; 1343Int_t TH1::AutoP2FindLimits(Double_t xmi, Double_t xma); 1344{; 1345 // We need meaningful raw limits; 1346 if (xmi >= xma); 1347 return -1;; 1348 ; 1349 THLimitsFinder::GetLi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:52153,Energy Efficiency,power,power,52153,"r.; 1290///; 1291/// NOTE that this is a static function. To call it, use;; 1292/// TH1::AddDirectory; 1293 ; 1294void TH1::AddDirectory(Bool_t add); 1295{; 1296 fgAddDirectory = add;; 1297}; 1298 ; 1299////////////////////////////////////////////////////////////////////////////////; 1300/// Auxiliary function to get the power of 2 next (larger) or previous (smaller); 1301/// a given x; 1302///; 1303/// next = kTRUE : next larger; 1304/// next = kFALSE : previous smaller; 1305///; 1306/// Used by the autobin power of 2 algorithm; 1307 ; 1308inline Double_t TH1::AutoP2GetPower2(Double_t x, Bool_t next); 1309{; 1310 Int_t nn;; 1311 Double_t f2 = std::frexp(x, &nn);; 1312 return ((next && x > 0.) || (!next && x <= 0.)) ? std::ldexp(std::copysign(1., f2), nn); 1313 : std::ldexp(std::copysign(1., f2), --nn);; 1314}; 1315 ; 1316////////////////////////////////////////////////////////////////////////////////; 1317/// Auxiliary function to get the next power of 2 integer value larger then n; 1318///; 1319/// Used by the autobin power of 2 algorithm; 1320 ; 1321inline Int_t TH1::AutoP2GetBins(Int_t n); 1322{; 1323 Int_t nn;; 1324 Double_t f2 = std::frexp(n, &nn);; 1325 if (TMath::Abs(f2 - .5) > 0.001); 1326 return (Int_t)std::ldexp(1., nn);; 1327 return n;; 1328}; 1329 ; 1330////////////////////////////////////////////////////////////////////////////////; 1331/// Buffer-based estimate of the histogram range using the power of 2 algorithm.; 1332///; 1333/// Used by the autobin power of 2 algorithm.; 1334///; 1335/// Works on arguments (min and max from fBuffer) and internal inputs: fXmin,; 1336/// fXmax, NBinsX (from fXaxis), ...; 1337/// Result save internally in fXaxis.; 1338///; 1339/// Overloaded by TH2 and TH3.; 1340///; 1341/// Return -1 if internal inputs are inconsistent, 0 otherwise.; 1342 ; 1343Int_t TH1::AutoP2FindLimits(Double_t xmi, Double_t xma); 1344{; 1345 // We need meaningful raw limits; 1346 if (xmi >= xma); 1347 return -1;; 1348 ; 1349 THLimitsFinder::GetLi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:52549,Energy Efficiency,power,power,52549,"r previous (smaller); 1301/// a given x; 1302///; 1303/// next = kTRUE : next larger; 1304/// next = kFALSE : previous smaller; 1305///; 1306/// Used by the autobin power of 2 algorithm; 1307 ; 1308inline Double_t TH1::AutoP2GetPower2(Double_t x, Bool_t next); 1309{; 1310 Int_t nn;; 1311 Double_t f2 = std::frexp(x, &nn);; 1312 return ((next && x > 0.) || (!next && x <= 0.)) ? std::ldexp(std::copysign(1., f2), nn); 1313 : std::ldexp(std::copysign(1., f2), --nn);; 1314}; 1315 ; 1316////////////////////////////////////////////////////////////////////////////////; 1317/// Auxiliary function to get the next power of 2 integer value larger then n; 1318///; 1319/// Used by the autobin power of 2 algorithm; 1320 ; 1321inline Int_t TH1::AutoP2GetBins(Int_t n); 1322{; 1323 Int_t nn;; 1324 Double_t f2 = std::frexp(n, &nn);; 1325 if (TMath::Abs(f2 - .5) > 0.001); 1326 return (Int_t)std::ldexp(1., nn);; 1327 return n;; 1328}; 1329 ; 1330////////////////////////////////////////////////////////////////////////////////; 1331/// Buffer-based estimate of the histogram range using the power of 2 algorithm.; 1332///; 1333/// Used by the autobin power of 2 algorithm.; 1334///; 1335/// Works on arguments (min and max from fBuffer) and internal inputs: fXmin,; 1336/// fXmax, NBinsX (from fXaxis), ...; 1337/// Result save internally in fXaxis.; 1338///; 1339/// Overloaded by TH2 and TH3.; 1340///; 1341/// Return -1 if internal inputs are inconsistent, 0 otherwise.; 1342 ; 1343Int_t TH1::AutoP2FindLimits(Double_t xmi, Double_t xma); 1344{; 1345 // We need meaningful raw limits; 1346 if (xmi >= xma); 1347 return -1;; 1348 ; 1349 THLimitsFinder::GetLimitsFinder()->FindGoodLimits(this, xmi, xma);; 1350 Double_t xhmi = fXaxis.GetXmin();; 1351 Double_t xhma = fXaxis.GetXmax();; 1352 ; 1353 // Now adjust; 1354 if (TMath::Abs(xhma) > TMath::Abs(xhmi)) {; 1355 // Start from the upper limit; 1356 xhma = TH1::AutoP2GetPower2(xhma);; 1357 xhmi = xhma - TH1::AutoP2GetPower2(xhma - xhmi);; 1358 } else {",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:52609,Energy Efficiency,power,power,52609,"/; 1306/// Used by the autobin power of 2 algorithm; 1307 ; 1308inline Double_t TH1::AutoP2GetPower2(Double_t x, Bool_t next); 1309{; 1310 Int_t nn;; 1311 Double_t f2 = std::frexp(x, &nn);; 1312 return ((next && x > 0.) || (!next && x <= 0.)) ? std::ldexp(std::copysign(1., f2), nn); 1313 : std::ldexp(std::copysign(1., f2), --nn);; 1314}; 1315 ; 1316////////////////////////////////////////////////////////////////////////////////; 1317/// Auxiliary function to get the next power of 2 integer value larger then n; 1318///; 1319/// Used by the autobin power of 2 algorithm; 1320 ; 1321inline Int_t TH1::AutoP2GetBins(Int_t n); 1322{; 1323 Int_t nn;; 1324 Double_t f2 = std::frexp(n, &nn);; 1325 if (TMath::Abs(f2 - .5) > 0.001); 1326 return (Int_t)std::ldexp(1., nn);; 1327 return n;; 1328}; 1329 ; 1330////////////////////////////////////////////////////////////////////////////////; 1331/// Buffer-based estimate of the histogram range using the power of 2 algorithm.; 1332///; 1333/// Used by the autobin power of 2 algorithm.; 1334///; 1335/// Works on arguments (min and max from fBuffer) and internal inputs: fXmin,; 1336/// fXmax, NBinsX (from fXaxis), ...; 1337/// Result save internally in fXaxis.; 1338///; 1339/// Overloaded by TH2 and TH3.; 1340///; 1341/// Return -1 if internal inputs are inconsistent, 0 otherwise.; 1342 ; 1343Int_t TH1::AutoP2FindLimits(Double_t xmi, Double_t xma); 1344{; 1345 // We need meaningful raw limits; 1346 if (xmi >= xma); 1347 return -1;; 1348 ; 1349 THLimitsFinder::GetLimitsFinder()->FindGoodLimits(this, xmi, xma);; 1350 Double_t xhmi = fXaxis.GetXmin();; 1351 Double_t xhma = fXaxis.GetXmax();; 1352 ; 1353 // Now adjust; 1354 if (TMath::Abs(xhma) > TMath::Abs(xhmi)) {; 1355 // Start from the upper limit; 1356 xhma = TH1::AutoP2GetPower2(xhma);; 1357 xhmi = xhma - TH1::AutoP2GetPower2(xhma - xhmi);; 1358 } else {; 1359 // Start from the lower limit; 1360 xhmi = TH1::AutoP2GetPower2(xhmi, kFALSE);; 1361 xhma = xhmi + TH1::AutoP2GetPower2(xhma - ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:53658,Energy Efficiency,power,power,53658,"334///; 1335/// Works on arguments (min and max from fBuffer) and internal inputs: fXmin,; 1336/// fXmax, NBinsX (from fXaxis), ...; 1337/// Result save internally in fXaxis.; 1338///; 1339/// Overloaded by TH2 and TH3.; 1340///; 1341/// Return -1 if internal inputs are inconsistent, 0 otherwise.; 1342 ; 1343Int_t TH1::AutoP2FindLimits(Double_t xmi, Double_t xma); 1344{; 1345 // We need meaningful raw limits; 1346 if (xmi >= xma); 1347 return -1;; 1348 ; 1349 THLimitsFinder::GetLimitsFinder()->FindGoodLimits(this, xmi, xma);; 1350 Double_t xhmi = fXaxis.GetXmin();; 1351 Double_t xhma = fXaxis.GetXmax();; 1352 ; 1353 // Now adjust; 1354 if (TMath::Abs(xhma) > TMath::Abs(xhmi)) {; 1355 // Start from the upper limit; 1356 xhma = TH1::AutoP2GetPower2(xhma);; 1357 xhmi = xhma - TH1::AutoP2GetPower2(xhma - xhmi);; 1358 } else {; 1359 // Start from the lower limit; 1360 xhmi = TH1::AutoP2GetPower2(xhmi, kFALSE);; 1361 xhma = xhmi + TH1::AutoP2GetPower2(xhma - xhmi);; 1362 }; 1363 ; 1364 // Round the bins to the next power of 2; take into account the possible inflation; 1365 // of the range; 1366 Double_t rr = (xhma - xhmi) / (xma - xmi);; 1367 Int_t nb = TH1::AutoP2GetBins((Int_t)(rr * GetNbinsX()));; 1368 ; 1369 // Adjust using the same bin width and offsets; 1370 Double_t bw = (xhma - xhmi) / nb;; 1371 // Bins to left free on each side; 1372 Double_t autoside = gEnv->GetValue(""Hist.Binning.Auto.Side"", 0.05);; 1373 Int_t nbside = (Int_t)(nb * autoside);; 1374 ; 1375 // Side up; 1376 Int_t nbup = (xhma - xma) / bw;; 1377 if (nbup % 2 != 0); 1378 nbup++; // Must be even; 1379 if (nbup != nbside) {; 1380 // Accounts also for both case: larger or smaller; 1381 xhma -= bw * (nbup - nbside);; 1382 nb -= (nbup - nbside);; 1383 }; 1384 ; 1385 // Side low; 1386 Int_t nblw = (xmi - xhmi) / bw;; 1387 if (nblw % 2 != 0); 1388 nblw++; // Must be even; 1389 if (nblw != nbside) {; 1390 // Accounts also for both case: larger or smaller; 1391 xhmi += bw * (nblw - nbside);; 1392 nb -= (nbl",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:57205,Energy Efficiency,power,power-of-,57205,"uffer = fBuffer;; 1435 if (nbentries < 0) {; 1436 nbentries = -nbentries;; 1437 // a reset might call BufferEmpty() giving an infinite recursion; 1438 // Protect it by setting fBuffer = nullptr; 1439 fBuffer = nullptr;; 1440 //do not reset the list of functions; 1441 Reset(""ICES"");; 1442 fBuffer = buffer;; 1443 }; 1444 if (CanExtendAllAxes() || (fXaxis.GetXmax() <= fXaxis.GetXmin())) {; 1445 //find min, max of entries in buffer; 1446 Double_t xmin = TMath::Infinity();; 1447 Double_t xmax = -TMath::Infinity();; 1448 for (Int_t i=0;i<nbentries;i++) {; 1449 Double_t x = fBuffer[2*i+2];; 1450 // skip infinity or NaN values; 1451 if (!std::isfinite(x)) continue;; 1452 if (x < xmin) xmin = x;; 1453 if (x > xmax) xmax = x;; 1454 }; 1455 if (fXaxis.GetXmax() <= fXaxis.GetXmin()) {; 1456 Int_t rc = -1;; 1457 if (TestBit(TH1::kAutoBinPTwo)) {; 1458 if ((rc = AutoP2FindLimits(xmin, xmax)) < 0); 1459 Warning(""BufferEmpty"",; 1460 ""inconsistency found by power-of-2 autobin algorithm: fallback to standard method"");; 1461 }; 1462 if (rc < 0); 1463 THLimitsFinder::GetLimitsFinder()->FindGoodLimits(this, xmin, xmax);; 1464 } else {; 1465 fBuffer = nullptr;; 1466 Int_t keep = fBufferSize; fBufferSize = 0;; 1467 if (xmin < fXaxis.GetXmin()) ExtendAxis(xmin, &fXaxis);; 1468 if (xmax >= fXaxis.GetXmax()) ExtendAxis(xmax, &fXaxis);; 1469 fBuffer = buffer;; 1470 fBufferSize = keep;; 1471 }; 1472 }; 1473 ; 1474 // call DoFillN which will not put entries in the buffer as FillN does; 1475 // set fBuffer to zero to avoid re-emptying the buffer from functions called; 1476 // by DoFillN (e.g Sumw2); 1477 buffer = fBuffer; fBuffer = nullptr;; 1478 DoFillN(nbentries,&buffer[2],&buffer[1],2);; 1479 fBuffer = buffer;; 1480 ; 1481 // if action == 1 - delete the buffer; 1482 if (action > 0) {; 1483 delete [] fBuffer;; 1484 fBuffer = nullptr;; 1485 fBufferSize = 0;; 1486 } else {; 1487 // if number of entries is consistent with buffer - set it negative to avoid; 1488 // refilling the histogram every tim",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:69504,Energy Efficiency,power,power,69504,"hypotheses that two histograms; 1763/// represent identical distributions. To make a decision p-value should; 1764/// be calculated. The hypotheses of identity is rejected if the p-value is; 1765/// lower then some significance level. Traditionally significance levels; 1766/// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; 1767/// analysis of the residuals which is often helpful in identifying the; 1768/// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; 1769/// Residuals are the difference between bin contents and expected bin; 1770/// contents. Most convenient for analysis are the normalized residuals. If; 1771/// hypotheses of identity are valid then normalized residuals are; 1772/// approximately independent and identically distributed random variables; 1773/// having N(0,1) distribution. Analysis of residuals expect test of above; 1774/// mentioned properties of residuals. Notice that indirectly the analysis; 1775/// of residuals increase the power of \f$ \chi^{2} \f$ test.; 1776///; 1777/// #### Methods of comparison:; 1778///; 1779/// \f$ \chi^{2} \f$ test for comparison two (unweighted) histograms:; 1780/// Let us consider two histograms with the same binning and the number; 1781/// of bins equal to r. Let us denote the number of events in the ith bin; 1782/// in the first histogram as ni and as mi in the second one. The total; 1783/// number of events in the first histogram is equal to:; 1784/// \f[; 1785/// N = \sum_{i=1}^{r} n_{i}; 1786/// \f]; 1787/// and; 1788/// \f[; 1789/// M = \sum_{i=1}^{r} m_{i}; 1790/// \f]; 1791/// in the second histogram. The hypothesis of identity (homogeneity) [3]; 1792/// is that the two histograms represent random values with identical; 1793/// distributions. It is equivalent that there exist r constants p1,...,pr,; 1794/// such that; 1795/// \f[; 1796///\sum_{i=1}^{r} p_{i}=1; 1797/// \f]; 1798/// and the probability of belonging to the ith bin for some measured valu",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:179299,Energy Efficiency,adapt,adapted,179299,"~~~; 4314///; 4315/// works for 1D, 2D, etc. histograms; 4316/// c2 is an optional argument that gives a relative weight between the two; 4317/// histograms, and dc2 is the error on this weight. This is useful, for example,; 4318/// when forming an asymmetry between two histograms from 2 different data sets that; 4319/// need to be normalized to each other in some way. The function calculates; 4320/// the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).; 4321///; 4322/// example: assuming 'h1' and 'h2' are already filled; 4323///; 4324/// ~~~ {.cpp}; 4325/// h3 = h1->GetAsymmetry(h2); 4326/// ~~~; 4327///; 4328/// then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; 4329/// h1 and h2 are left intact.; 4330///; 4331/// Note that it is the user's responsibility to manage the created histogram.; 4332/// The name of the returned histogram will be `Asymmetry_nameOfh1-nameOfh2`; 4333///; 4334/// code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun; 4335///; 4336/// clone the histograms so top and bottom will have the; 4337/// correct dimensions:; 4338/// Sumw2 just makes sure the errors will be computed properly; 4339/// when we form sums and ratios below.; 4340 ; 4341TH1 *TH1::GetAsymmetry(TH1* h2, Double_t c2, Double_t dc2); 4342{; 4343 TH1 *h1 = this;; 4344 TString name = TString::Format(""Asymmetry_%s-%s"",h1->GetName(),h2->GetName() );; 4345 TH1 *asym = (TH1*)Clone(name);; 4346 ; 4347 // set also the title; 4348 TString title = TString::Format(""(%s - %s)/(%s+%s)"",h1->GetName(),h2->GetName(),h1->GetName(),h2->GetName() );; 4349 asym->SetTitle(title);; 4350 ; 4351 asym->Sumw2();; 4352 Bool_t addStatus = TH1::AddDirectoryStatus();; 4353 TH1::AddDirectory(kFALSE);; 4354 TH1 *top = (TH1*)asym->Clone();; 4355 TH1 *bottom = (TH1*)asym->Clone();; 4356 TH1::AddDirectory(addStatus);; 4357 ; 4358 // form the top and bottom of the asymmetry, and then divide:; 4359 top->Add(h1,h2,1,-c2);; 4360 bottom->Add(h1,h2,1,c2);; 436",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:183326,Energy Efficiency,power,power,183326,"kTRUE if TH1::Sumw2 must be called when creating new histograms.; 4415/// see TH1::SetDefaultSumw2.; 4416 ; 4417Bool_t TH1::GetDefaultSumw2(); 4418{; 4419 return fgDefaultSumw2;; 4420}; 4421 ; 4422////////////////////////////////////////////////////////////////////////////////; 4423/// Return the current number of entries.; 4424 ; 4425Double_t TH1::GetEntries() const; 4426{; 4427 if (fBuffer) {; 4428 Int_t nentries = (Int_t) fBuffer[0];; 4429 if (nentries > 0) return nentries;; 4430 }; 4431 ; 4432 return fEntries;; 4433}; 4434 ; 4435////////////////////////////////////////////////////////////////////////////////; 4436/// Number of effective entries of the histogram.; 4437///; 4438/// \f[; 4439/// neff = \frac{(\sum Weights )^2}{(\sum Weight^2 )}; 4440/// \f]; 4441///; 4442/// In case of an unweighted histogram this number is equivalent to the; 4443/// number of entries of the histogram.; 4444/// For a weighted histogram, this number corresponds to the hypothetical number of unweighted entries; 4445/// a histogram would need to have the same statistical power as this weighted histogram.; 4446/// Note: The underflow/overflow are included if one has set the TH1::StatOverFlows flag; 4447/// and if the statistics has been computed at filling time.; 4448/// If a range is set in the histogram the number is computed from the given range.; 4449 ; 4450Double_t TH1::GetEffectiveEntries() const; 4451{; 4452 Stat_t s[kNstat];; 4453 this->GetStats(s);// s[1] sum of squares of weights, s[0] sum of weights; 4454 return (s[1] ? s[0]*s[0]/s[1] : TMath::Abs(s[0]) );; 4455}; 4456 ; 4457////////////////////////////////////////////////////////////////////////////////; 4458/// Shortcut to set the three histogram colors with a single call.; 4459///; 4460/// By default: linecolor = markercolor = fillcolor = -1; 4461/// If a color is < 0 this method does not change the corresponding color if positive or null it set the color.; 4462///; 4463/// For instance:; 4464/// ~~~ {.cpp}; 4465/// h->Set",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:195648,Energy Efficiency,power,power,195648,"[in] a array of parameters; 4765///; 4766/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 4767/// (E.Keil. revised by B.Schorr, 23.10.1981.); 4768 ; 4769void H1LeastSquareFit(Int_t n, Int_t m, Double_t *a); 4770{; 4771 const Double_t zero = 0.;; 4772 const Double_t one = 1.;; 4773 const Int_t idim = 20;; 4774 ; 4775 Double_t b[400] /* was [20][20] */;; 4776 Int_t i, k, l, ifail;; 4777 Double_t power;; 4778 Double_t da[20], xk, yk;; 4779 ; 4780 if (m <= 2) {; 4781 H1LeastSquareLinearFit(n, a[0], a[1], ifail);; 4782 return;; 4783 }; 4784 if (m > idim || m > n) return;; 4785 b[0] = Double_t(n);; 4786 da[0] = zero;; 4787 for (l = 2; l <= m; ++l) {; 4788 b[l-1] = zero;; 4789 b[m + l*20 - 21] = zero;; 4790 da[l-1] = zero;; 4791 }; 4792 TVirtualFitter *hFitter = TVirtualFitter::GetFitter();; 4793 TH1 *curHist = (TH1*)hFitter->GetObjectFit();; 4794 Int_t hxfirst = hFitter->GetXfirst();; 4795 Int_t hxlast = hFitter->GetXlast();; 4796 for (k = hxfirst; k <= hxlast; ++k) {; 4797 xk = curHist->GetBinCenter(k);; 4798 yk = curHist->GetBinContent(k);; 4799 power = one;; 4800 da[0] += yk;; 4801 for (l = 2; l <= m; ++l) {; 4802 power *= xk;; 4803 b[l-1] += power;; 4804 da[l-1] += power*yk;; 4805 }; 4806 for (l = 2; l <= m; ++l) {; 4807 power *= xk;; 4808 b[m + l*20 - 21] += power;; 4809 }; 4810 }; 4811 for (i = 3; i <= m; ++i) {; 4812 for (k = i; k <= m; ++k) {; 4813 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 4814 }; 4815 }; 4816 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 4817 ; 4818 for (i=0; i<m; ++i) a[i] = da[i];; 4819 ; 4820}; 4821 ; 4822////////////////////////////////////////////////////////////////////////////////; 4823/// Least square linear fit without weights.; 4824///; 4825/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 4826/// (added to LSQ by B. Schorr, 15.02.1982.); 4827 ; 4828void H1LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t &a1, Int_t &ifail); 4829{; 4830 Double_t xbar, ybar, x2bar;; 4831 Int_t i, n;; 4832 Do",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:196309,Energy Efficiency,power,power,196309,"[in] a array of parameters; 4765///; 4766/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 4767/// (E.Keil. revised by B.Schorr, 23.10.1981.); 4768 ; 4769void H1LeastSquareFit(Int_t n, Int_t m, Double_t *a); 4770{; 4771 const Double_t zero = 0.;; 4772 const Double_t one = 1.;; 4773 const Int_t idim = 20;; 4774 ; 4775 Double_t b[400] /* was [20][20] */;; 4776 Int_t i, k, l, ifail;; 4777 Double_t power;; 4778 Double_t da[20], xk, yk;; 4779 ; 4780 if (m <= 2) {; 4781 H1LeastSquareLinearFit(n, a[0], a[1], ifail);; 4782 return;; 4783 }; 4784 if (m > idim || m > n) return;; 4785 b[0] = Double_t(n);; 4786 da[0] = zero;; 4787 for (l = 2; l <= m; ++l) {; 4788 b[l-1] = zero;; 4789 b[m + l*20 - 21] = zero;; 4790 da[l-1] = zero;; 4791 }; 4792 TVirtualFitter *hFitter = TVirtualFitter::GetFitter();; 4793 TH1 *curHist = (TH1*)hFitter->GetObjectFit();; 4794 Int_t hxfirst = hFitter->GetXfirst();; 4795 Int_t hxlast = hFitter->GetXlast();; 4796 for (k = hxfirst; k <= hxlast; ++k) {; 4797 xk = curHist->GetBinCenter(k);; 4798 yk = curHist->GetBinContent(k);; 4799 power = one;; 4800 da[0] += yk;; 4801 for (l = 2; l <= m; ++l) {; 4802 power *= xk;; 4803 b[l-1] += power;; 4804 da[l-1] += power*yk;; 4805 }; 4806 for (l = 2; l <= m; ++l) {; 4807 power *= xk;; 4808 b[m + l*20 - 21] += power;; 4809 }; 4810 }; 4811 for (i = 3; i <= m; ++i) {; 4812 for (k = i; k <= m; ++k) {; 4813 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 4814 }; 4815 }; 4816 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 4817 ; 4818 for (i=0; i<m; ++i) a[i] = da[i];; 4819 ; 4820}; 4821 ; 4822////////////////////////////////////////////////////////////////////////////////; 4823/// Least square linear fit without weights.; 4824///; 4825/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 4826/// (added to LSQ by B. Schorr, 15.02.1982.); 4827 ; 4828void H1LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t &a1, Int_t &ifail); 4829{; 4830 Double_t xbar, ybar, x2bar;; 4831 Int_t i, n;; 4832 Do",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:196380,Energy Efficiency,power,power,196380,"[in] a array of parameters; 4765///; 4766/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 4767/// (E.Keil. revised by B.Schorr, 23.10.1981.); 4768 ; 4769void H1LeastSquareFit(Int_t n, Int_t m, Double_t *a); 4770{; 4771 const Double_t zero = 0.;; 4772 const Double_t one = 1.;; 4773 const Int_t idim = 20;; 4774 ; 4775 Double_t b[400] /* was [20][20] */;; 4776 Int_t i, k, l, ifail;; 4777 Double_t power;; 4778 Double_t da[20], xk, yk;; 4779 ; 4780 if (m <= 2) {; 4781 H1LeastSquareLinearFit(n, a[0], a[1], ifail);; 4782 return;; 4783 }; 4784 if (m > idim || m > n) return;; 4785 b[0] = Double_t(n);; 4786 da[0] = zero;; 4787 for (l = 2; l <= m; ++l) {; 4788 b[l-1] = zero;; 4789 b[m + l*20 - 21] = zero;; 4790 da[l-1] = zero;; 4791 }; 4792 TVirtualFitter *hFitter = TVirtualFitter::GetFitter();; 4793 TH1 *curHist = (TH1*)hFitter->GetObjectFit();; 4794 Int_t hxfirst = hFitter->GetXfirst();; 4795 Int_t hxlast = hFitter->GetXlast();; 4796 for (k = hxfirst; k <= hxlast; ++k) {; 4797 xk = curHist->GetBinCenter(k);; 4798 yk = curHist->GetBinContent(k);; 4799 power = one;; 4800 da[0] += yk;; 4801 for (l = 2; l <= m; ++l) {; 4802 power *= xk;; 4803 b[l-1] += power;; 4804 da[l-1] += power*yk;; 4805 }; 4806 for (l = 2; l <= m; ++l) {; 4807 power *= xk;; 4808 b[m + l*20 - 21] += power;; 4809 }; 4810 }; 4811 for (i = 3; i <= m; ++i) {; 4812 for (k = i; k <= m; ++k) {; 4813 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 4814 }; 4815 }; 4816 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 4817 ; 4818 for (i=0; i<m; ++i) a[i] = da[i];; 4819 ; 4820}; 4821 ; 4822////////////////////////////////////////////////////////////////////////////////; 4823/// Least square linear fit without weights.; 4824///; 4825/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 4826/// (added to LSQ by B. Schorr, 15.02.1982.); 4827 ; 4828void H1LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t &a1, Int_t &ifail); 4829{; 4830 Double_t xbar, ybar, x2bar;; 4831 Int_t i, n;; 4832 Do",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:196409,Energy Efficiency,power,power,196409,"[in] a array of parameters; 4765///; 4766/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 4767/// (E.Keil. revised by B.Schorr, 23.10.1981.); 4768 ; 4769void H1LeastSquareFit(Int_t n, Int_t m, Double_t *a); 4770{; 4771 const Double_t zero = 0.;; 4772 const Double_t one = 1.;; 4773 const Int_t idim = 20;; 4774 ; 4775 Double_t b[400] /* was [20][20] */;; 4776 Int_t i, k, l, ifail;; 4777 Double_t power;; 4778 Double_t da[20], xk, yk;; 4779 ; 4780 if (m <= 2) {; 4781 H1LeastSquareLinearFit(n, a[0], a[1], ifail);; 4782 return;; 4783 }; 4784 if (m > idim || m > n) return;; 4785 b[0] = Double_t(n);; 4786 da[0] = zero;; 4787 for (l = 2; l <= m; ++l) {; 4788 b[l-1] = zero;; 4789 b[m + l*20 - 21] = zero;; 4790 da[l-1] = zero;; 4791 }; 4792 TVirtualFitter *hFitter = TVirtualFitter::GetFitter();; 4793 TH1 *curHist = (TH1*)hFitter->GetObjectFit();; 4794 Int_t hxfirst = hFitter->GetXfirst();; 4795 Int_t hxlast = hFitter->GetXlast();; 4796 for (k = hxfirst; k <= hxlast; ++k) {; 4797 xk = curHist->GetBinCenter(k);; 4798 yk = curHist->GetBinContent(k);; 4799 power = one;; 4800 da[0] += yk;; 4801 for (l = 2; l <= m; ++l) {; 4802 power *= xk;; 4803 b[l-1] += power;; 4804 da[l-1] += power*yk;; 4805 }; 4806 for (l = 2; l <= m; ++l) {; 4807 power *= xk;; 4808 b[m + l*20 - 21] += power;; 4809 }; 4810 }; 4811 for (i = 3; i <= m; ++i) {; 4812 for (k = i; k <= m; ++k) {; 4813 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 4814 }; 4815 }; 4816 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 4817 ; 4818 for (i=0; i<m; ++i) a[i] = da[i];; 4819 ; 4820}; 4821 ; 4822////////////////////////////////////////////////////////////////////////////////; 4823/// Least square linear fit without weights.; 4824///; 4825/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 4826/// (added to LSQ by B. Schorr, 15.02.1982.); 4827 ; 4828void H1LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t &a1, Int_t &ifail); 4829{; 4830 Double_t xbar, ybar, x2bar;; 4831 Int_t i, n;; 4832 Do",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:196433,Energy Efficiency,power,power,196433,"[in] a array of parameters; 4765///; 4766/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 4767/// (E.Keil. revised by B.Schorr, 23.10.1981.); 4768 ; 4769void H1LeastSquareFit(Int_t n, Int_t m, Double_t *a); 4770{; 4771 const Double_t zero = 0.;; 4772 const Double_t one = 1.;; 4773 const Int_t idim = 20;; 4774 ; 4775 Double_t b[400] /* was [20][20] */;; 4776 Int_t i, k, l, ifail;; 4777 Double_t power;; 4778 Double_t da[20], xk, yk;; 4779 ; 4780 if (m <= 2) {; 4781 H1LeastSquareLinearFit(n, a[0], a[1], ifail);; 4782 return;; 4783 }; 4784 if (m > idim || m > n) return;; 4785 b[0] = Double_t(n);; 4786 da[0] = zero;; 4787 for (l = 2; l <= m; ++l) {; 4788 b[l-1] = zero;; 4789 b[m + l*20 - 21] = zero;; 4790 da[l-1] = zero;; 4791 }; 4792 TVirtualFitter *hFitter = TVirtualFitter::GetFitter();; 4793 TH1 *curHist = (TH1*)hFitter->GetObjectFit();; 4794 Int_t hxfirst = hFitter->GetXfirst();; 4795 Int_t hxlast = hFitter->GetXlast();; 4796 for (k = hxfirst; k <= hxlast; ++k) {; 4797 xk = curHist->GetBinCenter(k);; 4798 yk = curHist->GetBinContent(k);; 4799 power = one;; 4800 da[0] += yk;; 4801 for (l = 2; l <= m; ++l) {; 4802 power *= xk;; 4803 b[l-1] += power;; 4804 da[l-1] += power*yk;; 4805 }; 4806 for (l = 2; l <= m; ++l) {; 4807 power *= xk;; 4808 b[m + l*20 - 21] += power;; 4809 }; 4810 }; 4811 for (i = 3; i <= m; ++i) {; 4812 for (k = i; k <= m; ++k) {; 4813 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 4814 }; 4815 }; 4816 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 4817 ; 4818 for (i=0; i<m; ++i) a[i] = da[i];; 4819 ; 4820}; 4821 ; 4822////////////////////////////////////////////////////////////////////////////////; 4823/// Least square linear fit without weights.; 4824///; 4825/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 4826/// (added to LSQ by B. Schorr, 15.02.1982.); 4827 ; 4828void H1LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t &a1, Int_t &ifail); 4829{; 4830 Double_t xbar, ybar, x2bar;; 4831 Int_t i, n;; 4832 Do",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:196490,Energy Efficiency,power,power,196490,"[in] a array of parameters; 4765///; 4766/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 4767/// (E.Keil. revised by B.Schorr, 23.10.1981.); 4768 ; 4769void H1LeastSquareFit(Int_t n, Int_t m, Double_t *a); 4770{; 4771 const Double_t zero = 0.;; 4772 const Double_t one = 1.;; 4773 const Int_t idim = 20;; 4774 ; 4775 Double_t b[400] /* was [20][20] */;; 4776 Int_t i, k, l, ifail;; 4777 Double_t power;; 4778 Double_t da[20], xk, yk;; 4779 ; 4780 if (m <= 2) {; 4781 H1LeastSquareLinearFit(n, a[0], a[1], ifail);; 4782 return;; 4783 }; 4784 if (m > idim || m > n) return;; 4785 b[0] = Double_t(n);; 4786 da[0] = zero;; 4787 for (l = 2; l <= m; ++l) {; 4788 b[l-1] = zero;; 4789 b[m + l*20 - 21] = zero;; 4790 da[l-1] = zero;; 4791 }; 4792 TVirtualFitter *hFitter = TVirtualFitter::GetFitter();; 4793 TH1 *curHist = (TH1*)hFitter->GetObjectFit();; 4794 Int_t hxfirst = hFitter->GetXfirst();; 4795 Int_t hxlast = hFitter->GetXlast();; 4796 for (k = hxfirst; k <= hxlast; ++k) {; 4797 xk = curHist->GetBinCenter(k);; 4798 yk = curHist->GetBinContent(k);; 4799 power = one;; 4800 da[0] += yk;; 4801 for (l = 2; l <= m; ++l) {; 4802 power *= xk;; 4803 b[l-1] += power;; 4804 da[l-1] += power*yk;; 4805 }; 4806 for (l = 2; l <= m; ++l) {; 4807 power *= xk;; 4808 b[m + l*20 - 21] += power;; 4809 }; 4810 }; 4811 for (i = 3; i <= m; ++i) {; 4812 for (k = i; k <= m; ++k) {; 4813 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 4814 }; 4815 }; 4816 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 4817 ; 4818 for (i=0; i<m; ++i) a[i] = da[i];; 4819 ; 4820}; 4821 ; 4822////////////////////////////////////////////////////////////////////////////////; 4823/// Least square linear fit without weights.; 4824///; 4825/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 4826/// (added to LSQ by B. Schorr, 15.02.1982.); 4827 ; 4828void H1LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t &a1, Int_t &ifail); 4829{; 4830 Double_t xbar, ybar, x2bar;; 4831 Int_t i, n;; 4832 Do",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:196529,Energy Efficiency,power,power,196529,"[in] a array of parameters; 4765///; 4766/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 4767/// (E.Keil. revised by B.Schorr, 23.10.1981.); 4768 ; 4769void H1LeastSquareFit(Int_t n, Int_t m, Double_t *a); 4770{; 4771 const Double_t zero = 0.;; 4772 const Double_t one = 1.;; 4773 const Int_t idim = 20;; 4774 ; 4775 Double_t b[400] /* was [20][20] */;; 4776 Int_t i, k, l, ifail;; 4777 Double_t power;; 4778 Double_t da[20], xk, yk;; 4779 ; 4780 if (m <= 2) {; 4781 H1LeastSquareLinearFit(n, a[0], a[1], ifail);; 4782 return;; 4783 }; 4784 if (m > idim || m > n) return;; 4785 b[0] = Double_t(n);; 4786 da[0] = zero;; 4787 for (l = 2; l <= m; ++l) {; 4788 b[l-1] = zero;; 4789 b[m + l*20 - 21] = zero;; 4790 da[l-1] = zero;; 4791 }; 4792 TVirtualFitter *hFitter = TVirtualFitter::GetFitter();; 4793 TH1 *curHist = (TH1*)hFitter->GetObjectFit();; 4794 Int_t hxfirst = hFitter->GetXfirst();; 4795 Int_t hxlast = hFitter->GetXlast();; 4796 for (k = hxfirst; k <= hxlast; ++k) {; 4797 xk = curHist->GetBinCenter(k);; 4798 yk = curHist->GetBinContent(k);; 4799 power = one;; 4800 da[0] += yk;; 4801 for (l = 2; l <= m; ++l) {; 4802 power *= xk;; 4803 b[l-1] += power;; 4804 da[l-1] += power*yk;; 4805 }; 4806 for (l = 2; l <= m; ++l) {; 4807 power *= xk;; 4808 b[m + l*20 - 21] += power;; 4809 }; 4810 }; 4811 for (i = 3; i <= m; ++i) {; 4812 for (k = i; k <= m; ++k) {; 4813 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 4814 }; 4815 }; 4816 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 4817 ; 4818 for (i=0; i<m; ++i) a[i] = da[i];; 4819 ; 4820}; 4821 ; 4822////////////////////////////////////////////////////////////////////////////////; 4823/// Least square linear fit without weights.; 4824///; 4825/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 4826/// (added to LSQ by B. Schorr, 15.02.1982.); 4827 ; 4828void H1LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t &a1, Int_t &ifail); 4829{; 4830 Double_t xbar, ybar, x2bar;; 4831 Int_t i, n;; 4832 Do",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:246363,Energy Efficiency,reduce,reduced,246363,"22///; 6223/// #### case 1 xbins=0; 6224///; 6225/// If newname is blank (default), the current histogram is modified and; 6226/// a pointer to it is returned.; 6227///; 6228/// If newname is not blank, the current histogram is not modified, and a; 6229/// new histogram is returned which is a Clone of the current histogram; 6230/// with its name set to newname.; 6231///; 6232/// The parameter ngroup indicates how many bins of this have to be merged; 6233/// into one bin of the result.; 6234///; 6235/// If the original histogram has errors stored (via Sumw2), the resulting; 6236/// histograms has new errors correctly calculated.; 6237///; 6238/// examples: if h1 is an existing TH1F histogram with 100 bins; 6239///; 6240/// ~~~ {.cpp}; 6241/// h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; 6242/// h1->Rebin(5); //merges five bins in one in h1; 6243/// TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,""hnew"")); // creates a new histogram hnew; 6244/// // merging 5 bins of h1 in one bin; 6245/// ~~~; 6246///; 6247/// NOTE: If ngroup is not an exact divider of the number of bins,; 6248/// the top limit of the rebinned histogram is reduced; 6249/// to the upper edge of the last bin that can make a complete; 6250/// group. The remaining bins are added to the overflow bin.; 6251/// Statistics will be recomputed from the new bin contents.; 6252///; 6253/// #### case 2 xbins!=0; 6254///; 6255/// A new histogram is created (you should specify newname).; 6256/// The parameter ngroup is the number of variable size bins in the created histogram.; 6257/// The array xbins must contain ngroup+1 elements that represent the low-edges; 6258/// of the bins.; 6259/// If the original histogram has errors stored (via Sumw2), the resulting; 6260/// histograms has new errors correctly calculated.; 6261///; 6262/// NOTE: The bin edges specified in xbins should correspond to bin edges; 6263/// in the original histogram. If a bin edge in the new histogram is; 6264/// ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:319294,Energy Efficiency,adapt,adapted,319294,"119/// - ""D"" Put out a line of ""Debug"" printout; 8120/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 8121/// - ""X"" Run the pseudo experiments post-processor with the following procedure:; 8122/// make pseudoexperiments based on random values from the parent distribution,; 8123/// compare the KS distance of the pseudoexperiment to the parent; 8124/// distribution, and count all the KS values above the value; 8125/// obtained from the original data to Monte Carlo distribution.; 8126/// The number of pseudo-experiments nEXPT is by default 1000, and; 8127/// it can be changed by specifying the option as ""X=number"",; 8128/// for example ""X=10000"" for 10000 toys.; 8129/// The function returns the probability.; 8130/// (thanks to Ben Kilminster to submit this procedure). Note that; 8131/// this option ""X"" is much slower.; 8132///; 8133/// The returned function value is the probability of test; 8134/// (much less than one means NOT compatible); 8135///; 8136/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 8137///; 8138/// NOTE1; 8139/// A good description of the Kolmogorov test can be seen at:; 8140/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; 8141///; 8142/// NOTE2; 8143/// see also alternative function TH1::Chi2Test; 8144/// The Kolmogorov test is assumed to give better results than Chi2Test; 8145/// in case of histograms with low statistics.; 8146///; 8147/// NOTE3 (Jan Conrad, Fred James); 8148/// ""The returned value PROB is calculated such that it will be; 8149/// uniformly distributed between zero and one for compatible histograms,; 8150/// provided the data are not binned (or the number of bins is very large; 8151/// compared with the number of events). Users who have access to unbinned; 8152/// data and wish exact confidence levels should therefore not put their data; 8153/// into histograms, but should call directly TMath::KolmogorovTest. On; 8154/// the other hand, since TH1 is a convenient way of collecting",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:341223,Energy Efficiency,efficient,efficient,341223,"z<=zlast;binz++) {; 8692 for (biny=yfirst;biny<=ylast;biny++) {; 8693 for (binx=xfirst;binx<=xlast;binx++) {; 8694 bin = GetBin(binx,biny,binz);; 8695 value = RetrieveBinContent(bin);; 8696 if (value < minimum) {; 8697 minimum = value;; 8698 locm = bin;; 8699 locmix = binx;; 8700 locmiy = biny;; 8701 locmiz = binz;; 8702 }; 8703 }; 8704 }; 8705 }; 8706 return locm;; 8707}; 8708 ; 8709///////////////////////////////////////////////////////////////////////////////; 8710/// Retrieve the minimum and maximum values in the histogram; 8711///; 8712/// This will not return a cached value and will always search the; 8713/// histogram for the min and max values. The user can condition whether; 8714/// or not to call this with the GetMinimumStored() and GetMaximumStored(); 8715/// methods. If the cache is empty, then the value will be -1111. Users; 8716/// can then use the SetMinimum() or SetMaximum() methods to cache the results.; 8717/// For example, the following recipe will make efficient use of this method; 8718/// and the cached minimum and maximum values.; 8719//; 8720/// \code{.cpp}; 8721/// Double_t currentMin = pHist->GetMinimumStored();; 8722/// Double_t currentMax = pHist->GetMaximumStored();; 8723/// if ((currentMin == -1111) || (currentMax == -1111)) {; 8724/// pHist->GetMinimumAndMaximum(currentMin, currentMax);; 8725/// pHist->SetMinimum(currentMin);; 8726/// pHist->SetMaximum(currentMax);; 8727/// }; 8728/// \endcode; 8729///; 8730/// \param min reference to variable that will hold found minimum value; 8731/// \param max reference to variable that will hold found maximum value; 8732 ; 8733void TH1::GetMinimumAndMaximum(Double_t& min, Double_t& max) const; 8734{; 8735 // empty the buffer; 8736 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8737 ; 8738 Int_t bin, binx, biny, binz;; 8739 Int_t xfirst = fXaxis.GetFirst();; 8740 Int_t xlast = fXaxis.GetLast();; 8741 Int_t yfirst = fYaxis.GetFirst();; 8742 Int_t ylast = fYaxis.GetLast();; 8743 Int_t zfirst = fZaxis.GetF",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:424929,Energy Efficiency,allocate,allocated,424929,"ect of class TAxis.Definition TAxis.cxx:1216; TAxis::GetNbinsInt_t GetNbins() constDefinition TAxis.h:125; TAxis::GetLowEdgevirtual void GetLowEdge(Double_t *edge) constReturn an array with the low edge of all bins.Definition TAxis.cxx:562; TAxis::SetRangevirtual void SetRange(Int_t first=0, Int_t last=0)Set the viewing range for the axis using bin numbers.Definition TAxis.cxx:1052; TAxis::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width.Definition TAxis.cxx:540; TAxis::GetBinUpEdgevirtual Double_t GetBinUpEdge(Int_t bin) constReturn up edge of bin.Definition TAxis.cxx:528; TAxis::GetFirstInt_t GetFirst() constReturn first bin on the axis i.e.Definition TAxis.cxx:458; TAxis::GetLabelsTHashList * GetLabels() constDefinition TAxis.h:121; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7514; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::AddAllvirtual void AddAll(const TCollection *col)Add all objects from collection col to this collection.Definition TCollection.cxx:195; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TCollection::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an collection using the Streamer facility.Definition TCollection.cxx:263; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDirectoryDescribe directory str",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:433229,Energy Efficiency,power,power,433229,"al number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:9763; TH1S::~TH1S~TH1S() overrideDestructor.Definition TH1.cxx:9707; TH1S::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9724; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::~TH1~TH1() overrideHistogram default destructor.Definition TH1.cxx:643; TH1::SetErrorvirtual void SetError(const Double_t *error)Replace bin errors by values in array error.Definition TH1.cxx:8951; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FitPanelvirtual void FitPanel()Display a panel with all histogram fit options.Definition TH1.cxx:4284; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::AutoP2FindLimitsvirtual Int_t AutoP2FindLimits(Double_t min, Double_t max)Buffer-based estimate of the histogram range using the power of 2 algorithm.Definition TH1.cxx:1343; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::GetObjectInfo.Definition TH1.cxx:4502; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn bin center for 1D histogram.Definition TH1.cxx:9141; TH1::Rebuildvirtual void Rebuild(Option_t *option="""")Using the current bin info, recompute the arrays for contents and errors.Definition TH1.cxx:7087; TH1::SetBarOffsetvirtual void SetBarOffset(Float_t offset=0.25)Set the bar offset as fraction of the bin width for drawing mode ""B"".Definition TH1.h:364; TH1::fgStatOverflowsstatic Bool_t fgStatOverflows! Flag to use unde",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:441532,Energy Efficiency,power,power,441532,"llAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::fDirectoryTDirectory * fDirectory! Pointer to directory holding this histogramDefinition TH1.h:109; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::SetNameTitlevoid SetNameTitle(const char *name, const char *title) overrideChange the name and title of this histogram.Definition TH1.cxx:8974; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetBinXYZvirtual void GetBinXYZ(Int_t binglobal, Int_t &binx, Int_t &biny, Int_t &binz) constReturn binx, biny, binz corresponding to the global bin number globalbin see TH1::GetBin function abo...Definition TH1.cxx:4974; TH1::GetCumulativeTH1 * GetCumulative(Bool_t forward=kTRUE, const char *suffix=""_cumulative"") constReturn a pointer to a histogram containing the cumulative content.Definition TH1.cxx:2616; TH1::AutoP2GetPower2static Double_t AutoP2GetPower2(Double_t x, Bool_t next=kTRUE)Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x.Definition TH1.cxx:1308; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::ShowPeaksvirtual Int_t ShowPeaks(Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05)Interface to TSpectrum::Search.Definition TH1.cxx:9301; TH1::RecomputeAxisLimitsstatic Bool_t RecomputeAxisLimits(TAxis &destAxis, const TAxis &anAxis)Finds new limits for the axis for the Merge function.Definition TH1.cxx:5908; TH1::PutStatsvirtual void PutStats(Double_t *stats)Replace current statistics with the values in array stats.Definition TH1.cxx:7884; TH1::GetPainterTVirtualHistPainter * GetPainter(Option_t *option="""")Return pointer to painter.Definition TH1.cxx:4511; TH1::FindObjectTObject * FindObject(const char *name) const overrideSearch object named name in the list of functions.Definition TH1.cxx:3857; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nul",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:453242,Energy Efficiency,power,power,453242,"_t *option="""") constCompute and return the chisquare of this histogram with respect to a function The chisquare is comput...Definition TH1.cxx:2496; TH1::Chi2Testvirtual Double_t Chi2Test(const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) consttest for comparing weighted and unweighted histograms.Definition TH1.cxx:2008; TH1::DoFillNvirtual void DoFillN(Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1)Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty.Definition TH1.cxx:3473; TH1::GetMinimumAndMaximumvirtual void GetMinimumAndMaximum(Double_t &min, Double_t &max) constRetrieve the minimum and maximum values in the histogram.Definition TH1.cxx:8731; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::GetMaximumBinvirtual Int_t GetMaximumBin() constReturn location of bin with maximum value in the range.Definition TH1.cxx:8577; TH1::AutoP2GetBinsstatic Int_t AutoP2GetBins(Int_t n)Auxiliary function to get the next power of 2 integer value larger then n.Definition TH1.cxx:1321; TH1::fEntriesDouble_t fEntriesNumber of entries.Definition TH1.h:95; TH1::Mergevirtual Long64_t Merge(TCollection *list)Definition TH1.h:345; TH1::SetColorsvirtual void SetColors(Color_t linecolor=-1, Color_t markercolor=-1, Color_t fillcolor=-1)Shortcut to set the three histogram colors with a single call.Definition TH1.cxx:4467; TH1::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TH1.cxx:3240; TH1::GetIntegralvirtual Double_t * GetIntegral()Return a pointer to the array of bins integral.Definition TH1.cxx:2586; TH1::fZaxisTAxis fZaxisZ axis descriptor.Definition TH1.h:92; TH1::fStatOverflowsEStatOverflows fStatOverflowsPer object flag to use under/overflows in statistics.Definition TH1.h:114; TH1::IsATClass * IsA() const overrideDefinition TH1.h:444; TH1::FillNvirtual void FillN(Int_t ntimes, const Double_t *x, const",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:476918,Energy Efficiency,power,power,476918,"; TMath::MedianDouble_t Median(Long64_t n, const T *a, const Double_t *w=nullptr, Long64_t *work=nullptr)Same as RMS.Definition TMath.h:1272; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::MinElementT MinElement(Long64_t n, const T *a)Returns minimum of array a of length n.Definition TMath.h:960; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::AreEqualRelBool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec)Comparing floating points.Definition TMath.h:426; TMath::AreEqualAbsBool_t AreEqualAbs(Double_t af, Double_t bf, Double_t epsilon)Comparing floating points.Definition TMath.h:418; TMath::KolmogorovProbDouble_t KolmogorovProb(Double_t z)Calculates the Kolmogorov distribution function,.Definition TMath.cxx:679; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::Log10Double_t Log10(Double_t x)Ret",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:2403,Integrability,interface,interface,2403,"TVirtualPaveStats.h""; 48 ; 49#include ""HFitInterface.h""; 50#include ""Fit/DataRange.h""; 51#include ""Fit/BinData.h""; 52#include ""Math/GoFTest.h""; 53#include ""Math/MinimizerOptions.h""; 54#include ""Math/QuantFuncMathCore.h""; 55 ; 56#include ""TH1Merger.h""; 57 ; 58/** \addtogroup Histograms; 59@{; 60\class TH1C; 61\brief 1-D histogram with a byte per channel (see TH1 documentation); 62\class TH1S; 63\brief 1-D histogram with a short per channel (see TH1 documentation); 64\class TH1I; 65\brief 1-D histogram with an int per channel (see TH1 documentation); 66\class TH1L; 67\brief 1-D histogram with a long64 per channel (see TH1 documentation); 68\class TH1F; 69\brief 1-D histogram with a float per channel (see TH1 documentation); 70\class TH1D; 71\brief 1-D histogram with a double per channel (see TH1 documentation); 72@}; 73*/; 74 ; 75/** \class TH1; 76 \ingroup Histograms; 77TH1 is the base class of all histogram classes in %ROOT.; 78 ; 79It provides the common interface for operations such as binning, filling, drawing, which; 80will be detailed below.; 81 ; 82-# [Creating histograms](\ref creating-histograms); 83 - [Labelling axes](\ref labelling-axis); 84-# [Binning](\ref binning); 85 - [Fix or variable bin size](\ref fix-var); 86 - [Convention for numbering bins](\ref convention); 87 - [Alphanumeric Bin Labels](\ref alpha); 88 - [Histograms with automatic bins](\ref auto-bin); 89 - [Rebinning](\ref rebinning); 90-# [Filling histograms](\ref filling-histograms); 91 - [Associated errors](\ref associated-errors); 92 - [Associated functions](\ref associated-functions); 93 - [Projections of histograms](\ref prof-hist); 94 - [Random Numbers and histograms](\ref random-numbers); 95 - [Making a copy of a histogram](\ref making-a-copy); 96 - [Normalizing histograms](\ref normalizing); 97-# [Drawing histograms](\ref drawing-histograms); 98 - [Setting Drawing histogram contour levels (2-D hists only)](\ref cont-level); 99 - [Setting histogram graphics attributes](\ref graph-att);",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:24638,Integrability,depend,depend,24638,"38 ; 539 The following statements create a ROOT file and store a histogram; 540 on the file. Because TH1 derives from TNamed, the key identifier on; 541 the file is the histogram name:; 542~~~ {.cpp}; 543 TFile f(""histos.root"", ""new"");; 544 TH1F h1(""hgaus"", ""histo from a gaussian"", 100, -3, 3);; 545 h1.FillRandom(""gaus"", 10000);; 546 h1->Write();; 547~~~; 548 To read this histogram in another Root session, do:; 549~~~ {.cpp}; 550 TFile f(""histos.root"");; 551 TH1F *h = (TH1F*)f.Get(""hgaus"");; 552~~~; 553 One can save all histograms in memory to the file by:; 554~~~ {.cpp}; 555 file->Write();; 556~~~; 557 ; 558 ; 559\anchor misc; 560## Miscellaneous operations; 561 ; 562~~~ {.cpp}; 563 TH1::KolmogorovTest(): statistical test of compatibility in shape; 564 between two histograms; 565 TH1::Smooth() smooths the bin contents of a 1-d histogram; 566 TH1::Integral() returns the integral of bin contents in a given bin range; 567 TH1::GetMean(int axis) returns the mean value along axis; 568 TH1::GetStdDev(int axis) returns the sigma distribution along axis; 569 TH1::GetEntries() returns the number of entries; 570 TH1::Reset() resets the bin contents and errors of a histogram; 571~~~; 572 IMPORTANT NOTE: The returned values for GetMean and GetStdDev depend on how the; 573 histogram statistics are calculated. By default, if no range has been set, the; 574 returned values are the (unbinned) ones calculated at fill time. If a range has been; 575 set, however, the values are calculated using the bins in range; THIS IS TRUE EVEN; 576 IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset the range.; 577 To ensure that the returned values are always those of the binned data stored in the; 578 histogram, call TH1::ResetStats. See TH1::GetStats.; 579*/; 580 ; 581TF1 *gF1=nullptr; //left for back compatibility (use TVirtualFitter::GetUserFunc instead); 582 ; 583Int_t TH1::fgBufferSize = 1000;; 584Bool_t TH1::fgAddDirectory = kTRUE;; 585Bool_t TH1::fgDefaultSumw2 = kFALSE;; 5",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:38179,Integrability,depend,depending,38179,"ill be; 928/// added merging them by bin number independently of the labels.; 929/// For adding histogram with labels one should use TH1::Merge; 930///; 931/// SPECIAL CASE (Average/Efficiency histograms); 932/// For histograms representing averages or efficiencies, one should compute the average; 933/// of the two histograms and not the sum. One can mark a histogram to be an average; 934/// histogram by setting its bit kIsAverage with; 935/// myhist.SetBit(TH1::kIsAverage);; 936/// Note that the two histograms must have their kIsAverage bit set; 937///; 938/// IMPORTANT NOTE1: If you intend to use the errors of this histogram later; 939/// you should call Sumw2 before making this operation.; 940/// This is particularly important if you fit the histogram after TH1::Add; 941///; 942/// IMPORTANT NOTE2: if h1 has a normalisation factor, the normalisation factor; 943/// is used , ie this = this + c1*factor*h1; 944/// Use the other TH1::Add function if you do not want this feature; 945///; 946/// IMPORTANT NOTE3: You should be careful about the statistics of the; 947/// returned histogram, whose statistics may be binned or unbinned,; 948/// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; 949/// and whether TH1::ResetStats has been called on either this or h1.; 950/// See TH1::GetStats.; 951///; 952/// The function return kFALSE if the Add operation failed; 953 ; 954Bool_t TH1::Add(const TH1 *h1, Double_t c1); 955{; 956 if (!h1) {; 957 Error(""Add"",""Attempt to add a non-existing histogram"");; 958 return kFALSE;; 959 }; 960 ; 961 // delete buffer if it is there since it will become invalid; 962 if (fBuffer) BufferEmpty(1);; 963 ; 964 bool useMerge = false;; 965 const bool considerMerge = (c1 == 1. && !this->TestBit(kIsAverage) && !h1->TestBit(kIsAverage) );; 966 const auto inconsistency = LoggedInconsistency(""Add"", this, h1, considerMerge);; 967 // If there is a bad inconsistency and we can't even consider merging, just give up; 968 if(inconsistenc",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:39979,Integrability,depend,depending,39979,"there is an inconsistency, we try to use merging; 972 if(inconsistency > kFullyConsistent) {; 973 useMerge = considerMerge;; 974 }; 975 ; 976 if (useMerge) {; 977 TList l;; 978 l.Add(const_cast<TH1*>(h1));; 979 auto iret = Merge(&l);; 980 return (iret >= 0);; 981 }; 982 ; 983 // Create Sumw2 if h1 has Sumw2 set; 984 if (fSumw2.fN == 0 && h1->GetSumw2N() != 0) Sumw2();; 985 ; 986 // - Add statistics; 987 Double_t entries = TMath::Abs( GetEntries() + c1 * h1->GetEntries() );; 988 ; 989 // statistics can be preserved only in case of positive coefficients; 990 // otherwise with negative c1 (histogram subtraction) one risks to get negative variances; 991 Bool_t resetStats = (c1 < 0);; 992 Double_t s1[kNstat] = {0};; 993 Double_t s2[kNstat] = {0};; 994 if (!resetStats) {; 995 // need to initialize to zero s1 and s2 since; 996 // GetStats fills only used elements depending on dimension and type; 997 GetStats(s1);; 998 h1->GetStats(s2);; 999 }; 1000 ; 1001 SetMinimum();; 1002 SetMaximum();; 1003 ; 1004 // - Loop on bins (including underflows/overflows); 1005 Double_t factor = 1;; 1006 if (h1->GetNormFactor() != 0) factor = h1->GetNormFactor()/h1->GetSumOfWeights();; 1007 Double_t c1sq = c1 * c1;; 1008 Double_t factsq = factor * factor;; 1009 ; 1010 for (Int_t bin = 0; bin < fNcells; ++bin) {; 1011 //special case where histograms have the kIsAverage bit set; 1012 if (this->TestBit(kIsAverage) && h1->TestBit(kIsAverage)) {; 1013 Double_t y1 = h1->RetrieveBinContent(bin);; 1014 Double_t y2 = this->RetrieveBinContent(bin);; 1015 Double_t e1sq = h1->GetBinErrorSqUnchecked(bin);; 1016 Double_t e2sq = this->GetBinErrorSqUnchecked(bin);; 1017 Double_t w1 = 1., w2 = 1.;; 1018 ; 1019 // consider all special cases when bin errors are zero; 1020 // see http://root-forum.cern.ch/viewtopic.php?f=3&t=13299; 1021 if (e1sq) w1 = 1. / e1sq;; 1022 else if (h1->fSumw2.fN) {; 1023 w1 = 1.E200; // use an arbitrary huge value; 1024 if (y1 == 0) {; 1025 // use an estimated error from the global hi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:43869,Integrability,depend,depending,43869,".; 1077///; 1078/// Note also that adding histogram with labels is not supported, histogram will be; 1079/// added merging them by bin number independently of the labels.; 1080/// For adding histogram ith labels one should use TH1::Merge; 1081///; 1082/// SPECIAL CASE (Average/Efficiency histograms); 1083/// For histograms representing averages or efficiencies, one should compute the average; 1084/// of the two histograms and not the sum. One can mark a histogram to be an average; 1085/// histogram by setting its bit kIsAverage with; 1086/// myhist.SetBit(TH1::kIsAverage);; 1087/// Note that the two histograms must have their kIsAverage bit set; 1088///; 1089/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 1090/// you should call Sumw2 before making this operation.; 1091/// This is particularly important if you fit the histogram after TH1::Add; 1092///; 1093/// IMPORTANT NOTE2: You should be careful about the statistics of the; 1094/// returned histogram, whose statistics may be binned or unbinned,; 1095/// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; 1096/// and whether TH1::ResetStats has been called on either this or h1.; 1097/// See TH1::GetStats.; 1098///; 1099/// ANOTHER SPECIAL CASE : h1 = h2 and c2 < 0; 1100/// do a scaling this = c1 * h1 / (bin Volume); 1101///; 1102/// The function returns kFALSE if the Add operation failed; 1103 ; 1104Bool_t TH1::Add(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2); 1105{; 1106 ; 1107 if (!h1 || !h2) {; 1108 Error(""Add"",""Attempt to add a non-existing histogram"");; 1109 return kFALSE;; 1110 }; 1111 ; 1112 // delete buffer if it is there since it will become invalid; 1113 if (fBuffer) BufferEmpty(1);; 1114 ; 1115 Bool_t normWidth = kFALSE;; 1116 if (h1 == h2 && c2 < 0) {c2 = 0; normWidth = kTRUE;}; 1117 ; 1118 if (h1 != h2) {; 1119 bool useMerge = false;; 1120 const bool considerMerge = (c1 == 1. && c2 == 1. && !this->TestBit(kIsAverage) && !h1->TestBit(kIsAvera",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:46516,Integrability,depend,depending,46516,"w2 if h1 or h2 have Sumw2 set; 1148 if (fSumw2.fN == 0 && (h1->GetSumw2N() != 0 || h2->GetSumw2N() != 0)) Sumw2();; 1149 ; 1150 // - Add statistics; 1151 Double_t nEntries = TMath::Abs( c1*h1->GetEntries() + c2*h2->GetEntries() );; 1152 ; 1153 // TODO remove; 1154 // statistics can be preserved only in case of positive coefficients; 1155 // otherwise with negative c1 (histogram subtraction) one risks to get negative variances; 1156 // also in case of scaling with the width we cannot preserve the statistics; 1157 Double_t s1[kNstat] = {0};; 1158 Double_t s2[kNstat] = {0};; 1159 Double_t s3[kNstat];; 1160 ; 1161 ; 1162 Bool_t resetStats = (c1*c2 < 0) || normWidth;; 1163 if (!resetStats) {; 1164 // need to initialize to zero s1 and s2 since; 1165 // GetStats fills only used elements depending on dimension and type; 1166 h1->GetStats(s1);; 1167 h2->GetStats(s2);; 1168 for (Int_t i=0;i<kNstat;i++) {; 1169 if (i == 1) s3[i] = c1*c1*s1[i] + c2*c2*s2[i];; 1170 //else s3[i] = TMath::Abs(c1)*s1[i] + TMath::Abs(c2)*s2[i];; 1171 else s3[i] = c1*s1[i] + c2*s2[i];; 1172 }; 1173 }; 1174 ; 1175 SetMinimum();; 1176 SetMaximum();; 1177 ; 1178 if (normWidth) { // DEPRECATED CASE: belongs to fitting / drawing modules; 1179 ; 1180 Int_t nbinsx = GetNbinsX() + 2; // normal bins + underflow, overflow; 1181 Int_t nbinsy = GetNbinsY() + 2;; 1182 Int_t nbinsz = GetNbinsZ() + 2;; 1183 ; 1184 if (fDimension < 2) nbinsy = 1;; 1185 if (fDimension < 3) nbinsz = 1;; 1186 ; 1187 Int_t bin, binx, biny, binz;; 1188 for (binz = 0; binz < nbinsz; ++binz) {; 1189 Double_t wz = h1->GetZaxis()->GetBinWidth(binz);; 1190 for (biny = 0; biny < nbinsy; ++biny) {; 1191 Double_t wy = h1->GetYaxis()->GetBinWidth(biny);; 1192 for (binx = 0; binx < nbinsx; ++binx) {; 1193 Double_t wx = h1->GetXaxis()->GetBinWidth(binx);; 1194 bin = GetBin(binx, biny, binz);; 1195 Double_t w = wx*wy*wz;; 1196 UpdateBinContent(bin, c1 * h1->RetrieveBinContent(bin) / w);; 1197 if (fSumw2.fN) {; 1198 Double_t e1 = h1->GetBinError(bin)/",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:82918,Integrability,rout,routine,82918,"4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; 2004/// Biometrics 29, 205-220.; 2005/// - [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; 2006/// test in 2xN tables. Biometrics 21, 19-33.; 2007/// - [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; 2008/// John Wiley & Sons Inc., New York.; 2009 ; 2010Double_t TH1::Chi2Test(const TH1* h2, Option_t *option, Double_t *res) const; 2011{; 2012 Double_t chi2 = 0;; 2013 Int_t ndf = 0, igood = 0;; 2014 ; 2015 TString opt = option;; 2016 opt.ToUpper();; 2017 ; 2018 Double_t prob = Chi2TestX(h2,chi2,ndf,igood,option,res);; 2019 ; 2020 if(opt.Contains(""P"")) {; 2021 printf(""Chi2 = %f, Prob = %g, NDF = %d, igood = %d\n"", chi2,prob,ndf,igood);; 2022 }; 2023 if(opt.Contains(""CHI2/NDF"")) {; 2024 if (ndf == 0) return 0;; 2025 return chi2/ndf;; 2026 }; 2027 if(opt.Contains(""CHI2"")) {; 2028 return chi2;; 2029 }; 2030 ; 2031 return prob;; 2032}; 2033 ; 2034////////////////////////////////////////////////////////////////////////////////; 2035/// The computation routine of the Chisquare test. For the method description,; 2036/// see Chi2Test() function.; 2037///; 2038/// \return p-value; 2039/// \param[in] h2 the second histogram; 2040/// \param[in] option; 2041/// - ""UU"" = experiment experiment comparison (unweighted-unweighted); 2042/// - ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first; 2043/// histogram should be unweighted; 2044/// - ""WW"" = MC MC comparison (weighted-weighted); 2045/// - ""NORM"" = if one or both histograms is scaled; 2046/// - ""OF"" = overflows included; 2047/// - ""UF"" = underflows included; 2048/// by default underflows and overflows are not included; 2049/// \param[out] igood test output; 2050/// - igood=0 - no problems; 2051/// - For unweighted unweighted comparison; 2052/// - igood=1'There is a bin in the 1st histogram with less than 1 event'; 2053/// - igood=2'There is a bin in the 2nd histogram with less than ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:100808,Integrability,rout,routine,100808,"andom functions.; 2531/// This function is automatically called by GetRandom when the fIntegral; 2532/// array does not exist or when the number of entries in the histogram; 2533/// has changed since the previous call to GetRandom.; 2534/// The resulting integral is normalized to 1.; 2535/// If the routine is called with the onlyPositive flag set an error will; 2536/// be produced in case of negative bin content and a NaN value returned; 2537/// \return 1 if success, 0 if integral is zero, NAN if onlyPositive-test fails; 2538 ; 2539Double_t TH1::ComputeIntegral(Bool_t onlyPositive); 2540{; 2541 if (fBuffer) BufferEmpty();; 2542 ; 2543 // delete previously computed integral (if any); 2544 if (fIntegral) delete [] fIntegral;; 2545 ; 2546 // - Allocate space to store the integral and compute integral; 2547 Int_t nbinsx = GetNbinsX();; 2548 Int_t nbinsy = GetNbinsY();; 2549 Int_t nbinsz = GetNbinsZ();; 2550 Int_t nbins = nbinsx * nbinsy * nbinsz;; 2551 ; 2552 fIntegral = new Double_t[nbins + 2];; 2553 Int_t ibin = 0; fIntegral[ibin] = 0;; 2554 ; 2555 for (Int_t binz=1; binz <= nbinsz; ++binz) {; 2556 for (Int_t biny=1; biny <= nbinsy; ++biny) {; 2557 for (Int_t binx=1; binx <= nbinsx; ++binx) {; 2558 ++ibin;; 2559 Double_t y = RetrieveBinContent(GetBin(binx, biny, binz));; 2560 if (onlyPositive && y < 0) {; 2561 Error(""ComputeIntegral"",""Bin content is negative - return a NaN value"");; 2562 fIntegral[nbins] = TMath::QuietNaN();; 2563 break;; 2564 }; 2565 fIntegral[ibin] = fIntegral[ibin - 1] + y;; 2566 }; 2567 }; 2568 }; 2569 ; 2570 // - Normalize integral to 1; 2571 if (fIntegral[nbins] == 0 ) {; 2572 Error(""ComputeIntegral"", ""Integral = 0, no hits in histogram bins (excluding over/underflow)."");; 2573 return 0;; 2574 }; 2575 for (Int_t bin=1; bin <= nbins; ++bin) fIntegral[bin] /= fIntegral[nbins];; 2576 fIntegral[nbins+1] = fEntries;; 2577 return fIntegral[nbins];; 2578}; 2579 ; 2580////////////////////////////////////////////////////////////////////////////////; 2581/",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:131281,Integrability,depend,depending,131281,"t; 3263/// - option of transform type; 3264/// - ""R2C"" - real to complex transforms - default; 3265/// - ""R2HC"" - real to halfcomplex (special format of storing output data,; 3266/// results the same as for R2C); 3267/// - ""DHT"" - discrete Hartley transform; 3268/// real to real transforms (sine and cosine):; 3269/// - ""R2R_0"", ""R2R_1"", ""R2R_2"", ""R2R_3"" - discrete cosine transforms of types I-IV; 3270/// - ""R2R_4"", ""R2R_5"", ""R2R_6"", ""R2R_7"" - discrete sine transforms of types I-IV; 3271/// To specify the type of each dimension of a 2-dimensional real to real; 3272/// transform, use options of form ""R2R_XX"", for example, ""R2R_02"" for a transform,; 3273/// which is of type ""R2R_0"" in 1st dimension and ""R2R_2"" in the 2nd.; 3274/// - option of transform flag; 3275/// - ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; 3276/// performance; 3277/// - ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; 3278/// - ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; 3279/// - ""EX"" (from ""exhaustive"") - the most optimal way is found; 3280/// This option should be chosen depending on how many transforms of the same size and; 3281/// type are going to be done. Planning is only done once, for the first transform of this; 3282/// size and type. Default is ""ES"".; 3283///; 3284/// Examples of valid options: ""Mag R2C M"" ""Re R2R_11"" ""Im R2C ES"" ""PH R2HC EX""; 3285 ; 3286TH1* TH1::FFT(TH1* h_output, Option_t *option); 3287{; 3288 ; 3289 Int_t ndim[3];; 3290 ndim[0] = this->GetNbinsX();; 3291 ndim[1] = this->GetNbinsY();; 3292 ndim[2] = this->GetNbinsZ();; 3293 ; 3294 TVirtualFFT *fft;; 3295 TString opt = option;; 3296 opt.ToUpper();; 3297 if (!opt.Contains(""2R"")){; 3298 if (!opt.Contains(""2C"") && !opt.Contains(""2HC"") && !opt.Contains(""DHT"")) {; 3299 //no type specified, ""R2C"" by default; 3300 opt.Append(""R2C"");; 3301 }; 3302 fft = TVirtualFFT::FFT(this->GetDimension(), ndim, opt.Da",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:139622,Integrability,integrat,integrated,139622,"ide); 3476{; 3477 Int_t bin,i;; 3478 ; 3479 fEntries += ntimes;; 3480 Double_t ww = 1;; 3481 Int_t nbins = fXaxis.GetNbins();; 3482 ntimes *= stride;; 3483 for (i=0;i<ntimes;i+=stride) {; 3484 bin =fXaxis.FindBin(x[i]);; 3485 if (bin <0) continue;; 3486 if (w) ww = w[i];; 3487 if (!fSumw2.fN && ww != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2();; 3488 if (fSumw2.fN) fSumw2.fArray[bin] += ww*ww;; 3489 AddBinContent(bin, ww);; 3490 if (bin == 0 || bin > nbins) {; 3491 if (!GetStatOverflowsBehaviour()) continue;; 3492 }; 3493 Double_t z= ww;; 3494 fTsumw += z;; 3495 fTsumw2 += z*z;; 3496 fTsumwx += z*x[i];; 3497 fTsumwx2 += z*x[i]*x[i];; 3498 }; 3499}; 3500 ; 3501////////////////////////////////////////////////////////////////////////////////; 3502/// Fill histogram following distribution in function fname.; 3503///; 3504/// @param fname : Function name used for filling the histogram; 3505/// @param ntimes : number of times the histogram is filled; 3506/// @param rng : (optional) Random number generator used to sample; 3507///; 3508///; 3509/// The distribution contained in the function fname (TF1) is integrated; 3510/// over the channel contents for the bin range of this histogram.; 3511/// It is normalized to 1.; 3512///; 3513/// Getting one random number implies:; 3514/// - Generating a random number between 0 and 1 (say r1); 3515/// - Look in which bin in the normalized integral r1 corresponds to; 3516/// - Fill histogram channel; 3517/// ntimes random numbers are generated; 3518///; 3519/// One can also call TF1::GetRandom to get a random variate from a function.; 3520 ; 3521void TH1::FillRandom(const char *fname, Int_t ntimes, TRandom * rng); 3522{; 3523 Int_t bin, binx, ibin, loop;; 3524 Double_t r1, x;; 3525 // - Search for fname in the list of ROOT defined functions; 3526 TF1 *f1 = (TF1*)gROOT->GetFunction(fname);; 3527 if (!f1) { Error(""FillRandom"", ""Unknown function: %s"",fname); return; }; 3528 ; 3529 // - Allocate temporary space to store the integral and compute ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:142467,Integrability,integrat,integrated,142467," 3554 delete [] integral;; 3555 Error(""FillRandom"", ""Integral = zero""); return;; 3556 }; 3557 for (bin=1;bin<=nbinsx;bin++) integral[bin] /= integral[nbinsx];; 3558 ; 3559 // --------------Start main loop ntimes; 3560 for (loop=0;loop<ntimes;loop++) {; 3561 r1 = (rng) ? rng->Rndm() : gRandom->Rndm();; 3562 ibin = TMath::BinarySearch(nbinsx,&integral[0],r1);; 3563 //binx = 1 + ibin;; 3564 //x = xAxis->GetBinCenter(binx); //this is not OK when SetBuffer is used; 3565 x = xAxis->GetBinLowEdge(ibin+first); 3566 +xAxis->GetBinWidth(ibin+first)*(r1-integral[ibin])/(integral[ibin+1] - integral[ibin]);; 3567 Fill(x);; 3568 }; 3569 delete [] integral;; 3570}; 3571 ; 3572////////////////////////////////////////////////////////////////////////////////; 3573/// Fill histogram following distribution in histogram h.; 3574///; 3575/// @param h : Histogram pointer used for sampling random number; 3576/// @param ntimes : number of times the histogram is filled; 3577/// @param rng : (optional) Random number generator used for sampling; 3578///; 3579/// The distribution contained in the histogram h (TH1) is integrated; 3580/// over the channel contents for the bin range of this histogram.; 3581/// It is normalized to 1.; 3582///; 3583/// Getting one random number implies:; 3584/// - Generating a random number between 0 and 1 (say r1); 3585/// - Look in which bin in the normalized integral r1 corresponds to; 3586/// - Fill histogram channel ntimes random numbers are generated; 3587///; 3588/// SPECIAL CASE when the target histogram has the same binning as the source.; 3589/// in this case we simply use a poisson distribution where; 3590/// the mean value per bin = bincontent/integral.; 3591 ; 3592void TH1::FillRandom(TH1 *h, Int_t ntimes, TRandom * rng); 3593{; 3594 if (!h) { Error(""FillRandom"", ""Null histogram""); return; }; 3595 if (fDimension != h->GetDimension()) {; 3596 Error(""FillRandom"", ""Histograms with different dimensions""); return;; 3597 }; 3598 if (std::isnan(h->ComputeIntegr",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:161745,Integrability,depend,depending,161745,"ers by calling these static functions before fitting (before calling `TH1::Fit`):; 3984/// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; 3985/// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; 3986/// The current defaults are (""Minuit"",""Migrad"").; 3987/// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; 3988/// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; 3989/// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; 3990/// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; 3991///; 3992/// Other options are possible depending on the Minimizer used, see the corresponding documentation.; 3993/// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; 3994///; 3995/// ~~~ {.cpp}; 3996/// Root.Fitter: Minuit2; 3997/// ~~~; 3998///; 3999/// \anchor HFitChi2; 4000/// ### Chi-square Fits; 4001///; 4002/// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; 4003/// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; 4004///; 4005/// \f[; 4006/// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; 4007/// \f]; 4008///; 4009/// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; 4010/// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also l",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:168503,Integrability,depend,depends,168503,"ram list of functions (fFunctions).; 4092/// If the histogram is made persistent, the list of associated functions is also persistent.; 4093/// Given a histogram h, one can retrieve an associated function with:; 4094///; 4095/// ~~~ {.cpp}; 4096/// TF1 *myfunc = h->GetFunction(""myfunc"");; 4097/// ~~~; 4098/// or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; 4099///; 4100/// \anchor HFitStatus; 4101/// ### Fit status; 4102///; 4103/// The status of the fit is obtained converting the TFitResultPtr to an integer; 4104/// independently if the fit option ""S"" is used or not:; 4105///; 4106/// ~~~ {.cpp}; 4107/// TFitResultPtr r = h->Fit(myFunc,opt);; 4108/// Int_t fitStatus = r;; 4109/// ~~~; 4110///; 4111/// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; 4112/// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; 4113/// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; 4114/// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; 4115/// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; 4116/// only in Minos but not in Migrad a fitStatus of 40 will be returned.; 4117/// Minuit2 returns 0 in case of success and different values in migrad,minos or; 4118/// hesse depending on the error. See in this case the documentation of; 4119/// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; 4120/// minos return status and Minuit2Minimizer::Hesse for the hesse return status.; 4121/// If other minimizers are used see their specific documentation for the status code returned.; 4122/// For example in the case of Fumili, see TFumili::Minimize.; 4123///; 4124/// \anchor HFitRange; 4125///",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:169022,Integrability,depend,depending,169022,"btained converting the TFitResultPtr to an integer; 4104/// independently if the fit option ""S"" is used or not:; 4105///; 4106/// ~~~ {.cpp}; 4107/// TFitResultPtr r = h->Fit(myFunc,opt);; 4108/// Int_t fitStatus = r;; 4109/// ~~~; 4110///; 4111/// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; 4112/// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; 4113/// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; 4114/// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; 4115/// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; 4116/// only in Minos but not in Migrad a fitStatus of 40 will be returned.; 4117/// Minuit2 returns 0 in case of success and different values in migrad,minos or; 4118/// hesse depending on the error. See in this case the documentation of; 4119/// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; 4120/// minos return status and Minuit2Minimizer::Hesse for the hesse return status.; 4121/// If other minimizers are used see their specific documentation for the status code returned.; 4122/// For example in the case of Fumili, see TFumili::Minimize.; 4123///; 4124/// \anchor HFitRange; 4125/// ### Fitting in a range; 4126///; 4127/// In order to fit in a sub-range of the histogram you have two options:; 4128/// - pass to this function the lower (`xxmin`) and upper (`xxmax`) values for the fitting range;; 4129/// - define a specific range in the fitted function and use the fitting option ""R"".; 4130/// For example, if your histogram has a defined range between -4 and 4 and you want to fit a gaussian; 4131/// only in the interval 1 to 3, you can do:; 4132///; 4133/// ~~~ {.cpp}; 41",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:173815,Integrability,rout,routines,173815,"etX2NDC(newx2); //new x end position; 4197///; 4198/// \anchor HFitExtra; 4199/// ### Additional Notes on Fitting; 4200///; 4201/// #### Fitting a histogram of dimension N with a function of dimension N-1; 4202///; 4203/// It is possible to fit a TH2 with a TF1 or a TH3 with a TF2.; 4204/// In this case the chi-square is computed from the squared error distance between the function values and the bin centers weighted by the bin content.; 4205/// For correct error scaling, the obtained parameter error are corrected as in the case when the; 4206/// option ""W"" is used.; 4207///; 4208/// #### User defined objective functions; 4209///; 4210/// By default when fitting a chi square function is used for fitting. When option ""L"" is used; 4211/// a Poisson likelihood function is used. Using option ""MULTI"" a multinomial likelihood fit is used.; 4212/// Thes functions are defined in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they; 4213/// are implemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in; 4214/// the file math/mathcore/src/FitUtil.cxx.; 4215/// It is possible to specify a user defined fitting function, using option ""U"" and; 4216/// calling the following functions:; 4217///; 4218/// ~~~ {.cpp}; 4219/// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; 4220/// ~~~; 4221///; 4222/// where MyFittingFunction is of type:; 4223///; 4224/// ~~~ {.cpp}; 4225/// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 4226/// ~~~; 4227///; 4228/// #### Note on treatment of empty bins; 4229///; 4230/// Empty bins, which have the content equal to zero AND error equal to zero,; 4231/// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; 4232/// since they affect the likelihood if the function value in these bins is not negligible.; 4233/// Note that if the histogram is having bins with zero content and non zero-errors they are considered as",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:195296,Integrability,rout,routine,195296,"/////////////////////////; 4737/// Compute Initial values of parameters for a polynom.; 4738 ; 4739void H1InitPolynom(); 4740{; 4741 Double_t fitpar[25];; 4742 ; 4743 TVirtualFitter *hFitter = TVirtualFitter::GetFitter();; 4744 TF1 *f1 = (TF1*)hFitter->GetUserFunc();; 4745 Int_t hxfirst = hFitter->GetXfirst();; 4746 Int_t hxlast = hFitter->GetXlast();; 4747 Int_t nchanx = hxlast - hxfirst + 1;; 4748 Int_t npar = f1->GetNpar();; 4749 ; 4750 if (nchanx <=1 || npar == 1) {; 4751 TH1 *curHist = (TH1*)hFitter->GetObjectFit();; 4752 fitpar[0] = curHist->GetSumOfWeights()/Double_t(nchanx);; 4753 } else {; 4754 H1LeastSquareFit( nchanx, npar, fitpar);; 4755 }; 4756 for (Int_t i=0;i<npar;i++) f1->SetParameter(i, fitpar[i]);; 4757}; 4758 ; 4759////////////////////////////////////////////////////////////////////////////////; 4760/// Least squares lpolynomial fitting without weights.; 4761///; 4762/// \param[in] n number of points to fit; 4763/// \param[in] m number of parameters; 4764/// \param[in] a array of parameters; 4765///; 4766/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 4767/// (E.Keil. revised by B.Schorr, 23.10.1981.); 4768 ; 4769void H1LeastSquareFit(Int_t n, Int_t m, Double_t *a); 4770{; 4771 const Double_t zero = 0.;; 4772 const Double_t one = 1.;; 4773 const Int_t idim = 20;; 4774 ; 4775 Double_t b[400] /* was [20][20] */;; 4776 Int_t i, k, l, ifail;; 4777 Double_t power;; 4778 Double_t da[20], xk, yk;; 4779 ; 4780 if (m <= 2) {; 4781 H1LeastSquareLinearFit(n, a[0], a[1], ifail);; 4782 return;; 4783 }; 4784 if (m > idim || m > n) return;; 4785 b[0] = Double_t(n);; 4786 da[0] = zero;; 4787 for (l = 2; l <= m; ++l) {; 4788 b[l-1] = zero;; 4789 b[m + l*20 - 21] = zero;; 4790 da[l-1] = zero;; 4791 }; 4792 TVirtualFitter *hFitter = TVirtualFitter::GetFitter();; 4793 TH1 *curHist = (TH1*)hFitter->GetObjectFit();; 4794 Int_t hxfirst = hFitter->GetXfirst();; 4795 Int_t hxlast = hFitter->GetXlast();; 4796 for (k = hxfirst; k <= hxlast; ++k) {; 4797 xk",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:198291,Integrability,rout,routine,198291,"; 4816 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 4817 ; 4818 for (i=0; i<m; ++i) a[i] = da[i];; 4819 ; 4820}; 4821 ; 4822////////////////////////////////////////////////////////////////////////////////; 4823/// Least square linear fit without weights.; 4824///; 4825/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 4826/// (added to LSQ by B. Schorr, 15.02.1982.); 4827 ; 4828void H1LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t &a1, Int_t &ifail); 4829{; 4830 Double_t xbar, ybar, x2bar;; 4831 Int_t i, n;; 4832 Double_t xybar;; 4833 Double_t fn, xk, yk;; 4834 Double_t det;; 4835 ; 4836 n = TMath::Abs(ndata);; 4837 ifail = -2;; 4838 xbar = ybar = x2bar = xybar = 0;; 4839 TVirtualFitter *hFitter = TVirtualFitter::GetFitter();; 4840 TH1 *curHist = (TH1*)hFitter->GetObjectFit();; 4841 Int_t hxfirst = hFitter->GetXfirst();; 4842 Int_t hxlast = hFitter->GetXlast();; 4843 for (i = hxfirst; i <= hxlast; ++i) {; 4844 xk = curHist->GetBinCenter(i);; 4845 yk = curHist->GetBinContent(i);; 4846 if (ndata < 0) {; 4847 if (yk <= 0) yk = 1e-9;; 4848 yk = TMath::Log(yk);; 4849 }; 4850 xbar += xk;; 4851 ybar += yk;; 4852 x2bar += xk*xk;; 4853 xybar += xk*yk;; 4854 }; 4855 fn = Double_t(n);; 4856 det = fn*x2bar - xbar*xbar;; 4857 ifail = -1;; 4858 if (det <= 0) {; 4859 a0 = ybar/fn;; 4860 a1 = 0;; 4861 return;; 4862 }; 4863 ifail = 0;; 4864 a0 = (x2bar*ybar - xbar*xybar) / det;; 4865 a1 = (fn*xybar - xbar*ybar) / det;; 4866 ; 4867}; 4868 ; 4869////////////////////////////////////////////////////////////////////////////////; 4870/// Extracted from CERN Program library routine DSEQN.; 4871///; 4872/// Translated to C++ by Rene Brun; 4873 ; 4874void H1LeastSquareSeqnd(Int_t n, Double_t *a, Int_t idim, Int_t &ifail, Int_t k, Double_t *b); 4875{; 4876 Int_t a_dim1, a_offset, b_dim1, b_offset;; 4877 Int_t nmjp1, i, j, l;; 4878 Int_t im1, jp1, nm1, nmi;; 4879 Double_t s1, s21, s22;; 4880 const Double_t one = 1.;; 4881 ; 4882 /* Parameter adjustments */; 4883 b_dim",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:219213,Integrability,message,message,219213,"ant to support this special case; 5447 // Int_t n = TMath::Min(axis->GetNbins(), labels->GetSize());; 5448 ; 5449 // support only cases where each bin has a labels (should be when axis is alphanumeric); 5450 Int_t n = labels->GetSize();; 5451 if (n != axis->GetNbins()) {; 5452 // check if labels are all consecutive and starts from the first bin; 5453 // in that case the current code will work fine; 5454 Int_t firstLabelBin = axis->GetNbins()+1;; 5455 Int_t lastLabelBin = -1;; 5456 for (Int_t i = 0; i < n; ++i) {; 5457 Int_t bin = labels->At(i)->GetUniqueID();; 5458 if (bin < firstLabelBin) firstLabelBin = bin;; 5459 if (bin > lastLabelBin) lastLabelBin = bin;; 5460 }; 5461 if (firstLabelBin != 1 || lastLabelBin-firstLabelBin +1 != n) {; 5462 Error(""LabelsOption"", ""%s of Histogram %s contains bins without labels. Sorting will not work correctly - return"",; 5463 axis->GetName(), GetName());; 5464 return;; 5465 }; 5466 // case where label bins are consecutive starting from first bin will work; 5467 // calling before a TH1::LabelsDeflate() will avoid this error message; 5468 Warning(""LabelsOption"", ""axis %s of Histogram %s has extra following bins without labels. Sorting will work only for first label bins"",; 5469 axis->GetName(), GetName());; 5470 }; 5471 std::vector<Int_t> a(n);; 5472 std::vector<Int_t> b(n);; 5473 ; 5474 ; 5475 Int_t i, j, k;; 5476 std::vector<Double_t> cont;; 5477 std::vector<Double_t> errors2;; 5478 THashList *labold = new THashList(labels->GetSize(), 1);; 5479 TIter nextold(labels);; 5480 TObject *obj = nullptr;; 5481 labold->AddAll(labels);; 5482 labels->Clear();; 5483 ; 5484 // delete buffer if it is there since bins will be reordered.; 5485 if (fBuffer); 5486 BufferEmpty(1);; 5487 ; 5488 if (sort > 0) {; 5489 //---sort by values of bins; 5490 if (GetDimension() == 1) {; 5491 cont.resize(n);; 5492 if (fSumw2.fN); 5493 errors2.resize(n);; 5494 for (i = 0; i < n; i++) {; 5495 cont[i] = RetrieveBinContent(i + 1);; 5496 if (!errors2.empty()); 5497 e",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:244656,Integrability,rout,routine,244656,"e buffer if it is there since it will become invalid; 6174 if (fBuffer) BufferEmpty(1);; 6175 ; 6176 if (LoggedInconsistency(""Multiply"", this, h1) >= kDifferentNumberOfBins ||; 6177 LoggedInconsistency(""Multiply"", h1, h2) >= kDifferentNumberOfBins) {; 6178 return false;; 6179 }; 6180 ; 6181 // Create Sumw2 if h1 or h2 have Sumw2 set; 6182 if (fSumw2.fN == 0 && (h1->GetSumw2N() != 0 || h2->GetSumw2N() != 0)) Sumw2();; 6183 ; 6184 // - Reset min - maximum; 6185 SetMinimum();; 6186 SetMaximum();; 6187 ; 6188 // - Loop on bins (including underflows/overflows); 6189 Double_t c1sq = c1 * c1; Double_t c2sq = c2 * c2;; 6190 for (Int_t i = 0; i < fNcells; ++i) {; 6191 Double_t b1 = h1->RetrieveBinContent(i);; 6192 Double_t b2 = h2->RetrieveBinContent(i);; 6193 UpdateBinContent(i, c1 * b1 * c2 * b2);; 6194 if (fSumw2.fN) {; 6195 fSumw2.fArray[i] = c1sq * c2sq * (h1->GetBinErrorSqUnchecked(i) * b2 * b2 + h2->GetBinErrorSqUnchecked(i) * b1 * b1);; 6196 }; 6197 }; 6198 ResetStats();; 6199 return kTRUE;; 6200}; 6201 ; 6202////////////////////////////////////////////////////////////////////////////////; 6203/// Control routine to paint any kind of histograms.; 6204///; 6205/// This function is automatically called by TCanvas::Update.; 6206/// (see TH1::Draw for the list of options); 6207 ; 6208void TH1::Paint(Option_t *option); 6209{; 6210 GetPainter(option);; 6211 ; 6212 if (fPainter) {; 6213 if (option && strlen(option) > 0); 6214 fPainter->Paint(option);; 6215 else; 6216 fPainter->Paint(fOption.Data());; 6217 }; 6218}; 6219 ; 6220////////////////////////////////////////////////////////////////////////////////; 6221/// Rebin this histogram; 6222///; 6223/// #### case 1 xbins=0; 6224///; 6225/// If newname is blank (default), the current histogram is modified and; 6226/// a pointer to it is returned.; 6227///; 6228/// If newname is not blank, the current histogram is not modified, and a; 6229/// new histogram is returned which is a Clone of the current histogram; 6230/// with its",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:247449,Integrability,message,message,247449,"tatistics will be recomputed from the new bin contents.; 6252///; 6253/// #### case 2 xbins!=0; 6254///; 6255/// A new histogram is created (you should specify newname).; 6256/// The parameter ngroup is the number of variable size bins in the created histogram.; 6257/// The array xbins must contain ngroup+1 elements that represent the low-edges; 6258/// of the bins.; 6259/// If the original histogram has errors stored (via Sumw2), the resulting; 6260/// histograms has new errors correctly calculated.; 6261///; 6262/// NOTE: The bin edges specified in xbins should correspond to bin edges; 6263/// in the original histogram. If a bin edge in the new histogram is; 6264/// in the middle of a bin in the original histogram, all entries in; 6265/// the split bin in the original histogram will be transfered to the; 6266/// lower of the two possible bins in the new histogram. This is; 6267/// probably not what you want. A warning message is emitted in this; 6268/// case; 6269///; 6270/// examples: if h1 is an existing TH1F histogram with 100 bins; 6271///; 6272/// ~~~ {.cpp}; 6273/// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; 6274/// h1->Rebin(24,""hnew"",xbins); //creates a new variable bin size histogram hnew; 6275/// ~~~; 6276 ; 6277TH1 *TH1::Rebin(Int_t ngroup, const char*newname, const Double_t *xbins); 6278{; 6279 Int_t nbins = fXaxis.GetNbins();; 6280 Double_t xmin = fXaxis.GetXmin();; 6281 Double_t xmax = fXaxis.GetXmax();; 6282 if ((ngroup <= 0) || (ngroup > nbins)) {; 6283 Error(""Rebin"", ""Illegal value of ngroup=%d"",ngroup);; 6284 return nullptr;; 6285 }; 6286 ; 6287 if (fDimension > 1 || InheritsFrom(TProfile::Class())) {; 6288 Error(""Rebin"", ""Operation valid on 1-D histograms only"");; 6289 return nullptr;; 6290 }; 6291 if (!newname && xbins) {; 6292 Error(""Rebin"",""if xbins is specified, newname must be given"");; 6293 return nullptr;; 6294 }; 6295 ; 6296 Int_t newbins = nbins/ngroup;; 6297 if (!xbins) {; 6298 Int_t nbg = n",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:266141,Integrability,rout,routine,266141,"nt_t lns = str1.Length();; 6729 ; 6730 if (isc >=0 ) {; 6731 fTitle = str1(0,isc);; 6732 str1 = str1(isc+1, lns);; 6733 isc = str1.Index("";"");; 6734 if (isc >=0 ) {; 6735 str2 = str1(0,isc);; 6736 str2.ReplaceAll(""#semicolon"",10,"";"",1);; 6737 fXaxis.SetTitle(str2.Data());; 6738 lns = str1.Length();; 6739 str1 = str1(isc+1, lns);; 6740 isc = str1.Index("";"");; 6741 if (isc >=0 ) {; 6742 str2 = str1(0,isc);; 6743 str2.ReplaceAll(""#semicolon"",10,"";"",1);; 6744 fYaxis.SetTitle(str2.Data());; 6745 lns = str1.Length();; 6746 str1 = str1(isc+1, lns);; 6747 str1.ReplaceAll(""#semicolon"",10,"";"",1);; 6748 fZaxis.SetTitle(str1.Data());; 6749 } else {; 6750 str1.ReplaceAll(""#semicolon"",10,"";"",1);; 6751 fYaxis.SetTitle(str1.Data());; 6752 }; 6753 } else {; 6754 str1.ReplaceAll(""#semicolon"",10,"";"",1);; 6755 fXaxis.SetTitle(str1.Data());; 6756 }; 6757 }; 6758 ; 6759 fTitle.ReplaceAll(""#semicolon"",10,"";"",1);; 6760 ; 6761 if (gPad && TestBit(kMustCleanup)) gPad->Modified();; 6762}; 6763 ; 6764////////////////////////////////////////////////////////////////////////////////; 6765/// Smooth array xx, translation of Hbook routine `hsmoof.F`.; 6766/// Based on algorithm 353QH twice presented by J. Friedman; 6767/// in [Proc. of the 1974 CERN School of Computing, Norway, 11-24 August, 1974](https://cds.cern.ch/record/186223).; 6768/// See also Section 4.2 in [J. Friedman, Data Analysis Techniques for High Energy Physics](https://www.slac.stanford.edu/pubs/slacreports/reports16/slac-r-176.pdf).; 6769 ; 6770void TH1::SmoothArray(Int_t nn, Double_t *xx, Int_t ntimes); 6771{; 6772 if (nn < 3 ) {; 6773 ::Error(""SmoothArray"",""Need at least 3 points for smoothing: n = %d"",nn);; 6774 return;; 6775 }; 6776 ; 6777 Int_t ii;; 6778 std::array<double, 3> hh{};; 6779 ; 6780 std::vector<double> yy(nn);; 6781 std::vector<double> zz(nn);; 6782 std::vector<double> rr(nn);; 6783 ; 6784 for (Int_t pass=0;pass<ntimes;pass++) {; 6785 // first copy original data into temp array; 6786 std::copy(xx, xx+nn, zz.begin(",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:293208,Integrability,depend,depends,293208,"02 gStyle->SetOptStat(TestBit(kNoStats));; 7503 }; 7504 TIter next(GetListOfFunctions());; 7505 TObject *obj;; 7506 ; 7507 while ((obj = next())) {; 7508 obj->UseCurrentStyle();; 7509 }; 7510}; 7511 ; 7512////////////////////////////////////////////////////////////////////////////////; 7513/// For axis = 1,2 or 3 returns the mean value of the histogram along; 7514/// X,Y or Z axis.; 7515///; 7516/// For axis = 11, 12, 13 returns the standard error of the mean value; 7517/// of the histogram along X, Y or Z axis; 7518///; 7519/// Note that the mean value/StdDev is computed using the bins in the currently; 7520/// defined range (see TAxis::SetRange). By default the range includes; 7521/// all bins from 1 to nbins included, excluding underflows and overflows.; 7522/// To force the underflows and overflows in the computation, one must; 7523/// call the static function TH1::StatOverflows(kTRUE) before filling; 7524/// the histogram.; 7525///; 7526/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7527/// are calculated. By default, if no range has been set, the returned mean is; 7528/// the (unbinned) one calculated at fill time. If a range has been set, however,; 7529/// the mean is calculated using the bins in range, as described above; THIS; 7530/// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; 7531/// the range. To ensure that the returned mean (and all other statistics) is; 7532/// always that of the binned data stored in the histogram, call TH1::ResetStats.; 7533/// See TH1::GetStats.; 7534///; 7535/// Return mean value of this histogram along the X axis.; 7536 ; 7537Double_t TH1::GetMean(Int_t axis) const; 7538{; 7539 if (axis<1 || (axis>3 && axis<11) || axis>13) return 0;; 7540 Double_t stats[kNstat];; 7541 for (Int_t i=4;i<kNstat;i++) stats[i] = 0;; 7542 GetStats(stats);; 7543 if (stats[0] == 0) return 0;; 7544 if (axis<4){; 7545 Int_t ax[3] = {2,4,7};; 7546 return stats[ax[axis-1]]/stats[0];; 7547 ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:295253,Integrability,depend,depends,295253," Neff ); 7549 Double_t stddev = GetStdDev(axis-10);; 7550 Double_t neff = GetEffectiveEntries();; 7551 return ( neff > 0 ? stddev/TMath::Sqrt(neff) : 0. );; 7552 }; 7553}; 7554 ; 7555////////////////////////////////////////////////////////////////////////////////; 7556/// Return standard error of mean of this histogram along the X axis.; 7557///; 7558/// Note that the mean value/StdDev is computed using the bins in the currently; 7559/// defined range (see TAxis::SetRange). By default the range includes; 7560/// all bins from 1 to nbins included, excluding underflows and overflows.; 7561/// To force the underflows and overflows in the computation, one must; 7562/// call the static function TH1::StatOverflows(kTRUE) before filling; 7563/// the histogram.; 7564///; 7565/// Also note, that although the definition of standard error doesn't include the; 7566/// assumption of normality, many uses of this feature implicitly assume it.; 7567///; 7568/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7569/// are calculated. By default, if no range has been set, the returned value is; 7570/// the (unbinned) one calculated at fill time. If a range has been set, however,; 7571/// the value is calculated using the bins in range, as described above; THIS; 7572/// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; 7573/// the range. To ensure that the returned value (and all other statistics) is; 7574/// always that of the binned data stored in the histogram, call TH1::ResetStats.; 7575/// See TH1::GetStats.; 7576 ; 7577Double_t TH1::GetMeanError(Int_t axis) const; 7578{; 7579 return GetMean(axis+10);; 7580}; 7581 ; 7582////////////////////////////////////////////////////////////////////////////////; 7583/// Returns the Standard Deviation (Sigma).; 7584/// The Sigma estimate is computed as; 7585/// \f[; 7586/// \sqrt{\frac{1}{N}(\sum(x_i-x_{mean})^2)}; 7587/// \f]; 7588/// For axis = 1,2 or 3 returns the Sigma value of the",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:296902,Integrability,depend,depends,296902,"eturn GetMean(axis+10);; 7580}; 7581 ; 7582////////////////////////////////////////////////////////////////////////////////; 7583/// Returns the Standard Deviation (Sigma).; 7584/// The Sigma estimate is computed as; 7585/// \f[; 7586/// \sqrt{\frac{1}{N}(\sum(x_i-x_{mean})^2)}; 7587/// \f]; 7588/// For axis = 1,2 or 3 returns the Sigma value of the histogram along; 7589/// X, Y or Z axis; 7590/// For axis = 11, 12 or 13 returns the error of StdDev estimation along; 7591/// X, Y or Z axis for Normal distribution; 7592///; 7593/// Note that the mean value/sigma is computed using the bins in the currently; 7594/// defined range (see TAxis::SetRange). By default the range includes; 7595/// all bins from 1 to nbins included, excluding underflows and overflows.; 7596/// To force the underflows and overflows in the computation, one must; 7597/// call the static function TH1::StatOverflows(kTRUE) before filling; 7598/// the histogram.; 7599///; 7600/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7601/// are calculated. By default, if no range has been set, the returned standard; 7602/// deviation is the (unbinned) one calculated at fill time. If a range has been; 7603/// set, however, the standard deviation is calculated using the bins in range,; 7604/// as described above; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use; 7605/// TAxis::SetRange(0, 0) to unset the range. To ensure that the returned standard; 7606/// deviation (and all other statistics) is always that of the binned data stored; 7607/// in the histogram, call TH1::ResetStats. See TH1::GetStats.; 7608 ; 7609Double_t TH1::GetStdDev(Int_t axis) const; 7610{; 7611 if (axis<1 || (axis>3 && axis<11) || axis>13) return 0;; 7612 ; 7613 Double_t x, stddev2, stats[kNstat];; 7614 for (Int_t i=4;i<kNstat;i++) stats[i] = 0;; 7615 GetStats(stats);; 7616 if (stats[0] == 0) return 0;; 7617 Int_t ax[3] = {2,4,7};; 7618 Int_t axm = ax[axis%10 - 1];; 7619 x = stats[axm]/stats[0];; 7620 // ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:298154,Integrability,depend,depends,298154,"bove; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use; 7605/// TAxis::SetRange(0, 0) to unset the range. To ensure that the returned standard; 7606/// deviation (and all other statistics) is always that of the binned data stored; 7607/// in the histogram, call TH1::ResetStats. See TH1::GetStats.; 7608 ; 7609Double_t TH1::GetStdDev(Int_t axis) const; 7610{; 7611 if (axis<1 || (axis>3 && axis<11) || axis>13) return 0;; 7612 ; 7613 Double_t x, stddev2, stats[kNstat];; 7614 for (Int_t i=4;i<kNstat;i++) stats[i] = 0;; 7615 GetStats(stats);; 7616 if (stats[0] == 0) return 0;; 7617 Int_t ax[3] = {2,4,7};; 7618 Int_t axm = ax[axis%10 - 1];; 7619 x = stats[axm]/stats[0];; 7620 // for negative stddev (e.g. when having negative weights) - return stdev=0; 7621 stddev2 = TMath::Max( stats[axm+1]/stats[0] -x*x, 0.0 );; 7622 if (axis<10); 7623 return TMath::Sqrt(stddev2);; 7624 else {; 7625 // The right formula for StdDev error depends on 4th momentum (see Kendall-Stuart Vol 1 pag 243); 7626 // formula valid for only gaussian distribution ( 4-th momentum = 3 * sigma^4 ); 7627 Double_t neff = GetEffectiveEntries();; 7628 return ( neff > 0 ? TMath::Sqrt(stddev2/(2*neff) ) : 0. );; 7629 }; 7630}; 7631 ; 7632////////////////////////////////////////////////////////////////////////////////; 7633/// Return error of standard deviation estimation for Normal distribution; 7634///; 7635/// Note that the mean value/StdDev is computed using the bins in the currently; 7636/// defined range (see TAxis::SetRange). By default the range includes; 7637/// all bins from 1 to nbins included, excluding underflows and overflows.; 7638/// To force the underflows and overflows in the computation, one must; 7639/// call the static function TH1::StatOverflows(kTRUE) before filling; 7640/// the histogram.; 7641///; 7642/// Value returned is standard deviation of sample standard deviation.; 7643/// Note that it is an approximated value which is valid only in the case that the; 7644/// original data distr",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:299474,Integrability,depend,depends,299474,"/////////////////////////////////////; 7633/// Return error of standard deviation estimation for Normal distribution; 7634///; 7635/// Note that the mean value/StdDev is computed using the bins in the currently; 7636/// defined range (see TAxis::SetRange). By default the range includes; 7637/// all bins from 1 to nbins included, excluding underflows and overflows.; 7638/// To force the underflows and overflows in the computation, one must; 7639/// call the static function TH1::StatOverflows(kTRUE) before filling; 7640/// the histogram.; 7641///; 7642/// Value returned is standard deviation of sample standard deviation.; 7643/// Note that it is an approximated value which is valid only in the case that the; 7644/// original data distribution is Normal. The correct one would require; 7645/// the 4-th momentum value, which cannot be accurately estimated from a histogram since; 7646/// the x-information for all entries is not kept.; 7647///; 7648/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7649/// are calculated. By default, if no range has been set, the returned value is; 7650/// the (unbinned) one calculated at fill time. If a range has been set, however,; 7651/// the value is calculated using the bins in range, as described above; THIS; 7652/// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; 7653/// the range. To ensure that the returned value (and all other statistics) is; 7654/// always that of the binned data stored in the histogram, call TH1::ResetStats.; 7655/// See TH1::GetStats.; 7656 ; 7657Double_t TH1::GetStdDevError(Int_t axis) const; 7658{; 7659 return GetStdDev(axis+10);; 7660}; 7661 ; 7662////////////////////////////////////////////////////////////////////////////////; 7663/// - For axis = 1, 2 or 3 returns skewness of the histogram along x, y or z axis.; 7664/// - For axis = 11, 12 or 13 returns the approximate standard error of skewness; 7665/// of the histogram along x, y or z axis; 7",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:300689,Integrability,depend,depends,300689,"t, if no range has been set, the returned value is; 7650/// the (unbinned) one calculated at fill time. If a range has been set, however,; 7651/// the value is calculated using the bins in range, as described above; THIS; 7652/// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; 7653/// the range. To ensure that the returned value (and all other statistics) is; 7654/// always that of the binned data stored in the histogram, call TH1::ResetStats.; 7655/// See TH1::GetStats.; 7656 ; 7657Double_t TH1::GetStdDevError(Int_t axis) const; 7658{; 7659 return GetStdDev(axis+10);; 7660}; 7661 ; 7662////////////////////////////////////////////////////////////////////////////////; 7663/// - For axis = 1, 2 or 3 returns skewness of the histogram along x, y or z axis.; 7664/// - For axis = 11, 12 or 13 returns the approximate standard error of skewness; 7665/// of the histogram along x, y or z axis; 7666///; 7667///Note, that since third and fourth moment are not calculated; 7668///at the fill time, skewness and its standard error are computed bin by bin; 7669///; 7670/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7671/// are calculated. See TH1::GetMean and TH1::GetStdDev.; 7672 ; 7673Double_t TH1::GetSkewness(Int_t axis) const; 7674{; 7675 ; 7676 if (axis > 0 && axis <= 3){; 7677 ; 7678 Double_t mean = GetMean(axis);; 7679 Double_t stddev = GetStdDev(axis);; 7680 Double_t stddev3 = stddev*stddev*stddev;; 7681 ; 7682 Int_t firstBinX = fXaxis.GetFirst();; 7683 Int_t lastBinX = fXaxis.GetLast();; 7684 Int_t firstBinY = fYaxis.GetFirst();; 7685 Int_t lastBinY = fYaxis.GetLast();; 7686 Int_t firstBinZ = fZaxis.GetFirst();; 7687 Int_t lastBinZ = fZaxis.GetLast();; 7688 // include underflow/overflow if TH1::StatOverflows(kTRUE) in case no range is set on the axis; 7689 if (GetStatOverflowsBehaviour()) {; 7690 if ( !fXaxis.TestBit(TAxis::kAxisRange) ) {; 7691 if (firstBinX == 1) firstBinX = 0;; 7692 if (lastBinX == fXaxis.",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:303473,Integrability,depend,depends,303473,"13 Double_t w = GetBinContent(binx,biny,binz);; 7714 np+=w;; 7715 sum+=w*(x-mean)*(x-mean)*(x-mean);; 7716 }; 7717 }; 7718 }; 7719 sum/=np*stddev3;; 7720 return sum;; 7721 }; 7722 else if (axis > 10 && axis <= 13) {; 7723 //compute standard error of skewness; 7724 // assume parent normal distribution use formula from Kendall-Stuart, Vol 1 pag 243, second edition; 7725 Double_t neff = GetEffectiveEntries();; 7726 return ( neff > 0 ? TMath::Sqrt(6./neff ) : 0. );; 7727 }; 7728 else {; 7729 Error(""GetSkewness"", ""illegal value of parameter"");; 7730 return 0;; 7731 }; 7732}; 7733 ; 7734////////////////////////////////////////////////////////////////////////////////; 7735/// - For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; 7736/// Kurtosis(gaussian(0, 1)) = 0.; 7737/// - For axis =11, 12 or 13 returns the approximate standard error of kurtosis; 7738/// of the histogram along x, y or z axis; 7739////; 7740/// Note, that since third and fourth moment are not calculated; 7741/// at the fill time, kurtosis and its standard error are computed bin by bin; 7742///; 7743/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7744/// are calculated. See TH1::GetMean and TH1::GetStdDev.; 7745 ; 7746Double_t TH1::GetKurtosis(Int_t axis) const; 7747{; 7748 if (axis > 0 && axis <= 3){; 7749 ; 7750 Double_t mean = GetMean(axis);; 7751 Double_t stddev = GetStdDev(axis);; 7752 Double_t stddev4 = stddev*stddev*stddev*stddev;; 7753 ; 7754 Int_t firstBinX = fXaxis.GetFirst();; 7755 Int_t lastBinX = fXaxis.GetLast();; 7756 Int_t firstBinY = fYaxis.GetFirst();; 7757 Int_t lastBinY = fYaxis.GetLast();; 7758 Int_t firstBinZ = fZaxis.GetFirst();; 7759 Int_t lastBinZ = fZaxis.GetLast();; 7760 // include underflow/overflow if TH1::StatOverflows(kTRUE) in case no range is set on the axis; 7761 if (GetStatOverflowsBehaviour()) {; 7762 if ( !fXaxis.TestBit(TAxis::kAxisRange) ) {; 7763 if (firstBinX == 1) firstBinX = 0;; 7764 if (lastBinX == fXaxis",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:306484,Integrability,depend,dependent,306484,"om Kendall-Stuart, Vol 1 pag 243, second edition; 7797 Double_t neff = GetEffectiveEntries();; 7798 return ( neff > 0 ? TMath::Sqrt(24./neff ) : 0. );; 7799 }; 7800 else {; 7801 Error(""GetKurtosis"", ""illegal value of parameter"");; 7802 return 0;; 7803 }; 7804}; 7805 ; 7806////////////////////////////////////////////////////////////////////////////////; 7807/// fill the array stats from the contents of this histogram; 7808/// The array stats must be correctly dimensioned in the calling program.; 7809///; 7810/// ~~~ {.cpp}; 7811/// stats[0] = sumw; 7812/// stats[1] = sumw2; 7813/// stats[2] = sumwx; 7814/// stats[3] = sumwx2; 7815/// ~~~; 7816///; 7817/// If no axis-subrange is specified (via TAxis::SetRange), the array stats; 7818/// is simply a copy of the statistics quantities computed at filling time.; 7819/// If a sub-range is specified, the function recomputes these quantities; 7820/// from the bin contents in the current axis range.; 7821///; 7822/// IMPORTANT NOTE: This means that the returned statistics are context-dependent.; 7823/// If TAxis::kAxisRange, the returned statistics are dependent on the binning;; 7824/// otherwise, they are a copy of the histogram statistics computed at fill time,; 7825/// which are unbinned by default (calling TH1::ResetStats forces them to use; 7826/// binned statistics). You can reset TAxis::kAxisRange using TAxis::SetRange(0, 0).; 7827///; 7828/// Note that the mean value/StdDev is computed using the bins in the currently; 7829/// defined range (see TAxis::SetRange). By default the range includes; 7830/// all bins from 1 to nbins included, excluding underflows and overflows.; 7831/// To force the underflows and overflows in the computation, one must; 7832/// call the static function TH1::StatOverflows(kTRUE) before filling; 7833/// the histogram.; 7834 ; 7835void TH1::GetStats(Double_t *stats) const; 7836{; 7837 if (fBuffer) ((TH1*)this)->BufferEmpty();; 7838 ; 7839 // Loop on bins (possibly including underflows/overflows); ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:306554,Integrability,depend,dependent,306554,"tosis"", ""illegal value of parameter"");; 7802 return 0;; 7803 }; 7804}; 7805 ; 7806////////////////////////////////////////////////////////////////////////////////; 7807/// fill the array stats from the contents of this histogram; 7808/// The array stats must be correctly dimensioned in the calling program.; 7809///; 7810/// ~~~ {.cpp}; 7811/// stats[0] = sumw; 7812/// stats[1] = sumw2; 7813/// stats[2] = sumwx; 7814/// stats[3] = sumwx2; 7815/// ~~~; 7816///; 7817/// If no axis-subrange is specified (via TAxis::SetRange), the array stats; 7818/// is simply a copy of the statistics quantities computed at filling time.; 7819/// If a sub-range is specified, the function recomputes these quantities; 7820/// from the bin contents in the current axis range.; 7821///; 7822/// IMPORTANT NOTE: This means that the returned statistics are context-dependent.; 7823/// If TAxis::kAxisRange, the returned statistics are dependent on the binning;; 7824/// otherwise, they are a copy of the histogram statistics computed at fill time,; 7825/// which are unbinned by default (calling TH1::ResetStats forces them to use; 7826/// binned statistics). You can reset TAxis::kAxisRange using TAxis::SetRange(0, 0).; 7827///; 7828/// Note that the mean value/StdDev is computed using the bins in the currently; 7829/// defined range (see TAxis::SetRange). By default the range includes; 7830/// all bins from 1 to nbins included, excluding underflows and overflows.; 7831/// To force the underflows and overflows in the computation, one must; 7832/// call the static function TH1::StatOverflows(kTRUE) before filling; 7833/// the histogram.; 7834 ; 7835void TH1::GetStats(Double_t *stats) const; 7836{; 7837 if (fBuffer) ((TH1*)this)->BufferEmpty();; 7838 ; 7839 // Loop on bins (possibly including underflows/overflows); 7840 Int_t bin, binx;; 7841 Double_t w,err;; 7842 Double_t x;; 7843 // identify the case of labels with extension of axis range; 7844 // in this case the statistics in x does not make any se",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:319335,Integrability,rout,routine,319335,"119/// - ""D"" Put out a line of ""Debug"" printout; 8120/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 8121/// - ""X"" Run the pseudo experiments post-processor with the following procedure:; 8122/// make pseudoexperiments based on random values from the parent distribution,; 8123/// compare the KS distance of the pseudoexperiment to the parent; 8124/// distribution, and count all the KS values above the value; 8125/// obtained from the original data to Monte Carlo distribution.; 8126/// The number of pseudo-experiments nEXPT is by default 1000, and; 8127/// it can be changed by specifying the option as ""X=number"",; 8128/// for example ""X=10000"" for 10000 toys.; 8129/// The function returns the probability.; 8130/// (thanks to Ben Kilminster to submit this procedure). Note that; 8131/// this option ""X"" is much slower.; 8132///; 8133/// The returned function value is the probability of test; 8134/// (much less than one means NOT compatible); 8135///; 8136/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 8137///; 8138/// NOTE1; 8139/// A good description of the Kolmogorov test can be seen at:; 8140/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; 8141///; 8142/// NOTE2; 8143/// see also alternative function TH1::Chi2Test; 8144/// The Kolmogorov test is assumed to give better results than Chi2Test; 8145/// in case of histograms with low statistics.; 8146///; 8147/// NOTE3 (Jan Conrad, Fred James); 8148/// ""The returned value PROB is calculated such that it will be; 8149/// uniformly distributed between zero and one for compatible histograms,; 8150/// provided the data are not binned (or the number of bins is very large; 8151/// compared with the number of events). Users who have access to unbinned; 8152/// data and wish exact confidence levels should therefore not put their data; 8153/// into histograms, but should call directly TMath::KolmogorovTest. On; 8154/// the other hand, since TH1 is a convenient way of collecting",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:320478,Integrability,depend,depending,320478,"40/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; 8141///; 8142/// NOTE2; 8143/// see also alternative function TH1::Chi2Test; 8144/// The Kolmogorov test is assumed to give better results than Chi2Test; 8145/// in case of histograms with low statistics.; 8146///; 8147/// NOTE3 (Jan Conrad, Fred James); 8148/// ""The returned value PROB is calculated such that it will be; 8149/// uniformly distributed between zero and one for compatible histograms,; 8150/// provided the data are not binned (or the number of bins is very large; 8151/// compared with the number of events). Users who have access to unbinned; 8152/// data and wish exact confidence levels should therefore not put their data; 8153/// into histograms, but should call directly TMath::KolmogorovTest. On; 8154/// the other hand, since TH1 is a convenient way of collecting data and; 8155/// saving space, this function has been provided. However, the values of; 8156/// PROB for binned data will be shifted slightly higher than expected,; 8157/// depending on the effects of the binning. For example, when comparing two; 8158/// uniform distributions of 500 events in 100 bins, the values of PROB,; 8159/// instead of being exactly uniformly distributed between zero and one, have; 8160/// a mean value of about 0.56. We can apply a useful; 8161/// rule: As long as the bin width is small compared with any significant; 8162/// physical effect (for example the experimental resolution) then the binning; 8163/// cannot have an important effect. Therefore, we believe that for all; 8164/// practical purposes, the probability value PROB is calculated correctly; 8165/// provided the user is aware that:; 8166///; 8167/// 1. The value of PROB should not be expected to have exactly the correct; 8168/// distribution for binned data.; 8169/// 2. The user is responsible for seeing to it that the bin widths are; 8170/// small compared with any physical phenomena of interest.; 8171/// 3. The effect of binning (if a",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:353924,Integrability,depend,depend,353924,");; 9056}; 9057 ; 9058////////////////////////////////////////////////////////////////////////////////; 9059/// Return value of error associated to bin number bin.; 9060///; 9061/// if the sum of squares of weights has been defined (via Sumw2),; 9062/// this function returns the sqrt(sum of w2).; 9063/// otherwise it returns the sqrt(contents) for this bin.; 9064 ; 9065Double_t TH1::GetBinError(Int_t bin) const; 9066{; 9067 if (bin < 0) bin = 0;; 9068 if (bin >= fNcells) bin = fNcells-1;; 9069 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9070 if (fSumw2.fN) return TMath::Sqrt(fSumw2.fArray[bin]);; 9071 ; 9072 return TMath::Sqrt(TMath::Abs(RetrieveBinContent(bin)));; 9073}; 9074 ; 9075////////////////////////////////////////////////////////////////////////////////; 9076/// Return lower error associated to bin number bin.; 9077///; 9078/// The error will depend on the statistic option used will return; 9079/// the binContent - lower interval value; 9080 ; 9081Double_t TH1::GetBinErrorLow(Int_t bin) const; 9082{; 9083 if (fBinStatErrOpt == kNormal) return GetBinError(bin);; 9084 // in case of weighted histogram check if it is really weighted; 9085 if (fSumw2.fN && fTsumw != fTsumw2) return GetBinError(bin);; 9086 ; 9087 if (bin < 0) bin = 0;; 9088 if (bin >= fNcells) bin = fNcells-1;; 9089 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9090 ; 9091 Double_t alpha = 1.- 0.682689492;; 9092 if (fBinStatErrOpt == kPoisson2) alpha = 0.05;; 9093 ; 9094 Double_t c = RetrieveBinContent(bin);; 9095 Int_t n = int(c);; 9096 if (n < 0) {; 9097 Warning(""GetBinErrorLow"",""Histogram has negative bin content-force usage to normal errors"");; 9098 ((TH1*)this)->fBinStatErrOpt = kNormal;; 9099 return GetBinError(bin);; 9100 }; 9101 ; 9102 if (n == 0) return 0;; 9103 return c - ROOT::Math::gamma_quantile( alpha/2, n, 1.);; 9104}; 9105 ; 9106////////////////////////////////////////////////////////////////////////////////; 9107/// Return upper error associated to bin number bin.; 9108///; 9109/// Th",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:355075,Integrability,depend,depend,355075,"ted; 9085 if (fSumw2.fN && fTsumw != fTsumw2) return GetBinError(bin);; 9086 ; 9087 if (bin < 0) bin = 0;; 9088 if (bin >= fNcells) bin = fNcells-1;; 9089 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9090 ; 9091 Double_t alpha = 1.- 0.682689492;; 9092 if (fBinStatErrOpt == kPoisson2) alpha = 0.05;; 9093 ; 9094 Double_t c = RetrieveBinContent(bin);; 9095 Int_t n = int(c);; 9096 if (n < 0) {; 9097 Warning(""GetBinErrorLow"",""Histogram has negative bin content-force usage to normal errors"");; 9098 ((TH1*)this)->fBinStatErrOpt = kNormal;; 9099 return GetBinError(bin);; 9100 }; 9101 ; 9102 if (n == 0) return 0;; 9103 return c - ROOT::Math::gamma_quantile( alpha/2, n, 1.);; 9104}; 9105 ; 9106////////////////////////////////////////////////////////////////////////////////; 9107/// Return upper error associated to bin number bin.; 9108///; 9109/// The error will depend on the statistic option used will return; 9110/// the binContent - upper interval value; 9111 ; 9112Double_t TH1::GetBinErrorUp(Int_t bin) const; 9113{; 9114 if (fBinStatErrOpt == kNormal) return GetBinError(bin);; 9115 // in case of weighted histogram check if it is really weighted; 9116 if (fSumw2.fN && fTsumw != fTsumw2) return GetBinError(bin);; 9117 if (bin < 0) bin = 0;; 9118 if (bin >= fNcells) bin = fNcells-1;; 9119 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9120 ; 9121 Double_t alpha = 1.- 0.682689492;; 9122 if (fBinStatErrOpt == kPoisson2) alpha = 0.05;; 9123 ; 9124 Double_t c = RetrieveBinContent(bin);; 9125 Int_t n = int(c);; 9126 if (n < 0) {; 9127 Warning(""GetBinErrorUp"",""Histogram has negative bin content-force usage to normal errors"");; 9128 ((TH1*)this)->fBinStatErrOpt = kNormal;; 9129 return GetBinError(bin);; 9130 }; 9131 ; 9132 // for N==0 return an upper limit at 0.68 or (1-alpha)/2 ?; 9133 // decide to return always (1-alpha)/2 upper interval; 9134 //if (n == 0) return ROOT::Math::gamma_quantile_c(alpha,n+1,1);; 9135 return ROOT::Math::gamma_quantile_c( alpha/2, n+1, 1) - c;; 9136}; 9137 ; 9",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:411665,Integrability,rout,routine,411665,"ption_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; TH1Merger.h; IsEquidistantBinningstatic bool IsEquidistantBinning(const TAxis &axis)Test if the binning is equidistant.Definition TH1.cxx:5878; H1LeastSquareLinearFitvoid H1LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t &a1, Int_t &ifail)Least square linear fit without weights.Definition TH1.cxx:4826; H1InitGausvoid H1InitGaus()Compute Initial values of parameters for a gaussian.Definition TH1.cxx:4661; H1InitExpovoid H1InitExpo()Compute Initial values of parameters for an exponential.Definition TH1.cxx:4717; operator+TH1C operator+(const TH1C &h1, const TH1C &h2)Operator +.Definition TH1.cxx:9608; operator-TH1C operator-(const TH1C &h1, const TH1C &h2)Operator -.Definition TH1.cxx:9619; operator/TH1C operator/(const TH1C &h1, const TH1C &h2)Operator /.Definition TH1.cxx:9641; H1LeastSquareSeqndvoid H1LeastSquareSeqnd(Int_t n, Double_t *a, Int_t idim, Int_t &ifail, Int_t k, Double_t *b)Extracted from CERN Program library routine DSEQN.Definition TH1.cxx:4872; AlmostEqualstatic Bool_t AlmostEqual(Double_t a, Double_t b, Double_t epsilon=0.00000001)Test if two double are almost equal.Definition TH1.cxx:5861; AlmostIntegerstatic Bool_t AlmostInteger(Double_t a, Double_t epsilon=0.00000001)Test if a double is almost an integer.Definition TH1.cxx:5869; gF1TF1 * gF1Definition TH1.cxx:581; R__HTH1 * R__H(Int_t hid)return pointer to histogram with name hid if id >=0 h_id if id <0Definition TH1.cxx:10579; operator*TH1C operator*(Double_t c1, const TH1C &h1)Operator *.Definition TH1.cxx:9597; H1LeastSquareFitvoid H1LeastSquareFit(Int_t n, Int_t m, Double_t *a)Least squares lpolynomial fitting without weights.Definition TH1.cxx:4767; H1InitPolynomvoid H1InitPolynom()Compute Initial values of parameters for a polynom.Definition TH1.cxx:4737; TH1.h; TH2.h; TH3.h; THLimitsFinder.h; THashList.h; xminfloat xminDefinition THbookFile.cxx:95; nentries",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:425043,Integrability,wrap,wrapper,425043,"LowEdge(Double_t *edge) constReturn an array with the low edge of all bins.Definition TAxis.cxx:562; TAxis::SetRangevirtual void SetRange(Int_t first=0, Int_t last=0)Set the viewing range for the axis using bin numbers.Definition TAxis.cxx:1052; TAxis::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width.Definition TAxis.cxx:540; TAxis::GetBinUpEdgevirtual Double_t GetBinUpEdge(Int_t bin) constReturn up edge of bin.Definition TAxis.cxx:528; TAxis::GetFirstInt_t GetFirst() constReturn first bin on the axis i.e.Definition TAxis.cxx:458; TAxis::GetLabelsTHashList * GetLabels() constDefinition TAxis.h:121; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7514; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::AddAllvirtual void AddAll(const TCollection *col)Add all objects from collection col to this collection.Definition TCollection.cxx:195; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TCollection::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an collection using the Streamer facility.Definition TCollection.cxx:263; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:437919,Integrability,rout,routine,437919," of weight*X*X.Definition TH1.h:99; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::TH1TH1()Histogram default constructor.Definition TH1.cxx:615; TH1::TransformHistostatic TH1 * TransformHisto(TVirtualFFT *fft, TH1 *h_output, Option_t *option)For a given transform (first parameter), fills the histogram (second parameter) with the transform ou...Definition TH1.cxx:9319; TH1::UseCurrentStylevoid UseCurrentStyle() overrideCopy current attributes from/to current style.Definition TH1.cxx:7469; TH1::LabelsOptionvirtual void LabelsOption(Option_t *option=""h"", Option_t *axis=""X"")Sort bins with labels or set option(s) to draw axis with labels.Definition TH1.cxx:5382; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::fBarOffsetShort_t fBarOffset(1000*offset) for bar charts or legosDefinition TH1.h:93; TH1::Chi2TestXvirtual Double_t Chi2TestX(const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) constThe computation routine of the Chisquare test.Definition TH1.cxx:2067; TH1::CheckBinLimitsstatic bool CheckBinLimits(const TAxis *a1, const TAxis *a2)Check bin limits.Definition TH1.cxx:1541; TH1::AddBinContentvirtual void AddBinContent(Int_t bin)Increment bin content by 1.Definition TH1.cxx:1268; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::FitOptionsMakestatic Int_t FitOptionsMake(Option_t *option, Foption_t &Foption)Decode string choptin and fill fitOption structure.Definition TH1.cxx:4652; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::GetNormFactorvirtual Double_t GetNormFactor() constDefinition TH1.h:301; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::GetSkewnessvirtual Double_t GetSkewness",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:450983,Integrability,rout,routine,450983,"inx in the range [firstx,lastx] for which diff = abs(bin_content-c) <= maxdiff.Definition TH1.cxx:5086; TH1::SetCanExtendvirtual UInt_t SetCanExtend(UInt_t extendBitMask)Make the histogram axes extendable / not extendable according to the bit mask returns the previous bi...Definition TH1.cxx:6649; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::IsEmptyBool_t IsEmpty() constCheck if a histogram is empty (this is a protected method used mainly by TH1Merger )Definition TH1.cxx:5164; TH1::GetMeanErrorvirtual Double_t GetMeanError(Int_t axis=1) constReturn standard error of mean of this histogram along the X axis.Definition TH1.cxx:7575; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling ...Definition TH1.cxx:8062; TH1::ResetStatsvirtual void ResetStats()Reset the statistics including the number of entries and replace with values calculated from bin cont...Definition TH1.cxx:7902; TH1::SetDefaultBufferSizestatic void SetDefaultBufferSize(Int_t buffersize=1000)Static function to set the default buffer size for automatic histograms.Definition TH1.cxx:6693; TH1::SetBinErrorOptionvirtual void SetBinErrorOption(EBinErrorOpt type)Definition TH1.h:381; TH1::SetBuffervirtual void SetBuffer(Int_t buffersize, Option_t *option="""")Set the maximum number of entries to be kept in the buffer.Definition TH1.cxx:8458; TH1::DrawPanelvirtual void DrawPanel()Display a panel with all histogram drawing options.Def",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:459099,Integrability,rout,routine,459099,"H1.cxx:8635; TH1::LoggedInconsistencyint LoggedInconsistency(const char *name, const TH1 *h1, const TH1 *h2, bool useMerge=false) constDefinition TH1.cxx:883; TH1::CheckConsistentSubAxesstatic bool CheckConsistentSubAxes(const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0)Check that two sub axis are the same.Definition TH1.cxx:1640; TH1::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove object from the list of functions.Definition TH1.cxx:6576; TH1::fYaxisTAxis fYaxisY axis descriptor.Definition TH1.h:91; TH1::KolmogorovTestvirtual Double_t KolmogorovTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using Kolmogorov test.Definition TH1.cxx:8178; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TH1::SmoothArraystatic void SmoothArray(Int_t NN, Double_t *XX, Int_t ntimes=1)Smooth array xx, translation of Hbook routine hsmoof.F.Definition TH1.cxx:6768; TH1::GetCentervirtual void GetCenter(Double_t *center) constFill array with center of bins for 1D histogram Better to use h1.GetXaxis()->GetCenter(center)Definition TH1.cxx:9174; TH1::fPainterTVirtualHistPainter * fPainter! Pointer to histogram painterDefinition TH1.h:112; TH1::SetBinsvirtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax)Redefine x axis parameters.Definition TH1.cxx:8767; TH1::FindFixBinvirtual Int_t FindFixBin(Double_t x, Double_t y=0, Double_t z=0) constReturn Global bin number corresponding to x,y,z.Definition TH1.cxx:3705; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TH1::SetEntriesvirtual void SetEntries(Double_t n)Definition TH1.h:391; TH1::FindNewAxisLimitsvirtual Bool_t FindNewAxisLimits(const TAxis *axis, const Double_t point, Double_t &newMin, Double_t &newMax)finds new limits fo",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:465396,Integrability,message,message,465396,"TNamed.Definition TNamed.cxx:140; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::AbstractMethodvoid AbstractMethod(const char *method) constUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinit",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:466107,Integrability,message,message,466107,"cxx:213; TObject::UseCurrentStylevirtual void UseCurrentStyle()Set current style settings in this object This function is called when either TCanvas::UseCurrentStyl...Definition TObject.cxx:807; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TProfile::Classstatic TClass * Class(); TRandomThis is the base class for the ROOT R",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:466725,Integrability,message,message,466725,"92; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TProfile::Classstatic TClass * Class(); TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TRandom::PoissonDvirtual Double_t PoissonD(Double_t mean)Generates a random number according to a Poisson law.Definition TRandom.cxx:461; TRandom::Poissonvirtual ULong64_t Poisson(Double_t mean)Generates a random integer N according to a Poisson law.Definition TRandom.cxx:404; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:470764,Integrability,interface,interface,470764,"lStyle() constDefinition TStyle.h:234; TStyle::GetHistFillColorColor_t GetHistFillColor() constDefinition TStyle.h:232; TStyle::GetBarWidthFloat_t GetBarWidth() constDefinition TStyle.h:183; TStyle::GetCanvasPreferGLBool_t GetCanvasPreferGL() constDefinition TStyle.h:187; TStyle::SetHistLineColorvoid SetHistLineColor(Color_t color=1)Definition TStyle.h:380; TStyle::SetBarOffsetvoid SetBarOffset(Float_t baroff=0.5)Definition TStyle.h:335; TStyle::GetHistLineStyleStyle_t GetHistLineStyle() constDefinition TStyle.h:235; TStyle::SetBarWidthvoid SetBarWidth(Float_t barwidth=0.5)Definition TStyle.h:336; TStyle::SetHistFillStylevoid SetHistFillStyle(Style_t styl=0)Definition TStyle.h:381; TStyle::GetHistLineWidthWidth_t GetHistLineWidth() constDefinition TStyle.h:236; TStyle::GetOptFitInt_t GetOptFit() constDefinition TStyle.h:244; TStyle::SetHistLineWidthvoid SetHistLineWidth(Width_t width=1)Definition TStyle.h:383; TVectorTTVectorT.Definition TVectorT.h:27; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualFFT::FFTstatic TVirtualFFT * FFT(Int_t ndim, Int_t *n, Option_t *option)Returns a pointer to the FFT of requested size and type.Definition TVirtualFFT.cxx:131; TVirtualFFT::GetNdimvirtual Int_t GetNdim() const =0; TVirtualFFT::SineCosinestatic TVirtualFFT * SineCosine(Int_t ndim, Int_t *n, Int_t *r2rkind, Option_t *option)Returns a pointer to a sine or cosine transform of requested size and kind.Definition TVirtualFFT.cxx:279; TVirtualFFT::GetTypevirtual Option_t * GetType() const =0; TVirtualFFT::Transformvirtual void Transform()=0; TVirtualFFT::GetPointComplexvirtual void GetPointComplex(Int_t ipoint, Double_t &re, Double_t &im, Bool_t fromInput=kFALSE) const =0; TVirtualFFT::GetNvirtual Int_t * GetN() const =0; TVirtualFFT::GetPointRealvirtual Double_t GetPointReal(Int_t ipoint, Bool_t fromInput=kFALSE) const =0; TVirtualFFT::SetPointvirtual void SetPoint(Int_t ipoint, Double_t re, Double_t im=0)=0; TVirtual",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:472363,Integrability,interface,interface,472363,"al void Transform()=0; TVirtualFFT::GetPointComplexvirtual void GetPointComplex(Int_t ipoint, Double_t &re, Double_t &im, Bool_t fromInput=kFALSE) const =0; TVirtualFFT::GetNvirtual Int_t * GetN() const =0; TVirtualFFT::GetPointRealvirtual Double_t GetPointReal(Int_t ipoint, Bool_t fromInput=kFALSE) const =0; TVirtualFFT::SetPointvirtual void SetPoint(Int_t ipoint, Double_t re, Double_t im=0)=0; TVirtualFitterAbstract Base Class for Fitting.Definition TVirtualFitter.h:29; TVirtualFitter::GetXlastvirtual Int_t GetXlast() constDefinition TVirtualFitter.h:86; TVirtualFitter::GetObjectFitvirtual TObject * GetObjectFit() constDefinition TVirtualFitter.h:77; TVirtualFitter::GetXfirstvirtual Int_t GetXfirst() constDefinition TVirtualFitter.h:85; TVirtualFitter::GetFitterstatic TVirtualFitter * GetFitter()static: return the current FitterDefinition TVirtualFitter.cxx:209; TVirtualFitter::GetUserFuncvirtual TObject * GetUserFunc() constDefinition TVirtualFitter.h:84; TVirtualHistPainterAbstract interface to a histogram painter.Definition TVirtualHistPainter.h:30; TVirtualHistPainter::DrawPanelvirtual void DrawPanel()=0; TVirtualHistPainter::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) override=0Computes distance from point (px,py) to the object.; TVirtualHistPainter::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) override=0Execute action corresponding to an event at (px,py).; TVirtualHistPainter::SetHighlightvirtual void SetHighlight()=0; TVirtualHistPainter::HistPainterstatic TVirtualHistPainter * HistPainter(TH1 *obj)Static function returning a pointer to the current histogram painter.Definition TVirtualHistPainter.cxx:31; TVirtualHistPainter::Paintvoid Paint(Option_t *option="""") override=0This method must be overridden if a class wants to paint itself.; TVirtualPaveStatsDefinition TVirtualPaveStats.h:28; TVirtualPaveStats::SetParentvirtual void SetParent(TObject *)=0; bool; double; int; unsigned int; ROOT::Math::gamma_quantile_cdouble ga",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:2643,Modifiability,variab,variable,2643,"\brief 1-D histogram with a double per channel (see TH1 documentation); 72@}; 73*/; 74 ; 75/** \class TH1; 76 \ingroup Histograms; 77TH1 is the base class of all histogram classes in %ROOT.; 78 ; 79It provides the common interface for operations such as binning, filling, drawing, which; 80will be detailed below.; 81 ; 82-# [Creating histograms](\ref creating-histograms); 83 - [Labelling axes](\ref labelling-axis); 84-# [Binning](\ref binning); 85 - [Fix or variable bin size](\ref fix-var); 86 - [Convention for numbering bins](\ref convention); 87 - [Alphanumeric Bin Labels](\ref alpha); 88 - [Histograms with automatic bins](\ref auto-bin); 89 - [Rebinning](\ref rebinning); 90-# [Filling histograms](\ref filling-histograms); 91 - [Associated errors](\ref associated-errors); 92 - [Associated functions](\ref associated-functions); 93 - [Projections of histograms](\ref prof-hist); 94 - [Random Numbers and histograms](\ref random-numbers); 95 - [Making a copy of a histogram](\ref making-a-copy); 96 - [Normalizing histograms](\ref normalizing); 97-# [Drawing histograms](\ref drawing-histograms); 98 - [Setting Drawing histogram contour levels (2-D hists only)](\ref cont-level); 99 - [Setting histogram graphics attributes](\ref graph-att); 100 - [Customising how axes are drawn](\ref axis-drawing); 101-# [Fitting histograms](\ref fitting-histograms); 102-# [Saving/reading histograms to/from a ROOT file](\ref saving-histograms); 103-# [Operations on histograms](\ref operations-on-histograms); 104-# [Miscellaneous operations](\ref misc); 105 ; 106ROOT supports the following histogram types:; 107 ; 108 - 1-D histograms:; 109 - TH1C : histograms with one byte per channel. Maximum bin content = 127; 110 - TH1S : histograms with one short per channel. Maximum bin content = 32767; 111 - TH1I : histograms with one int per channel. Maximum bin content = INT_MAX (\ref intmax ""*""); 112 - TH1L : histograms with one long64 per channel. Maximum bin content = LLONG_MAX (\ref llongmax ""**"")",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:6555,Modifiability,variab,variable,6555," content = LLONG_MAX (\ref llongmax ""**""); 127 - TH3F : histograms with one float per channel. Maximum precision 7 digits, maximum integer bin content = +/-16777216 (\ref floatmax ""***""); 128 - TH3D : histograms with one double per channel. Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 (\ref doublemax ""****""); 129 - Profile histograms: See classes TProfile, TProfile2D and TProfile3D.; 130 Profile histograms are used to display the mean value of Y and its standard deviation; 131 for each bin in X. Profile histograms are in many cases an elegant; 132 replacement of two-dimensional histograms : the inter-relation of two; 133 measured quantities X and Y can always be visualized by a two-dimensional; 134 histogram or scatter-plot; If Y is an unknown (but single-valued); 135 approximate function of X, this function is displayed by a profile; 136 histogram with much better precision than by a scatter-plot.; 137 ; 138<sup>; 139\anchor intmax (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 140\anchor llongmax (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 141\anchor floatmax (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 142\anchor doublemax (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 143</sup>; 144 ; 145The inheritance hierarchy looks as follows:; 146 ; 147\image html classTH1__inherit__graph_org.svg width=100%; 148 ; 149\anchor creating-histograms; 150## Creating histograms; 151 ; 152Histograms are created by invoking one of the constructors, e.g.; 153~~~ {.cpp}; 154 TH1F *h1 = new TH1F",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:6736,Modifiability,variab,variable,6736,"77216 (\ref floatmax ""***""); 128 - TH3D : histograms with one double per channel. Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 (\ref doublemax ""****""); 129 - Profile histograms: See classes TProfile, TProfile2D and TProfile3D.; 130 Profile histograms are used to display the mean value of Y and its standard deviation; 131 for each bin in X. Profile histograms are in many cases an elegant; 132 replacement of two-dimensional histograms : the inter-relation of two; 133 measured quantities X and Y can always be visualized by a two-dimensional; 134 histogram or scatter-plot; If Y is an unknown (but single-valued); 135 approximate function of X, this function is displayed by a profile; 136 histogram with much better precision than by a scatter-plot.; 137 ; 138<sup>; 139\anchor intmax (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 140\anchor llongmax (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 141\anchor floatmax (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 142\anchor doublemax (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 143</sup>; 144 ; 145The inheritance hierarchy looks as follows:; 146 ; 147\image html classTH1__inherit__graph_org.svg width=100%; 148 ; 149\anchor creating-histograms; 150## Creating histograms; 151 ; 152Histograms are created by invoking one of the constructors, e.g.; 153~~~ {.cpp}; 154 TH1F *h1 = new TH1F(""h1"", ""h1 title"", 100, 0, 4.4);; 155 TH2F *h2 = new TH2F(""h2"", ""h2 title"", 40, 0, 4, 30, -3, 3);; 156~~~; 157Histograms may also be created by:; 158 ; 159 - ca",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:7236,Modifiability,inherit,inheritance,7236,"; 134 histogram or scatter-plot; If Y is an unknown (but single-valued); 135 approximate function of X, this function is displayed by a profile; 136 histogram with much better precision than by a scatter-plot.; 137 ; 138<sup>; 139\anchor intmax (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 140\anchor llongmax (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 141\anchor floatmax (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 142\anchor doublemax (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 143</sup>; 144 ; 145The inheritance hierarchy looks as follows:; 146 ; 147\image html classTH1__inherit__graph_org.svg width=100%; 148 ; 149\anchor creating-histograms; 150## Creating histograms; 151 ; 152Histograms are created by invoking one of the constructors, e.g.; 153~~~ {.cpp}; 154 TH1F *h1 = new TH1F(""h1"", ""h1 title"", 100, 0, 4.4);; 155 TH2F *h2 = new TH2F(""h2"", ""h2 title"", 40, 0, 4, 30, -3, 3);; 156~~~; 157Histograms may also be created by:; 158 ; 159 - calling the Clone() function, see below; 160 - making a projection from a 2-D or 3-D histogram, see below; 161 - reading a histogram from a file; 162 ; 163 When a histogram is created, a reference to it is automatically added; 164 to the list of in-memory objects for the current file or directory.; 165 Then the pointer to this histogram in the current directory can be found; 166 by its name, doing:; 167~~~ {.cpp}; 168 TH1F *h1 = (TH1F*)gDirectory->FindObject(name);; 169~~~; 170 ; 171 This default behaviour can be changed by:; 172~~~ {.cpp}; 173 h->SetDirectory(nullptr); //",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:9599,Modifiability,variab,variable,9599," 181\anchor labelling-axis; 182### Labelling axes; 183 ; 184 Axis titles can be specified in the title argument of the constructor.; 185 They must be separated by "";"":; 186~~~ {.cpp}; 187 TH1F* h=new TH1F(""h"", ""Histogram title;X Axis;Y Axis"", 100, 0, 1);; 188~~~; 189 The histogram title and the axis titles can be any TLatex string, and; 190 are persisted if a histogram is written to a file.; 191 ; 192 Any title can be omitted:; 193~~~ {.cpp}; 194 TH1F* h=new TH1F(""h"", ""Histogram title;;Y Axis"", 100, 0, 1);; 195 TH1F* h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);; 196~~~; 197 The method SetTitle() has the same syntax:; 198~~~ {.cpp}; 199 h->SetTitle(""Histogram title;Another X title Axis"");; 200~~~; 201Alternatively, the title of each axis can be set directly:; 202~~~ {.cpp}; 203 h->GetXaxis()->SetTitle(""X axis title"");; 204 h->GetYaxis()->SetTitle(""Y axis title"");; 205~~~; 206For bin labels see \ref binning.; 207 ; 208\anchor binning; 209## Binning; 210 ; 211\anchor fix-var; 212### Fix or variable bin size; 213 ; 214 All histogram types support either fix or variable bin sizes.; 215 2-D histograms may have fix size bins along X and variable size bins; 216 along Y or vice-versa. The functions to fill, manipulate, draw or access; 217 histograms are identical in both cases.; 218 ; 219 Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; 220 To access the axis parameters, use:; 221~~~ {.cpp}; 222 TAxis *xaxis = h->GetXaxis(); etc.; 223 Double_t binCenter = xaxis->GetBinCenter(bin), etc.; 224~~~; 225 See class TAxis for a description of all the access functions.; 226 The axis range is always stored internally in double precision.; 227 ; 228\anchor convention; 229### Convention for numbering bins; 230 ; 231 For all histogram types: nbins, xlow, xup; 232~~~ {.cpp}; 233 bin = 0; underflow bin; 234 bin = 1; first bin with low-edge xlow INCLUDED; 235 bin = nbins; last bin with upper-edge xup EXCLUDED; 236 bin = nbins+1; overflow bin; 237~~~; 238 In",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:9670,Modifiability,variab,variable,9670," 181\anchor labelling-axis; 182### Labelling axes; 183 ; 184 Axis titles can be specified in the title argument of the constructor.; 185 They must be separated by "";"":; 186~~~ {.cpp}; 187 TH1F* h=new TH1F(""h"", ""Histogram title;X Axis;Y Axis"", 100, 0, 1);; 188~~~; 189 The histogram title and the axis titles can be any TLatex string, and; 190 are persisted if a histogram is written to a file.; 191 ; 192 Any title can be omitted:; 193~~~ {.cpp}; 194 TH1F* h=new TH1F(""h"", ""Histogram title;;Y Axis"", 100, 0, 1);; 195 TH1F* h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);; 196~~~; 197 The method SetTitle() has the same syntax:; 198~~~ {.cpp}; 199 h->SetTitle(""Histogram title;Another X title Axis"");; 200~~~; 201Alternatively, the title of each axis can be set directly:; 202~~~ {.cpp}; 203 h->GetXaxis()->SetTitle(""X axis title"");; 204 h->GetYaxis()->SetTitle(""Y axis title"");; 205~~~; 206For bin labels see \ref binning.; 207 ; 208\anchor binning; 209## Binning; 210 ; 211\anchor fix-var; 212### Fix or variable bin size; 213 ; 214 All histogram types support either fix or variable bin sizes.; 215 2-D histograms may have fix size bins along X and variable size bins; 216 along Y or vice-versa. The functions to fill, manipulate, draw or access; 217 histograms are identical in both cases.; 218 ; 219 Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; 220 To access the axis parameters, use:; 221~~~ {.cpp}; 222 TAxis *xaxis = h->GetXaxis(); etc.; 223 Double_t binCenter = xaxis->GetBinCenter(bin), etc.; 224~~~; 225 See class TAxis for a description of all the access functions.; 226 The axis range is always stored internally in double precision.; 227 ; 228\anchor convention; 229### Convention for numbering bins; 230 ; 231 For all histogram types: nbins, xlow, xup; 232~~~ {.cpp}; 233 bin = 0; underflow bin; 234 bin = 1; first bin with low-edge xlow INCLUDED; 235 bin = nbins; last bin with upper-edge xup EXCLUDED; 236 bin = nbins+1; overflow bin; 237~~~; 238 In",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:9745,Modifiability,variab,variable,9745,"hey must be separated by "";"":; 186~~~ {.cpp}; 187 TH1F* h=new TH1F(""h"", ""Histogram title;X Axis;Y Axis"", 100, 0, 1);; 188~~~; 189 The histogram title and the axis titles can be any TLatex string, and; 190 are persisted if a histogram is written to a file.; 191 ; 192 Any title can be omitted:; 193~~~ {.cpp}; 194 TH1F* h=new TH1F(""h"", ""Histogram title;;Y Axis"", 100, 0, 1);; 195 TH1F* h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);; 196~~~; 197 The method SetTitle() has the same syntax:; 198~~~ {.cpp}; 199 h->SetTitle(""Histogram title;Another X title Axis"");; 200~~~; 201Alternatively, the title of each axis can be set directly:; 202~~~ {.cpp}; 203 h->GetXaxis()->SetTitle(""X axis title"");; 204 h->GetYaxis()->SetTitle(""Y axis title"");; 205~~~; 206For bin labels see \ref binning.; 207 ; 208\anchor binning; 209## Binning; 210 ; 211\anchor fix-var; 212### Fix or variable bin size; 213 ; 214 All histogram types support either fix or variable bin sizes.; 215 2-D histograms may have fix size bins along X and variable size bins; 216 along Y or vice-versa. The functions to fill, manipulate, draw or access; 217 histograms are identical in both cases.; 218 ; 219 Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; 220 To access the axis parameters, use:; 221~~~ {.cpp}; 222 TAxis *xaxis = h->GetXaxis(); etc.; 223 Double_t binCenter = xaxis->GetBinCenter(bin), etc.; 224~~~; 225 See class TAxis for a description of all the access functions.; 226 The axis range is always stored internally in double precision.; 227 ; 228\anchor convention; 229### Convention for numbering bins; 230 ; 231 For all histogram types: nbins, xlow, xup; 232~~~ {.cpp}; 233 bin = 0; underflow bin; 234 bin = 1; first bin with low-edge xlow INCLUDED; 235 bin = nbins; last bin with upper-edge xup EXCLUDED; 236 bin = nbins+1; overflow bin; 237~~~; 238 In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; 239 For example, assuming a 3-D histogram with (binx, biny, binz), the",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:15716,Modifiability,extend,extend,15716,"ne of the Fill functions accepting names described above.; 341 The Fill functions compute the bin number corresponding to the given; 342 x, y or z argument and increment this bin by the given weight.; 343 The Fill functions return the bin number for 1-D histograms or global; 344 bin number for 2-D and 3-D histograms.; 345 If TH1::Sumw2 has been called before filling, the sum of squares of; 346 weights is also stored.; 347 One can also increment directly a bin number via TH1::AddBinContent; 348 or replace the existing content via TH1::SetBinContent. Passing an; 349 out-of-range bin to TH1::AddBinContent leads to undefined behavior.; 350 To access the bin content of a given bin, do:; 351~~~ {.cpp}; 352 Double_t binContent = h->GetBinContent(bin);; 353~~~; 354 ; 355 By default, the bin number is computed using the current axis ranges.; 356 If the automatic binning option has been set via; 357~~~ {.cpp}; 358 h->SetCanExtend(TH1::kAllAxes);; 359~~~; 360 then, the Fill Function will automatically extend the axis range to; 361 accomodate the new value specified in the Fill argument. The method; 362 used is to double the bin size until the new value fits in the range,; 363 merging bins two by two. This automatic binning options is extensively; 364 used by the TTree::Draw function when histogramming Tree variables; 365 with an unknown range.; 366 This automatic binning option is supported for 1-D, 2-D and 3-D histograms.; 367 ; 368 During filling, some statistics parameters are incremented to compute; 369 the mean value and Root Mean Square with the maximum precision.; 370 ; 371 In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; 372 a check is made that the bin contents do not exceed the maximum positive; 373 capacity (127 or 32767). Histograms of all types may have positive; 374 or/and negative bin contents.; 375 ; 376\anchor associated-errors; 377### Associated errors; 378 By default, for each bin, the sum of weights is computed at fill time.; 379 One can al",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:16027,Modifiability,variab,variables,16027,"in number for 2-D and 3-D histograms.; 345 If TH1::Sumw2 has been called before filling, the sum of squares of; 346 weights is also stored.; 347 One can also increment directly a bin number via TH1::AddBinContent; 348 or replace the existing content via TH1::SetBinContent. Passing an; 349 out-of-range bin to TH1::AddBinContent leads to undefined behavior.; 350 To access the bin content of a given bin, do:; 351~~~ {.cpp}; 352 Double_t binContent = h->GetBinContent(bin);; 353~~~; 354 ; 355 By default, the bin number is computed using the current axis ranges.; 356 If the automatic binning option has been set via; 357~~~ {.cpp}; 358 h->SetCanExtend(TH1::kAllAxes);; 359~~~; 360 then, the Fill Function will automatically extend the axis range to; 361 accomodate the new value specified in the Fill argument. The method; 362 used is to double the bin size until the new value fits in the range,; 363 merging bins two by two. This automatic binning options is extensively; 364 used by the TTree::Draw function when histogramming Tree variables; 365 with an unknown range.; 366 This automatic binning option is supported for 1-D, 2-D and 3-D histograms.; 367 ; 368 During filling, some statistics parameters are incremented to compute; 369 the mean value and Root Mean Square with the maximum precision.; 370 ; 371 In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; 372 a check is made that the bin contents do not exceed the maximum positive; 373 capacity (127 or 32767). Histograms of all types may have positive; 374 or/and negative bin contents.; 375 ; 376\anchor associated-errors; 377### Associated errors; 378 By default, for each bin, the sum of weights is computed at fill time.; 379 One can also call TH1::Sumw2 to force the storage and computation; 380 of the sum of the square of weights per bin.; 381 If Sumw2 has been called, the error per bin is computed as the; 382 sqrt(sum of squares of weights), otherwise the error is set equal; 383 to the sqrt(bin content).; 384 ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:21810,Modifiability,inherit,inherit,21810,"new status; 480 of the histogram will be automatically shown in the pad next time; 481 the pad is updated. One does not need to redraw the histogram.; 482 To draw the current version of a histogram in a pad, one can use; 483~~~ {.cpp}; 484 h->DrawCopy();; 485~~~; 486 This makes a clone (see Clone below) of the histogram. Once the clone; 487 is drawn, the original histogram may be modified or deleted without; 488 affecting the aspect of the clone.; 489 ; 490 One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular; 491 value for the maximum or the minimum scale on the plot. (For 1-D; 492 histograms this means the y-axis, while for 2-D histograms these; 493 functions affect the z-axis).; 494 ; 495 TH1::UseCurrentStyle() can be used to change all histogram graphics; 496 attributes to correspond to the current selected style.; 497 This function must be called for each histogram.; 498 In case one reads and draws many histograms from a file, one can force; 499 the histograms to inherit automatically the current graphics style; 500 by calling before gROOT->ForceStyle().; 501 ; 502\anchor cont-level; 503### Setting Drawing histogram contour levels (2-D hists only); 504 ; 505 By default contours are automatically generated at equidistant; 506 intervals. A default value of 20 levels is used. This can be modified; 507 via TH1::SetContour() or TH1::SetContourLevel().; 508 the contours level info is used by the drawing options ""cont"", ""surf"",; 509 and ""lego"".; 510 ; 511\anchor graph-att; 512### Setting histogram graphics attributes; 513 ; 514 The histogram classes inherit from the attribute classes:; 515 TAttLine, TAttFill, and TAttMarker.; 516 See the member functions of these classes for the list of options.; 517 ; 518\anchor axis-drawing; 519### Customizing how axes are drawn; 520 ; 521 Use the functions of TAxis, such as; 522~~~ {.cpp}; 523 histogram.GetXaxis()->SetTicks(""+"");; 524 histogram.GetYaxis()->SetRangeUser(1., 5.);; 525~~~; 526 ; 527\anchor fitting",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:22401,Modifiability,inherit,inherit,22401,"cale on the plot. (For 1-D; 492 histograms this means the y-axis, while for 2-D histograms these; 493 functions affect the z-axis).; 494 ; 495 TH1::UseCurrentStyle() can be used to change all histogram graphics; 496 attributes to correspond to the current selected style.; 497 This function must be called for each histogram.; 498 In case one reads and draws many histograms from a file, one can force; 499 the histograms to inherit automatically the current graphics style; 500 by calling before gROOT->ForceStyle().; 501 ; 502\anchor cont-level; 503### Setting Drawing histogram contour levels (2-D hists only); 504 ; 505 By default contours are automatically generated at equidistant; 506 intervals. A default value of 20 levels is used. This can be modified; 507 via TH1::SetContour() or TH1::SetContourLevel().; 508 the contours level info is used by the drawing options ""cont"", ""surf"",; 509 and ""lego"".; 510 ; 511\anchor graph-att; 512### Setting histogram graphics attributes; 513 ; 514 The histogram classes inherit from the attribute classes:; 515 TAttLine, TAttFill, and TAttMarker.; 516 See the member functions of these classes for the list of options.; 517 ; 518\anchor axis-drawing; 519### Customizing how axes are drawn; 520 ; 521 Use the functions of TAxis, such as; 522~~~ {.cpp}; 523 histogram.GetXaxis()->SetTicks(""+"");; 524 histogram.GetYaxis()->SetRangeUser(1., 5.);; 525~~~; 526 ; 527\anchor fitting-histograms; 528## Fitting histograms; 529 ; 530 Histograms (1-D, 2-D, 3-D and Profiles) can be fitted with a user; 531 specified function or a pre-defined function via TH1::Fit.; 532 See TH1::Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t) for the fitting documentation and the possible [fitting options](\ref HFitOpt); 533 ; 534 The FitPanel can also be used for fitting an histogram. See the [FitPanel documentation](https://root.cern/manual/fitting/#using-the-fit-panel).; 535 ; 536\anchor saving-histograms; 537## Saving/reading histograms to/from a ROOT file; 538 ; 5",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:29256,Modifiability,variab,variable,29256,"///////////////////////////////////////////////////////////////; 684/// Constructor for fix bin size histograms.; 685/// Creates the main histogram structure.; 686///; 687/// \param[in] name name of histogram (avoid blanks); 688/// \param[in] title histogram title.; 689/// If title is of the form `stringt;stringx;stringy;stringz`,; 690/// the histogram title is set to `stringt`,; 691/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 692/// \param[in] nbins number of bins; 693/// \param[in] xlow low edge of first bin; 694/// \param[in] xup upper edge of last bin (not included in last bin); 695 ; 696 ; 697TH1::TH1(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 698 :TNamed(name,title); 699{; 700 Build();; 701 if (nbins <= 0) {Warning(""TH1"",""nbins is <=0 - set to nbins = 1""); nbins = 1; }; 702 fXaxis.Set(nbins,xlow,xup);; 703 fNcells = fXaxis.GetNbins()+2;; 704}; 705 ; 706////////////////////////////////////////////////////////////////////////////////; 707/// Constructor for variable bin size histograms using an input array of type float.; 708/// Creates the main histogram structure.; 709///; 710/// \param[in] name name of histogram (avoid blanks); 711/// \param[in] title histogram title.; 712/// If title is of the form `stringt;stringx;stringy;stringz`; 713/// the histogram title is set to `stringt`,; 714/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 715/// \param[in] nbins number of bins; 716/// \param[in] xbins array of low-edges for each bin.; 717/// This is an array of type float and size nbins+1; 718 ; 719TH1::TH1(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 720 :TNamed(name,title); 721{; 722 Build();; 723 if (nbins <= 0) {Warning(""TH1"",""nbins is <=0 - set to nbins = 1""); nbins = 1; }; 724 if (xbins) fXaxis.Set(nbins,xbins);; 725 else fXaxis.Set(nbins,0,1);; 726 fNcells = fXaxis.GetNbins()+2;; 727}; 728 ; 729///////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:30267,Modifiability,variab,variable,30267," 707/// Constructor for variable bin size histograms using an input array of type float.; 708/// Creates the main histogram structure.; 709///; 710/// \param[in] name name of histogram (avoid blanks); 711/// \param[in] title histogram title.; 712/// If title is of the form `stringt;stringx;stringy;stringz`; 713/// the histogram title is set to `stringt`,; 714/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 715/// \param[in] nbins number of bins; 716/// \param[in] xbins array of low-edges for each bin.; 717/// This is an array of type float and size nbins+1; 718 ; 719TH1::TH1(const char *name,const char *title,Int_t nbins,const Float_t *xbins); 720 :TNamed(name,title); 721{; 722 Build();; 723 if (nbins <= 0) {Warning(""TH1"",""nbins is <=0 - set to nbins = 1""); nbins = 1; }; 724 if (xbins) fXaxis.Set(nbins,xbins);; 725 else fXaxis.Set(nbins,0,1);; 726 fNcells = fXaxis.GetNbins()+2;; 727}; 728 ; 729////////////////////////////////////////////////////////////////////////////////; 730/// Constructor for variable bin size histograms using an input array of type double.; 731///; 732/// \param[in] name name of histogram (avoid blanks); 733/// \param[in] title histogram title.; 734/// If title is of the form `stringt;stringx;stringy;stringz`; 735/// the histogram title is set to `stringt`,; 736/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 737/// \param[in] nbins number of bins; 738/// \param[in] xbins array of low-edges for each bin.; 739/// This is an array of type double and size nbins+1; 740 ; 741TH1::TH1(const char *name,const char *title,Int_t nbins,const Double_t *xbins); 742 :TNamed(name,title); 743{; 744 Build();; 745 if (nbins <= 0) {Warning(""TH1"",""nbins is <=0 - set to nbins = 1""); nbins = 1; }; 746 if (xbins) fXaxis.Set(nbins,xbins);; 747 else fXaxis.Set(nbins,0,1);; 748 fNcells = fXaxis.GetNbins()+2;; 749}; 750 ; 751////////////////////////////////////////////////////////////////////////////////; 752/// Static functi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:63135,Modifiability,variab,variable,63135,"s have different bin limits"");; 1623 return false;; 1624 }; 1625 ; 1626 // check labels; 1627 if(!CheckBinLabels(a1,a2)) {; 1628 ::Info(""CheckEqualAxes"",""Axes have different labels"");; 1629 return false;; 1630 }; 1631 ; 1632 return true;; 1633}; 1634 ; 1635////////////////////////////////////////////////////////////////////////////////; 1636/// Check that two sub axis are the same.; 1637/// The limits are defined by first bin and last bin; 1638/// N.B. no check is done in this case for variable bins; 1639 ; 1640bool TH1::CheckConsistentSubAxes(const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis * a2, Int_t firstBin2, Int_t lastBin2 ); 1641{; 1642 // By default is assumed that no bins are given for the second axis; 1643 Int_t nbins1 = lastBin1-firstBin1 + 1;; 1644 Double_t xmin1 = a1->GetBinLowEdge(firstBin1);; 1645 Double_t xmax1 = a1->GetBinUpEdge(lastBin1);; 1646 ; 1647 Int_t nbins2 = a2->GetNbins();; 1648 Double_t xmin2 = a2->GetXmin();; 1649 Double_t xmax2 = a2->GetXmax();; 1650 ; 1651 if (firstBin2 < lastBin2) {; 1652 // in this case assume no bins are given for the second axis; 1653 nbins2 = lastBin1-firstBin1 + 1;; 1654 xmin2 = a1->GetBinLowEdge(firstBin1);; 1655 xmax2 = a1->GetBinUpEdge(lastBin1);; 1656 }; 1657 ; 1658 if (nbins1 != nbins2 ) {; 1659 ::Info(""CheckConsistentSubAxes"",""Axes have different number of bins"");; 1660 return false;; 1661 }; 1662 ; 1663 Double_t firstBin = a1->GetBinWidth(firstBin1);; 1664 Double_t lastBin = a1->GetBinWidth(lastBin1);; 1665 if ( ! TMath::AreEqualAbs(xmin1,xmin2,1.E-10 * firstBin) ||; 1666 ! TMath::AreEqualAbs(xmax1,xmax2,1.E-10 * lastBin) ) {; 1667 ::Info(""CheckConsistentSubAxes"",""Axes have different limits"");; 1668 return false;; 1669 }; 1670 ; 1671 return true;; 1672}; 1673 ; 1674////////////////////////////////////////////////////////////////////////////////; 1675/// Check histogram compatibility.; 1676 ; 1677int TH1::CheckConsistency(const TH1* h1, const TH1* h2); 1678{; 1679 if (h1 == h2) return kFullyCons",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:69299,Modifiability,variab,variables,69299,"d two weighted; 1757/// histograms [2] as well as usual Pearson's \f$ \chi^{2} \f$ test for; 1758/// comparison two usual (unweighted) histograms.; 1759///; 1760/// #### Overview:; 1761///; 1762/// Comparison of two histograms expect hypotheses that two histograms; 1763/// represent identical distributions. To make a decision p-value should; 1764/// be calculated. The hypotheses of identity is rejected if the p-value is; 1765/// lower then some significance level. Traditionally significance levels; 1766/// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; 1767/// analysis of the residuals which is often helpful in identifying the; 1768/// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; 1769/// Residuals are the difference between bin contents and expected bin; 1770/// contents. Most convenient for analysis are the normalized residuals. If; 1771/// hypotheses of identity are valid then normalized residuals are; 1772/// approximately independent and identically distributed random variables; 1773/// having N(0,1) distribution. Analysis of residuals expect test of above; 1774/// mentioned properties of residuals. Notice that indirectly the analysis; 1775/// of residuals increase the power of \f$ \chi^{2} \f$ test.; 1776///; 1777/// #### Methods of comparison:; 1778///; 1779/// \f$ \chi^{2} \f$ test for comparison two (unweighted) histograms:; 1780/// Let us consider two histograms with the same binning and the number; 1781/// of bins equal to r. Let us denote the number of events in the ith bin; 1782/// in the first histogram as ni and as mi in the second one. The total; 1783/// number of events in the first histogram is equal to:; 1784/// \f[; 1785/// N = \sum_{i=1}^{r} n_{i}; 1786/// \f]; 1787/// and; 1788/// \f[; 1789/// M = \sum_{i=1}^{r} m_{i}; 1790/// \f]; 1791/// in the second histogram. The hypothesis of identity (homogeneity) [3]; 1792/// is that the two histograms represent random values with identical; ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:70588,Modifiability,variab,variable,70588,"ing and the number; 1781/// of bins equal to r. Let us denote the number of events in the ith bin; 1782/// in the first histogram as ni and as mi in the second one. The total; 1783/// number of events in the first histogram is equal to:; 1784/// \f[; 1785/// N = \sum_{i=1}^{r} n_{i}; 1786/// \f]; 1787/// and; 1788/// \f[; 1789/// M = \sum_{i=1}^{r} m_{i}; 1790/// \f]; 1791/// in the second histogram. The hypothesis of identity (homogeneity) [3]; 1792/// is that the two histograms represent random values with identical; 1793/// distributions. It is equivalent that there exist r constants p1,...,pr,; 1794/// such that; 1795/// \f[; 1796///\sum_{i=1}^{r} p_{i}=1; 1797/// \f]; 1798/// and the probability of belonging to the ith bin for some measured value; 1799/// in both experiments is equal to pi. The number of events in the ith; 1800/// bin is a random variable with a distribution approximated by a Poisson; 1801/// probability distribution; 1802/// \f[; 1803///\frac{e^{-Np_{i}}(Np_{i})^{n_{i}}}{n_{i}!}; 1804/// \f]; 1805///for the first histogram and with distribution; 1806/// \f[; 1807///\frac{e^{-Mp_{i}}(Mp_{i})^{m_{i}}}{m_{i}!}; 1808/// \f]; 1809/// for the second histogram. If the hypothesis of homogeneity is valid,; 1810/// then the maximum likelihood estimator of pi, i=1,...,r, is; 1811/// \f[; 1812///\hat{p}_{i}= \frac{n_{i}+m_{i}}{N+M}; 1813/// \f]; 1814/// and then; 1815/// \f[; 1816/// X^{2} = \sum_{i=1}^{r}\frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r}\frac{(m_{i}-M\hat{p}_{i})^{2}}{M\hat{p}_{i}} =\frac{1}{MN} \sum_{i=1}^{r}\frac{(Mn_{i}-Nm_{i})^{2}}{n_{i}+m_{i}}; 1817/// \f]; 1818/// has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [3].; 1819/// The comparison procedure can include an analysis of the residuals which; 1820/// is often helpful in identifying the bins of histograms responsible for; 1821/// a significant overall \f$ \chi^{2} \f$ value. Most convenient for; 1822/// analysis are the adjusted (normalized) residuals [4]; 1",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:71994,Modifiability,variab,variables,71994,"p_{i}}(Mp_{i})^{m_{i}}}{m_{i}!}; 1808/// \f]; 1809/// for the second histogram. If the hypothesis of homogeneity is valid,; 1810/// then the maximum likelihood estimator of pi, i=1,...,r, is; 1811/// \f[; 1812///\hat{p}_{i}= \frac{n_{i}+m_{i}}{N+M}; 1813/// \f]; 1814/// and then; 1815/// \f[; 1816/// X^{2} = \sum_{i=1}^{r}\frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r}\frac{(m_{i}-M\hat{p}_{i})^{2}}{M\hat{p}_{i}} =\frac{1}{MN} \sum_{i=1}^{r}\frac{(Mn_{i}-Nm_{i})^{2}}{n_{i}+m_{i}}; 1817/// \f]; 1818/// has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [3].; 1819/// The comparison procedure can include an analysis of the residuals which; 1820/// is often helpful in identifying the bins of histograms responsible for; 1821/// a significant overall \f$ \chi^{2} \f$ value. Most convenient for; 1822/// analysis are the adjusted (normalized) residuals [4]; 1823/// \f[; 1824/// r_{i} = \frac{n_{i}-N\hat{p}_{i}}{\sqrt{N\hat{p}_{i}}\sqrt{(1-N/(N+M))(1-(n_{i}+m_{i})/(N+M))}}; 1825/// \f]; 1826/// If hypotheses of homogeneity are valid then residuals ri are; 1827/// approximately independent and identically distributed random variables; 1828/// having N(0,1) distribution. The application of the \f$ \chi^{2} \f$ test has; 1829/// restrictions related to the value of the expected frequencies Npi,; 1830/// Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the; 1831/// expectations must be 1 or greater for both histograms. In practical; 1832/// cases when expected frequencies are not known the estimated expected; 1833/// frequencies \f$ M\hat{p}_{i}, N\hat{p}_{i}, i=1,...,r \f$ can be used.; 1834///; 1835/// #### Unweighted and weighted histograms comparison:; 1836///; 1837/// A simple modification of the ideas described above can be used for the; 1838/// comparison of the usual (unweighted) and weighted histograms. Let us; 1839/// denote the number of events in the ith bin in the unweighted; 1840/// histogram as ni and the common weight of eve",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:73469,Modifiability,variab,variable,73469,"836///; 1837/// A simple modification of the ideas described above can be used for the; 1838/// comparison of the usual (unweighted) and weighted histograms. Let us; 1839/// denote the number of events in the ith bin in the unweighted; 1840/// histogram as ni and the common weight of events in the ith bin of the; 1841/// weighted histogram as wi. The total number of events in the; 1842/// unweighted histogram is equal to; 1843///\f[; 1844/// N = \sum_{i=1}^{r} n_{i}; 1845///\f]; 1846/// and the total weight of events in the weighted histogram is equal to; 1847///\f[; 1848/// W = \sum_{i=1}^{r} w_{i}; 1849///\f]; 1850/// Let us formulate the hypothesis of identity of an unweighted histogram; 1851/// to a weighted histogram so that there exist r constants p1,...,pr, such; 1852/// that; 1853///\f[; 1854/// \sum_{i=1}^{r} p_{i} = 1; 1855///\f]; 1856/// for the unweighted histogram. The weight wi is a random variable with a; 1857/// distribution approximated by the normal probability distribution; 1858/// \f$ N(Wp_{i},\sigma_{i}^{2}) \f$ where \f$ \sigma_{i}^{2} \f$ is the variance of the weight wi.; 1859/// If we replace the variance \f$ \sigma_{i}^{2} \f$; 1860/// with estimate \f$ s_{i}^{2} \f$ (sum of squares of weights of; 1861/// events in the ith bin) and the hypothesis of identity is valid, then the; 1862/// maximum likelihood estimator of pi,i=1,...,r, is; 1863///\f[; 1864/// \hat{p}_{i} = \frac{Ww_{i}-Ns_{i}^{2}+\sqrt{(Ww_{i}-Ns_{i}^{2})^{2}+4W^{2}s_{i}^{2}n_{i}}}{2W^{2}}; 1865///\f]; 1866/// We may then use the test statistic; 1867///\f[; 1868/// X^{2} = \sum_{i=1}^{r} \frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r} \frac{(w_{i}-W\hat{p}_{i})^{2}}{s_{i}^{2}}; 1869///\f]; 1870/// and it has approximately a \f$ \sigma^{2}_{(r-1)} \f$ distribution [2]. This test, as well; 1871/// as the original one [3], has a restriction on the expected frequencies. The; 1872/// expected frequencies recommended for the weighted histogram is more than 25.; 1873/// T",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:76673,Modifiability,variab,variables,76673,"mately a normal distribution with mean equal to 0 and standard; 1893/// deviation equal to 1.; 1894///; 1895/// #### Two weighted histograms comparison:; 1896///; 1897/// Let us denote the common weight of events of the ith bin in the first; 1898/// histogram as w1i and as w2i in the second one. The total weight of events; 1899/// in the first histogram is equal to; 1900///\f[; 1901/// W_{1} = \sum_{i=1}^{r} w_{1i}; 1902///\f]; 1903/// and; 1904///\f[; 1905/// W_{2} = \sum_{i=1}^{r} w_{2i}; 1906///\f]; 1907/// in the second histogram. Let us formulate the hypothesis of identity of; 1908/// weighted histograms so that there exist r constants p1,...,pr, such that; 1909///\f[; 1910/// \sum_{i=1}^{r} p_{i} = 1; 1911///\f]; 1912/// and also expectation value of weight w1i equal to W1pi and expectation value; 1913/// of weight w2i equal to W2pi. Weights in both the histograms are random; 1914/// variables with distributions which can be approximated by a normal; 1915/// probability distribution \f$ N(W_{1}p_{i},\sigma_{1i}^{2}) \f$ for the first histogram; 1916/// and by a distribution \f$ N(W_{2}p_{i},\sigma_{2i}^{2}) \f$ for the second.; 1917/// Here \f$ \sigma_{1i}^{2} \f$ and \f$ \sigma_{2i}^{2} \f$ are the variances; 1918/// of w1i and w2i with estimators \f$ s_{1i}^{2} \f$ and \f$ s_{2i}^{2} \f$ respectively.; 1919/// If the hypothesis of identity is valid, then the maximum likelihood and; 1920/// Least Square Method estimator of pi,i=1,...,r, is; 1921///\f[; 1922/// \hat{p}_{i} = \frac{w_{1i}W_{1}/s_{1i}^{2}+w_{2i}W_{2} /s_{2i}^{2}}{W_{1}^{2}/s_{1i}^{2}+W_{2}^{2}/s_{2i}^{2}}; 1923///\f]; 1924/// We may then use the test statistic; 1925///\f[; 1926/// X^{2} = \sum_{i=1}^{r} \frac{(w_{1i}-W_{1}\hat{p}_{i})^{2}}{s_{1i}^{2}} + \sum_{i=1}^{r} \frac{(w_{2i}-W_{2}\hat{p}_{i})^{2}}{s_{2i}^{2}} = \sum_{i=1}^{r} \frac{(W_{1}w_{2i}-W_{2}w_{1i})^{2}}{W_{1}^{2}s_{2i}^{2}+W_{2}^{2}s_{1i}^{2}}; 1927///\f]; 1928/// and it has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [2",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:122045,Modifiability,inherit,inherit,122045,"ew status; 3047/// of the histogram will be automatically shown in the pad next time; 3048/// the pad is updated. One does not need to redraw the histogram.; 3049/// To draw the current version of a histogram in a pad, one can use; 3050/// `h->DrawCopy();`; 3051/// This makes a clone of the histogram. Once the clone is drawn, the original; 3052/// histogram may be modified or deleted without affecting the aspect of the; 3053/// clone.; 3054/// By default, TH1::Draw clears the current pad.; 3055///; 3056/// One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; 3057/// value for the maximum or the minimum scale on the plot.; 3058///; 3059/// TH1::UseCurrentStyle can be used to change all histogram graphics; 3060/// attributes to correspond to the current selected style.; 3061/// This function must be called for each histogram.; 3062/// In case one reads and draws many histograms from a file, one can force; 3063/// the histograms to inherit automatically the current graphics style; 3064/// by calling before gROOT->ForceStyle();; 3065///; 3066/// See the THistPainter class for a description of all the drawing options.; 3067 ; 3068void TH1::Draw(Option_t *option); 3069{; 3070 TString opt1 = option; opt1.ToLower();; 3071 TString opt2 = option;; 3072 Int_t index = opt1.Index(""same"");; 3073 ; 3074 // Check if the string ""same"" is part of a TCutg name.; 3075 if (index>=0) {; 3076 Int_t indb = opt1.Index(""["");; 3077 if (indb>=0) {; 3078 Int_t indk = opt1.Index(""]"");; 3079 if (index>indb && index<indk) index = -1;; 3080 }; 3081 }; 3082 ; 3083 // If there is no pad or an empty pad the ""same"" option is ignored.; 3084 if (gPad) {; 3085 if (!gPad->IsEditable()) gROOT->MakeDefCanvas();; 3086 if (index>=0) {; 3087 if (gPad->GetX1() == 0 && gPad->GetX2() == 1 &&; 3088 gPad->GetY1() == 0 && gPad->GetY2() == 1 &&; 3089 gPad->GetListOfPrimitives()->GetSize()==0) opt2.Remove(index,4);; 3090 } else {; 3091 //the following statement is necessary in case one attempts to draw",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:136603,Modifiability,extend,extended,136603,"3403///; 3404/// if x is less than the low-edge of the first bin, the Underflow bin is incremented; 3405/// if x is equal to or greater than the upper edge of last bin, the Overflow bin is incremented; 3406///; 3407/// If the weight is not equal to 1, the storage of the sum of squares of; 3408/// weights is automatically triggered and the sum of the squares of weights is incremented; 3409/// by \f$ w^2 \f$ in the bin corresponding to x.; 3410///; 3411/// The function returns the corresponding bin number which has its content; 3412/// incremented by w.; 3413 ; 3414Int_t TH1::Fill(const char *namex, Double_t w); 3415{; 3416 Int_t bin;; 3417 fEntries++;; 3418 bin =fXaxis.FindBin(namex);; 3419 if (bin <0) return -1;; 3420 if (!fSumw2.fN && w != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2();; 3421 if (fSumw2.fN) fSumw2.fArray[bin] += w*w;; 3422 AddBinContent(bin, w);; 3423 if (bin == 0 || bin > fXaxis.GetNbins()) return -1;; 3424 Double_t z= w;; 3425 fTsumw += z;; 3426 fTsumw2 += z*z;; 3427 // this make sense if the histogram is not expanding (the x axis cannot be extended); 3428 if (!fXaxis.CanExtend() || !fXaxis.IsAlphanumeric()) {; 3429 Double_t x = fXaxis.GetBinCenter(bin);; 3430 fTsumwx += z*x;; 3431 fTsumwx2 += z*x*x;; 3432 }; 3433 return bin;; 3434}; 3435 ; 3436////////////////////////////////////////////////////////////////////////////////; 3437/// Fill this histogram with an array x and weights w.; 3438///; 3439/// \param[in] ntimes number of entries in arrays x and w (array size must be ntimes*stride); 3440/// \param[in] x array of values to be histogrammed; 3441/// \param[in] w array of weighs; 3442/// \param[in] stride step size through arrays x and w; 3443///; 3444/// If the weight is not equal to 1, the storage of the sum of squares of; 3445/// weights is automatically triggered and the sum of the squares of weights is incremented; 3446/// by \f$ w^2 \f$ in the bin corresponding to x.; 3447/// if w is NULL each entry is assumed a weight=1; 3448 ; 3449void TH1::Fil",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:145745,Modifiability,extend,extend,145745,"ntimes) {; 3638 Double_t x = h->GetRandom(rng);; 3639 Int_t ibin = fXaxis.FindBin(x);; 3640 Double_t y = RetrieveBinContent(ibin);; 3641 // skip in case bin is empty; 3642 if (y > 0) {; 3643 SetBinContent(ibin, y-1.);; 3644 i--;; 3645 }; 3646 }; 3647 }; 3648 ; 3649 ResetStats();; 3650 return;; 3651 }; 3652 // case of different axis and not too large ntimes; 3653 ; 3654 if (h->ComputeIntegral() ==0) return;; 3655 Int_t loop;; 3656 Double_t x;; 3657 for (loop=0;loop<ntimes;loop++) {; 3658 x = h->GetRandom();; 3659 Fill(x);; 3660 }; 3661}; 3662 ; 3663////////////////////////////////////////////////////////////////////////////////; 3664/// Return Global bin number corresponding to x,y,z; 3665///; 3666/// 2-D and 3-D histograms are represented with a one dimensional; 3667/// structure. This has the advantage that all existing functions, such as; 3668/// GetBinContent, GetBinError, GetBinFunction work for all dimensions.; 3669/// This function tries to extend the axis if the given point belongs to an; 3670/// under-/overflow bin AND if CanExtendAllAxes() is true.; 3671///; 3672/// See also TH1::GetBin, TAxis::FindBin and TAxis::FindFixBin; 3673 ; 3674Int_t TH1::FindBin(Double_t x, Double_t y, Double_t z); 3675{; 3676 if (GetDimension() < 2) {; 3677 return fXaxis.FindBin(x);; 3678 }; 3679 if (GetDimension() < 3) {; 3680 Int_t nx = fXaxis.GetNbins()+2;; 3681 Int_t binx = fXaxis.FindBin(x);; 3682 Int_t biny = fYaxis.FindBin(y);; 3683 return binx + nx*biny;; 3684 }; 3685 if (GetDimension() < 4) {; 3686 Int_t nx = fXaxis.GetNbins()+2;; 3687 Int_t ny = fYaxis.GetNbins()+2;; 3688 Int_t binx = fXaxis.FindBin(x);; 3689 Int_t biny = fYaxis.FindBin(y);; 3690 Int_t binz = fZaxis.FindBin(z);; 3691 return binx + nx*(biny +ny*binz);; 3692 }; 3693 return -1;; 3694}; 3695 ; 3696////////////////////////////////////////////////////////////////////////////////; 3697/// Return Global bin number corresponding to x,y,z.; 3698///; 3699/// 2-D and 3-D histograms are represented with a one dimensio",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:146985,Modifiability,extend,extend,146985,"675{; 3676 if (GetDimension() < 2) {; 3677 return fXaxis.FindBin(x);; 3678 }; 3679 if (GetDimension() < 3) {; 3680 Int_t nx = fXaxis.GetNbins()+2;; 3681 Int_t binx = fXaxis.FindBin(x);; 3682 Int_t biny = fYaxis.FindBin(y);; 3683 return binx + nx*biny;; 3684 }; 3685 if (GetDimension() < 4) {; 3686 Int_t nx = fXaxis.GetNbins()+2;; 3687 Int_t ny = fYaxis.GetNbins()+2;; 3688 Int_t binx = fXaxis.FindBin(x);; 3689 Int_t biny = fYaxis.FindBin(y);; 3690 Int_t binz = fZaxis.FindBin(z);; 3691 return binx + nx*(biny +ny*binz);; 3692 }; 3693 return -1;; 3694}; 3695 ; 3696////////////////////////////////////////////////////////////////////////////////; 3697/// Return Global bin number corresponding to x,y,z.; 3698///; 3699/// 2-D and 3-D histograms are represented with a one dimensional; 3700/// structure. This has the advantage that all existing functions, such as; 3701/// GetBinContent, GetBinError, GetBinFunction work for all dimensions.; 3702/// This function DOES NOT try to extend the axis if the given point belongs; 3703/// to an under-/overflow bin.; 3704///; 3705/// See also TH1::GetBin, TAxis::FindBin and TAxis::FindFixBin; 3706 ; 3707Int_t TH1::FindFixBin(Double_t x, Double_t y, Double_t z) const; 3708{; 3709 if (GetDimension() < 2) {; 3710 return fXaxis.FindFixBin(x);; 3711 }; 3712 if (GetDimension() < 3) {; 3713 Int_t nx = fXaxis.GetNbins()+2;; 3714 Int_t binx = fXaxis.FindFixBin(x);; 3715 Int_t biny = fYaxis.FindFixBin(y);; 3716 return binx + nx*biny;; 3717 }; 3718 if (GetDimension() < 4) {; 3719 Int_t nx = fXaxis.GetNbins()+2;; 3720 Int_t ny = fYaxis.GetNbins()+2;; 3721 Int_t binx = fXaxis.FindFixBin(x);; 3722 Int_t biny = fYaxis.FindFixBin(y);; 3723 Int_t binz = fZaxis.FindFixBin(z);; 3724 return binx + nx*(biny +ny*binz);; 3725 }; 3726 return -1;; 3727}; 3728 ; 3729////////////////////////////////////////////////////////////////////////////////; 3730/// Find first bin with content > threshold for axis (1=x, 2=y, 3=z); 3731/// if no bins with content > threshold i",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:159218,Modifiability,variab,variable,159218,"is kept.; 3959/// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; 3960/// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; 3961/// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; 3962/// ""B"" | Use this option when you want to fix or set limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; 3963/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 3964/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 3965/// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); 3966/// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; 3967/// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; 3968///; 3969/// The default fitting of an histogram (when no option is given) is perfomed as following:; 3970/// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; 3971/// - the full range of the histogram is used;; 3972/// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; 3973/// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; 3974/// - only the status of the fit is returned;; 3975/// - the fit is performed in Multithread whenever",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:159880,Modifiability,config,configuration,159880,"eters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; 3963/// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; 3964/// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; 3965/// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); 3966/// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; 3967/// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; 3968///; 3969/// The default fitting of an histogram (when no option is given) is perfomed as following:; 3970/// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; 3971/// - the full range of the histogram is used;; 3972/// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; 3973/// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; 3974/// - only the status of the fit is returned;; 3975/// - the fit is performed in Multithread whenever is enabled in ROOT;; 3976/// - only the last fitted function is saved in the histogram;; 3977/// - the histogram is drawn after fitting overalyed with the resulting fitting function; 3978///; 3979/// \anchor HFitMinimizer; 3980/// ### Minimizer Configuration; 3981///; 3982/// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; 3983/// It is possible to change the default minimizer and its configuration parameters by calling thes",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:160654,Modifiability,config,configuration,160654,"zero errors (empty bins);; 3971/// - the full range of the histogram is used;; 3972/// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; 3973/// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; 3974/// - only the status of the fit is returned;; 3975/// - the fit is performed in Multithread whenever is enabled in ROOT;; 3976/// - only the last fitted function is saved in the histogram;; 3977/// - the histogram is drawn after fitting overalyed with the resulting fitting function; 3978///; 3979/// \anchor HFitMinimizer; 3980/// ### Minimizer Configuration; 3981///; 3982/// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; 3983/// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; 3984/// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; 3985/// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; 3986/// The current defaults are (""Minuit"",""Migrad"").; 3987/// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; 3988/// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; 3989/// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; 3990/// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; 3991///; 3992/// Other options are possible dependi",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:177604,Modifiability,plugin,plugin,177604," 4269 ; 4270 // create range and minimizer options with default values; 4271 ROOT::Fit::DataRange range(xxmin,xxmax);; 4272 ROOT::Math::MinimizerOptions minOption;; 4273 ; 4274 // need to empty the buffer before; 4275 // (t.b.d. do a ML unbinned fit with buffer data); 4276 if (fBuffer) BufferEmpty();; 4277 ; 4278 return ROOT::Fit::FitObject(this, f1 , fitOption , minOption, goption, range);; 4279}; 4280 ; 4281////////////////////////////////////////////////////////////////////////////////; 4282/// Display a panel with all histogram fit options.; 4283///; 4284/// See class TFitPanel for example; 4285 ; 4286void TH1::FitPanel(); 4287{; 4288 if (!gPad); 4289 gROOT->MakeDefCanvas();; 4290 ; 4291 if (!gPad) {; 4292 Error(""FitPanel"", ""Unable to create a default canvas"");; 4293 return;; 4294 }; 4295 ; 4296 ; 4297 // use plugin manager to create instance of TFitEditor; 4298 TPluginHandler *handler = gROOT->GetPluginManager()->FindHandler(""TFitEditor"");; 4299 if (handler && handler->LoadPlugin() != -1) {; 4300 if (handler->ExecPlugin(2, gPad, this) == 0); 4301 Error(""FitPanel"", ""Unable to create the FitPanel"");; 4302 }; 4303 else; 4304 Error(""FitPanel"", ""Unable to find the FitPanel plug-in"");; 4305}; 4306 ; 4307////////////////////////////////////////////////////////////////////////////////; 4308/// Return a histogram containing the asymmetry of this histogram with h2,; 4309/// where the asymmetry is defined as:; 4310///; 4311/// ~~~ {.cpp}; 4312/// Asymmetry = (h1 - h2)/(h1 + h2) where h1 = this; 4313/// ~~~; 4314///; 4315/// works for 1D, 2D, etc. histograms; 4316/// c2 is an optional argument that gives a relative weight between the two; 4317/// histograms, and dc2 is the error on this weight. This is useful, for example,; 4318/// when forming an asymmetry between two histograms from 2 different data sets that; 4319/// need to be normalized to each other in some way. The function calculates; 4320/// the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:177971,Modifiability,plug-in,plug-in,177971," 4269 ; 4270 // create range and minimizer options with default values; 4271 ROOT::Fit::DataRange range(xxmin,xxmax);; 4272 ROOT::Math::MinimizerOptions minOption;; 4273 ; 4274 // need to empty the buffer before; 4275 // (t.b.d. do a ML unbinned fit with buffer data); 4276 if (fBuffer) BufferEmpty();; 4277 ; 4278 return ROOT::Fit::FitObject(this, f1 , fitOption , minOption, goption, range);; 4279}; 4280 ; 4281////////////////////////////////////////////////////////////////////////////////; 4282/// Display a panel with all histogram fit options.; 4283///; 4284/// See class TFitPanel for example; 4285 ; 4286void TH1::FitPanel(); 4287{; 4288 if (!gPad); 4289 gROOT->MakeDefCanvas();; 4290 ; 4291 if (!gPad) {; 4292 Error(""FitPanel"", ""Unable to create a default canvas"");; 4293 return;; 4294 }; 4295 ; 4296 ; 4297 // use plugin manager to create instance of TFitEditor; 4298 TPluginHandler *handler = gROOT->GetPluginManager()->FindHandler(""TFitEditor"");; 4299 if (handler && handler->LoadPlugin() != -1) {; 4300 if (handler->ExecPlugin(2, gPad, this) == 0); 4301 Error(""FitPanel"", ""Unable to create the FitPanel"");; 4302 }; 4303 else; 4304 Error(""FitPanel"", ""Unable to find the FitPanel plug-in"");; 4305}; 4306 ; 4307////////////////////////////////////////////////////////////////////////////////; 4308/// Return a histogram containing the asymmetry of this histogram with h2,; 4309/// where the asymmetry is defined as:; 4310///; 4311/// ~~~ {.cpp}; 4312/// Asymmetry = (h1 - h2)/(h1 + h2) where h1 = this; 4313/// ~~~; 4314///; 4315/// works for 1D, 2D, etc. histograms; 4316/// c2 is an optional argument that gives a relative weight between the two; 4317/// histograms, and dc2 is the error on this weight. This is useful, for example,; 4318/// when forming an asymmetry between two histograms from 2 different data sets that; 4319/// need to be normalized to each other in some way. The function calculates; 4320/// the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:179299,Modifiability,adapt,adapted,179299,"~~~; 4314///; 4315/// works for 1D, 2D, etc. histograms; 4316/// c2 is an optional argument that gives a relative weight between the two; 4317/// histograms, and dc2 is the error on this weight. This is useful, for example,; 4318/// when forming an asymmetry between two histograms from 2 different data sets that; 4319/// need to be normalized to each other in some way. The function calculates; 4320/// the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).; 4321///; 4322/// example: assuming 'h1' and 'h2' are already filled; 4323///; 4324/// ~~~ {.cpp}; 4325/// h3 = h1->GetAsymmetry(h2); 4326/// ~~~; 4327///; 4328/// then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; 4329/// h1 and h2 are left intact.; 4330///; 4331/// Note that it is the user's responsibility to manage the created histogram.; 4332/// The name of the returned histogram will be `Asymmetry_nameOfh1-nameOfh2`; 4333///; 4334/// code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun; 4335///; 4336/// clone the histograms so top and bottom will have the; 4337/// correct dimensions:; 4338/// Sumw2 just makes sure the errors will be computed properly; 4339/// when we form sums and ratios below.; 4340 ; 4341TH1 *TH1::GetAsymmetry(TH1* h2, Double_t c2, Double_t dc2); 4342{; 4343 TH1 *h1 = this;; 4344 TString name = TString::Format(""Asymmetry_%s-%s"",h1->GetName(),h2->GetName() );; 4345 TH1 *asym = (TH1*)Clone(name);; 4346 ; 4347 // set also the title; 4348 TString title = TString::Format(""(%s - %s)/(%s+%s)"",h1->GetName(),h2->GetName(),h1->GetName(),h2->GetName() );; 4349 asym->SetTitle(title);; 4350 ; 4351 asym->Sumw2();; 4352 Bool_t addStatus = TH1::AddDirectoryStatus();; 4353 TH1::AddDirectory(kFALSE);; 4354 TH1 *top = (TH1*)asym->Clone();; 4355 TH1 *bottom = (TH1*)asym->Clone();; 4356 TH1::AddDirectory(addStatus);; 4357 ; 4358 // form the top and bottom of the asymmetry, and then divide:; 4359 top->Add(h1,h2,1,-c2);; 4360 bottom->Add(h1,h2,1,c2);; 436",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:180930,Modifiability,variab,variables,180930,"// correct dimensions:; 4338/// Sumw2 just makes sure the errors will be computed properly; 4339/// when we form sums and ratios below.; 4340 ; 4341TH1 *TH1::GetAsymmetry(TH1* h2, Double_t c2, Double_t dc2); 4342{; 4343 TH1 *h1 = this;; 4344 TString name = TString::Format(""Asymmetry_%s-%s"",h1->GetName(),h2->GetName() );; 4345 TH1 *asym = (TH1*)Clone(name);; 4346 ; 4347 // set also the title; 4348 TString title = TString::Format(""(%s - %s)/(%s+%s)"",h1->GetName(),h2->GetName(),h1->GetName(),h2->GetName() );; 4349 asym->SetTitle(title);; 4350 ; 4351 asym->Sumw2();; 4352 Bool_t addStatus = TH1::AddDirectoryStatus();; 4353 TH1::AddDirectory(kFALSE);; 4354 TH1 *top = (TH1*)asym->Clone();; 4355 TH1 *bottom = (TH1*)asym->Clone();; 4356 TH1::AddDirectory(addStatus);; 4357 ; 4358 // form the top and bottom of the asymmetry, and then divide:; 4359 top->Add(h1,h2,1,-c2);; 4360 bottom->Add(h1,h2,1,c2);; 4361 asym->Divide(top,bottom);; 4362 ; 4363 Int_t xmax = asym->GetNbinsX();; 4364 Int_t ymax = asym->GetNbinsY();; 4365 Int_t zmax = asym->GetNbinsZ();; 4366 ; 4367 if (h1->fBuffer) h1->BufferEmpty(1);; 4368 if (h2->fBuffer) h2->BufferEmpty(1);; 4369 if (bottom->fBuffer) bottom->BufferEmpty(1);; 4370 ; 4371 // now loop over bins to calculate the correct errors; 4372 // the reason this error calculation looks complex is because of c2; 4373 for(Int_t i=1; i<= xmax; i++){; 4374 for(Int_t j=1; j<= ymax; j++){; 4375 for(Int_t k=1; k<= zmax; k++){; 4376 Int_t bin = GetBin(i, j, k);; 4377 // here some bin contents are written into variables to make the error; 4378 // calculation a little more legible:; 4379 Double_t a = h1->RetrieveBinContent(bin);; 4380 Double_t b = h2->RetrieveBinContent(bin);; 4381 Double_t bot = bottom->RetrieveBinContent(bin);; 4382 ; 4383 // make sure there are some events, if not, then the errors are set = 0; 4384 // automatically.; 4385 //if(bot < 1){} was changed to the next line from recommendation of Jason Seely (28 Nov 2005); 4386 if(bot < 1e-6){}; 4387 else{",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:186633,Modifiability,variab,variable,186633,"bjectInfo.; 4501/// Displays the histogram info (bin number, contents, integral up to bin; 4502/// corresponding to cursor position px,py; 4503 ; 4504char *TH1::GetObjectInfo(Int_t px, Int_t py) const; 4505{; 4506 return ((TH1*)this)->GetPainter()->GetObjectInfo(px,py);; 4507}; 4508 ; 4509////////////////////////////////////////////////////////////////////////////////; 4510/// Return pointer to painter.; 4511/// If painter does not exist, it is created; 4512 ; 4513TVirtualHistPainter *TH1::GetPainter(Option_t *option); 4514{; 4515 if (!fPainter) {; 4516 TString opt = option;; 4517 opt.ToLower();; 4518 if (opt.Contains(""gl"") || gStyle->GetCanvasPreferGL()) {; 4519 //try to create TGLHistPainter; 4520 TPluginHandler *handler = gROOT->GetPluginManager()->FindHandler(""TGLHistPainter"");; 4521 ; 4522 if (handler && handler->LoadPlugin() != -1); 4523 fPainter = reinterpret_cast<TVirtualHistPainter *>(handler->ExecPlugin(1, this));; 4524 }; 4525 }; 4526 ; 4527 if (!fPainter) fPainter = TVirtualHistPainter::HistPainter(this);; 4528 ; 4529 return fPainter;; 4530}; 4531 ; 4532////////////////////////////////////////////////////////////////////////////////; 4533/// Compute Quantiles for this histogram; 4534/// Quantile x_p := Q(p) is defined as the value x_p such that the cumulative; 4535/// probability distribution Function F of variable X yields:; 4536///; 4537/// ~~~ {.cpp}; 4538/// F(x_p) = Pr(X <= x_p) = p with 0 <= p <= 1.; 4539/// x_p = Q(p) = F_inv(p); 4540/// ~~~; 4541///; 4542/// For instance the median x_0.5 of a distribution is defined as that value; 4543/// of the random variable X for which the distribution function equals 0.5:; 4544///; 4545/// ~~~ {.cpp}; 4546/// F(x_0.5) = Probability(X < x_0.5) = 0.5; 4547/// x_0.5 = Q(0.5); 4548/// ~~~; 4549///; 4550/// \author Eddy Offermann; 4551/// code from Eddy Offermann, Renaissance; 4552///; 4553/// \param[in] n maximum size of array xp and size of array p (if given); 4554/// \param[out] xp array to be filled with nq q",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:186892,Modifiability,variab,variable,186892,"oLower();; 4518 if (opt.Contains(""gl"") || gStyle->GetCanvasPreferGL()) {; 4519 //try to create TGLHistPainter; 4520 TPluginHandler *handler = gROOT->GetPluginManager()->FindHandler(""TGLHistPainter"");; 4521 ; 4522 if (handler && handler->LoadPlugin() != -1); 4523 fPainter = reinterpret_cast<TVirtualHistPainter *>(handler->ExecPlugin(1, this));; 4524 }; 4525 }; 4526 ; 4527 if (!fPainter) fPainter = TVirtualHistPainter::HistPainter(this);; 4528 ; 4529 return fPainter;; 4530}; 4531 ; 4532////////////////////////////////////////////////////////////////////////////////; 4533/// Compute Quantiles for this histogram; 4534/// Quantile x_p := Q(p) is defined as the value x_p such that the cumulative; 4535/// probability distribution Function F of variable X yields:; 4536///; 4537/// ~~~ {.cpp}; 4538/// F(x_p) = Pr(X <= x_p) = p with 0 <= p <= 1.; 4539/// x_p = Q(p) = F_inv(p); 4540/// ~~~; 4541///; 4542/// For instance the median x_0.5 of a distribution is defined as that value; 4543/// of the random variable X for which the distribution function equals 0.5:; 4544///; 4545/// ~~~ {.cpp}; 4546/// F(x_0.5) = Probability(X < x_0.5) = 0.5; 4547/// x_0.5 = Q(0.5); 4548/// ~~~; 4549///; 4550/// \author Eddy Offermann; 4551/// code from Eddy Offermann, Renaissance; 4552///; 4553/// \param[in] n maximum size of array xp and size of array p (if given); 4554/// \param[out] xp array to be filled with nq quantiles evaluated at (p). Memory has to be preallocated by caller.; 4555/// If p is null (default value), then xp is actually set to the (first n) histogram bin edges; 4556/// \param[in] p array of cumulative probabilities where quantiles should be evaluated.; 4557/// - if p is null, the CDF of the histogram will be used instead as array, and will; 4558/// have a size = number of bins + 1 in h. It will correspond to the; 4559/// quantiles calculated at the lowest edge of the histogram (quantile=0) and; 4560/// all the upper edges of the bins. (nbins might be > n).; 4561/// - if p is no",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:246732,Modifiability,variab,variable,246732,"errors stored (via Sumw2), the resulting; 6236/// histograms has new errors correctly calculated.; 6237///; 6238/// examples: if h1 is an existing TH1F histogram with 100 bins; 6239///; 6240/// ~~~ {.cpp}; 6241/// h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; 6242/// h1->Rebin(5); //merges five bins in one in h1; 6243/// TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,""hnew"")); // creates a new histogram hnew; 6244/// // merging 5 bins of h1 in one bin; 6245/// ~~~; 6246///; 6247/// NOTE: If ngroup is not an exact divider of the number of bins,; 6248/// the top limit of the rebinned histogram is reduced; 6249/// to the upper edge of the last bin that can make a complete; 6250/// group. The remaining bins are added to the overflow bin.; 6251/// Statistics will be recomputed from the new bin contents.; 6252///; 6253/// #### case 2 xbins!=0; 6254///; 6255/// A new histogram is created (you should specify newname).; 6256/// The parameter ngroup is the number of variable size bins in the created histogram.; 6257/// The array xbins must contain ngroup+1 elements that represent the low-edges; 6258/// of the bins.; 6259/// If the original histogram has errors stored (via Sumw2), the resulting; 6260/// histograms has new errors correctly calculated.; 6261///; 6262/// NOTE: The bin edges specified in xbins should correspond to bin edges; 6263/// in the original histogram. If a bin edge in the new histogram is; 6264/// in the middle of a bin in the original histogram, all entries in; 6265/// the split bin in the original histogram will be transfered to the; 6266/// lower of the two possible bins in the new histogram. This is; 6267/// probably not what you want. A warning message is emitted in this; 6268/// case; 6269///; 6270/// examples: if h1 is an existing TH1F histogram with 100 bins; 6271///; 6272/// ~~~ {.cpp}; 6273/// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; 6274/// h1->Rebin(24,""hnew"",xbins); ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:247746,Modifiability,variab,variable,247746,"gram.; 6257/// The array xbins must contain ngroup+1 elements that represent the low-edges; 6258/// of the bins.; 6259/// If the original histogram has errors stored (via Sumw2), the resulting; 6260/// histograms has new errors correctly calculated.; 6261///; 6262/// NOTE: The bin edges specified in xbins should correspond to bin edges; 6263/// in the original histogram. If a bin edge in the new histogram is; 6264/// in the middle of a bin in the original histogram, all entries in; 6265/// the split bin in the original histogram will be transfered to the; 6266/// lower of the two possible bins in the new histogram. This is; 6267/// probably not what you want. A warning message is emitted in this; 6268/// case; 6269///; 6270/// examples: if h1 is an existing TH1F histogram with 100 bins; 6271///; 6272/// ~~~ {.cpp}; 6273/// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; 6274/// h1->Rebin(24,""hnew"",xbins); //creates a new variable bin size histogram hnew; 6275/// ~~~; 6276 ; 6277TH1 *TH1::Rebin(Int_t ngroup, const char*newname, const Double_t *xbins); 6278{; 6279 Int_t nbins = fXaxis.GetNbins();; 6280 Double_t xmin = fXaxis.GetXmin();; 6281 Double_t xmax = fXaxis.GetXmax();; 6282 if ((ngroup <= 0) || (ngroup > nbins)) {; 6283 Error(""Rebin"", ""Illegal value of ngroup=%d"",ngroup);; 6284 return nullptr;; 6285 }; 6286 ; 6287 if (fDimension > 1 || InheritsFrom(TProfile::Class())) {; 6288 Error(""Rebin"", ""Operation valid on 1-D histograms only"");; 6289 return nullptr;; 6290 }; 6291 if (!newname && xbins) {; 6292 Error(""Rebin"",""if xbins is specified, newname must be given"");; 6293 return nullptr;; 6294 }; 6295 ; 6296 Int_t newbins = nbins/ngroup;; 6297 if (!xbins) {; 6298 Int_t nbg = nbins/ngroup;; 6299 if (nbg*ngroup != nbins) {; 6300 Warning(""Rebin"", ""ngroup=%d is not an exact divider of nbins=%d."",ngroup,nbins);; 6301 }; 6302 }; 6303 else {; 6304 // in the case that xbins is given (rebinning in variable bins), ngroup is; 6305 // the ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:248732,Modifiability,variab,variable,248732,"creates a new variable bin size histogram hnew; 6275/// ~~~; 6276 ; 6277TH1 *TH1::Rebin(Int_t ngroup, const char*newname, const Double_t *xbins); 6278{; 6279 Int_t nbins = fXaxis.GetNbins();; 6280 Double_t xmin = fXaxis.GetXmin();; 6281 Double_t xmax = fXaxis.GetXmax();; 6282 if ((ngroup <= 0) || (ngroup > nbins)) {; 6283 Error(""Rebin"", ""Illegal value of ngroup=%d"",ngroup);; 6284 return nullptr;; 6285 }; 6286 ; 6287 if (fDimension > 1 || InheritsFrom(TProfile::Class())) {; 6288 Error(""Rebin"", ""Operation valid on 1-D histograms only"");; 6289 return nullptr;; 6290 }; 6291 if (!newname && xbins) {; 6292 Error(""Rebin"",""if xbins is specified, newname must be given"");; 6293 return nullptr;; 6294 }; 6295 ; 6296 Int_t newbins = nbins/ngroup;; 6297 if (!xbins) {; 6298 Int_t nbg = nbins/ngroup;; 6299 if (nbg*ngroup != nbins) {; 6300 Warning(""Rebin"", ""ngroup=%d is not an exact divider of nbins=%d."",ngroup,nbins);; 6301 }; 6302 }; 6303 else {; 6304 // in the case that xbins is given (rebinning in variable bins), ngroup is; 6305 // the new number of bins and number of grouped bins is not constant.; 6306 // when looping for setting the contents for the new histogram we; 6307 // need to loop on all bins of original histogram. Then set ngroup=nbins; 6308 newbins = ngroup;; 6309 ngroup = nbins;; 6310 }; 6311 ; 6312 // Save old bin contents into a new array; 6313 Double_t entries = fEntries;; 6314 Double_t *oldBins = new Double_t[nbins+2];; 6315 Int_t bin, i;; 6316 for (bin=0;bin<nbins+2;bin++) oldBins[bin] = RetrieveBinContent(bin);; 6317 Double_t *oldErrors = nullptr;; 6318 if (fSumw2.fN != 0) {; 6319 oldErrors = new Double_t[nbins+2];; 6320 for (bin=0;bin<nbins+2;bin++) oldErrors[bin] = GetBinError(bin);; 6321 }; 6322 // rebin will not include underflow/overflow if new axis range is larger than old axis range; 6323 if (xbins) {; 6324 if (xbins[0] < fXaxis.GetXmin() && oldBins[0] != 0 ); 6325 Warning(""Rebin"",""underflow entries will not be used when rebinning"");; 6326 if (xbins[newb",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:250096,Modifiability,extend,extend,250096,"t entries = fEntries;; 6314 Double_t *oldBins = new Double_t[nbins+2];; 6315 Int_t bin, i;; 6316 for (bin=0;bin<nbins+2;bin++) oldBins[bin] = RetrieveBinContent(bin);; 6317 Double_t *oldErrors = nullptr;; 6318 if (fSumw2.fN != 0) {; 6319 oldErrors = new Double_t[nbins+2];; 6320 for (bin=0;bin<nbins+2;bin++) oldErrors[bin] = GetBinError(bin);; 6321 }; 6322 // rebin will not include underflow/overflow if new axis range is larger than old axis range; 6323 if (xbins) {; 6324 if (xbins[0] < fXaxis.GetXmin() && oldBins[0] != 0 ); 6325 Warning(""Rebin"",""underflow entries will not be used when rebinning"");; 6326 if (xbins[newbins] > fXaxis.GetXmax() && oldBins[nbins+1] != 0 ); 6327 Warning(""Rebin"",""overflow entries will not be used when rebinning"");; 6328 }; 6329 ; 6330 ; 6331 // create a clone of the old histogram if newname is specified; 6332 TH1 *hnew = this;; 6333 if ((newname && strlen(newname) > 0) || xbins) {; 6334 hnew = (TH1*)Clone(newname);; 6335 }; 6336 ; 6337 //reset can extend bit to avoid an axis extension in SetBinContent; 6338 UInt_t oldExtendBitMask = hnew->SetCanExtend(kNoAxis);; 6339 ; 6340 // save original statistics; 6341 Double_t stat[kNstat];; 6342 GetStats(stat);; 6343 bool resetStat = false;; 6344 // change axis specs and rebuild bin contents array::RebinAx; 6345 if(!xbins && (newbins*ngroup != nbins)) {; 6346 xmax = fXaxis.GetBinUpEdge(newbins*ngroup);; 6347 resetStat = true; //stats must be reset because top bins will be moved to overflow bin; 6348 }; 6349 // save the TAttAxis members (reset by SetBins); 6350 Int_t nDivisions = fXaxis.GetNdivisions();; 6351 Color_t axisColor = fXaxis.GetAxisColor();; 6352 Color_t labelColor = fXaxis.GetLabelColor();; 6353 Style_t labelFont = fXaxis.GetLabelFont();; 6354 Float_t labelOffset = fXaxis.GetLabelOffset();; 6355 Float_t labelSize = fXaxis.GetLabelSize();; 6356 Float_t tickLength = fXaxis.GetTickLength();; 6357 Float_t titleOffset = fXaxis.GetTitleOffset();; 6358 Float_t titleSize = fXaxis.GetTitleSize();; ",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:251273,Modifiability,variab,variable,251273,"setStat = false;; 6344 // change axis specs and rebuild bin contents array::RebinAx; 6345 if(!xbins && (newbins*ngroup != nbins)) {; 6346 xmax = fXaxis.GetBinUpEdge(newbins*ngroup);; 6347 resetStat = true; //stats must be reset because top bins will be moved to overflow bin; 6348 }; 6349 // save the TAttAxis members (reset by SetBins); 6350 Int_t nDivisions = fXaxis.GetNdivisions();; 6351 Color_t axisColor = fXaxis.GetAxisColor();; 6352 Color_t labelColor = fXaxis.GetLabelColor();; 6353 Style_t labelFont = fXaxis.GetLabelFont();; 6354 Float_t labelOffset = fXaxis.GetLabelOffset();; 6355 Float_t labelSize = fXaxis.GetLabelSize();; 6356 Float_t tickLength = fXaxis.GetTickLength();; 6357 Float_t titleOffset = fXaxis.GetTitleOffset();; 6358 Float_t titleSize = fXaxis.GetTitleSize();; 6359 Color_t titleColor = fXaxis.GetTitleColor();; 6360 Style_t titleFont = fXaxis.GetTitleFont();; 6361 ; 6362 if(!xbins && (fXaxis.GetXbins()->GetSize() > 0)){ // variable bin sizes; 6363 Double_t *bins = new Double_t[newbins+1];; 6364 for(i = 0; i <= newbins; ++i) bins[i] = fXaxis.GetBinLowEdge(1+i*ngroup);; 6365 hnew->SetBins(newbins,bins); //this also changes errors array (if any); 6366 delete [] bins;; 6367 } else if (xbins) {; 6368 hnew->SetBins(newbins,xbins);; 6369 } else {; 6370 hnew->SetBins(newbins,xmin,xmax);; 6371 }; 6372 ; 6373 // Restore axis attributes; 6374 fXaxis.SetNdivisions(nDivisions);; 6375 fXaxis.SetAxisColor(axisColor);; 6376 fXaxis.SetLabelColor(labelColor);; 6377 fXaxis.SetLabelFont(labelFont);; 6378 fXaxis.SetLabelOffset(labelOffset);; 6379 fXaxis.SetLabelSize(labelSize);; 6380 fXaxis.SetTickLength(tickLength);; 6381 fXaxis.SetTitleOffset(titleOffset);; 6382 fXaxis.SetTitleSize(titleSize);; 6383 fXaxis.SetTitleColor(titleColor);; 6384 fXaxis.SetTitleFont(titleFont);; 6385 ; 6386 // copy merged bin contents (ignore under/overflows); 6387 // Start merging only once the new lowest edge is reached; 6388 Int_t startbin = 1;; 6389 const Double_t newxmin = hnew->GetXax",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:254885,Modifiability,variab,variables,254885,"nt);; 6430 if (oldErrors) hnew->SetBinError(0,TMath::Sqrt(binError));; 6431 // sum overflow; 6432 binContent = 0;; 6433 binError = 0;; 6434 for (i = oldbin; i <= nbins+1; ++i) {; 6435 binContent += oldBins[i];; 6436 if (oldErrors) binError += oldErrors[i]*oldErrors[i];; 6437 }; 6438 hnew->SetBinContent(newbins+1,binContent);; 6439 if (oldErrors) hnew->SetBinError(newbins+1,TMath::Sqrt(binError));; 6440 ; 6441 hnew->SetCanExtend(oldExtendBitMask); // restore previous state; 6442 ; 6443 // restore statistics and entries modified by SetBinContent; 6444 hnew->SetEntries(entries);; 6445 if (!resetStat) hnew->PutStats(stat);; 6446 delete [] oldBins;; 6447 if (oldErrors) delete [] oldErrors;; 6448 return hnew;; 6449}; 6450 ; 6451////////////////////////////////////////////////////////////////////////////////; 6452/// finds new limits for the axis so that *point* is within the range and; 6453/// the limits are compatible with the previous ones (see TH1::Merge).; 6454/// new limits are put into *newMin* and *newMax* variables.; 6455/// axis - axis whose limits are to be recomputed; 6456/// point - point that should fit within the new axis limits; 6457/// newMin - new minimum will be stored here; 6458/// newMax - new maximum will be stored here.; 6459/// false if failed (e.g. if the initial axis limits are wrong; 6460/// or the new range is more than \f$ 2^{64} \f$ times the old one).; 6461 ; 6462Bool_t TH1::FindNewAxisLimits(const TAxis* axis, const Double_t point, Double_t& newMin, Double_t &newMax); 6463{; 6464 Double_t xmin = axis->GetXmin();; 6465 Double_t xmax = axis->GetXmax();; 6466 if (xmin >= xmax) return kFALSE;; 6467 Double_t range = xmax-xmin;; 6468 ; 6469 //recompute new axis limits by doubling the current range; 6470 Int_t ntimes = 0;; 6471 while (point < xmin) {; 6472 if (ntimes++ > 64); 6473 return kFALSE;; 6474 xmin = xmin - range;; 6475 range *= 2;; 6476 }; 6477 while (point >= xmax) {; 6478 if (ntimes++ > 64); 6479 return kFALSE;; 6480 xmax = xmax + range;",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:256552,Modifiability,extend,extended,256552,";; 6467 Double_t range = xmax-xmin;; 6468 ; 6469 //recompute new axis limits by doubling the current range; 6470 Int_t ntimes = 0;; 6471 while (point < xmin) {; 6472 if (ntimes++ > 64); 6473 return kFALSE;; 6474 xmin = xmin - range;; 6475 range *= 2;; 6476 }; 6477 while (point >= xmax) {; 6478 if (ntimes++ > 64); 6479 return kFALSE;; 6480 xmax = xmax + range;; 6481 range *= 2;; 6482 }; 6483 newMin = xmin;; 6484 newMax = xmax;; 6485 // Info(""FindNewAxisLimits"", ""OldAxis: (%lf, %lf), new: (%lf, %lf), point: %lf"",; 6486 // axis->GetXmin(), axis->GetXmax(), xmin, xmax, point);; 6487 ; 6488 return kTRUE;; 6489}; 6490 ; 6491////////////////////////////////////////////////////////////////////////////////; 6492/// Histogram is resized along axis such that x is in the axis range.; 6493/// The new axis limits are recomputed by doubling iteratively; 6494/// the current axis range until the specified value x is within the limits.; 6495/// The algorithm makes a copy of the histogram, then loops on all bins; 6496/// of the old histogram to fill the extended histogram.; 6497/// Takes into account errors (Sumw2) if any.; 6498/// The algorithm works for 1-d, 2-D and 3-D histograms.; 6499/// The axis must be extendable before invoking this function.; 6500/// Ex:; 6501///; 6502/// ~~~ {.cpp}; 6503/// h->GetXaxis()->SetCanExtend(kTRUE);; 6504/// ~~~; 6505 ; 6506void TH1::ExtendAxis(Double_t x, TAxis *axis); 6507{; 6508 if (!axis->CanExtend()) return;; 6509 if (TMath::IsNaN(x)) { // x may be a NaN; 6510 SetCanExtend(kNoAxis);; 6511 return;; 6512 }; 6513 ; 6514 if (axis->GetXmin() >= axis->GetXmax()) return;; 6515 if (axis->GetNbins() <= 0) return;; 6516 ; 6517 Double_t xmin, xmax;; 6518 if (!FindNewAxisLimits(axis, x, xmin, xmax)); 6519 return;; 6520 ; 6521 //save a copy of this histogram; 6522 TH1 *hold = (TH1*)IsA()->New();; 6523 hold->SetDirectory(nullptr);; 6524 Copy(*hold);; 6525 //set new axis limits; 6526 axis->SetLimits(xmin,xmax);; 6527 ; 6528 ; 6529 //now loop on all bins and r",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:256711,Modifiability,extend,extendable,256711,"= xmin - range;; 6475 range *= 2;; 6476 }; 6477 while (point >= xmax) {; 6478 if (ntimes++ > 64); 6479 return kFALSE;; 6480 xmax = xmax + range;; 6481 range *= 2;; 6482 }; 6483 newMin = xmin;; 6484 newMax = xmax;; 6485 // Info(""FindNewAxisLimits"", ""OldAxis: (%lf, %lf), new: (%lf, %lf), point: %lf"",; 6486 // axis->GetXmin(), axis->GetXmax(), xmin, xmax, point);; 6487 ; 6488 return kTRUE;; 6489}; 6490 ; 6491////////////////////////////////////////////////////////////////////////////////; 6492/// Histogram is resized along axis such that x is in the axis range.; 6493/// The new axis limits are recomputed by doubling iteratively; 6494/// the current axis range until the specified value x is within the limits.; 6495/// The algorithm makes a copy of the histogram, then loops on all bins; 6496/// of the old histogram to fill the extended histogram.; 6497/// Takes into account errors (Sumw2) if any.; 6498/// The algorithm works for 1-d, 2-D and 3-D histograms.; 6499/// The axis must be extendable before invoking this function.; 6500/// Ex:; 6501///; 6502/// ~~~ {.cpp}; 6503/// h->GetXaxis()->SetCanExtend(kTRUE);; 6504/// ~~~; 6505 ; 6506void TH1::ExtendAxis(Double_t x, TAxis *axis); 6507{; 6508 if (!axis->CanExtend()) return;; 6509 if (TMath::IsNaN(x)) { // x may be a NaN; 6510 SetCanExtend(kNoAxis);; 6511 return;; 6512 }; 6513 ; 6514 if (axis->GetXmin() >= axis->GetXmax()) return;; 6515 if (axis->GetNbins() <= 0) return;; 6516 ; 6517 Double_t xmin, xmax;; 6518 if (!FindNewAxisLimits(axis, x, xmin, xmax)); 6519 return;; 6520 ; 6521 //save a copy of this histogram; 6522 TH1 *hold = (TH1*)IsA()->New();; 6523 hold->SetDirectory(nullptr);; 6524 Copy(*hold);; 6525 //set new axis limits; 6526 axis->SetLimits(xmin,xmax);; 6527 ; 6528 ; 6529 //now loop on all bins and refill; 6530 Int_t errors = GetSumw2N();; 6531 ; 6532 Reset(""ICE""); //reset only Integral, contents and Errors; 6533 ; 6534 int iaxis = 0;; 6535 if (axis == &fXaxis) iaxis = 1;; 6536 if (axis == &fYaxis) iaxis = 2;; 6",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:258625,Modifiability,extend,extendable,258625,"//reset only Integral, contents and Errors; 6533 ; 6534 int iaxis = 0;; 6535 if (axis == &fXaxis) iaxis = 1;; 6536 if (axis == &fYaxis) iaxis = 2;; 6537 if (axis == &fZaxis) iaxis = 3;; 6538 bool firstw = kTRUE;; 6539 Int_t binx,biny, binz = 0;; 6540 Int_t ix = 0,iy = 0,iz = 0;; 6541 Double_t bx,by,bz;; 6542 Int_t ncells = hold->GetNcells();; 6543 for (Int_t bin = 0; bin < ncells; ++bin) {; 6544 hold->GetBinXYZ(bin,binx,biny,binz);; 6545 bx = hold->GetXaxis()->GetBinCenter(binx);; 6546 ix = fXaxis.FindFixBin(bx);; 6547 if (fDimension > 1) {; 6548 by = hold->GetYaxis()->GetBinCenter(biny);; 6549 iy = fYaxis.FindFixBin(by);; 6550 if (fDimension > 2) {; 6551 bz = hold->GetZaxis()->GetBinCenter(binz);; 6552 iz = fZaxis.FindFixBin(bz);; 6553 }; 6554 }; 6555 // exclude underflow/overflow; 6556 double content = hold->RetrieveBinContent(bin);; 6557 if (content == 0) continue;; 6558 if (IsBinUnderflow(bin,iaxis) || IsBinOverflow(bin,iaxis) ) {; 6559 if (firstw) {; 6560 Warning(""ExtendAxis"",""Histogram %s has underflow or overflow in the axis that is extendable""; 6561 "" their content will be lost"",GetName() );; 6562 firstw= kFALSE;; 6563 }; 6564 continue;; 6565 }; 6566 Int_t ibin= GetBin(ix,iy,iz);; 6567 AddBinContent(ibin, content);; 6568 if (errors) {; 6569 fSumw2.fArray[ibin] += hold->GetBinErrorSqUnchecked(bin);; 6570 }; 6571 }; 6572 delete hold;; 6573}; 6574 ; 6575////////////////////////////////////////////////////////////////////////////////; 6576/// Recursively remove object from the list of functions; 6577 ; 6578void TH1::RecursiveRemove(TObject *obj); 6579{; 6580 // Rely on TROOT::RecursiveRemove to take the readlock.; 6581 ; 6582 if (fFunctions) {; 6583 if (!fFunctions->TestBit(kInvalidObject)) fFunctions->RecursiveRemove(obj);; 6584 }; 6585}; 6586 ; 6587////////////////////////////////////////////////////////////////////////////////; 6588/// Multiply this histogram by a constant c1.; 6589///; 6590/// `this = c1*this`; 6591///; 6592/// Note that both contents and err",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:261480,Modifiability,extend,extendable,261480,"ore be computed as sqrt(N); 6611 if (!opt.Contains(""nosw2"") && GetSumw2N() == 0) Sumw2();; 6612 if (opt.Contains(""width"")) Add(this, this, c1, -1);; 6613 else {; 6614 if (fBuffer) BufferEmpty(1);; 6615 for(Int_t i = 0; i < fNcells; ++i) UpdateBinContent(i, c1 * RetrieveBinContent(i));; 6616 if (fSumw2.fN) for(Int_t i = 0; i < fNcells; ++i) fSumw2.fArray[i] *= (c1 * c1); // update errors; 6617 // update global histograms statistics; 6618 Double_t s[kNstat] = {0};; 6619 GetStats(s);; 6620 for (Int_t i=0 ; i < kNstat; i++) {; 6621 if (i == 1) s[i] = c1*c1*s[i];; 6622 else s[i] = c1*s[i];; 6623 }; 6624 PutStats(s);; 6625 SetMinimum(); SetMaximum(); // minimum and maximum value will be recalculated the next time; 6626 }; 6627 ; 6628 // if contours set, must also scale contours; 6629 Int_t ncontours = GetContour();; 6630 if (ncontours == 0) return;; 6631 Double_t* levels = fContour.GetArray();; 6632 for (Int_t i = 0; i < ncontours; ++i) levels[i] *= c1;; 6633}; 6634 ; 6635////////////////////////////////////////////////////////////////////////////////; 6636/// Returns true if all axes are extendable.; 6637 ; 6638Bool_t TH1::CanExtendAllAxes() const; 6639{; 6640 Bool_t canExtend = fXaxis.CanExtend();; 6641 if (GetDimension() > 1) canExtend &= fYaxis.CanExtend();; 6642 if (GetDimension() > 2) canExtend &= fZaxis.CanExtend();; 6643 ; 6644 return canExtend;; 6645}; 6646 ; 6647////////////////////////////////////////////////////////////////////////////////; 6648/// Make the histogram axes extendable / not extendable according to the bit mask; 6649/// returns the previous bit mask specifying which axes are extendable; 6650 ; 6651UInt_t TH1::SetCanExtend(UInt_t extendBitMask); 6652{; 6653 UInt_t oldExtendBitMask = kNoAxis;; 6654 ; 6655 if (fXaxis.CanExtend()) oldExtendBitMask |= kXaxis;; 6656 if (extendBitMask & kXaxis) fXaxis.SetCanExtend(kTRUE);; 6657 else fXaxis.SetCanExtend(kFALSE);; 6658 ; 6659 if (GetDimension() > 1) {; 6660 if (fYaxis.CanExtend()) oldExtendBitMask |= kYax",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:261883,Modifiability,extend,extendable,261883," s[i] = c1*c1*s[i];; 6622 else s[i] = c1*s[i];; 6623 }; 6624 PutStats(s);; 6625 SetMinimum(); SetMaximum(); // minimum and maximum value will be recalculated the next time; 6626 }; 6627 ; 6628 // if contours set, must also scale contours; 6629 Int_t ncontours = GetContour();; 6630 if (ncontours == 0) return;; 6631 Double_t* levels = fContour.GetArray();; 6632 for (Int_t i = 0; i < ncontours; ++i) levels[i] *= c1;; 6633}; 6634 ; 6635////////////////////////////////////////////////////////////////////////////////; 6636/// Returns true if all axes are extendable.; 6637 ; 6638Bool_t TH1::CanExtendAllAxes() const; 6639{; 6640 Bool_t canExtend = fXaxis.CanExtend();; 6641 if (GetDimension() > 1) canExtend &= fYaxis.CanExtend();; 6642 if (GetDimension() > 2) canExtend &= fZaxis.CanExtend();; 6643 ; 6644 return canExtend;; 6645}; 6646 ; 6647////////////////////////////////////////////////////////////////////////////////; 6648/// Make the histogram axes extendable / not extendable according to the bit mask; 6649/// returns the previous bit mask specifying which axes are extendable; 6650 ; 6651UInt_t TH1::SetCanExtend(UInt_t extendBitMask); 6652{; 6653 UInt_t oldExtendBitMask = kNoAxis;; 6654 ; 6655 if (fXaxis.CanExtend()) oldExtendBitMask |= kXaxis;; 6656 if (extendBitMask & kXaxis) fXaxis.SetCanExtend(kTRUE);; 6657 else fXaxis.SetCanExtend(kFALSE);; 6658 ; 6659 if (GetDimension() > 1) {; 6660 if (fYaxis.CanExtend()) oldExtendBitMask |= kYaxis;; 6661 if (extendBitMask & kYaxis) fYaxis.SetCanExtend(kTRUE);; 6662 else fYaxis.SetCanExtend(kFALSE);; 6663 }; 6664 ; 6665 if (GetDimension() > 2) {; 6666 if (fZaxis.CanExtend()) oldExtendBitMask |= kZaxis;; 6667 if (extendBitMask & kZaxis) fZaxis.SetCanExtend(kTRUE);; 6668 else fZaxis.SetCanExtend(kFALSE);; 6669 }; 6670 ; 6671 return oldExtendBitMask;; 6672}; 6673 ; 6674///////////////////////////////////////////////////////////////////////////////; 6675/// Internal function used in TH1::Fill to see which axis is full alphanumeric,; 6",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:261900,Modifiability,extend,extendable,261900," s[i] = c1*c1*s[i];; 6622 else s[i] = c1*s[i];; 6623 }; 6624 PutStats(s);; 6625 SetMinimum(); SetMaximum(); // minimum and maximum value will be recalculated the next time; 6626 }; 6627 ; 6628 // if contours set, must also scale contours; 6629 Int_t ncontours = GetContour();; 6630 if (ncontours == 0) return;; 6631 Double_t* levels = fContour.GetArray();; 6632 for (Int_t i = 0; i < ncontours; ++i) levels[i] *= c1;; 6633}; 6634 ; 6635////////////////////////////////////////////////////////////////////////////////; 6636/// Returns true if all axes are extendable.; 6637 ; 6638Bool_t TH1::CanExtendAllAxes() const; 6639{; 6640 Bool_t canExtend = fXaxis.CanExtend();; 6641 if (GetDimension() > 1) canExtend &= fYaxis.CanExtend();; 6642 if (GetDimension() > 2) canExtend &= fZaxis.CanExtend();; 6643 ; 6644 return canExtend;; 6645}; 6646 ; 6647////////////////////////////////////////////////////////////////////////////////; 6648/// Make the histogram axes extendable / not extendable according to the bit mask; 6649/// returns the previous bit mask specifying which axes are extendable; 6650 ; 6651UInt_t TH1::SetCanExtend(UInt_t extendBitMask); 6652{; 6653 UInt_t oldExtendBitMask = kNoAxis;; 6654 ; 6655 if (fXaxis.CanExtend()) oldExtendBitMask |= kXaxis;; 6656 if (extendBitMask & kXaxis) fXaxis.SetCanExtend(kTRUE);; 6657 else fXaxis.SetCanExtend(kFALSE);; 6658 ; 6659 if (GetDimension() > 1) {; 6660 if (fYaxis.CanExtend()) oldExtendBitMask |= kYaxis;; 6661 if (extendBitMask & kYaxis) fYaxis.SetCanExtend(kTRUE);; 6662 else fYaxis.SetCanExtend(kFALSE);; 6663 }; 6664 ; 6665 if (GetDimension() > 2) {; 6666 if (fZaxis.CanExtend()) oldExtendBitMask |= kZaxis;; 6667 if (extendBitMask & kZaxis) fZaxis.SetCanExtend(kTRUE);; 6668 else fZaxis.SetCanExtend(kFALSE);; 6669 }; 6670 ; 6671 return oldExtendBitMask;; 6672}; 6673 ; 6674///////////////////////////////////////////////////////////////////////////////; 6675/// Internal function used in TH1::Fill to see which axis is full alphanumeric,; 6",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
https://root.cern/doc/master/TH1_8cxx_source.html:262002,Modifiability,extend,extendable,262002," s[i] = c1*c1*s[i];; 6622 else s[i] = c1*s[i];; 6623 }; 6624 PutStats(s);; 6625 SetMinimum(); SetMaximum(); // minimum and maximum value will be recalculated the next time; 6626 }; 6627 ; 6628 // if contours set, must also scale contours; 6629 Int_t ncontours = GetContour();; 6630 if (ncontours == 0) return;; 6631 Double_t* levels = fContour.GetArray();; 6632 for (Int_t i = 0; i < ncontours; ++i) levels[i] *= c1;; 6633}; 6634 ; 6635////////////////////////////////////////////////////////////////////////////////; 6636/// Returns true if all axes are extendable.; 6637 ; 6638Bool_t TH1::CanExtendAllAxes() const; 6639{; 6640 Bool_t canExtend = fXaxis.CanExtend();; 6641 if (GetDimension() > 1) canExtend &= fYaxis.CanExtend();; 6642 if (GetDimension() > 2) canExtend &= fZaxis.CanExtend();; 6643 ; 6644 return canExtend;; 6645}; 6646 ; 6647////////////////////////////////////////////////////////////////////////////////; 6648/// Make the histogram axes extendable / not extendable according to the bit mask; 6649/// returns the previous bit mask specifying which axes are extendable; 6650 ; 6651UInt_t TH1::SetCanExtend(UInt_t extendBitMask); 6652{; 6653 UInt_t oldExtendBitMask = kNoAxis;; 6654 ; 6655 if (fXaxis.CanExtend()) oldExtendBitMask |= kXaxis;; 6656 if (extendBitMask & kXaxis) fXaxis.SetCanExtend(kTRUE);; 6657 else fXaxis.SetCanExtend(kFALSE);; 6658 ; 6659 if (GetDimension() > 1) {; 6660 if (fYaxis.CanExtend()) oldExtendBitMask |= kYaxis;; 6661 if (extendBitMask & kYaxis) fYaxis.SetCanExtend(kTRUE);; 6662 else fYaxis.SetCanExtend(kFALSE);; 6663 }; 6664 ; 6665 if (GetDimension() > 2) {; 6666 if (fZaxis.CanExtend()) oldExtendBitMask |= kZaxis;; 6667 if (extendBitMask & kZaxis) fZaxis.SetCanExtend(kTRUE);; 6668 else fZaxis.SetCanExtend(kFALSE);; 6669 }; 6670 ; 6671 return oldExtendBitMask;; 6672}; 6673 ; 6674///////////////////////////////////////////////////////////////////////////////; 6675/// Internal function used in TH1::Fill to see which axis is full alphanumeric,; 6",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
